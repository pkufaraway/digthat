/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(1);
	__webpack_require__(1);
	module.exports = __webpack_require__(7);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	var Vue = __webpack_require__(2);
	var app1 = __webpack_require__(3);
	var logic = __webpack_require__(4);

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Vue.js v2.0.5
	 * (c) 2014-2016 Evan You
	 * Released under the MIT License.
	 */
	(function (global, factory) {
	   true ? module.exports = factory() :
	  typeof define === 'function' && define.amd ? define(factory) :
	  (global.Vue = factory());
	}(this, (function () { 'use strict';

	/*  */

	/**
	 * Convert a value to a string that is actually rendered.
	 */
	function _toString (val) {
	  return val == null
	    ? ''
	    : typeof val === 'object'
	      ? JSON.stringify(val, null, 2)
	      : String(val)
	}

	/**
	 * Convert a input value to a number for persistence.
	 * If the conversion fails, return original string.
	 */
	function toNumber (val) {
	  var n = parseFloat(val, 10);
	  return (n || n === 0) ? n : val
	}

	/**
	 * Make a map and return a function for checking if a key
	 * is in that map.
	 */
	function makeMap (
	  str,
	  expectsLowerCase
	) {
	  var map = Object.create(null);
	  var list = str.split(',');
	  for (var i = 0; i < list.length; i++) {
	    map[list[i]] = true;
	  }
	  return expectsLowerCase
	    ? function (val) { return map[val.toLowerCase()]; }
	    : function (val) { return map[val]; }
	}

	/**
	 * Check if a tag is a built-in tag.
	 */
	var isBuiltInTag = makeMap('slot,component', true);

	/**
	 * Remove an item from an array
	 */
	function remove$1 (arr, item) {
	  if (arr.length) {
	    var index = arr.indexOf(item);
	    if (index > -1) {
	      return arr.splice(index, 1)
	    }
	  }
	}

	/**
	 * Check whether the object has the property.
	 */
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	function hasOwn (obj, key) {
	  return hasOwnProperty.call(obj, key)
	}

	/**
	 * Check if value is primitive
	 */
	function isPrimitive (value) {
	  return typeof value === 'string' || typeof value === 'number'
	}

	/**
	 * Create a cached version of a pure function.
	 */
	function cached (fn) {
	  var cache = Object.create(null);
	  return function cachedFn (str) {
	    var hit = cache[str];
	    return hit || (cache[str] = fn(str))
	  }
	}

	/**
	 * Camelize a hyphen-delmited string.
	 */
	var camelizeRE = /-(\w)/g;
	var camelize = cached(function (str) {
	  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })
	});

	/**
	 * Capitalize a string.
	 */
	var capitalize = cached(function (str) {
	  return str.charAt(0).toUpperCase() + str.slice(1)
	});

	/**
	 * Hyphenate a camelCase string.
	 */
	var hyphenateRE = /([^-])([A-Z])/g;
	var hyphenate = cached(function (str) {
	  return str
	    .replace(hyphenateRE, '$1-$2')
	    .replace(hyphenateRE, '$1-$2')
	    .toLowerCase()
	});

	/**
	 * Simple bind, faster than native
	 */
	function bind$1 (fn, ctx) {
	  function boundFn (a) {
	    var l = arguments.length;
	    return l
	      ? l > 1
	        ? fn.apply(ctx, arguments)
	        : fn.call(ctx, a)
	      : fn.call(ctx)
	  }
	  // record original fn length
	  boundFn._length = fn.length;
	  return boundFn
	}

	/**
	 * Convert an Array-like object to a real Array.
	 */
	function toArray (list, start) {
	  start = start || 0;
	  var i = list.length - start;
	  var ret = new Array(i);
	  while (i--) {
	    ret[i] = list[i + start];
	  }
	  return ret
	}

	/**
	 * Mix properties into target object.
	 */
	function extend (to, _from) {
	  for (var key in _from) {
	    to[key] = _from[key];
	  }
	  return to
	}

	/**
	 * Quick object check - this is primarily used to tell
	 * Objects from primitive values when we know the value
	 * is a JSON-compliant type.
	 */
	function isObject (obj) {
	  return obj !== null && typeof obj === 'object'
	}

	/**
	 * Strict object type check. Only returns true
	 * for plain JavaScript objects.
	 */
	var toString = Object.prototype.toString;
	var OBJECT_STRING = '[object Object]';
	function isPlainObject (obj) {
	  return toString.call(obj) === OBJECT_STRING
	}

	/**
	 * Merge an Array of Objects into a single Object.
	 */
	function toObject (arr) {
	  var res = {};
	  for (var i = 0; i < arr.length; i++) {
	    if (arr[i]) {
	      extend(res, arr[i]);
	    }
	  }
	  return res
	}

	/**
	 * Perform no operation.
	 */
	function noop () {}

	/**
	 * Always return false.
	 */
	var no = function () { return false; };

	/**
	 * Generate a static keys string from compiler modules.
	 */
	function genStaticKeys (modules) {
	  return modules.reduce(function (keys, m) {
	    return keys.concat(m.staticKeys || [])
	  }, []).join(',')
	}

	/**
	 * Check if two values are loosely equal - that is,
	 * if they are plain objects, do they have the same shape?
	 */
	function looseEqual (a, b) {
	  /* eslint-disable eqeqeq */
	  return a == b || (
	    isObject(a) && isObject(b)
	      ? JSON.stringify(a) === JSON.stringify(b)
	      : false
	  )
	  /* eslint-enable eqeqeq */
	}

	function looseIndexOf (arr, val) {
	  for (var i = 0; i < arr.length; i++) {
	    if (looseEqual(arr[i], val)) { return i }
	  }
	  return -1
	}

	/*  */

	var config = {
	  /**
	   * Option merge strategies (used in core/util/options)
	   */
	  optionMergeStrategies: Object.create(null),

	  /**
	   * Whether to suppress warnings.
	   */
	  silent: false,

	  /**
	   * Whether to enable devtools
	   */
	  devtools: "development" !== 'production',

	  /**
	   * Error handler for watcher errors
	   */
	  errorHandler: null,

	  /**
	   * Ignore certain custom elements
	   */
	  ignoredElements: null,

	  /**
	   * Custom user key aliases for v-on
	   */
	  keyCodes: Object.create(null),

	  /**
	   * Check if a tag is reserved so that it cannot be registered as a
	   * component. This is platform-dependent and may be overwritten.
	   */
	  isReservedTag: no,

	  /**
	   * Check if a tag is an unknown element.
	   * Platform-dependent.
	   */
	  isUnknownElement: no,

	  /**
	   * Get the namespace of an element
	   */
	  getTagNamespace: noop,

	  /**
	   * Check if an attribute must be bound using property, e.g. value
	   * Platform-dependent.
	   */
	  mustUseProp: no,

	  /**
	   * List of asset types that a component can own.
	   */
	  _assetTypes: [
	    'component',
	    'directive',
	    'filter'
	  ],

	  /**
	   * List of lifecycle hooks.
	   */
	  _lifecycleHooks: [
	    'beforeCreate',
	    'created',
	    'beforeMount',
	    'mounted',
	    'beforeUpdate',
	    'updated',
	    'beforeDestroy',
	    'destroyed',
	    'activated',
	    'deactivated'
	  ],

	  /**
	   * Max circular updates allowed in a scheduler flush cycle.
	   */
	  _maxUpdateCount: 100,

	  /**
	   * Server rendering?
	   */
	  _isServer: "client" === 'server'
	};

	/*  */

	/**
	 * Check if a string starts with $ or _
	 */
	function isReserved (str) {
	  var c = (str + '').charCodeAt(0);
	  return c === 0x24 || c === 0x5F
	}

	/**
	 * Define a property.
	 */
	function def (obj, key, val, enumerable) {
	  Object.defineProperty(obj, key, {
	    value: val,
	    enumerable: !!enumerable,
	    writable: true,
	    configurable: true
	  });
	}

	/**
	 * Parse simple path.
	 */
	var bailRE = /[^\w.$]/;
	function parsePath (path) {
	  if (bailRE.test(path)) {
	    return
	  } else {
	    var segments = path.split('.');
	    return function (obj) {
	      for (var i = 0; i < segments.length; i++) {
	        if (!obj) { return }
	        obj = obj[segments[i]];
	      }
	      return obj
	    }
	  }
	}

	/*  */
	/* globals MutationObserver */

	// can we use __proto__?
	var hasProto = '__proto__' in {};

	// Browser environment sniffing
	var inBrowser =
	  typeof window !== 'undefined' &&
	  Object.prototype.toString.call(window) !== '[object Object]';

	var UA = inBrowser && window.navigator.userAgent.toLowerCase();
	var isIE = UA && /msie|trident/.test(UA);
	var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
	var isEdge = UA && UA.indexOf('edge/') > 0;
	var isAndroid = UA && UA.indexOf('android') > 0;
	var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);

	// detect devtools
	var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

	/* istanbul ignore next */
	function isNative (Ctor) {
	  return /native code/.test(Ctor.toString())
	}

	/**
	 * Defer a task to execute it asynchronously.
	 */
	var nextTick = (function () {
	  var callbacks = [];
	  var pending = false;
	  var timerFunc;

	  function nextTickHandler () {
	    pending = false;
	    var copies = callbacks.slice(0);
	    callbacks.length = 0;
	    for (var i = 0; i < copies.length; i++) {
	      copies[i]();
	    }
	  }

	  // the nextTick behavior leverages the microtask queue, which can be accessed
	  // via either native Promise.then or MutationObserver.
	  // MutationObserver has wider support, however it is seriously bugged in
	  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
	  // completely stops working after triggering a few times... so, if native
	  // Promise is available, we will use it:
	  /* istanbul ignore if */
	  if (typeof Promise !== 'undefined' && isNative(Promise)) {
	    var p = Promise.resolve();
	    timerFunc = function () {
	      p.then(nextTickHandler);
	      // in problematic UIWebViews, Promise.then doesn't completely break, but
	      // it can get stuck in a weird state where callbacks are pushed into the
	      // microtask queue but the queue isn't being flushed, until the browser
	      // needs to do some other work, e.g. handle a timer. Therefore we can
	      // "force" the microtask queue to be flushed by adding an empty timer.
	      if (isIOS) { setTimeout(noop); }
	    };
	  } else if (typeof MutationObserver !== 'undefined' && (
	    isNative(MutationObserver) ||
	    // PhantomJS and iOS 7.x
	    MutationObserver.toString() === '[object MutationObserverConstructor]'
	  )) {
	    // use MutationObserver where native Promise is not available,
	    // e.g. PhantomJS IE11, iOS7, Android 4.4
	    var counter = 1;
	    var observer = new MutationObserver(nextTickHandler);
	    var textNode = document.createTextNode(String(counter));
	    observer.observe(textNode, {
	      characterData: true
	    });
	    timerFunc = function () {
	      counter = (counter + 1) % 2;
	      textNode.data = String(counter);
	    };
	  } else {
	    // fallback to setTimeout
	    /* istanbul ignore next */
	    timerFunc = function () {
	      setTimeout(nextTickHandler, 0);
	    };
	  }

	  return function queueNextTick (cb, ctx) {
	    var func = ctx
	      ? function () { cb.call(ctx); }
	      : cb;
	    callbacks.push(func);
	    if (!pending) {
	      pending = true;
	      timerFunc();
	    }
	  }
	})();

	var _Set;
	/* istanbul ignore if */
	if (typeof Set !== 'undefined' && isNative(Set)) {
	  // use native Set when available.
	  _Set = Set;
	} else {
	  // a non-standard Set polyfill that only works with primitive keys.
	  _Set = (function () {
	    function Set () {
	      this.set = Object.create(null);
	    }
	    Set.prototype.has = function has (key) {
	      return this.set[key] !== undefined
	    };
	    Set.prototype.add = function add (key) {
	      this.set[key] = 1;
	    };
	    Set.prototype.clear = function clear () {
	      this.set = Object.create(null);
	    };

	    return Set;
	  }());
	}

	/* not type checking this file because flow doesn't play well with Proxy */

	var hasProxy;
	var proxyHandlers;
	var initProxy;

	{
	  var allowedGlobals = makeMap(
	    'Infinity,undefined,NaN,isFinite,isNaN,' +
	    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +
	    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +
	    'require' // for Webpack/Browserify
	  );

	  hasProxy =
	    typeof Proxy !== 'undefined' &&
	    Proxy.toString().match(/native code/);

	  proxyHandlers = {
	    has: function has (target, key) {
	      var has = key in target;
	      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';
	      if (!has && !isAllowed) {
	        warn(
	          "Property or method \"" + key + "\" is not defined on the instance but " +
	          "referenced during render. Make sure to declare reactive data " +
	          "properties in the data option.",
	          target
	        );
	      }
	      return has || !isAllowed
	    }
	  };

	  initProxy = function initProxy (vm) {
	    if (hasProxy) {
	      vm._renderProxy = new Proxy(vm, proxyHandlers);
	    } else {
	      vm._renderProxy = vm;
	    }
	  };
	}

	/*  */


	var uid$2 = 0;

	/**
	 * A dep is an observable that can have multiple
	 * directives subscribing to it.
	 */
	var Dep = function Dep () {
	  this.id = uid$2++;
	  this.subs = [];
	};

	Dep.prototype.addSub = function addSub (sub) {
	  this.subs.push(sub);
	};

	Dep.prototype.removeSub = function removeSub (sub) {
	  remove$1(this.subs, sub);
	};

	Dep.prototype.depend = function depend () {
	  if (Dep.target) {
	    Dep.target.addDep(this);
	  }
	};

	Dep.prototype.notify = function notify () {
	  // stablize the subscriber list first
	  var subs = this.subs.slice();
	  for (var i = 0, l = subs.length; i < l; i++) {
	    subs[i].update();
	  }
	};

	// the current target watcher being evaluated.
	// this is globally unique because there could be only one
	// watcher being evaluated at any time.
	Dep.target = null;
	var targetStack = [];

	function pushTarget (_target) {
	  if (Dep.target) { targetStack.push(Dep.target); }
	  Dep.target = _target;
	}

	function popTarget () {
	  Dep.target = targetStack.pop();
	}

	/*  */


	var queue = [];
	var has$1 = {};
	var circular = {};
	var waiting = false;
	var flushing = false;
	var index = 0;

	/**
	 * Reset the scheduler's state.
	 */
	function resetSchedulerState () {
	  queue.length = 0;
	  has$1 = {};
	  {
	    circular = {};
	  }
	  waiting = flushing = false;
	}

	/**
	 * Flush both queues and run the watchers.
	 */
	function flushSchedulerQueue () {
	  flushing = true;

	  // Sort queue before flush.
	  // This ensures that:
	  // 1. Components are updated from parent to child. (because parent is always
	  //    created before the child)
	  // 2. A component's user watchers are run before its render watcher (because
	  //    user watchers are created before the render watcher)
	  // 3. If a component is destroyed during a parent component's watcher run,
	  //    its watchers can be skipped.
	  queue.sort(function (a, b) { return a.id - b.id; });

	  // do not cache length because more watchers might be pushed
	  // as we run existing watchers
	  for (index = 0; index < queue.length; index++) {
	    var watcher = queue[index];
	    var id = watcher.id;
	    has$1[id] = null;
	    watcher.run();
	    // in dev build, check and stop circular updates.
	    if ("development" !== 'production' && has$1[id] != null) {
	      circular[id] = (circular[id] || 0) + 1;
	      if (circular[id] > config._maxUpdateCount) {
	        warn(
	          'You may have an infinite update loop ' + (
	            watcher.user
	              ? ("in watcher with expression \"" + (watcher.expression) + "\"")
	              : "in a component render function."
	          ),
	          watcher.vm
	        );
	        break
	      }
	    }
	  }

	  // devtool hook
	  /* istanbul ignore if */
	  if (devtools && config.devtools) {
	    devtools.emit('flush');
	  }

	  resetSchedulerState();
	}

	/**
	 * Push a watcher into the watcher queue.
	 * Jobs with duplicate IDs will be skipped unless it's
	 * pushed when the queue is being flushed.
	 */
	function queueWatcher (watcher) {
	  var id = watcher.id;
	  if (has$1[id] == null) {
	    has$1[id] = true;
	    if (!flushing) {
	      queue.push(watcher);
	    } else {
	      // if already flushing, splice the watcher based on its id
	      // if already past its id, it will be run next immediately.
	      var i = queue.length - 1;
	      while (i >= 0 && queue[i].id > watcher.id) {
	        i--;
	      }
	      queue.splice(Math.max(i, index) + 1, 0, watcher);
	    }
	    // queue the flush
	    if (!waiting) {
	      waiting = true;
	      nextTick(flushSchedulerQueue);
	    }
	  }
	}

	/*  */

	var uid$1 = 0;

	/**
	 * A watcher parses an expression, collects dependencies,
	 * and fires callback when the expression value changes.
	 * This is used for both the $watch() api and directives.
	 */
	var Watcher = function Watcher (
	  vm,
	  expOrFn,
	  cb,
	  options
	) {
	  if ( options === void 0 ) options = {};

	  this.vm = vm;
	  vm._watchers.push(this);
	  // options
	  this.deep = !!options.deep;
	  this.user = !!options.user;
	  this.lazy = !!options.lazy;
	  this.sync = !!options.sync;
	  this.expression = expOrFn.toString();
	  this.cb = cb;
	  this.id = ++uid$1; // uid for batching
	  this.active = true;
	  this.dirty = this.lazy; // for lazy watchers
	  this.deps = [];
	  this.newDeps = [];
	  this.depIds = new _Set();
	  this.newDepIds = new _Set();
	  // parse expression for getter
	  if (typeof expOrFn === 'function') {
	    this.getter = expOrFn;
	  } else {
	    this.getter = parsePath(expOrFn);
	    if (!this.getter) {
	      this.getter = function () {};
	      "development" !== 'production' && warn(
	        "Failed watching path: \"" + expOrFn + "\" " +
	        'Watcher only accepts simple dot-delimited paths. ' +
	        'For full control, use a function instead.',
	        vm
	      );
	    }
	  }
	  this.value = this.lazy
	    ? undefined
	    : this.get();
	};

	/**
	 * Evaluate the getter, and re-collect dependencies.
	 */
	Watcher.prototype.get = function get () {
	  pushTarget(this);
	  var value = this.getter.call(this.vm, this.vm);
	  // "touch" every property so they are all tracked as
	  // dependencies for deep watching
	  if (this.deep) {
	    traverse(value);
	  }
	  popTarget();
	  this.cleanupDeps();
	  return value
	};

	/**
	 * Add a dependency to this directive.
	 */
	Watcher.prototype.addDep = function addDep (dep) {
	  var id = dep.id;
	  if (!this.newDepIds.has(id)) {
	    this.newDepIds.add(id);
	    this.newDeps.push(dep);
	    if (!this.depIds.has(id)) {
	      dep.addSub(this);
	    }
	  }
	};

	/**
	 * Clean up for dependency collection.
	 */
	Watcher.prototype.cleanupDeps = function cleanupDeps () {
	    var this$1 = this;

	  var i = this.deps.length;
	  while (i--) {
	    var dep = this$1.deps[i];
	    if (!this$1.newDepIds.has(dep.id)) {
	      dep.removeSub(this$1);
	    }
	  }
	  var tmp = this.depIds;
	  this.depIds = this.newDepIds;
	  this.newDepIds = tmp;
	  this.newDepIds.clear();
	  tmp = this.deps;
	  this.deps = this.newDeps;
	  this.newDeps = tmp;
	  this.newDeps.length = 0;
	};

	/**
	 * Subscriber interface.
	 * Will be called when a dependency changes.
	 */
	Watcher.prototype.update = function update () {
	  /* istanbul ignore else */
	  if (this.lazy) {
	    this.dirty = true;
	  } else if (this.sync) {
	    this.run();
	  } else {
	    queueWatcher(this);
	  }
	};

	/**
	 * Scheduler job interface.
	 * Will be called by the scheduler.
	 */
	Watcher.prototype.run = function run () {
	  if (this.active) {
	    var value = this.get();
	      if (
	        value !== this.value ||
	      // Deep watchers and watchers on Object/Arrays should fire even
	      // when the value is the same, because the value may
	      // have mutated.
	      isObject(value) ||
	      this.deep
	    ) {
	      // set new value
	      var oldValue = this.value;
	      this.value = value;
	      if (this.user) {
	        try {
	          this.cb.call(this.vm, value, oldValue);
	        } catch (e) {
	          "development" !== 'production' && warn(
	            ("Error in watcher \"" + (this.expression) + "\""),
	            this.vm
	          );
	          /* istanbul ignore else */
	          if (config.errorHandler) {
	            config.errorHandler.call(null, e, this.vm);
	          } else {
	            throw e
	          }
	        }
	      } else {
	        this.cb.call(this.vm, value, oldValue);
	      }
	    }
	  }
	};

	/**
	 * Evaluate the value of the watcher.
	 * This only gets called for lazy watchers.
	 */
	Watcher.prototype.evaluate = function evaluate () {
	  this.value = this.get();
	  this.dirty = false;
	};

	/**
	 * Depend on all deps collected by this watcher.
	 */
	Watcher.prototype.depend = function depend () {
	    var this$1 = this;

	  var i = this.deps.length;
	  while (i--) {
	    this$1.deps[i].depend();
	  }
	};

	/**
	 * Remove self from all dependencies' subscriber list.
	 */
	Watcher.prototype.teardown = function teardown () {
	    var this$1 = this;

	  if (this.active) {
	    // remove self from vm's watcher list
	    // this is a somewhat expensive operation so we skip it
	    // if the vm is being destroyed or is performing a v-for
	    // re-render (the watcher list is then filtered by v-for).
	    if (!this.vm._isBeingDestroyed && !this.vm._vForRemoving) {
	      remove$1(this.vm._watchers, this);
	    }
	    var i = this.deps.length;
	    while (i--) {
	      this$1.deps[i].removeSub(this$1);
	    }
	    this.active = false;
	  }
	};

	/**
	 * Recursively traverse an object to evoke all converted
	 * getters, so that every nested property inside the object
	 * is collected as a "deep" dependency.
	 */
	var seenObjects = new _Set();
	function traverse (val) {
	  seenObjects.clear();
	  _traverse(val, seenObjects);
	}

	function _traverse (val, seen) {
	  var i, keys;
	  var isA = Array.isArray(val);
	  if ((!isA && !isObject(val)) || !Object.isExtensible(val)) {
	    return
	  }
	  if (val.__ob__) {
	    var depId = val.__ob__.dep.id;
	    if (seen.has(depId)) {
	      return
	    }
	    seen.add(depId);
	  }
	  if (isA) {
	    i = val.length;
	    while (i--) { _traverse(val[i], seen); }
	  } else {
	    keys = Object.keys(val);
	    i = keys.length;
	    while (i--) { _traverse(val[keys[i]], seen); }
	  }
	}

	/*
	 * not type checking this file because flow doesn't play well with
	 * dynamically accessing methods on Array prototype
	 */

	var arrayProto = Array.prototype;
	var arrayMethods = Object.create(arrayProto);[
	  'push',
	  'pop',
	  'shift',
	  'unshift',
	  'splice',
	  'sort',
	  'reverse'
	]
	.forEach(function (method) {
	  // cache original method
	  var original = arrayProto[method];
	  def(arrayMethods, method, function mutator () {
	    var arguments$1 = arguments;

	    // avoid leaking arguments:
	    // http://jsperf.com/closure-with-arguments
	    var i = arguments.length;
	    var args = new Array(i);
	    while (i--) {
	      args[i] = arguments$1[i];
	    }
	    var result = original.apply(this, args);
	    var ob = this.__ob__;
	    var inserted;
	    switch (method) {
	      case 'push':
	        inserted = args;
	        break
	      case 'unshift':
	        inserted = args;
	        break
	      case 'splice':
	        inserted = args.slice(2);
	        break
	    }
	    if (inserted) { ob.observeArray(inserted); }
	    // notify change
	    ob.dep.notify();
	    return result
	  });
	});

	/*  */

	var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

	/**
	 * By default, when a reactive property is set, the new value is
	 * also converted to become reactive. However when passing down props,
	 * we don't want to force conversion because the value may be a nested value
	 * under a frozen data structure. Converting it would defeat the optimization.
	 */
	var observerState = {
	  shouldConvert: true,
	  isSettingProps: false
	};

	/**
	 * Observer class that are attached to each observed
	 * object. Once attached, the observer converts target
	 * object's property keys into getter/setters that
	 * collect dependencies and dispatches updates.
	 */
	var Observer = function Observer (value) {
	  this.value = value;
	  this.dep = new Dep();
	  this.vmCount = 0;
	  def(value, '__ob__', this);
	  if (Array.isArray(value)) {
	    var augment = hasProto
	      ? protoAugment
	      : copyAugment;
	    augment(value, arrayMethods, arrayKeys);
	    this.observeArray(value);
	  } else {
	    this.walk(value);
	  }
	};

	/**
	 * Walk through each property and convert them into
	 * getter/setters. This method should only be called when
	 * value type is Object.
	 */
	Observer.prototype.walk = function walk (obj) {
	  var keys = Object.keys(obj);
	  for (var i = 0; i < keys.length; i++) {
	    defineReactive$$1(obj, keys[i], obj[keys[i]]);
	  }
	};

	/**
	 * Observe a list of Array items.
	 */
	Observer.prototype.observeArray = function observeArray (items) {
	  for (var i = 0, l = items.length; i < l; i++) {
	    observe(items[i]);
	  }
	};

	// helpers

	/**
	 * Augment an target Object or Array by intercepting
	 * the prototype chain using __proto__
	 */
	function protoAugment (target, src) {
	  /* eslint-disable no-proto */
	  target.__proto__ = src;
	  /* eslint-enable no-proto */
	}

	/**
	 * Augment an target Object or Array by defining
	 * hidden properties.
	 *
	 * istanbul ignore next
	 */
	function copyAugment (target, src, keys) {
	  for (var i = 0, l = keys.length; i < l; i++) {
	    var key = keys[i];
	    def(target, key, src[key]);
	  }
	}

	/**
	 * Attempt to create an observer instance for a value,
	 * returns the new observer if successfully observed,
	 * or the existing observer if the value already has one.
	 */
	function observe (value) {
	  if (!isObject(value)) {
	    return
	  }
	  var ob;
	  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
	    ob = value.__ob__;
	  } else if (
	    observerState.shouldConvert &&
	    !config._isServer &&
	    (Array.isArray(value) || isPlainObject(value)) &&
	    Object.isExtensible(value) &&
	    !value._isVue
	  ) {
	    ob = new Observer(value);
	  }
	  return ob
	}

	/**
	 * Define a reactive property on an Object.
	 */
	function defineReactive$$1 (
	  obj,
	  key,
	  val,
	  customSetter
	) {
	  var dep = new Dep();

	  var property = Object.getOwnPropertyDescriptor(obj, key);
	  if (property && property.configurable === false) {
	    return
	  }

	  // cater for pre-defined getter/setters
	  var getter = property && property.get;
	  var setter = property && property.set;

	  var childOb = observe(val);
	  Object.defineProperty(obj, key, {
	    enumerable: true,
	    configurable: true,
	    get: function reactiveGetter () {
	      var value = getter ? getter.call(obj) : val;
	      if (Dep.target) {
	        dep.depend();
	        if (childOb) {
	          childOb.dep.depend();
	        }
	        if (Array.isArray(value)) {
	          dependArray(value);
	        }
	      }
	      return value
	    },
	    set: function reactiveSetter (newVal) {
	      var value = getter ? getter.call(obj) : val;
	      if (newVal === value) {
	        return
	      }
	      if ("development" !== 'production' && customSetter) {
	        customSetter();
	      }
	      if (setter) {
	        setter.call(obj, newVal);
	      } else {
	        val = newVal;
	      }
	      childOb = observe(newVal);
	      dep.notify();
	    }
	  });
	}

	/**
	 * Set a property on an object. Adds the new property and
	 * triggers change notification if the property doesn't
	 * already exist.
	 */
	function set (obj, key, val) {
	  if (Array.isArray(obj)) {
	    obj.length = Math.max(obj.length, key);
	    obj.splice(key, 1, val);
	    return val
	  }
	  if (hasOwn(obj, key)) {
	    obj[key] = val;
	    return
	  }
	  var ob = obj.__ob__;
	  if (obj._isVue || (ob && ob.vmCount)) {
	    "development" !== 'production' && warn(
	      'Avoid adding reactive properties to a Vue instance or its root $data ' +
	      'at runtime - declare it upfront in the data option.'
	    );
	    return
	  }
	  if (!ob) {
	    obj[key] = val;
	    return
	  }
	  defineReactive$$1(ob.value, key, val);
	  ob.dep.notify();
	  return val
	}

	/**
	 * Delete a property and trigger change if necessary.
	 */
	function del (obj, key) {
	  var ob = obj.__ob__;
	  if (obj._isVue || (ob && ob.vmCount)) {
	    "development" !== 'production' && warn(
	      'Avoid deleting properties on a Vue instance or its root $data ' +
	      '- just set it to null.'
	    );
	    return
	  }
	  if (!hasOwn(obj, key)) {
	    return
	  }
	  delete obj[key];
	  if (!ob) {
	    return
	  }
	  ob.dep.notify();
	}

	/**
	 * Collect dependencies on array elements when the array is touched, since
	 * we cannot intercept array element access like property getters.
	 */
	function dependArray (value) {
	  for (var e = void 0, i = 0, l = value.length; i < l; i++) {
	    e = value[i];
	    e && e.__ob__ && e.__ob__.dep.depend();
	    if (Array.isArray(e)) {
	      dependArray(e);
	    }
	  }
	}

	/*  */

	function initState (vm) {
	  vm._watchers = [];
	  initProps(vm);
	  initData(vm);
	  initComputed(vm);
	  initMethods(vm);
	  initWatch(vm);
	}

	function initProps (vm) {
	  var props = vm.$options.props;
	  if (props) {
	    var propsData = vm.$options.propsData || {};
	    var keys = vm.$options._propKeys = Object.keys(props);
	    var isRoot = !vm.$parent;
	    // root instance props should be converted
	    observerState.shouldConvert = isRoot;
	    var loop = function ( i ) {
	      var key = keys[i];
	      /* istanbul ignore else */
	      {
	        defineReactive$$1(vm, key, validateProp(key, props, propsData, vm), function () {
	          if (vm.$parent && !observerState.isSettingProps) {
	            warn(
	              "Avoid mutating a prop directly since the value will be " +
	              "overwritten whenever the parent component re-renders. " +
	              "Instead, use a data or computed property based on the prop's " +
	              "value. Prop being mutated: \"" + key + "\"",
	              vm
	            );
	          }
	        });
	      }
	    };

	    for (var i = 0; i < keys.length; i++) loop( i );
	    observerState.shouldConvert = true;
	  }
	}

	function initData (vm) {
	  var data = vm.$options.data;
	  data = vm._data = typeof data === 'function'
	    ? data.call(vm)
	    : data || {};
	  if (!isPlainObject(data)) {
	    data = {};
	    "development" !== 'production' && warn(
	      'data functions should return an object.',
	      vm
	    );
	  }
	  // proxy data on instance
	  var keys = Object.keys(data);
	  var props = vm.$options.props;
	  var i = keys.length;
	  while (i--) {
	    if (props && hasOwn(props, keys[i])) {
	      "development" !== 'production' && warn(
	        "The data property \"" + (keys[i]) + "\" is already declared as a prop. " +
	        "Use prop default value instead.",
	        vm
	      );
	    } else {
	      proxy(vm, keys[i]);
	    }
	  }
	  // observe data
	  observe(data);
	  data.__ob__ && data.__ob__.vmCount++;
	}

	var computedSharedDefinition = {
	  enumerable: true,
	  configurable: true,
	  get: noop,
	  set: noop
	};

	function initComputed (vm) {
	  var computed = vm.$options.computed;
	  if (computed) {
	    for (var key in computed) {
	      var userDef = computed[key];
	      if (typeof userDef === 'function') {
	        computedSharedDefinition.get = makeComputedGetter(userDef, vm);
	        computedSharedDefinition.set = noop;
	      } else {
	        computedSharedDefinition.get = userDef.get
	          ? userDef.cache !== false
	            ? makeComputedGetter(userDef.get, vm)
	            : bind$1(userDef.get, vm)
	          : noop;
	        computedSharedDefinition.set = userDef.set
	          ? bind$1(userDef.set, vm)
	          : noop;
	      }
	      Object.defineProperty(vm, key, computedSharedDefinition);
	    }
	  }
	}

	function makeComputedGetter (getter, owner) {
	  var watcher = new Watcher(owner, getter, noop, {
	    lazy: true
	  });
	  return function computedGetter () {
	    if (watcher.dirty) {
	      watcher.evaluate();
	    }
	    if (Dep.target) {
	      watcher.depend();
	    }
	    return watcher.value
	  }
	}

	function initMethods (vm) {
	  var methods = vm.$options.methods;
	  if (methods) {
	    for (var key in methods) {
	      vm[key] = methods[key] == null ? noop : bind$1(methods[key], vm);
	      {
	        methods[key] == null && warn(
	          "method \"" + key + "\" has an undefined value in the component definition. " +
	          "Did you reference the function correctly?",
	          vm
	        );
	        hasOwn(Vue$2.prototype, key) && warn(
	          ("Avoid overriding Vue's internal method \"" + key + "\"."),
	          vm
	        );
	      }
	    }
	  }
	}

	function initWatch (vm) {
	  var watch = vm.$options.watch;
	  if (watch) {
	    for (var key in watch) {
	      var handler = watch[key];
	      if (Array.isArray(handler)) {
	        for (var i = 0; i < handler.length; i++) {
	          createWatcher(vm, key, handler[i]);
	        }
	      } else {
	        createWatcher(vm, key, handler);
	      }
	    }
	  }
	}

	function createWatcher (vm, key, handler) {
	  var options;
	  if (isPlainObject(handler)) {
	    options = handler;
	    handler = handler.handler;
	  }
	  if (typeof handler === 'string') {
	    handler = vm[handler];
	  }
	  vm.$watch(key, handler, options);
	}

	function stateMixin (Vue) {
	  // flow somehow has problems with directly declared definition object
	  // when using Object.defineProperty, so we have to procedurally build up
	  // the object here.
	  var dataDef = {};
	  dataDef.get = function () {
	    return this._data
	  };
	  {
	    dataDef.set = function (newData) {
	      warn(
	        'Avoid replacing instance root $data. ' +
	        'Use nested data properties instead.',
	        this
	      );
	    };
	  }
	  Object.defineProperty(Vue.prototype, '$data', dataDef);

	  Vue.prototype.$set = set;
	  Vue.prototype.$delete = del;

	  Vue.prototype.$watch = function (
	    expOrFn,
	    cb,
	    options
	  ) {
	    var vm = this;
	    options = options || {};
	    options.user = true;
	    var watcher = new Watcher(vm, expOrFn, cb, options);
	    if (options.immediate) {
	      cb.call(vm, watcher.value);
	    }
	    return function unwatchFn () {
	      watcher.teardown();
	    }
	  };
	}

	function proxy (vm, key) {
	  if (!isReserved(key)) {
	    Object.defineProperty(vm, key, {
	      configurable: true,
	      enumerable: true,
	      get: function proxyGetter () {
	        return vm._data[key]
	      },
	      set: function proxySetter (val) {
	        vm._data[key] = val;
	      }
	    });
	  }
	}

	/*  */

	var VNode = function VNode (
	  tag,
	  data,
	  children,
	  text,
	  elm,
	  ns,
	  context,
	  componentOptions
	) {
	  this.tag = tag;
	  this.data = data;
	  this.children = children;
	  this.text = text;
	  this.elm = elm;
	  this.ns = ns;
	  this.context = context;
	  this.functionalContext = undefined;
	  this.key = data && data.key;
	  this.componentOptions = componentOptions;
	  this.child = undefined;
	  this.parent = undefined;
	  this.raw = false;
	  this.isStatic = false;
	  this.isRootInsert = true;
	  this.isComment = false;
	  this.isCloned = false;
	  this.isOnce = false;
	};

	var emptyVNode = function () {
	  var node = new VNode();
	  node.text = '';
	  node.isComment = true;
	  return node
	};

	// optimized shallow clone
	// used for static nodes and slot nodes because they may be reused across
	// multiple renders, cloning them avoids errors when DOM manipulations rely
	// on their elm reference.
	function cloneVNode (vnode) {
	  var cloned = new VNode(
	    vnode.tag,
	    vnode.data,
	    vnode.children,
	    vnode.text,
	    vnode.elm,
	    vnode.ns,
	    vnode.context,
	    vnode.componentOptions
	  );
	  cloned.isStatic = vnode.isStatic;
	  cloned.key = vnode.key;
	  cloned.isCloned = true;
	  return cloned
	}

	function cloneVNodes (vnodes) {
	  var res = new Array(vnodes.length);
	  for (var i = 0; i < vnodes.length; i++) {
	    res[i] = cloneVNode(vnodes[i]);
	  }
	  return res
	}

	/*  */

	function mergeVNodeHook (def, hookKey, hook, key) {
	  key = key + hookKey;
	  var injectedHash = def.__injected || (def.__injected = {});
	  if (!injectedHash[key]) {
	    injectedHash[key] = true;
	    var oldHook = def[hookKey];
	    if (oldHook) {
	      def[hookKey] = function () {
	        oldHook.apply(this, arguments);
	        hook.apply(this, arguments);
	      };
	    } else {
	      def[hookKey] = hook;
	    }
	  }
	}

	/*  */

	function updateListeners (
	  on,
	  oldOn,
	  add,
	  remove$$1,
	  vm
	) {
	  var name, cur, old, fn, event, capture;
	  for (name in on) {
	    cur = on[name];
	    old = oldOn[name];
	    if (!cur) {
	      "development" !== 'production' && warn(
	        "Invalid handler for event \"" + name + "\": got " + String(cur),
	        vm
	      );
	    } else if (!old) {
	      capture = name.charAt(0) === '!';
	      event = capture ? name.slice(1) : name;
	      if (Array.isArray(cur)) {
	        add(event, (cur.invoker = arrInvoker(cur)), capture);
	      } else {
	        if (!cur.invoker) {
	          fn = cur;
	          cur = on[name] = {};
	          cur.fn = fn;
	          cur.invoker = fnInvoker(cur);
	        }
	        add(event, cur.invoker, capture);
	      }
	    } else if (cur !== old) {
	      if (Array.isArray(old)) {
	        old.length = cur.length;
	        for (var i = 0; i < old.length; i++) { old[i] = cur[i]; }
	        on[name] = old;
	      } else {
	        old.fn = cur;
	        on[name] = old;
	      }
	    }
	  }
	  for (name in oldOn) {
	    if (!on[name]) {
	      event = name.charAt(0) === '!' ? name.slice(1) : name;
	      remove$$1(event, oldOn[name].invoker);
	    }
	  }
	}

	function arrInvoker (arr) {
	  return function (ev) {
	    var arguments$1 = arguments;

	    var single = arguments.length === 1;
	    for (var i = 0; i < arr.length; i++) {
	      single ? arr[i](ev) : arr[i].apply(null, arguments$1);
	    }
	  }
	}

	function fnInvoker (o) {
	  return function (ev) {
	    var single = arguments.length === 1;
	    single ? o.fn(ev) : o.fn.apply(null, arguments);
	  }
	}

	/*  */

	function normalizeChildren (
	  children,
	  ns,
	  nestedIndex
	) {
	  if (isPrimitive(children)) {
	    return [createTextVNode(children)]
	  }
	  if (Array.isArray(children)) {
	    var res = [];
	    for (var i = 0, l = children.length; i < l; i++) {
	      var c = children[i];
	      var last = res[res.length - 1];
	      //  nested
	      if (Array.isArray(c)) {
	        res.push.apply(res, normalizeChildren(c, ns, ((nestedIndex || '') + "_" + i)));
	      } else if (isPrimitive(c)) {
	        if (last && last.text) {
	          last.text += String(c);
	        } else if (c !== '') {
	          // convert primitive to vnode
	          res.push(createTextVNode(c));
	        }
	      } else if (c instanceof VNode) {
	        if (c.text && last && last.text) {
	          last.text += c.text;
	        } else {
	          // inherit parent namespace
	          if (ns) {
	            applyNS(c, ns);
	          }
	          // default key for nested array children (likely generated by v-for)
	          if (c.tag && c.key == null && nestedIndex != null) {
	            c.key = "__vlist" + nestedIndex + "_" + i + "__";
	          }
	          res.push(c);
	        }
	      }
	    }
	    return res
	  }
	}

	function createTextVNode (val) {
	  return new VNode(undefined, undefined, undefined, String(val))
	}

	function applyNS (vnode, ns) {
	  if (vnode.tag && !vnode.ns) {
	    vnode.ns = ns;
	    if (vnode.children) {
	      for (var i = 0, l = vnode.children.length; i < l; i++) {
	        applyNS(vnode.children[i], ns);
	      }
	    }
	  }
	}

	/*  */

	function getFirstComponentChild (children) {
	  return children && children.filter(function (c) { return c && c.componentOptions; })[0]
	}

	/*  */

	var activeInstance = null;

	function initLifecycle (vm) {
	  var options = vm.$options;

	  // locate first non-abstract parent
	  var parent = options.parent;
	  if (parent && !options.abstract) {
	    while (parent.$options.abstract && parent.$parent) {
	      parent = parent.$parent;
	    }
	    parent.$children.push(vm);
	  }

	  vm.$parent = parent;
	  vm.$root = parent ? parent.$root : vm;

	  vm.$children = [];
	  vm.$refs = {};

	  vm._watcher = null;
	  vm._inactive = false;
	  vm._isMounted = false;
	  vm._isDestroyed = false;
	  vm._isBeingDestroyed = false;
	}

	function lifecycleMixin (Vue) {
	  Vue.prototype._mount = function (
	    el,
	    hydrating
	  ) {
	    var vm = this;
	    vm.$el = el;
	    if (!vm.$options.render) {
	      vm.$options.render = emptyVNode;
	      {
	        /* istanbul ignore if */
	        if (vm.$options.template) {
	          warn(
	            'You are using the runtime-only build of Vue where the template ' +
	            'option is not available. Either pre-compile the templates into ' +
	            'render functions, or use the compiler-included build.',
	            vm
	          );
	        } else {
	          warn(
	            'Failed to mount component: template or render function not defined.',
	            vm
	          );
	        }
	      }
	    }
	    callHook(vm, 'beforeMount');
	    vm._watcher = new Watcher(vm, function () {
	      vm._update(vm._render(), hydrating);
	    }, noop);
	    hydrating = false;
	    // manually mounted instance, call mounted on self
	    // mounted is called for render-created child components in its inserted hook
	    if (vm.$vnode == null) {
	      vm._isMounted = true;
	      callHook(vm, 'mounted');
	    }
	    return vm
	  };

	  Vue.prototype._update = function (vnode, hydrating) {
	    var vm = this;
	    if (vm._isMounted) {
	      callHook(vm, 'beforeUpdate');
	    }
	    var prevEl = vm.$el;
	    var prevActiveInstance = activeInstance;
	    activeInstance = vm;
	    var prevVnode = vm._vnode;
	    vm._vnode = vnode;
	    if (!prevVnode) {
	      // Vue.prototype.__patch__ is injected in entry points
	      // based on the rendering backend used.
	      vm.$el = vm.__patch__(vm.$el, vnode, hydrating);
	    } else {
	      vm.$el = vm.__patch__(prevVnode, vnode);
	    }
	    activeInstance = prevActiveInstance;
	    // update __vue__ reference
	    if (prevEl) {
	      prevEl.__vue__ = null;
	    }
	    if (vm.$el) {
	      vm.$el.__vue__ = vm;
	    }
	    // if parent is an HOC, update its $el as well
	    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
	      vm.$parent.$el = vm.$el;
	    }
	    if (vm._isMounted) {
	      callHook(vm, 'updated');
	    }
	  };

	  Vue.prototype._updateFromParent = function (
	    propsData,
	    listeners,
	    parentVnode,
	    renderChildren
	  ) {
	    var vm = this;
	    var hasChildren = !!(vm.$options._renderChildren || renderChildren);
	    vm.$options._parentVnode = parentVnode;
	    vm.$options._renderChildren = renderChildren;
	    // update props
	    if (propsData && vm.$options.props) {
	      observerState.shouldConvert = false;
	      {
	        observerState.isSettingProps = true;
	      }
	      var propKeys = vm.$options._propKeys || [];
	      for (var i = 0; i < propKeys.length; i++) {
	        var key = propKeys[i];
	        vm[key] = validateProp(key, vm.$options.props, propsData, vm);
	      }
	      observerState.shouldConvert = true;
	      {
	        observerState.isSettingProps = false;
	      }
	      vm.$options.propsData = propsData;
	    }
	    // update listeners
	    if (listeners) {
	      var oldListeners = vm.$options._parentListeners;
	      vm.$options._parentListeners = listeners;
	      vm._updateListeners(listeners, oldListeners);
	    }
	    // resolve slots + force update if has children
	    if (hasChildren) {
	      vm.$slots = resolveSlots(renderChildren, vm._renderContext);
	      vm.$forceUpdate();
	    }
	  };

	  Vue.prototype.$forceUpdate = function () {
	    var vm = this;
	    if (vm._watcher) {
	      vm._watcher.update();
	    }
	  };

	  Vue.prototype.$destroy = function () {
	    var vm = this;
	    if (vm._isBeingDestroyed) {
	      return
	    }
	    callHook(vm, 'beforeDestroy');
	    vm._isBeingDestroyed = true;
	    // remove self from parent
	    var parent = vm.$parent;
	    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
	      remove$1(parent.$children, vm);
	    }
	    // teardown watchers
	    if (vm._watcher) {
	      vm._watcher.teardown();
	    }
	    var i = vm._watchers.length;
	    while (i--) {
	      vm._watchers[i].teardown();
	    }
	    // remove reference from data ob
	    // frozen object may not have observer.
	    if (vm._data.__ob__) {
	      vm._data.__ob__.vmCount--;
	    }
	    // call the last hook...
	    vm._isDestroyed = true;
	    callHook(vm, 'destroyed');
	    // turn off all instance listeners.
	    vm.$off();
	    // remove __vue__ reference
	    if (vm.$el) {
	      vm.$el.__vue__ = null;
	    }
	    // invoke destroy hooks on current rendered tree
	    vm.__patch__(vm._vnode, null);
	  };
	}

	function callHook (vm, hook) {
	  var handlers = vm.$options[hook];
	  if (handlers) {
	    for (var i = 0, j = handlers.length; i < j; i++) {
	      handlers[i].call(vm);
	    }
	  }
	  vm.$emit('hook:' + hook);
	}

	/*  */

	var hooks = { init: init, prepatch: prepatch, insert: insert, destroy: destroy$1 };
	var hooksToMerge = Object.keys(hooks);

	function createComponent (
	  Ctor,
	  data,
	  context,
	  children,
	  tag
	) {
	  if (!Ctor) {
	    return
	  }

	  if (isObject(Ctor)) {
	    Ctor = Vue$2.extend(Ctor);
	  }

	  if (typeof Ctor !== 'function') {
	    {
	      warn(("Invalid Component definition: " + (String(Ctor))), context);
	    }
	    return
	  }

	  // resolve constructor options in case global mixins are applied after
	  // component constructor creation
	  resolveConstructorOptions(Ctor);

	  // async component
	  if (!Ctor.cid) {
	    if (Ctor.resolved) {
	      Ctor = Ctor.resolved;
	    } else {
	      Ctor = resolveAsyncComponent(Ctor, function () {
	        // it's ok to queue this on every render because
	        // $forceUpdate is buffered by the scheduler.
	        context.$forceUpdate();
	      });
	      if (!Ctor) {
	        // return nothing if this is indeed an async component
	        // wait for the callback to trigger parent update.
	        return
	      }
	    }
	  }

	  data = data || {};

	  // extract props
	  var propsData = extractProps(data, Ctor);

	  // functional component
	  if (Ctor.options.functional) {
	    return createFunctionalComponent(Ctor, propsData, data, context, children)
	  }

	  // extract listeners, since these needs to be treated as
	  // child component listeners instead of DOM listeners
	  var listeners = data.on;
	  // replace with listeners with .native modifier
	  data.on = data.nativeOn;

	  if (Ctor.options.abstract) {
	    // abstract components do not keep anything
	    // other than props & listeners
	    data = {};
	  }

	  // merge component management hooks onto the placeholder node
	  mergeHooks(data);

	  // return a placeholder vnode
	  var name = Ctor.options.name || tag;
	  var vnode = new VNode(
	    ("vue-component-" + (Ctor.cid) + (name ? ("-" + name) : '')),
	    data, undefined, undefined, undefined, undefined, context,
	    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }
	  );
	  return vnode
	}

	function createFunctionalComponent (
	  Ctor,
	  propsData,
	  data,
	  context,
	  children
	) {
	  var props = {};
	  var propOptions = Ctor.options.props;
	  if (propOptions) {
	    for (var key in propOptions) {
	      props[key] = validateProp(key, propOptions, propsData);
	    }
	  }
	  var vnode = Ctor.options.render.call(
	    null,
	    // ensure the createElement function in functional components
	    // gets a unique context - this is necessary for correct named slot check
	    bind$1(createElement, { _self: Object.create(context) }),
	    {
	      props: props,
	      data: data,
	      parent: context,
	      children: normalizeChildren(children),
	      slots: function () { return resolveSlots(children, context); }
	    }
	  );
	  if (vnode instanceof VNode) {
	    vnode.functionalContext = context;
	    if (data.slot) {
	      (vnode.data || (vnode.data = {})).slot = data.slot;
	    }
	  }
	  return vnode
	}

	function createComponentInstanceForVnode (
	  vnode, // we know it's MountedComponentVNode but flow doesn't
	  parent // activeInstance in lifecycle state
	) {
	  var vnodeComponentOptions = vnode.componentOptions;
	  var options = {
	    _isComponent: true,
	    parent: parent,
	    propsData: vnodeComponentOptions.propsData,
	    _componentTag: vnodeComponentOptions.tag,
	    _parentVnode: vnode,
	    _parentListeners: vnodeComponentOptions.listeners,
	    _renderChildren: vnodeComponentOptions.children
	  };
	  // check inline-template render functions
	  var inlineTemplate = vnode.data.inlineTemplate;
	  if (inlineTemplate) {
	    options.render = inlineTemplate.render;
	    options.staticRenderFns = inlineTemplate.staticRenderFns;
	  }
	  return new vnodeComponentOptions.Ctor(options)
	}

	function init (vnode, hydrating) {
	  if (!vnode.child || vnode.child._isDestroyed) {
	    var child = vnode.child = createComponentInstanceForVnode(vnode, activeInstance);
	    child.$mount(hydrating ? vnode.elm : undefined, hydrating);
	  }
	}

	function prepatch (
	  oldVnode,
	  vnode
	) {
	  var options = vnode.componentOptions;
	  var child = vnode.child = oldVnode.child;
	  child._updateFromParent(
	    options.propsData, // updated props
	    options.listeners, // updated listeners
	    vnode, // new parent vnode
	    options.children // new children
	  );
	}

	function insert (vnode) {
	  if (!vnode.child._isMounted) {
	    vnode.child._isMounted = true;
	    callHook(vnode.child, 'mounted');
	  }
	  if (vnode.data.keepAlive) {
	    vnode.child._inactive = false;
	    callHook(vnode.child, 'activated');
	  }
	}

	function destroy$1 (vnode) {
	  if (!vnode.child._isDestroyed) {
	    if (!vnode.data.keepAlive) {
	      vnode.child.$destroy();
	    } else {
	      vnode.child._inactive = true;
	      callHook(vnode.child, 'deactivated');
	    }
	  }
	}

	function resolveAsyncComponent (
	  factory,
	  cb
	) {
	  if (factory.requested) {
	    // pool callbacks
	    factory.pendingCallbacks.push(cb);
	  } else {
	    factory.requested = true;
	    var cbs = factory.pendingCallbacks = [cb];
	    var sync = true;

	    var resolve = function (res) {
	      if (isObject(res)) {
	        res = Vue$2.extend(res);
	      }
	      // cache resolved
	      factory.resolved = res;
	      // invoke callbacks only if this is not a synchronous resolve
	      // (async resolves are shimmed as synchronous during SSR)
	      if (!sync) {
	        for (var i = 0, l = cbs.length; i < l; i++) {
	          cbs[i](res);
	        }
	      }
	    };

	    var reject = function (reason) {
	      "development" !== 'production' && warn(
	        "Failed to resolve async component: " + (String(factory)) +
	        (reason ? ("\nReason: " + reason) : '')
	      );
	    };

	    var res = factory(resolve, reject);

	    // handle promise
	    if (res && typeof res.then === 'function' && !factory.resolved) {
	      res.then(resolve, reject);
	    }

	    sync = false;
	    // return in case resolved synchronously
	    return factory.resolved
	  }
	}

	function extractProps (data, Ctor) {
	  // we are only extracting raw values here.
	  // validation and default values are handled in the child
	  // component itself.
	  var propOptions = Ctor.options.props;
	  if (!propOptions) {
	    return
	  }
	  var res = {};
	  var attrs = data.attrs;
	  var props = data.props;
	  var domProps = data.domProps;
	  if (attrs || props || domProps) {
	    for (var key in propOptions) {
	      var altKey = hyphenate(key);
	      checkProp(res, props, key, altKey, true) ||
	      checkProp(res, attrs, key, altKey) ||
	      checkProp(res, domProps, key, altKey);
	    }
	  }
	  return res
	}

	function checkProp (
	  res,
	  hash,
	  key,
	  altKey,
	  preserve
	) {
	  if (hash) {
	    if (hasOwn(hash, key)) {
	      res[key] = hash[key];
	      if (!preserve) {
	        delete hash[key];
	      }
	      return true
	    } else if (hasOwn(hash, altKey)) {
	      res[key] = hash[altKey];
	      if (!preserve) {
	        delete hash[altKey];
	      }
	      return true
	    }
	  }
	  return false
	}

	function mergeHooks (data) {
	  if (!data.hook) {
	    data.hook = {};
	  }
	  for (var i = 0; i < hooksToMerge.length; i++) {
	    var key = hooksToMerge[i];
	    var fromParent = data.hook[key];
	    var ours = hooks[key];
	    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;
	  }
	}

	function mergeHook$1 (a, b) {
	  // since all hooks have at most two args, use fixed args
	  // to avoid having to use fn.apply().
	  return function (_, __) {
	    a(_, __);
	    b(_, __);
	  }
	}

	/*  */

	// wrapper function for providing a more flexible interface
	// without getting yelled at by flow
	function createElement (
	  tag,
	  data,
	  children
	) {
	  if (data && (Array.isArray(data) || typeof data !== 'object')) {
	    children = data;
	    data = undefined;
	  }
	  // make sure to use real instance instead of proxy as context
	  return _createElement(this._self, tag, data, children)
	}

	function _createElement (
	  context,
	  tag,
	  data,
	  children
	) {
	  if (data && data.__ob__) {
	    "development" !== 'production' && warn(
	      "Avoid using observed data object as vnode data: " + (JSON.stringify(data)) + "\n" +
	      'Always create fresh vnode data objects in each render!',
	      context
	    );
	    return
	  }
	  if (!tag) {
	    // in case of component :is set to falsy value
	    return emptyVNode()
	  }
	  if (typeof tag === 'string') {
	    var Ctor;
	    var ns = config.getTagNamespace(tag);
	    if (config.isReservedTag(tag)) {
	      // platform built-in elements
	      return new VNode(
	        tag, data, normalizeChildren(children, ns),
	        undefined, undefined, ns, context
	      )
	    } else if ((Ctor = resolveAsset(context.$options, 'components', tag))) {
	      // component
	      return createComponent(Ctor, data, context, children, tag)
	    } else {
	      // unknown or unlisted namespaced elements
	      // check at runtime because it may get assigned a namespace when its
	      // parent normalizes children
	      var childNs = tag === 'foreignObject' ? 'xhtml' : ns;
	      return new VNode(
	        tag, data, normalizeChildren(children, childNs),
	        undefined, undefined, ns, context
	      )
	    }
	  } else {
	    // direct component options / constructor
	    return createComponent(tag, data, context, children)
	  }
	}

	/*  */

	function initRender (vm) {
	  vm.$vnode = null; // the placeholder node in parent tree
	  vm._vnode = null; // the root of the child tree
	  vm._staticTrees = null;
	  vm._renderContext = vm.$options._parentVnode && vm.$options._parentVnode.context;
	  vm.$slots = resolveSlots(vm.$options._renderChildren, vm._renderContext);
	  // bind the public createElement fn to this instance
	  // so that we get proper render context inside it.
	  vm.$createElement = bind$1(createElement, vm);
	  if (vm.$options.el) {
	    vm.$mount(vm.$options.el);
	  }
	}

	function renderMixin (Vue) {
	  Vue.prototype.$nextTick = function (fn) {
	    nextTick(fn, this);
	  };

	  Vue.prototype._render = function () {
	    var vm = this;
	    var ref = vm.$options;
	    var render = ref.render;
	    var staticRenderFns = ref.staticRenderFns;
	    var _parentVnode = ref._parentVnode;

	    if (vm._isMounted) {
	      // clone slot nodes on re-renders
	      for (var key in vm.$slots) {
	        vm.$slots[key] = cloneVNodes(vm.$slots[key]);
	      }
	    }

	    if (staticRenderFns && !vm._staticTrees) {
	      vm._staticTrees = [];
	    }
	    // set parent vnode. this allows render functions to have access
	    // to the data on the placeholder node.
	    vm.$vnode = _parentVnode;
	    // render self
	    var vnode;
	    try {
	      vnode = render.call(vm._renderProxy, vm.$createElement);
	    } catch (e) {
	      {
	        warn(("Error when rendering " + (formatComponentName(vm)) + ":"));
	      }
	      /* istanbul ignore else */
	      if (config.errorHandler) {
	        config.errorHandler.call(null, e, vm);
	      } else {
	        if (config._isServer) {
	          throw e
	        } else {
	          console.error(e);
	        }
	      }
	      // return previous vnode to prevent render error causing blank component
	      vnode = vm._vnode;
	    }
	    // return empty vnode in case the render function errored out
	    if (!(vnode instanceof VNode)) {
	      if ("development" !== 'production' && Array.isArray(vnode)) {
	        warn(
	          'Multiple root nodes returned from render function. Render function ' +
	          'should return a single root node.',
	          vm
	        );
	      }
	      vnode = emptyVNode();
	    }
	    // set parent
	    vnode.parent = _parentVnode;
	    return vnode
	  };

	  // shorthands used in render functions
	  Vue.prototype._h = createElement;
	  // toString for mustaches
	  Vue.prototype._s = _toString;
	  // number conversion
	  Vue.prototype._n = toNumber;
	  // empty vnode
	  Vue.prototype._e = emptyVNode;
	  // loose equal
	  Vue.prototype._q = looseEqual;
	  // loose indexOf
	  Vue.prototype._i = looseIndexOf;

	  // render static tree by index
	  Vue.prototype._m = function renderStatic (
	    index,
	    isInFor
	  ) {
	    var tree = this._staticTrees[index];
	    // if has already-rendered static tree and not inside v-for,
	    // we can reuse the same tree by doing a shallow clone.
	    if (tree && !isInFor) {
	      return Array.isArray(tree)
	        ? cloneVNodes(tree)
	        : cloneVNode(tree)
	    }
	    // otherwise, render a fresh tree.
	    tree = this._staticTrees[index] = this.$options.staticRenderFns[index].call(this._renderProxy);
	    markStatic(tree, ("__static__" + index), false);
	    return tree
	  };

	  // mark node as static (v-once)
	  Vue.prototype._o = function markOnce (
	    tree,
	    index,
	    key
	  ) {
	    markStatic(tree, ("__once__" + index + (key ? ("_" + key) : "")), true);
	    return tree
	  };

	  function markStatic (tree, key, isOnce) {
	    if (Array.isArray(tree)) {
	      for (var i = 0; i < tree.length; i++) {
	        if (tree[i] && typeof tree[i] !== 'string') {
	          markStaticNode(tree[i], (key + "_" + i), isOnce);
	        }
	      }
	    } else {
	      markStaticNode(tree, key, isOnce);
	    }
	  }

	  function markStaticNode (node, key, isOnce) {
	    node.isStatic = true;
	    node.key = key;
	    node.isOnce = isOnce;
	  }

	  // filter resolution helper
	  var identity = function (_) { return _; };
	  Vue.prototype._f = function resolveFilter (id) {
	    return resolveAsset(this.$options, 'filters', id, true) || identity
	  };

	  // render v-for
	  Vue.prototype._l = function renderList (
	    val,
	    render
	  ) {
	    var ret, i, l, keys, key;
	    if (Array.isArray(val)) {
	      ret = new Array(val.length);
	      for (i = 0, l = val.length; i < l; i++) {
	        ret[i] = render(val[i], i);
	      }
	    } else if (typeof val === 'number') {
	      ret = new Array(val);
	      for (i = 0; i < val; i++) {
	        ret[i] = render(i + 1, i);
	      }
	    } else if (isObject(val)) {
	      keys = Object.keys(val);
	      ret = new Array(keys.length);
	      for (i = 0, l = keys.length; i < l; i++) {
	        key = keys[i];
	        ret[i] = render(val[key], key, i);
	      }
	    }
	    return ret
	  };

	  // renderSlot
	  Vue.prototype._t = function (
	    name,
	    fallback
	  ) {
	    var slotNodes = this.$slots[name];
	    // warn duplicate slot usage
	    if (slotNodes && "development" !== 'production') {
	      slotNodes._rendered && warn(
	        "Duplicate presence of slot \"" + name + "\" found in the same render tree " +
	        "- this will likely cause render errors.",
	        this
	      );
	      slotNodes._rendered = true;
	    }
	    return slotNodes || fallback
	  };

	  // apply v-bind object
	  Vue.prototype._b = function bindProps (
	    data,
	    value,
	    asProp
	  ) {
	    if (value) {
	      if (!isObject(value)) {
	        "development" !== 'production' && warn(
	          'v-bind without argument expects an Object or Array value',
	          this
	        );
	      } else {
	        if (Array.isArray(value)) {
	          value = toObject(value);
	        }
	        for (var key in value) {
	          if (key === 'class' || key === 'style') {
	            data[key] = value[key];
	          } else {
	            var hash = asProp || config.mustUseProp(key)
	              ? data.domProps || (data.domProps = {})
	              : data.attrs || (data.attrs = {});
	            hash[key] = value[key];
	          }
	        }
	      }
	    }
	    return data
	  };

	  // expose v-on keyCodes
	  Vue.prototype._k = function getKeyCodes (key) {
	    return config.keyCodes[key]
	  };
	}

	function resolveSlots (
	  renderChildren,
	  context
	) {
	  var slots = {};
	  if (!renderChildren) {
	    return slots
	  }
	  var children = normalizeChildren(renderChildren) || [];
	  var defaultSlot = [];
	  var name, child;
	  for (var i = 0, l = children.length; i < l; i++) {
	    child = children[i];
	    // named slots should only be respected if the vnode was rendered in the
	    // same context.
	    if ((child.context === context || child.functionalContext === context) &&
	        child.data && (name = child.data.slot)) {
	      var slot = (slots[name] || (slots[name] = []));
	      if (child.tag === 'template') {
	        slot.push.apply(slot, child.children);
	      } else {
	        slot.push(child);
	      }
	    } else {
	      defaultSlot.push(child);
	    }
	  }
	  // ignore single whitespace
	  if (defaultSlot.length && !(
	    defaultSlot.length === 1 &&
	    (defaultSlot[0].text === ' ' || defaultSlot[0].isComment)
	  )) {
	    slots.default = defaultSlot;
	  }
	  return slots
	}

	/*  */

	function initEvents (vm) {
	  vm._events = Object.create(null);
	  // init parent attached events
	  var listeners = vm.$options._parentListeners;
	  var on = bind$1(vm.$on, vm);
	  var off = bind$1(vm.$off, vm);
	  vm._updateListeners = function (listeners, oldListeners) {
	    updateListeners(listeners, oldListeners || {}, on, off, vm);
	  };
	  if (listeners) {
	    vm._updateListeners(listeners);
	  }
	}

	function eventsMixin (Vue) {
	  Vue.prototype.$on = function (event, fn) {
	    var vm = this;(vm._events[event] || (vm._events[event] = [])).push(fn);
	    return vm
	  };

	  Vue.prototype.$once = function (event, fn) {
	    var vm = this;
	    function on () {
	      vm.$off(event, on);
	      fn.apply(vm, arguments);
	    }
	    on.fn = fn;
	    vm.$on(event, on);
	    return vm
	  };

	  Vue.prototype.$off = function (event, fn) {
	    var vm = this;
	    // all
	    if (!arguments.length) {
	      vm._events = Object.create(null);
	      return vm
	    }
	    // specific event
	    var cbs = vm._events[event];
	    if (!cbs) {
	      return vm
	    }
	    if (arguments.length === 1) {
	      vm._events[event] = null;
	      return vm
	    }
	    // specific handler
	    var cb;
	    var i = cbs.length;
	    while (i--) {
	      cb = cbs[i];
	      if (cb === fn || cb.fn === fn) {
	        cbs.splice(i, 1);
	        break
	      }
	    }
	    return vm
	  };

	  Vue.prototype.$emit = function (event) {
	    var vm = this;
	    var cbs = vm._events[event];
	    if (cbs) {
	      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
	      var args = toArray(arguments, 1);
	      for (var i = 0, l = cbs.length; i < l; i++) {
	        cbs[i].apply(vm, args);
	      }
	    }
	    return vm
	  };
	}

	/*  */

	var uid = 0;

	function initMixin (Vue) {
	  Vue.prototype._init = function (options) {
	    var vm = this;
	    // a uid
	    vm._uid = uid++;
	    // a flag to avoid this being observed
	    vm._isVue = true;
	    // merge options
	    if (options && options._isComponent) {
	      // optimize internal component instantiation
	      // since dynamic options merging is pretty slow, and none of the
	      // internal component options needs special treatment.
	      initInternalComponent(vm, options);
	    } else {
	      vm.$options = mergeOptions(
	        resolveConstructorOptions(vm.constructor),
	        options || {},
	        vm
	      );
	    }
	    /* istanbul ignore else */
	    {
	      initProxy(vm);
	    }
	    // expose real self
	    vm._self = vm;
	    initLifecycle(vm);
	    initEvents(vm);
	    callHook(vm, 'beforeCreate');
	    initState(vm);
	    callHook(vm, 'created');
	    initRender(vm);
	  };
	}

	function initInternalComponent (vm, options) {
	  var opts = vm.$options = Object.create(vm.constructor.options);
	  // doing this because it's faster than dynamic enumeration.
	  opts.parent = options.parent;
	  opts.propsData = options.propsData;
	  opts._parentVnode = options._parentVnode;
	  opts._parentListeners = options._parentListeners;
	  opts._renderChildren = options._renderChildren;
	  opts._componentTag = options._componentTag;
	  if (options.render) {
	    opts.render = options.render;
	    opts.staticRenderFns = options.staticRenderFns;
	  }
	}

	function resolveConstructorOptions (Ctor) {
	  var options = Ctor.options;
	  if (Ctor.super) {
	    var superOptions = Ctor.super.options;
	    var cachedSuperOptions = Ctor.superOptions;
	    var extendOptions = Ctor.extendOptions;
	    if (superOptions !== cachedSuperOptions) {
	      // super option changed
	      Ctor.superOptions = superOptions;
	      extendOptions.render = options.render;
	      extendOptions.staticRenderFns = options.staticRenderFns;
	      options = Ctor.options = mergeOptions(superOptions, extendOptions);
	      if (options.name) {
	        options.components[options.name] = Ctor;
	      }
	    }
	  }
	  return options
	}

	function Vue$2 (options) {
	  if ("development" !== 'production' &&
	    !(this instanceof Vue$2)) {
	    warn('Vue is a constructor and should be called with the `new` keyword');
	  }
	  this._init(options);
	}

	initMixin(Vue$2);
	stateMixin(Vue$2);
	eventsMixin(Vue$2);
	lifecycleMixin(Vue$2);
	renderMixin(Vue$2);

	var warn = noop;
	var formatComponentName;

	{
	  var hasConsole = typeof console !== 'undefined';

	  warn = function (msg, vm) {
	    if (hasConsole && (!config.silent)) {
	      console.error("[Vue warn]: " + msg + " " + (
	        vm ? formatLocation(formatComponentName(vm)) : ''
	      ));
	    }
	  };

	  formatComponentName = function (vm) {
	    if (vm.$root === vm) {
	      return 'root instance'
	    }
	    var name = vm._isVue
	      ? vm.$options.name || vm.$options._componentTag
	      : vm.name;
	    return (
	      (name ? ("component <" + name + ">") : "anonymous component") +
	      (vm._isVue && vm.$options.__file ? (" at " + (vm.$options.__file)) : '')
	    )
	  };

	  var formatLocation = function (str) {
	    if (str === 'anonymous component') {
	      str += " - use the \"name\" option for better debugging messages.";
	    }
	    return ("\n(found in " + str + ")")
	  };
	}

	/*  */

	/**
	 * Option overwriting strategies are functions that handle
	 * how to merge a parent option value and a child option
	 * value into the final value.
	 */
	var strats = config.optionMergeStrategies;

	/**
	 * Options with restrictions
	 */
	{
	  strats.el = strats.propsData = function (parent, child, vm, key) {
	    if (!vm) {
	      warn(
	        "option \"" + key + "\" can only be used during instance " +
	        'creation with the `new` keyword.'
	      );
	    }
	    return defaultStrat(parent, child)
	  };
	}

	/**
	 * Helper that recursively merges two data objects together.
	 */
	function mergeData (to, from) {
	  var key, toVal, fromVal;
	  for (key in from) {
	    toVal = to[key];
	    fromVal = from[key];
	    if (!hasOwn(to, key)) {
	      set(to, key, fromVal);
	    } else if (isObject(toVal) && isObject(fromVal)) {
	      mergeData(toVal, fromVal);
	    }
	  }
	  return to
	}

	/**
	 * Data
	 */
	strats.data = function (
	  parentVal,
	  childVal,
	  vm
	) {
	  if (!vm) {
	    // in a Vue.extend merge, both should be functions
	    if (!childVal) {
	      return parentVal
	    }
	    if (typeof childVal !== 'function') {
	      "development" !== 'production' && warn(
	        'The "data" option should be a function ' +
	        'that returns a per-instance value in component ' +
	        'definitions.',
	        vm
	      );
	      return parentVal
	    }
	    if (!parentVal) {
	      return childVal
	    }
	    // when parentVal & childVal are both present,
	    // we need to return a function that returns the
	    // merged result of both functions... no need to
	    // check if parentVal is a function here because
	    // it has to be a function to pass previous merges.
	    return function mergedDataFn () {
	      return mergeData(
	        childVal.call(this),
	        parentVal.call(this)
	      )
	    }
	  } else if (parentVal || childVal) {
	    return function mergedInstanceDataFn () {
	      // instance merge
	      var instanceData = typeof childVal === 'function'
	        ? childVal.call(vm)
	        : childVal;
	      var defaultData = typeof parentVal === 'function'
	        ? parentVal.call(vm)
	        : undefined;
	      if (instanceData) {
	        return mergeData(instanceData, defaultData)
	      } else {
	        return defaultData
	      }
	    }
	  }
	};

	/**
	 * Hooks and param attributes are merged as arrays.
	 */
	function mergeHook (
	  parentVal,
	  childVal
	) {
	  return childVal
	    ? parentVal
	      ? parentVal.concat(childVal)
	      : Array.isArray(childVal)
	        ? childVal
	        : [childVal]
	    : parentVal
	}

	config._lifecycleHooks.forEach(function (hook) {
	  strats[hook] = mergeHook;
	});

	/**
	 * Assets
	 *
	 * When a vm is present (instance creation), we need to do
	 * a three-way merge between constructor options, instance
	 * options and parent options.
	 */
	function mergeAssets (parentVal, childVal) {
	  var res = Object.create(parentVal || null);
	  return childVal
	    ? extend(res, childVal)
	    : res
	}

	config._assetTypes.forEach(function (type) {
	  strats[type + 's'] = mergeAssets;
	});

	/**
	 * Watchers.
	 *
	 * Watchers hashes should not overwrite one
	 * another, so we merge them as arrays.
	 */
	strats.watch = function (parentVal, childVal) {
	  /* istanbul ignore if */
	  if (!childVal) { return parentVal }
	  if (!parentVal) { return childVal }
	  var ret = {};
	  extend(ret, parentVal);
	  for (var key in childVal) {
	    var parent = ret[key];
	    var child = childVal[key];
	    if (parent && !Array.isArray(parent)) {
	      parent = [parent];
	    }
	    ret[key] = parent
	      ? parent.concat(child)
	      : [child];
	  }
	  return ret
	};

	/**
	 * Other object hashes.
	 */
	strats.props =
	strats.methods =
	strats.computed = function (parentVal, childVal) {
	  if (!childVal) { return parentVal }
	  if (!parentVal) { return childVal }
	  var ret = Object.create(null);
	  extend(ret, parentVal);
	  extend(ret, childVal);
	  return ret
	};

	/**
	 * Default strategy.
	 */
	var defaultStrat = function (parentVal, childVal) {
	  return childVal === undefined
	    ? parentVal
	    : childVal
	};

	/**
	 * Validate component names
	 */
	function checkComponents (options) {
	  for (var key in options.components) {
	    var lower = key.toLowerCase();
	    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {
	      warn(
	        'Do not use built-in or reserved HTML elements as component ' +
	        'id: ' + key
	      );
	    }
	  }
	}

	/**
	 * Ensure all props option syntax are normalized into the
	 * Object-based format.
	 */
	function normalizeProps (options) {
	  var props = options.props;
	  if (!props) { return }
	  var res = {};
	  var i, val, name;
	  if (Array.isArray(props)) {
	    i = props.length;
	    while (i--) {
	      val = props[i];
	      if (typeof val === 'string') {
	        name = camelize(val);
	        res[name] = { type: null };
	      } else {
	        warn('props must be strings when using array syntax.');
	      }
	    }
	  } else if (isPlainObject(props)) {
	    for (var key in props) {
	      val = props[key];
	      name = camelize(key);
	      res[name] = isPlainObject(val)
	        ? val
	        : { type: val };
	    }
	  }
	  options.props = res;
	}

	/**
	 * Normalize raw function directives into object format.
	 */
	function normalizeDirectives (options) {
	  var dirs = options.directives;
	  if (dirs) {
	    for (var key in dirs) {
	      var def = dirs[key];
	      if (typeof def === 'function') {
	        dirs[key] = { bind: def, update: def };
	      }
	    }
	  }
	}

	/**
	 * Merge two option objects into a new one.
	 * Core utility used in both instantiation and inheritance.
	 */
	function mergeOptions (
	  parent,
	  child,
	  vm
	) {
	  {
	    checkComponents(child);
	  }
	  normalizeProps(child);
	  normalizeDirectives(child);
	  var extendsFrom = child.extends;
	  if (extendsFrom) {
	    parent = typeof extendsFrom === 'function'
	      ? mergeOptions(parent, extendsFrom.options, vm)
	      : mergeOptions(parent, extendsFrom, vm);
	  }
	  if (child.mixins) {
	    for (var i = 0, l = child.mixins.length; i < l; i++) {
	      var mixin = child.mixins[i];
	      if (mixin.prototype instanceof Vue$2) {
	        mixin = mixin.options;
	      }
	      parent = mergeOptions(parent, mixin, vm);
	    }
	  }
	  var options = {};
	  var key;
	  for (key in parent) {
	    mergeField(key);
	  }
	  for (key in child) {
	    if (!hasOwn(parent, key)) {
	      mergeField(key);
	    }
	  }
	  function mergeField (key) {
	    var strat = strats[key] || defaultStrat;
	    options[key] = strat(parent[key], child[key], vm, key);
	  }
	  return options
	}

	/**
	 * Resolve an asset.
	 * This function is used because child instances need access
	 * to assets defined in its ancestor chain.
	 */
	function resolveAsset (
	  options,
	  type,
	  id,
	  warnMissing
	) {
	  /* istanbul ignore if */
	  if (typeof id !== 'string') {
	    return
	  }
	  var assets = options[type];
	  var res = assets[id] ||
	    // camelCase ID
	    assets[camelize(id)] ||
	    // Pascal Case ID
	    assets[capitalize(camelize(id))];
	  if ("development" !== 'production' && warnMissing && !res) {
	    warn(
	      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,
	      options
	    );
	  }
	  return res
	}

	/*  */

	function validateProp (
	  key,
	  propOptions,
	  propsData,
	  vm
	) {
	  var prop = propOptions[key];
	  var absent = !hasOwn(propsData, key);
	  var value = propsData[key];
	  // handle boolean props
	  if (isBooleanType(prop.type)) {
	    if (absent && !hasOwn(prop, 'default')) {
	      value = false;
	    } else if (value === '' || value === hyphenate(key)) {
	      value = true;
	    }
	  }
	  // check default value
	  if (value === undefined) {
	    value = getPropDefaultValue(vm, prop, key);
	    // since the default value is a fresh copy,
	    // make sure to observe it.
	    var prevShouldConvert = observerState.shouldConvert;
	    observerState.shouldConvert = true;
	    observe(value);
	    observerState.shouldConvert = prevShouldConvert;
	  }
	  {
	    assertProp(prop, key, value, vm, absent);
	  }
	  return value
	}

	/**
	 * Get the default value of a prop.
	 */
	function getPropDefaultValue (vm, prop, key) {
	  // no default, return undefined
	  if (!hasOwn(prop, 'default')) {
	    return undefined
	  }
	  var def = prop.default;
	  // warn against non-factory defaults for Object & Array
	  if (isObject(def)) {
	    "development" !== 'production' && warn(
	      'Invalid default value for prop "' + key + '": ' +
	      'Props with type Object/Array must use a factory function ' +
	      'to return the default value.',
	      vm
	    );
	  }
	  // the raw prop value was also undefined from previous render,
	  // return previous default value to avoid unnecessary watcher trigger
	  if (vm && vm.$options.propsData &&
	    vm.$options.propsData[key] === undefined &&
	    vm[key] !== undefined) {
	    return vm[key]
	  }
	  // call factory function for non-Function types
	  return typeof def === 'function' && prop.type !== Function
	    ? def.call(vm)
	    : def
	}

	/**
	 * Assert whether a prop is valid.
	 */
	function assertProp (
	  prop,
	  name,
	  value,
	  vm,
	  absent
	) {
	  if (prop.required && absent) {
	    warn(
	      'Missing required prop: "' + name + '"',
	      vm
	    );
	    return
	  }
	  if (value == null && !prop.required) {
	    return
	  }
	  var type = prop.type;
	  var valid = !type || type === true;
	  var expectedTypes = [];
	  if (type) {
	    if (!Array.isArray(type)) {
	      type = [type];
	    }
	    for (var i = 0; i < type.length && !valid; i++) {
	      var assertedType = assertType(value, type[i]);
	      expectedTypes.push(assertedType.expectedType);
	      valid = assertedType.valid;
	    }
	  }
	  if (!valid) {
	    warn(
	      'Invalid prop: type check failed for prop "' + name + '".' +
	      ' Expected ' + expectedTypes.map(capitalize).join(', ') +
	      ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.',
	      vm
	    );
	    return
	  }
	  var validator = prop.validator;
	  if (validator) {
	    if (!validator(value)) {
	      warn(
	        'Invalid prop: custom validator check failed for prop "' + name + '".',
	        vm
	      );
	    }
	  }
	}

	/**
	 * Assert the type of a value
	 */
	function assertType (value, type) {
	  var valid;
	  var expectedType = getType(type);
	  if (expectedType === 'String') {
	    valid = typeof value === (expectedType = 'string');
	  } else if (expectedType === 'Number') {
	    valid = typeof value === (expectedType = 'number');
	  } else if (expectedType === 'Boolean') {
	    valid = typeof value === (expectedType = 'boolean');
	  } else if (expectedType === 'Function') {
	    valid = typeof value === (expectedType = 'function');
	  } else if (expectedType === 'Object') {
	    valid = isPlainObject(value);
	  } else if (expectedType === 'Array') {
	    valid = Array.isArray(value);
	  } else {
	    valid = value instanceof type;
	  }
	  return {
	    valid: valid,
	    expectedType: expectedType
	  }
	}

	/**
	 * Use function string name to check built-in types,
	 * because a simple equality check will fail when running
	 * across different vms / iframes.
	 */
	function getType (fn) {
	  var match = fn && fn.toString().match(/^\s*function (\w+)/);
	  return match && match[1]
	}

	function isBooleanType (fn) {
	  if (!Array.isArray(fn)) {
	    return getType(fn) === 'Boolean'
	  }
	  for (var i = 0, len = fn.length; i < len; i++) {
	    if (getType(fn[i]) === 'Boolean') {
	      return true
	    }
	  }
	  /* istanbul ignore next */
	  return false
	}



	var util = Object.freeze({
		defineReactive: defineReactive$$1,
		_toString: _toString,
		toNumber: toNumber,
		makeMap: makeMap,
		isBuiltInTag: isBuiltInTag,
		remove: remove$1,
		hasOwn: hasOwn,
		isPrimitive: isPrimitive,
		cached: cached,
		camelize: camelize,
		capitalize: capitalize,
		hyphenate: hyphenate,
		bind: bind$1,
		toArray: toArray,
		extend: extend,
		isObject: isObject,
		isPlainObject: isPlainObject,
		toObject: toObject,
		noop: noop,
		no: no,
		genStaticKeys: genStaticKeys,
		looseEqual: looseEqual,
		looseIndexOf: looseIndexOf,
		isReserved: isReserved,
		def: def,
		parsePath: parsePath,
		hasProto: hasProto,
		inBrowser: inBrowser,
		UA: UA,
		isIE: isIE,
		isIE9: isIE9,
		isEdge: isEdge,
		isAndroid: isAndroid,
		isIOS: isIOS,
		devtools: devtools,
		nextTick: nextTick,
		get _Set () { return _Set; },
		mergeOptions: mergeOptions,
		resolveAsset: resolveAsset,
		get warn () { return warn; },
		get formatComponentName () { return formatComponentName; },
		validateProp: validateProp
	});

	/*  */

	function initUse (Vue) {
	  Vue.use = function (plugin) {
	    /* istanbul ignore if */
	    if (plugin.installed) {
	      return
	    }
	    // additional parameters
	    var args = toArray(arguments, 1);
	    args.unshift(this);
	    if (typeof plugin.install === 'function') {
	      plugin.install.apply(plugin, args);
	    } else {
	      plugin.apply(null, args);
	    }
	    plugin.installed = true;
	    return this
	  };
	}

	/*  */

	function initMixin$1 (Vue) {
	  Vue.mixin = function (mixin) {
	    Vue.options = mergeOptions(Vue.options, mixin);
	  };
	}

	/*  */

	function initExtend (Vue) {
	  /**
	   * Each instance constructor, including Vue, has a unique
	   * cid. This enables us to create wrapped "child
	   * constructors" for prototypal inheritance and cache them.
	   */
	  Vue.cid = 0;
	  var cid = 1;

	  /**
	   * Class inheritance
	   */
	  Vue.extend = function (extendOptions) {
	    extendOptions = extendOptions || {};
	    var Super = this;
	    var isFirstExtend = Super.cid === 0;
	    if (isFirstExtend && extendOptions._Ctor) {
	      return extendOptions._Ctor
	    }
	    var name = extendOptions.name || Super.options.name;
	    {
	      if (!/^[a-zA-Z][\w-]*$/.test(name)) {
	        warn(
	          'Invalid component name: "' + name + '". Component names ' +
	          'can only contain alphanumeric characaters and the hyphen.'
	        );
	      }
	    }
	    var Sub = function VueComponent (options) {
	      this._init(options);
	    };
	    Sub.prototype = Object.create(Super.prototype);
	    Sub.prototype.constructor = Sub;
	    Sub.cid = cid++;
	    Sub.options = mergeOptions(
	      Super.options,
	      extendOptions
	    );
	    Sub['super'] = Super;
	    // allow further extension
	    Sub.extend = Super.extend;
	    // create asset registers, so extended classes
	    // can have their private assets too.
	    config._assetTypes.forEach(function (type) {
	      Sub[type] = Super[type];
	    });
	    // enable recursive self-lookup
	    if (name) {
	      Sub.options.components[name] = Sub;
	    }
	    // keep a reference to the super options at extension time.
	    // later at instantiation we can check if Super's options have
	    // been updated.
	    Sub.superOptions = Super.options;
	    Sub.extendOptions = extendOptions;
	    // cache constructor
	    if (isFirstExtend) {
	      extendOptions._Ctor = Sub;
	    }
	    return Sub
	  };
	}

	/*  */

	function initAssetRegisters (Vue) {
	  /**
	   * Create asset registration methods.
	   */
	  config._assetTypes.forEach(function (type) {
	    Vue[type] = function (
	      id,
	      definition
	    ) {
	      if (!definition) {
	        return this.options[type + 's'][id]
	      } else {
	        /* istanbul ignore if */
	        {
	          if (type === 'component' && config.isReservedTag(id)) {
	            warn(
	              'Do not use built-in or reserved HTML elements as component ' +
	              'id: ' + id
	            );
	          }
	        }
	        if (type === 'component' && isPlainObject(definition)) {
	          definition.name = definition.name || id;
	          definition = Vue.extend(definition);
	        }
	        if (type === 'directive' && typeof definition === 'function') {
	          definition = { bind: definition, update: definition };
	        }
	        this.options[type + 's'][id] = definition;
	        return definition
	      }
	    };
	  });
	}

	var KeepAlive = {
	  name: 'keep-alive',
	  abstract: true,
	  created: function created () {
	    this.cache = Object.create(null);
	  },
	  render: function render () {
	    var vnode = getFirstComponentChild(this.$slots.default);
	    if (vnode && vnode.componentOptions) {
	      var opts = vnode.componentOptions;
	      var key = vnode.key == null
	        // same constructor may get registered as different local components
	        // so cid alone is not enough (#3269)
	        ? opts.Ctor.cid + '::' + opts.tag
	        : vnode.key;
	      if (this.cache[key]) {
	        vnode.child = this.cache[key].child;
	      } else {
	        this.cache[key] = vnode;
	      }
	      vnode.data.keepAlive = true;
	    }
	    return vnode
	  },
	  destroyed: function destroyed () {
	    var this$1 = this;

	    for (var key in this.cache) {
	      var vnode = this$1.cache[key];
	      callHook(vnode.child, 'deactivated');
	      vnode.child.$destroy();
	    }
	  }
	};

	var builtInComponents = {
	  KeepAlive: KeepAlive
	};

	/*  */

	function initGlobalAPI (Vue) {
	  // config
	  var configDef = {};
	  configDef.get = function () { return config; };
	  {
	    configDef.set = function () {
	      warn(
	        'Do not replace the Vue.config object, set individual fields instead.'
	      );
	    };
	  }
	  Object.defineProperty(Vue, 'config', configDef);
	  Vue.util = util;
	  Vue.set = set;
	  Vue.delete = del;
	  Vue.nextTick = nextTick;

	  Vue.options = Object.create(null);
	  config._assetTypes.forEach(function (type) {
	    Vue.options[type + 's'] = Object.create(null);
	  });

	  extend(Vue.options.components, builtInComponents);

	  initUse(Vue);
	  initMixin$1(Vue);
	  initExtend(Vue);
	  initAssetRegisters(Vue);
	}

	initGlobalAPI(Vue$2);

	Object.defineProperty(Vue$2.prototype, '$isServer', {
	  get: function () { return config._isServer; }
	});

	Vue$2.version = '2.0.5';

	/*  */

	// attributes that should be using props for binding
	var mustUseProp = makeMap('value,selected,checked,muted');

	var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');

	var isBooleanAttr = makeMap(
	  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +
	  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +
	  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +
	  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +
	  'required,reversed,scoped,seamless,selected,sortable,translate,' +
	  'truespeed,typemustmatch,visible'
	);

	var isAttr = makeMap(
	  'accept,accept-charset,accesskey,action,align,alt,async,autocomplete,' +
	  'autofocus,autoplay,autosave,bgcolor,border,buffered,challenge,charset,' +
	  'checked,cite,class,code,codebase,color,cols,colspan,content,http-equiv,' +
	  'name,contenteditable,contextmenu,controls,coords,data,datetime,default,' +
	  'defer,dir,dirname,disabled,download,draggable,dropzone,enctype,method,for,' +
	  'form,formaction,headers,<th>,height,hidden,high,href,hreflang,http-equiv,' +
	  'icon,id,ismap,itemprop,keytype,kind,label,lang,language,list,loop,low,' +
	  'manifest,max,maxlength,media,method,GET,POST,min,multiple,email,file,' +
	  'muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,' +
	  'preload,radiogroup,readonly,rel,required,reversed,rows,rowspan,sandbox,' +
	  'scope,scoped,seamless,selected,shape,size,type,text,password,sizes,span,' +
	  'spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,' +
	  'target,title,type,usemap,value,width,wrap'
	);



	var xlinkNS = 'http://www.w3.org/1999/xlink';

	var isXlink = function (name) {
	  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'
	};

	var getXlinkProp = function (name) {
	  return isXlink(name) ? name.slice(6, name.length) : ''
	};

	var isFalsyAttrValue = function (val) {
	  return val == null || val === false
	};

	/*  */

	function genClassForVnode (vnode) {
	  var data = vnode.data;
	  var parentNode = vnode;
	  var childNode = vnode;
	  while (childNode.child) {
	    childNode = childNode.child._vnode;
	    if (childNode.data) {
	      data = mergeClassData(childNode.data, data);
	    }
	  }
	  while ((parentNode = parentNode.parent)) {
	    if (parentNode.data) {
	      data = mergeClassData(data, parentNode.data);
	    }
	  }
	  return genClassFromData(data)
	}

	function mergeClassData (child, parent) {
	  return {
	    staticClass: concat(child.staticClass, parent.staticClass),
	    class: child.class
	      ? [child.class, parent.class]
	      : parent.class
	  }
	}

	function genClassFromData (data) {
	  var dynamicClass = data.class;
	  var staticClass = data.staticClass;
	  if (staticClass || dynamicClass) {
	    return concat(staticClass, stringifyClass(dynamicClass))
	  }
	  /* istanbul ignore next */
	  return ''
	}

	function concat (a, b) {
	  return a ? b ? (a + ' ' + b) : a : (b || '')
	}

	function stringifyClass (value) {
	  var res = '';
	  if (!value) {
	    return res
	  }
	  if (typeof value === 'string') {
	    return value
	  }
	  if (Array.isArray(value)) {
	    var stringified;
	    for (var i = 0, l = value.length; i < l; i++) {
	      if (value[i]) {
	        if ((stringified = stringifyClass(value[i]))) {
	          res += stringified + ' ';
	        }
	      }
	    }
	    return res.slice(0, -1)
	  }
	  if (isObject(value)) {
	    for (var key in value) {
	      if (value[key]) { res += key + ' '; }
	    }
	    return res.slice(0, -1)
	  }
	  /* istanbul ignore next */
	  return res
	}

	/*  */

	var namespaceMap = {
	  svg: 'http://www.w3.org/2000/svg',
	  math: 'http://www.w3.org/1998/Math/MathML',
	  xhtml: 'http://www.w3.org/1999/xhtm'
	};

	var isHTMLTag = makeMap(
	  'html,body,base,head,link,meta,style,title,' +
	  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +
	  'div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,' +
	  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +
	  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +
	  'embed,object,param,source,canvas,script,noscript,del,ins,' +
	  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +
	  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +
	  'output,progress,select,textarea,' +
	  'details,dialog,menu,menuitem,summary,' +
	  'content,element,shadow,template'
	);

	var isUnaryTag = makeMap(
	  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +
	  'link,meta,param,source,track,wbr',
	  true
	);

	// Elements that you can, intentionally, leave open
	// (and which close themselves)
	var canBeLeftOpenTag = makeMap(
	  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source',
	  true
	);

	// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
	// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content
	var isNonPhrasingTag = makeMap(
	  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +
	  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +
	  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +
	  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +
	  'title,tr,track',
	  true
	);

	// this map is intentionally selective, only covering SVG elements that may
	// contain child elements.
	var isSVG = makeMap(
	  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font,' +
	  'font-face,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +
	  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',
	  true
	);

	var isPreTag = function (tag) { return tag === 'pre'; };

	var isReservedTag = function (tag) {
	  return isHTMLTag(tag) || isSVG(tag)
	};

	function getTagNamespace (tag) {
	  if (isSVG(tag)) {
	    return 'svg'
	  }
	  // basic support for MathML
	  // note it doesn't support other MathML elements being component roots
	  if (tag === 'math') {
	    return 'math'
	  }
	}

	var unknownElementCache = Object.create(null);
	function isUnknownElement (tag) {
	  /* istanbul ignore if */
	  if (!inBrowser) {
	    return true
	  }
	  if (isReservedTag(tag)) {
	    return false
	  }
	  tag = tag.toLowerCase();
	  /* istanbul ignore if */
	  if (unknownElementCache[tag] != null) {
	    return unknownElementCache[tag]
	  }
	  var el = document.createElement(tag);
	  if (tag.indexOf('-') > -1) {
	    // http://stackoverflow.com/a/28210364/1070244
	    return (unknownElementCache[tag] = (
	      el.constructor === window.HTMLUnknownElement ||
	      el.constructor === window.HTMLElement
	    ))
	  } else {
	    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))
	  }
	}

	/*  */

	/**
	 * Query an element selector if it's not an element already.
	 */
	function query (el) {
	  if (typeof el === 'string') {
	    var selector = el;
	    el = document.querySelector(el);
	    if (!el) {
	      "development" !== 'production' && warn(
	        'Cannot find element: ' + selector
	      );
	      return document.createElement('div')
	    }
	  }
	  return el
	}

	/*  */

	function createElement$1 (tagName, vnode) {
	  var elm = document.createElement(tagName);
	  if (tagName !== 'select') {
	    return elm
	  }
	  if (vnode.data && vnode.data.attrs && 'multiple' in vnode.data.attrs) {
	    elm.setAttribute('multiple', 'multiple');
	  }
	  return elm
	}

	function createElementNS (namespace, tagName) {
	  return document.createElementNS(namespaceMap[namespace], tagName)
	}

	function createTextNode (text) {
	  return document.createTextNode(text)
	}

	function createComment (text) {
	  return document.createComment(text)
	}

	function insertBefore (parentNode, newNode, referenceNode) {
	  parentNode.insertBefore(newNode, referenceNode);
	}

	function removeChild (node, child) {
	  node.removeChild(child);
	}

	function appendChild (node, child) {
	  node.appendChild(child);
	}

	function parentNode (node) {
	  return node.parentNode
	}

	function nextSibling (node) {
	  return node.nextSibling
	}

	function tagName (node) {
	  return node.tagName
	}

	function setTextContent (node, text) {
	  node.textContent = text;
	}

	function childNodes (node) {
	  return node.childNodes
	}

	function setAttribute (node, key, val) {
	  node.setAttribute(key, val);
	}


	var nodeOps = Object.freeze({
		createElement: createElement$1,
		createElementNS: createElementNS,
		createTextNode: createTextNode,
		createComment: createComment,
		insertBefore: insertBefore,
		removeChild: removeChild,
		appendChild: appendChild,
		parentNode: parentNode,
		nextSibling: nextSibling,
		tagName: tagName,
		setTextContent: setTextContent,
		childNodes: childNodes,
		setAttribute: setAttribute
	});

	/*  */

	var ref = {
	  create: function create (_, vnode) {
	    registerRef(vnode);
	  },
	  update: function update (oldVnode, vnode) {
	    if (oldVnode.data.ref !== vnode.data.ref) {
	      registerRef(oldVnode, true);
	      registerRef(vnode);
	    }
	  },
	  destroy: function destroy (vnode) {
	    registerRef(vnode, true);
	  }
	};

	function registerRef (vnode, isRemoval) {
	  var key = vnode.data.ref;
	  if (!key) { return }

	  var vm = vnode.context;
	  var ref = vnode.child || vnode.elm;
	  var refs = vm.$refs;
	  if (isRemoval) {
	    if (Array.isArray(refs[key])) {
	      remove$1(refs[key], ref);
	    } else if (refs[key] === ref) {
	      refs[key] = undefined;
	    }
	  } else {
	    if (vnode.data.refInFor) {
	      if (Array.isArray(refs[key])) {
	        refs[key].push(ref);
	      } else {
	        refs[key] = [ref];
	      }
	    } else {
	      refs[key] = ref;
	    }
	  }
	}

	/**
	 * Virtual DOM patching algorithm based on Snabbdom by
	 * Simon Friis Vindum (@paldepind)
	 * Licensed under the MIT License
	 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
	 *
	 * modified by Evan You (@yyx990803)
	 *

	/*
	 * Not type-checking this because this file is perf-critical and the cost
	 * of making flow understand it is not worth it.
	 */

	var emptyNode = new VNode('', {}, []);

	var hooks$1 = ['create', 'update', 'remove', 'destroy'];

	function isUndef (s) {
	  return s == null
	}

	function isDef (s) {
	  return s != null
	}

	function sameVnode (vnode1, vnode2) {
	  return (
	    vnode1.key === vnode2.key &&
	    vnode1.tag === vnode2.tag &&
	    vnode1.isComment === vnode2.isComment &&
	    !vnode1.data === !vnode2.data
	  )
	}

	function createKeyToOldIdx (children, beginIdx, endIdx) {
	  var i, key;
	  var map = {};
	  for (i = beginIdx; i <= endIdx; ++i) {
	    key = children[i].key;
	    if (isDef(key)) { map[key] = i; }
	  }
	  return map
	}

	function createPatchFunction (backend) {
	  var i, j;
	  var cbs = {};

	  var modules = backend.modules;
	  var nodeOps = backend.nodeOps;

	  for (i = 0; i < hooks$1.length; ++i) {
	    cbs[hooks$1[i]] = [];
	    for (j = 0; j < modules.length; ++j) {
	      if (modules[j][hooks$1[i]] !== undefined) { cbs[hooks$1[i]].push(modules[j][hooks$1[i]]); }
	    }
	  }

	  function emptyNodeAt (elm) {
	    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)
	  }

	  function createRmCb (childElm, listeners) {
	    function remove$$1 () {
	      if (--remove$$1.listeners === 0) {
	        removeElement(childElm);
	      }
	    }
	    remove$$1.listeners = listeners;
	    return remove$$1
	  }

	  function removeElement (el) {
	    var parent = nodeOps.parentNode(el);
	    // element may have already been removed due to v-html
	    if (parent) {
	      nodeOps.removeChild(parent, el);
	    }
	  }

	  function createElm (vnode, insertedVnodeQueue, nested) {
	    var i;
	    var data = vnode.data;
	    vnode.isRootInsert = !nested;
	    if (isDef(data)) {
	      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode); }
	      // after calling the init hook, if the vnode is a child component
	      // it should've created a child instance and mounted it. the child
	      // component also has set the placeholder vnode's elm.
	      // in that case we can just return the element and be done.
	      if (isDef(i = vnode.child)) {
	        initComponent(vnode, insertedVnodeQueue);
	        return vnode.elm
	      }
	    }
	    var children = vnode.children;
	    var tag = vnode.tag;
	    if (isDef(tag)) {
	      {
	        if (
	          !vnode.ns &&
	          !(config.ignoredElements && config.ignoredElements.indexOf(tag) > -1) &&
	          config.isUnknownElement(tag)
	        ) {
	          warn(
	            'Unknown custom element: <' + tag + '> - did you ' +
	            'register the component correctly? For recursive components, ' +
	            'make sure to provide the "name" option.',
	            vnode.context
	          );
	        }
	      }
	      vnode.elm = vnode.ns
	        ? nodeOps.createElementNS(vnode.ns, tag)
	        : nodeOps.createElement(tag, vnode);
	      setScope(vnode);
	      createChildren(vnode, children, insertedVnodeQueue);
	      if (isDef(data)) {
	        invokeCreateHooks(vnode, insertedVnodeQueue);
	      }
	    } else if (vnode.isComment) {
	      vnode.elm = nodeOps.createComment(vnode.text);
	    } else {
	      vnode.elm = nodeOps.createTextNode(vnode.text);
	    }
	    return vnode.elm
	  }

	  function createChildren (vnode, children, insertedVnodeQueue) {
	    if (Array.isArray(children)) {
	      for (var i = 0; i < children.length; ++i) {
	        nodeOps.appendChild(vnode.elm, createElm(children[i], insertedVnodeQueue, true));
	      }
	    } else if (isPrimitive(vnode.text)) {
	      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));
	    }
	  }

	  function isPatchable (vnode) {
	    while (vnode.child) {
	      vnode = vnode.child._vnode;
	    }
	    return isDef(vnode.tag)
	  }

	  function invokeCreateHooks (vnode, insertedVnodeQueue) {
	    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
	      cbs.create[i$1](emptyNode, vnode);
	    }
	    i = vnode.data.hook; // Reuse variable
	    if (isDef(i)) {
	      if (i.create) { i.create(emptyNode, vnode); }
	      if (i.insert) { insertedVnodeQueue.push(vnode); }
	    }
	  }

	  function initComponent (vnode, insertedVnodeQueue) {
	    if (vnode.data.pendingInsert) {
	      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
	    }
	    vnode.elm = vnode.child.$el;
	    if (isPatchable(vnode)) {
	      invokeCreateHooks(vnode, insertedVnodeQueue);
	      setScope(vnode);
	    } else {
	      // empty component root.
	      // skip all element-related modules except for ref (#3455)
	      registerRef(vnode);
	      // make sure to invoke the insert hook
	      insertedVnodeQueue.push(vnode);
	    }
	  }

	  // set scope id attribute for scoped CSS.
	  // this is implemented as a special case to avoid the overhead
	  // of going through the normal attribute patching process.
	  function setScope (vnode) {
	    var i;
	    if (isDef(i = vnode.context) && isDef(i = i.$options._scopeId)) {
	      nodeOps.setAttribute(vnode.elm, i, '');
	    }
	    if (isDef(i = activeInstance) &&
	        i !== vnode.context &&
	        isDef(i = i.$options._scopeId)) {
	      nodeOps.setAttribute(vnode.elm, i, '');
	    }
	  }

	  function addVnodes (parentElm, before, vnodes, startIdx, endIdx, insertedVnodeQueue) {
	    for (; startIdx <= endIdx; ++startIdx) {
	      nodeOps.insertBefore(parentElm, createElm(vnodes[startIdx], insertedVnodeQueue), before);
	    }
	  }

	  function invokeDestroyHook (vnode) {
	    var i, j;
	    var data = vnode.data;
	    if (isDef(data)) {
	      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }
	      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }
	    }
	    if (isDef(i = vnode.children)) {
	      for (j = 0; j < vnode.children.length; ++j) {
	        invokeDestroyHook(vnode.children[j]);
	      }
	    }
	  }

	  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {
	    for (; startIdx <= endIdx; ++startIdx) {
	      var ch = vnodes[startIdx];
	      if (isDef(ch)) {
	        if (isDef(ch.tag)) {
	          removeAndInvokeRemoveHook(ch);
	          invokeDestroyHook(ch);
	        } else { // Text node
	          nodeOps.removeChild(parentElm, ch.elm);
	        }
	      }
	    }
	  }

	  function removeAndInvokeRemoveHook (vnode, rm) {
	    if (rm || isDef(vnode.data)) {
	      var listeners = cbs.remove.length + 1;
	      if (!rm) {
	        // directly removing
	        rm = createRmCb(vnode.elm, listeners);
	      } else {
	        // we have a recursively passed down rm callback
	        // increase the listeners count
	        rm.listeners += listeners;
	      }
	      // recursively invoke hooks on child component root node
	      if (isDef(i = vnode.child) && isDef(i = i._vnode) && isDef(i.data)) {
	        removeAndInvokeRemoveHook(i, rm);
	      }
	      for (i = 0; i < cbs.remove.length; ++i) {
	        cbs.remove[i](vnode, rm);
	      }
	      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
	        i(vnode, rm);
	      } else {
	        rm();
	      }
	    } else {
	      removeElement(vnode.elm);
	    }
	  }

	  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
	    var oldStartIdx = 0;
	    var newStartIdx = 0;
	    var oldEndIdx = oldCh.length - 1;
	    var oldStartVnode = oldCh[0];
	    var oldEndVnode = oldCh[oldEndIdx];
	    var newEndIdx = newCh.length - 1;
	    var newStartVnode = newCh[0];
	    var newEndVnode = newCh[newEndIdx];
	    var oldKeyToIdx, idxInOld, elmToMove, before;

	    // removeOnly is a special flag used only by <transition-group>
	    // to ensure removed elements stay in correct relative positions
	    // during leaving transitions
	    var canMove = !removeOnly;

	    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
	      if (isUndef(oldStartVnode)) {
	        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
	      } else if (isUndef(oldEndVnode)) {
	        oldEndVnode = oldCh[--oldEndIdx];
	      } else if (sameVnode(oldStartVnode, newStartVnode)) {
	        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
	        oldStartVnode = oldCh[++oldStartIdx];
	        newStartVnode = newCh[++newStartIdx];
	      } else if (sameVnode(oldEndVnode, newEndVnode)) {
	        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
	        oldEndVnode = oldCh[--oldEndIdx];
	        newEndVnode = newCh[--newEndIdx];
	      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
	        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
	        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
	        oldStartVnode = oldCh[++oldStartIdx];
	        newEndVnode = newCh[--newEndIdx];
	      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
	        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
	        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
	        oldEndVnode = oldCh[--oldEndIdx];
	        newStartVnode = newCh[++newStartIdx];
	      } else {
	        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }
	        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;
	        if (isUndef(idxInOld)) { // New element
	          nodeOps.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
	          newStartVnode = newCh[++newStartIdx];
	        } else {
	          elmToMove = oldCh[idxInOld];
	          /* istanbul ignore if */
	          if ("development" !== 'production' && !elmToMove) {
	            warn(
	              'It seems there are duplicate keys that is causing an update error. ' +
	              'Make sure each v-for item has a unique key.'
	            );
	          }
	          if (elmToMove.tag !== newStartVnode.tag) {
	            // same key but different element. treat as new element
	            nodeOps.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
	            newStartVnode = newCh[++newStartIdx];
	          } else {
	            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
	            oldCh[idxInOld] = undefined;
	            canMove && nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);
	            newStartVnode = newCh[++newStartIdx];
	          }
	        }
	      }
	    }
	    if (oldStartIdx > oldEndIdx) {
	      before = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
	      addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
	    } else if (newStartIdx > newEndIdx) {
	      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
	    }
	  }

	  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {
	    if (oldVnode === vnode) {
	      return
	    }
	    // reuse element for static trees.
	    // note we only do this if the vnode is cloned -
	    // if the new node is not cloned it means the render functions have been
	    // reset by the hot-reload-api and we need to do a proper re-render.
	    if (vnode.isStatic &&
	        oldVnode.isStatic &&
	        vnode.key === oldVnode.key &&
	        (vnode.isCloned || vnode.isOnce)) {
	      vnode.elm = oldVnode.elm;
	      return
	    }
	    var i;
	    var data = vnode.data;
	    var hasData = isDef(data);
	    if (hasData && isDef(i = data.hook) && isDef(i = i.prepatch)) {
	      i(oldVnode, vnode);
	    }
	    var elm = vnode.elm = oldVnode.elm;
	    var oldCh = oldVnode.children;
	    var ch = vnode.children;
	    if (hasData && isPatchable(vnode)) {
	      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }
	      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }
	    }
	    if (isUndef(vnode.text)) {
	      if (isDef(oldCh) && isDef(ch)) {
	        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }
	      } else if (isDef(ch)) {
	        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }
	        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
	      } else if (isDef(oldCh)) {
	        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
	      } else if (isDef(oldVnode.text)) {
	        nodeOps.setTextContent(elm, '');
	      }
	    } else if (oldVnode.text !== vnode.text) {
	      nodeOps.setTextContent(elm, vnode.text);
	    }
	    if (hasData) {
	      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }
	    }
	  }

	  function invokeInsertHook (vnode, queue, initial) {
	    // delay insert hooks for component root nodes, invoke them after the
	    // element is really inserted
	    if (initial && vnode.parent) {
	      vnode.parent.data.pendingInsert = queue;
	    } else {
	      for (var i = 0; i < queue.length; ++i) {
	        queue[i].data.hook.insert(queue[i]);
	      }
	    }
	  }

	  var bailed = false;
	  function hydrate (elm, vnode, insertedVnodeQueue) {
	    {
	      if (!assertNodeMatch(elm, vnode)) {
	        return false
	      }
	    }
	    vnode.elm = elm;
	    var tag = vnode.tag;
	    var data = vnode.data;
	    var children = vnode.children;
	    if (isDef(data)) {
	      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }
	      if (isDef(i = vnode.child)) {
	        // child component. it should have hydrated its own tree.
	        initComponent(vnode, insertedVnodeQueue);
	        return true
	      }
	    }
	    if (isDef(tag)) {
	      if (isDef(children)) {
	        var childNodes = nodeOps.childNodes(elm);
	        // empty element, allow client to pick up and populate children
	        if (!childNodes.length) {
	          createChildren(vnode, children, insertedVnodeQueue);
	        } else {
	          var childrenMatch = true;
	          if (childNodes.length !== children.length) {
	            childrenMatch = false;
	          } else {
	            for (var i$1 = 0; i$1 < children.length; i$1++) {
	              if (!hydrate(childNodes[i$1], children[i$1], insertedVnodeQueue)) {
	                childrenMatch = false;
	                break
	              }
	            }
	          }
	          if (!childrenMatch) {
	            if ("development" !== 'production' &&
	                typeof console !== 'undefined' &&
	                !bailed) {
	              bailed = true;
	              console.warn('Parent: ', elm);
	              console.warn('Mismatching childNodes vs. VNodes: ', childNodes, children);
	            }
	            return false
	          }
	        }
	      }
	      if (isDef(data)) {
	        invokeCreateHooks(vnode, insertedVnodeQueue);
	      }
	    }
	    return true
	  }

	  function assertNodeMatch (node, vnode) {
	    if (vnode.tag) {
	      return (
	        vnode.tag.indexOf('vue-component') === 0 ||
	        vnode.tag === nodeOps.tagName(node).toLowerCase()
	      )
	    } else {
	      return _toString(vnode.text) === node.data
	    }
	  }

	  return function patch (oldVnode, vnode, hydrating, removeOnly) {
	    if (!vnode) {
	      if (oldVnode) { invokeDestroyHook(oldVnode); }
	      return
	    }

	    var elm, parent;
	    var isInitialPatch = false;
	    var insertedVnodeQueue = [];

	    if (!oldVnode) {
	      // empty mount, create new root element
	      isInitialPatch = true;
	      createElm(vnode, insertedVnodeQueue);
	    } else {
	      var isRealElement = isDef(oldVnode.nodeType);
	      if (!isRealElement && sameVnode(oldVnode, vnode)) {
	        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);
	      } else {
	        if (isRealElement) {
	          // mounting to a real element
	          // check if this is server-rendered content and if we can perform
	          // a successful hydration.
	          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute('server-rendered')) {
	            oldVnode.removeAttribute('server-rendered');
	            hydrating = true;
	          }
	          if (hydrating) {
	            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
	              invokeInsertHook(vnode, insertedVnodeQueue, true);
	              return oldVnode
	            } else {
	              warn(
	                'The client-side rendered virtual DOM tree is not matching ' +
	                'server-rendered content. This is likely caused by incorrect ' +
	                'HTML markup, for example nesting block-level elements inside ' +
	                '<p>, or missing <tbody>. Bailing hydration and performing ' +
	                'full client-side render.'
	              );
	            }
	          }
	          // either not server-rendered, or hydration failed.
	          // create an empty node and replace it
	          oldVnode = emptyNodeAt(oldVnode);
	        }
	        elm = oldVnode.elm;
	        parent = nodeOps.parentNode(elm);

	        createElm(vnode, insertedVnodeQueue);

	        // component root element replaced.
	        // update parent placeholder node element.
	        if (vnode.parent) {
	          vnode.parent.elm = vnode.elm;
	          if (isPatchable(vnode)) {
	            for (var i = 0; i < cbs.create.length; ++i) {
	              cbs.create[i](emptyNode, vnode.parent);
	            }
	          }
	        }

	        if (parent !== null) {
	          nodeOps.insertBefore(parent, vnode.elm, nodeOps.nextSibling(elm));
	          removeVnodes(parent, [oldVnode], 0, 0);
	        } else if (isDef(oldVnode.tag)) {
	          invokeDestroyHook(oldVnode);
	        }
	      }
	    }

	    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
	    return vnode.elm
	  }
	}

	/*  */

	var directives = {
	  create: updateDirectives,
	  update: updateDirectives,
	  destroy: function unbindDirectives (vnode) {
	    updateDirectives(vnode, emptyNode);
	  }
	};

	function updateDirectives (
	  oldVnode,
	  vnode
	) {
	  if (!oldVnode.data.directives && !vnode.data.directives) {
	    return
	  }
	  var isCreate = oldVnode === emptyNode;
	  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
	  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);

	  var dirsWithInsert = [];
	  var dirsWithPostpatch = [];

	  var key, oldDir, dir;
	  for (key in newDirs) {
	    oldDir = oldDirs[key];
	    dir = newDirs[key];
	    if (!oldDir) {
	      // new directive, bind
	      callHook$1(dir, 'bind', vnode, oldVnode);
	      if (dir.def && dir.def.inserted) {
	        dirsWithInsert.push(dir);
	      }
	    } else {
	      // existing directive, update
	      dir.oldValue = oldDir.value;
	      callHook$1(dir, 'update', vnode, oldVnode);
	      if (dir.def && dir.def.componentUpdated) {
	        dirsWithPostpatch.push(dir);
	      }
	    }
	  }

	  if (dirsWithInsert.length) {
	    var callInsert = function () {
	      dirsWithInsert.forEach(function (dir) {
	        callHook$1(dir, 'inserted', vnode, oldVnode);
	      });
	    };
	    if (isCreate) {
	      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert, 'dir-insert');
	    } else {
	      callInsert();
	    }
	  }

	  if (dirsWithPostpatch.length) {
	    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {
	      dirsWithPostpatch.forEach(function (dir) {
	        callHook$1(dir, 'componentUpdated', vnode, oldVnode);
	      });
	    }, 'dir-postpatch');
	  }

	  if (!isCreate) {
	    for (key in oldDirs) {
	      if (!newDirs[key]) {
	        // no longer present, unbind
	        callHook$1(oldDirs[key], 'unbind', oldVnode);
	      }
	    }
	  }
	}

	var emptyModifiers = Object.create(null);

	function normalizeDirectives$1 (
	  dirs,
	  vm
	) {
	  var res = Object.create(null);
	  if (!dirs) {
	    return res
	  }
	  var i, dir;
	  for (i = 0; i < dirs.length; i++) {
	    dir = dirs[i];
	    if (!dir.modifiers) {
	      dir.modifiers = emptyModifiers;
	    }
	    res[getRawDirName(dir)] = dir;
	    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
	  }
	  return res
	}

	function getRawDirName (dir) {
	  return dir.rawName || ((dir.name) + "." + (Object.keys(dir.modifiers || {}).join('.')))
	}

	function callHook$1 (dir, hook, vnode, oldVnode) {
	  var fn = dir.def && dir.def[hook];
	  if (fn) {
	    fn(vnode.elm, dir, vnode, oldVnode);
	  }
	}

	var baseModules = [
	  ref,
	  directives
	];

	/*  */

	function updateAttrs (oldVnode, vnode) {
	  if (!oldVnode.data.attrs && !vnode.data.attrs) {
	    return
	  }
	  var key, cur, old;
	  var elm = vnode.elm;
	  var oldAttrs = oldVnode.data.attrs || {};
	  var attrs = vnode.data.attrs || {};
	  // clone observed objects, as the user probably wants to mutate it
	  if (attrs.__ob__) {
	    attrs = vnode.data.attrs = extend({}, attrs);
	  }

	  for (key in attrs) {
	    cur = attrs[key];
	    old = oldAttrs[key];
	    if (old !== cur) {
	      setAttr(elm, key, cur);
	    }
	  }
	  for (key in oldAttrs) {
	    if (attrs[key] == null) {
	      if (isXlink(key)) {
	        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
	      } else if (!isEnumeratedAttr(key)) {
	        elm.removeAttribute(key);
	      }
	    }
	  }
	}

	function setAttr (el, key, value) {
	  if (isBooleanAttr(key)) {
	    // set attribute for blank value
	    // e.g. <option disabled>Select one</option>
	    if (isFalsyAttrValue(value)) {
	      el.removeAttribute(key);
	    } else {
	      el.setAttribute(key, key);
	    }
	  } else if (isEnumeratedAttr(key)) {
	    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');
	  } else if (isXlink(key)) {
	    if (isFalsyAttrValue(value)) {
	      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
	    } else {
	      el.setAttributeNS(xlinkNS, key, value);
	    }
	  } else {
	    if (isFalsyAttrValue(value)) {
	      el.removeAttribute(key);
	    } else {
	      el.setAttribute(key, value);
	    }
	  }
	}

	var attrs = {
	  create: updateAttrs,
	  update: updateAttrs
	};

	/*  */

	function updateClass (oldVnode, vnode) {
	  var el = vnode.elm;
	  var data = vnode.data;
	  var oldData = oldVnode.data;
	  if (!data.staticClass && !data.class &&
	      (!oldData || (!oldData.staticClass && !oldData.class))) {
	    return
	  }

	  var cls = genClassForVnode(vnode);

	  // handle transition classes
	  var transitionClass = el._transitionClasses;
	  if (transitionClass) {
	    cls = concat(cls, stringifyClass(transitionClass));
	  }

	  // set the class
	  if (cls !== el._prevClass) {
	    el.setAttribute('class', cls);
	    el._prevClass = cls;
	  }
	}

	var klass = {
	  create: updateClass,
	  update: updateClass
	};

	// skip type checking this file because we need to attach private properties
	// to elements

	function updateDOMListeners (oldVnode, vnode) {
	  if (!oldVnode.data.on && !vnode.data.on) {
	    return
	  }
	  var on = vnode.data.on || {};
	  var oldOn = oldVnode.data.on || {};
	  var add = vnode.elm._v_add || (vnode.elm._v_add = function (event, handler, capture) {
	    vnode.elm.addEventListener(event, handler, capture);
	  });
	  var remove = vnode.elm._v_remove || (vnode.elm._v_remove = function (event, handler) {
	    vnode.elm.removeEventListener(event, handler);
	  });
	  updateListeners(on, oldOn, add, remove, vnode.context);
	}

	var events = {
	  create: updateDOMListeners,
	  update: updateDOMListeners
	};

	/*  */

	function updateDOMProps (oldVnode, vnode) {
	  if (!oldVnode.data.domProps && !vnode.data.domProps) {
	    return
	  }
	  var key, cur;
	  var elm = vnode.elm;
	  var oldProps = oldVnode.data.domProps || {};
	  var props = vnode.data.domProps || {};
	  // clone observed objects, as the user probably wants to mutate it
	  if (props.__ob__) {
	    props = vnode.data.domProps = extend({}, props);
	  }

	  for (key in oldProps) {
	    if (props[key] == null) {
	      elm[key] = '';
	    }
	  }
	  for (key in props) {
	    // ignore children if the node has textContent or innerHTML,
	    // as these will throw away existing DOM nodes and cause removal errors
	    // on subsequent patches (#3360)
	    if ((key === 'textContent' || key === 'innerHTML') && vnode.children) {
	      vnode.children.length = 0;
	    }
	    cur = props[key];
	    if (key === 'value') {
	      // store value as _value as well since
	      // non-string values will be stringified
	      elm._value = cur;
	      // avoid resetting cursor position when value is the same
	      var strCur = cur == null ? '' : String(cur);
	      if (elm.value !== strCur && !elm.composing) {
	        elm.value = strCur;
	      }
	    } else {
	      elm[key] = cur;
	    }
	  }
	}

	var domProps = {
	  create: updateDOMProps,
	  update: updateDOMProps
	};

	/*  */

	var cssVarRE = /^--/;
	var setProp = function (el, name, val) {
	  /* istanbul ignore if */
	  if (cssVarRE.test(name)) {
	    el.style.setProperty(name, val);
	  } else {
	    el.style[normalize(name)] = val;
	  }
	};

	var prefixes = ['Webkit', 'Moz', 'ms'];

	var testEl;
	var normalize = cached(function (prop) {
	  testEl = testEl || document.createElement('div');
	  prop = camelize(prop);
	  if (prop !== 'filter' && (prop in testEl.style)) {
	    return prop
	  }
	  var upper = prop.charAt(0).toUpperCase() + prop.slice(1);
	  for (var i = 0; i < prefixes.length; i++) {
	    var prefixed = prefixes[i] + upper;
	    if (prefixed in testEl.style) {
	      return prefixed
	    }
	  }
	});

	function updateStyle (oldVnode, vnode) {
	  if ((!oldVnode.data || !oldVnode.data.style) && !vnode.data.style) {
	    return
	  }
	  var cur, name;
	  var el = vnode.elm;
	  var oldStyle = oldVnode.data.style || {};
	  var style = vnode.data.style || {};

	  // handle string
	  if (typeof style === 'string') {
	    el.style.cssText = style;
	    return
	  }

	  var needClone = style.__ob__;

	  // handle array syntax
	  if (Array.isArray(style)) {
	    style = vnode.data.style = toObject(style);
	  }

	  // clone the style for future updates,
	  // in case the user mutates the style object in-place.
	  if (needClone) {
	    style = vnode.data.style = extend({}, style);
	  }

	  for (name in oldStyle) {
	    if (style[name] == null) {
	      setProp(el, name, '');
	    }
	  }
	  for (name in style) {
	    cur = style[name];
	    if (cur !== oldStyle[name]) {
	      // ie9 setting to null has no effect, must use empty string
	      setProp(el, name, cur == null ? '' : cur);
	    }
	  }
	}

	var style = {
	  create: updateStyle,
	  update: updateStyle
	};

	/*  */

	/**
	 * Add class with compatibility for SVG since classList is not supported on
	 * SVG elements in IE
	 */
	function addClass (el, cls) {
	  /* istanbul ignore if */
	  if (!cls || !cls.trim()) {
	    return
	  }

	  /* istanbul ignore else */
	  if (el.classList) {
	    if (cls.indexOf(' ') > -1) {
	      cls.split(/\s+/).forEach(function (c) { return el.classList.add(c); });
	    } else {
	      el.classList.add(cls);
	    }
	  } else {
	    var cur = ' ' + el.getAttribute('class') + ' ';
	    if (cur.indexOf(' ' + cls + ' ') < 0) {
	      el.setAttribute('class', (cur + cls).trim());
	    }
	  }
	}

	/**
	 * Remove class with compatibility for SVG since classList is not supported on
	 * SVG elements in IE
	 */
	function removeClass (el, cls) {
	  /* istanbul ignore if */
	  if (!cls || !cls.trim()) {
	    return
	  }

	  /* istanbul ignore else */
	  if (el.classList) {
	    if (cls.indexOf(' ') > -1) {
	      cls.split(/\s+/).forEach(function (c) { return el.classList.remove(c); });
	    } else {
	      el.classList.remove(cls);
	    }
	  } else {
	    var cur = ' ' + el.getAttribute('class') + ' ';
	    var tar = ' ' + cls + ' ';
	    while (cur.indexOf(tar) >= 0) {
	      cur = cur.replace(tar, ' ');
	    }
	    el.setAttribute('class', cur.trim());
	  }
	}

	/*  */

	var hasTransition = inBrowser && !isIE9;
	var TRANSITION = 'transition';
	var ANIMATION = 'animation';

	// Transition property/event sniffing
	var transitionProp = 'transition';
	var transitionEndEvent = 'transitionend';
	var animationProp = 'animation';
	var animationEndEvent = 'animationend';
	if (hasTransition) {
	  /* istanbul ignore if */
	  if (window.ontransitionend === undefined &&
	    window.onwebkittransitionend !== undefined) {
	    transitionProp = 'WebkitTransition';
	    transitionEndEvent = 'webkitTransitionEnd';
	  }
	  if (window.onanimationend === undefined &&
	    window.onwebkitanimationend !== undefined) {
	    animationProp = 'WebkitAnimation';
	    animationEndEvent = 'webkitAnimationEnd';
	  }
	}

	var raf = (inBrowser && window.requestAnimationFrame) || setTimeout;
	function nextFrame (fn) {
	  raf(function () {
	    raf(fn);
	  });
	}

	function addTransitionClass (el, cls) {
	  (el._transitionClasses || (el._transitionClasses = [])).push(cls);
	  addClass(el, cls);
	}

	function removeTransitionClass (el, cls) {
	  if (el._transitionClasses) {
	    remove$1(el._transitionClasses, cls);
	  }
	  removeClass(el, cls);
	}

	function whenTransitionEnds (
	  el,
	  expectedType,
	  cb
	) {
	  var ref = getTransitionInfo(el, expectedType);
	  var type = ref.type;
	  var timeout = ref.timeout;
	  var propCount = ref.propCount;
	  if (!type) { return cb() }
	  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
	  var ended = 0;
	  var end = function () {
	    el.removeEventListener(event, onEnd);
	    cb();
	  };
	  var onEnd = function (e) {
	    if (e.target === el) {
	      if (++ended >= propCount) {
	        end();
	      }
	    }
	  };
	  setTimeout(function () {
	    if (ended < propCount) {
	      end();
	    }
	  }, timeout + 1);
	  el.addEventListener(event, onEnd);
	}

	var transformRE = /\b(transform|all)(,|$)/;

	function getTransitionInfo (el, expectedType) {
	  var styles = window.getComputedStyle(el);
	  var transitioneDelays = styles[transitionProp + 'Delay'].split(', ');
	  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');
	  var transitionTimeout = getTimeout(transitioneDelays, transitionDurations);
	  var animationDelays = styles[animationProp + 'Delay'].split(', ');
	  var animationDurations = styles[animationProp + 'Duration'].split(', ');
	  var animationTimeout = getTimeout(animationDelays, animationDurations);

	  var type;
	  var timeout = 0;
	  var propCount = 0;
	  /* istanbul ignore if */
	  if (expectedType === TRANSITION) {
	    if (transitionTimeout > 0) {
	      type = TRANSITION;
	      timeout = transitionTimeout;
	      propCount = transitionDurations.length;
	    }
	  } else if (expectedType === ANIMATION) {
	    if (animationTimeout > 0) {
	      type = ANIMATION;
	      timeout = animationTimeout;
	      propCount = animationDurations.length;
	    }
	  } else {
	    timeout = Math.max(transitionTimeout, animationTimeout);
	    type = timeout > 0
	      ? transitionTimeout > animationTimeout
	        ? TRANSITION
	        : ANIMATION
	      : null;
	    propCount = type
	      ? type === TRANSITION
	        ? transitionDurations.length
	        : animationDurations.length
	      : 0;
	  }
	  var hasTransform =
	    type === TRANSITION &&
	    transformRE.test(styles[transitionProp + 'Property']);
	  return {
	    type: type,
	    timeout: timeout,
	    propCount: propCount,
	    hasTransform: hasTransform
	  }
	}

	function getTimeout (delays, durations) {
	  /* istanbul ignore next */
	  while (delays.length < durations.length) {
	    delays = delays.concat(delays);
	  }

	  return Math.max.apply(null, durations.map(function (d, i) {
	    return toMs(d) + toMs(delays[i])
	  }))
	}

	function toMs (s) {
	  return Number(s.slice(0, -1)) * 1000
	}

	/*  */

	function enter (vnode) {
	  var el = vnode.elm;

	  // call leave callback now
	  if (el._leaveCb) {
	    el._leaveCb.cancelled = true;
	    el._leaveCb();
	  }

	  var data = resolveTransition(vnode.data.transition);
	  if (!data) {
	    return
	  }

	  /* istanbul ignore if */
	  if (el._enterCb || el.nodeType !== 1) {
	    return
	  }

	  var css = data.css;
	  var type = data.type;
	  var enterClass = data.enterClass;
	  var enterActiveClass = data.enterActiveClass;
	  var appearClass = data.appearClass;
	  var appearActiveClass = data.appearActiveClass;
	  var beforeEnter = data.beforeEnter;
	  var enter = data.enter;
	  var afterEnter = data.afterEnter;
	  var enterCancelled = data.enterCancelled;
	  var beforeAppear = data.beforeAppear;
	  var appear = data.appear;
	  var afterAppear = data.afterAppear;
	  var appearCancelled = data.appearCancelled;

	  // activeInstance will always be the <transition> component managing this
	  // transition. One edge case to check is when the <transition> is placed
	  // as the root node of a child component. In that case we need to check
	  // <transition>'s parent for appear check.
	  var transitionNode = activeInstance.$vnode;
	  var context = transitionNode && transitionNode.parent
	    ? transitionNode.parent.context
	    : activeInstance;

	  var isAppear = !context._isMounted || !vnode.isRootInsert;

	  if (isAppear && !appear && appear !== '') {
	    return
	  }

	  var startClass = isAppear ? appearClass : enterClass;
	  var activeClass = isAppear ? appearActiveClass : enterActiveClass;
	  var beforeEnterHook = isAppear ? (beforeAppear || beforeEnter) : beforeEnter;
	  var enterHook = isAppear ? (typeof appear === 'function' ? appear : enter) : enter;
	  var afterEnterHook = isAppear ? (afterAppear || afterEnter) : afterEnter;
	  var enterCancelledHook = isAppear ? (appearCancelled || enterCancelled) : enterCancelled;

	  var expectsCSS = css !== false && !isIE9;
	  var userWantsControl =
	    enterHook &&
	    // enterHook may be a bound method which exposes
	    // the length of original fn as _length
	    (enterHook._length || enterHook.length) > 1;

	  var cb = el._enterCb = once(function () {
	    if (expectsCSS) {
	      removeTransitionClass(el, activeClass);
	    }
	    if (cb.cancelled) {
	      if (expectsCSS) {
	        removeTransitionClass(el, startClass);
	      }
	      enterCancelledHook && enterCancelledHook(el);
	    } else {
	      afterEnterHook && afterEnterHook(el);
	    }
	    el._enterCb = null;
	  });

	  if (!vnode.data.show) {
	    // remove pending leave element on enter by injecting an insert hook
	    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {
	      var parent = el.parentNode;
	      var pendingNode = parent && parent._pending && parent._pending[vnode.key];
	      if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {
	        pendingNode.elm._leaveCb();
	      }
	      enterHook && enterHook(el, cb);
	    }, 'transition-insert');
	  }

	  // start enter transition
	  beforeEnterHook && beforeEnterHook(el);
	  if (expectsCSS) {
	    addTransitionClass(el, startClass);
	    addTransitionClass(el, activeClass);
	    nextFrame(function () {
	      removeTransitionClass(el, startClass);
	      if (!cb.cancelled && !userWantsControl) {
	        whenTransitionEnds(el, type, cb);
	      }
	    });
	  }

	  if (vnode.data.show) {
	    enterHook && enterHook(el, cb);
	  }

	  if (!expectsCSS && !userWantsControl) {
	    cb();
	  }
	}

	function leave (vnode, rm) {
	  var el = vnode.elm;

	  // call enter callback now
	  if (el._enterCb) {
	    el._enterCb.cancelled = true;
	    el._enterCb();
	  }

	  var data = resolveTransition(vnode.data.transition);
	  if (!data) {
	    return rm()
	  }

	  /* istanbul ignore if */
	  if (el._leaveCb || el.nodeType !== 1) {
	    return
	  }

	  var css = data.css;
	  var type = data.type;
	  var leaveClass = data.leaveClass;
	  var leaveActiveClass = data.leaveActiveClass;
	  var beforeLeave = data.beforeLeave;
	  var leave = data.leave;
	  var afterLeave = data.afterLeave;
	  var leaveCancelled = data.leaveCancelled;
	  var delayLeave = data.delayLeave;

	  var expectsCSS = css !== false && !isIE9;
	  var userWantsControl =
	    leave &&
	    // leave hook may be a bound method which exposes
	    // the length of original fn as _length
	    (leave._length || leave.length) > 1;

	  var cb = el._leaveCb = once(function () {
	    if (el.parentNode && el.parentNode._pending) {
	      el.parentNode._pending[vnode.key] = null;
	    }
	    if (expectsCSS) {
	      removeTransitionClass(el, leaveActiveClass);
	    }
	    if (cb.cancelled) {
	      if (expectsCSS) {
	        removeTransitionClass(el, leaveClass);
	      }
	      leaveCancelled && leaveCancelled(el);
	    } else {
	      rm();
	      afterLeave && afterLeave(el);
	    }
	    el._leaveCb = null;
	  });

	  if (delayLeave) {
	    delayLeave(performLeave);
	  } else {
	    performLeave();
	  }

	  function performLeave () {
	    // the delayed leave may have already been cancelled
	    if (cb.cancelled) {
	      return
	    }
	    // record leaving element
	    if (!vnode.data.show) {
	      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
	    }
	    beforeLeave && beforeLeave(el);
	    if (expectsCSS) {
	      addTransitionClass(el, leaveClass);
	      addTransitionClass(el, leaveActiveClass);
	      nextFrame(function () {
	        removeTransitionClass(el, leaveClass);
	        if (!cb.cancelled && !userWantsControl) {
	          whenTransitionEnds(el, type, cb);
	        }
	      });
	    }
	    leave && leave(el, cb);
	    if (!expectsCSS && !userWantsControl) {
	      cb();
	    }
	  }
	}

	function resolveTransition (def$$1) {
	  if (!def$$1) {
	    return
	  }
	  /* istanbul ignore else */
	  if (typeof def$$1 === 'object') {
	    var res = {};
	    if (def$$1.css !== false) {
	      extend(res, autoCssTransition(def$$1.name || 'v'));
	    }
	    extend(res, def$$1);
	    return res
	  } else if (typeof def$$1 === 'string') {
	    return autoCssTransition(def$$1)
	  }
	}

	var autoCssTransition = cached(function (name) {
	  return {
	    enterClass: (name + "-enter"),
	    leaveClass: (name + "-leave"),
	    appearClass: (name + "-enter"),
	    enterActiveClass: (name + "-enter-active"),
	    leaveActiveClass: (name + "-leave-active"),
	    appearActiveClass: (name + "-enter-active")
	  }
	});

	function once (fn) {
	  var called = false;
	  return function () {
	    if (!called) {
	      called = true;
	      fn();
	    }
	  }
	}

	var transition = inBrowser ? {
	  create: function create (_, vnode) {
	    if (!vnode.data.show) {
	      enter(vnode);
	    }
	  },
	  remove: function remove (vnode, rm) {
	    /* istanbul ignore else */
	    if (!vnode.data.show) {
	      leave(vnode, rm);
	    } else {
	      rm();
	    }
	  }
	} : {};

	var platformModules = [
	  attrs,
	  klass,
	  events,
	  domProps,
	  style,
	  transition
	];

	/*  */

	// the directive module should be applied last, after all
	// built-in modules have been applied.
	var modules = platformModules.concat(baseModules);

	var patch$1 = createPatchFunction({ nodeOps: nodeOps, modules: modules });

	/**
	 * Not type checking this file because flow doesn't like attaching
	 * properties to Elements.
	 */

	var modelableTagRE = /^input|select|textarea|vue-component-[0-9]+(-[0-9a-zA-Z_-]*)?$/;

	/* istanbul ignore if */
	if (isIE9) {
	  // http://www.matts411.com/post/internet-explorer-9-oninput/
	  document.addEventListener('selectionchange', function () {
	    var el = document.activeElement;
	    if (el && el.vmodel) {
	      trigger(el, 'input');
	    }
	  });
	}

	var model = {
	  inserted: function inserted (el, binding, vnode) {
	    {
	      if (!modelableTagRE.test(vnode.tag)) {
	        warn(
	          "v-model is not supported on element type: <" + (vnode.tag) + ">. " +
	          'If you are working with contenteditable, it\'s recommended to ' +
	          'wrap a library dedicated for that purpose inside a custom component.',
	          vnode.context
	        );
	      }
	    }
	    if (vnode.tag === 'select') {
	      var cb = function () {
	        setSelected(el, binding, vnode.context);
	      };
	      cb();
	      /* istanbul ignore if */
	      if (isIE || isEdge) {
	        setTimeout(cb, 0);
	      }
	    } else if (
	      (vnode.tag === 'textarea' || el.type === 'text') &&
	      !binding.modifiers.lazy
	    ) {
	      if (!isAndroid) {
	        el.addEventListener('compositionstart', onCompositionStart);
	        el.addEventListener('compositionend', onCompositionEnd);
	      }
	      /* istanbul ignore if */
	      if (isIE9) {
	        el.vmodel = true;
	      }
	    }
	  },
	  componentUpdated: function componentUpdated (el, binding, vnode) {
	    if (vnode.tag === 'select') {
	      setSelected(el, binding, vnode.context);
	      // in case the options rendered by v-for have changed,
	      // it's possible that the value is out-of-sync with the rendered options.
	      // detect such cases and filter out values that no longer has a matching
	      // option in the DOM.
	      var needReset = el.multiple
	        ? binding.value.some(function (v) { return hasNoMatchingOption(v, el.options); })
	        : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, el.options);
	      if (needReset) {
	        trigger(el, 'change');
	      }
	    }
	  }
	};

	function setSelected (el, binding, vm) {
	  var value = binding.value;
	  var isMultiple = el.multiple;
	  if (isMultiple && !Array.isArray(value)) {
	    "development" !== 'production' && warn(
	      "<select multiple v-model=\"" + (binding.expression) + "\"> " +
	      "expects an Array value for its binding, but got " + (Object.prototype.toString.call(value).slice(8, -1)),
	      vm
	    );
	    return
	  }
	  var selected, option;
	  for (var i = 0, l = el.options.length; i < l; i++) {
	    option = el.options[i];
	    if (isMultiple) {
	      selected = looseIndexOf(value, getValue(option)) > -1;
	      if (option.selected !== selected) {
	        option.selected = selected;
	      }
	    } else {
	      if (looseEqual(getValue(option), value)) {
	        if (el.selectedIndex !== i) {
	          el.selectedIndex = i;
	        }
	        return
	      }
	    }
	  }
	  if (!isMultiple) {
	    el.selectedIndex = -1;
	  }
	}

	function hasNoMatchingOption (value, options) {
	  for (var i = 0, l = options.length; i < l; i++) {
	    if (looseEqual(getValue(options[i]), value)) {
	      return false
	    }
	  }
	  return true
	}

	function getValue (option) {
	  return '_value' in option
	    ? option._value
	    : option.value
	}

	function onCompositionStart (e) {
	  e.target.composing = true;
	}

	function onCompositionEnd (e) {
	  e.target.composing = false;
	  trigger(e.target, 'input');
	}

	function trigger (el, type) {
	  var e = document.createEvent('HTMLEvents');
	  e.initEvent(type, true, true);
	  el.dispatchEvent(e);
	}

	/*  */

	// recursively search for possible transition defined inside the component root
	function locateNode (vnode) {
	  return vnode.child && (!vnode.data || !vnode.data.transition)
	    ? locateNode(vnode.child._vnode)
	    : vnode
	}

	var show = {
	  bind: function bind (el, ref, vnode) {
	    var value = ref.value;

	    vnode = locateNode(vnode);
	    var transition = vnode.data && vnode.data.transition;
	    if (value && transition && !isIE9) {
	      enter(vnode);
	    }
	    var originalDisplay = el.style.display === 'none' ? '' : el.style.display;
	    el.style.display = value ? originalDisplay : 'none';
	    el.__vOriginalDisplay = originalDisplay;
	  },
	  update: function update (el, ref, vnode) {
	    var value = ref.value;
	    var oldValue = ref.oldValue;

	    /* istanbul ignore if */
	    if (value === oldValue) { return }
	    vnode = locateNode(vnode);
	    var transition = vnode.data && vnode.data.transition;
	    if (transition && !isIE9) {
	      if (value) {
	        enter(vnode);
	        el.style.display = el.__vOriginalDisplay;
	      } else {
	        leave(vnode, function () {
	          el.style.display = 'none';
	        });
	      }
	    } else {
	      el.style.display = value ? el.__vOriginalDisplay : 'none';
	    }
	  }
	};

	var platformDirectives = {
	  model: model,
	  show: show
	};

	/*  */

	// Provides transition support for a single element/component.
	// supports transition mode (out-in / in-out)

	var transitionProps = {
	  name: String,
	  appear: Boolean,
	  css: Boolean,
	  mode: String,
	  type: String,
	  enterClass: String,
	  leaveClass: String,
	  enterActiveClass: String,
	  leaveActiveClass: String,
	  appearClass: String,
	  appearActiveClass: String
	};

	// in case the child is also an abstract component, e.g. <keep-alive>
	// we want to recursively retrieve the real component to be rendered
	function getRealChild (vnode) {
	  var compOptions = vnode && vnode.componentOptions;
	  if (compOptions && compOptions.Ctor.options.abstract) {
	    return getRealChild(getFirstComponentChild(compOptions.children))
	  } else {
	    return vnode
	  }
	}

	function extractTransitionData (comp) {
	  var data = {};
	  var options = comp.$options;
	  // props
	  for (var key in options.propsData) {
	    data[key] = comp[key];
	  }
	  // events.
	  // extract listeners and pass them directly to the transition methods
	  var listeners = options._parentListeners;
	  for (var key$1 in listeners) {
	    data[camelize(key$1)] = listeners[key$1].fn;
	  }
	  return data
	}

	function placeholder (h, rawChild) {
	  return /\d-keep-alive$/.test(rawChild.tag)
	    ? h('keep-alive')
	    : null
	}

	function hasParentTransition (vnode) {
	  while ((vnode = vnode.parent)) {
	    if (vnode.data.transition) {
	      return true
	    }
	  }
	}

	var Transition = {
	  name: 'transition',
	  props: transitionProps,
	  abstract: true,
	  render: function render (h) {
	    var this$1 = this;

	    var children = this.$slots.default;
	    if (!children) {
	      return
	    }

	    // filter out text nodes (possible whitespaces)
	    children = children.filter(function (c) { return c.tag; });
	    /* istanbul ignore if */
	    if (!children.length) {
	      return
	    }

	    // warn multiple elements
	    if ("development" !== 'production' && children.length > 1) {
	      warn(
	        '<transition> can only be used on a single element. Use ' +
	        '<transition-group> for lists.',
	        this.$parent
	      );
	    }

	    var mode = this.mode;

	    // warn invalid mode
	    if ("development" !== 'production' &&
	        mode && mode !== 'in-out' && mode !== 'out-in') {
	      warn(
	        'invalid <transition> mode: ' + mode,
	        this.$parent
	      );
	    }

	    var rawChild = children[0];

	    // if this is a component root node and the component's
	    // parent container node also has transition, skip.
	    if (hasParentTransition(this.$vnode)) {
	      return rawChild
	    }

	    // apply transition data to child
	    // use getRealChild() to ignore abstract components e.g. keep-alive
	    var child = getRealChild(rawChild);
	    /* istanbul ignore if */
	    if (!child) {
	      return rawChild
	    }

	    if (this._leaving) {
	      return placeholder(h, rawChild)
	    }

	    var key = child.key = child.key == null || child.isStatic
	      ? ("__v" + (child.tag + this._uid) + "__")
	      : child.key;
	    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
	    var oldRawChild = this._vnode;
	    var oldChild = getRealChild(oldRawChild);

	    // mark v-show
	    // so that the transition module can hand over the control to the directive
	    if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {
	      child.data.show = true;
	    }

	    if (oldChild && oldChild.data && oldChild.key !== key) {
	      // replace old child transition data with fresh one
	      // important for dynamic transitions!
	      var oldData = oldChild.data.transition = extend({}, data);

	      // handle transition mode
	      if (mode === 'out-in') {
	        // return placeholder node and queue update when leave finishes
	        this._leaving = true;
	        mergeVNodeHook(oldData, 'afterLeave', function () {
	          this$1._leaving = false;
	          this$1.$forceUpdate();
	        }, key);
	        return placeholder(h, rawChild)
	      } else if (mode === 'in-out') {
	        var delayedLeave;
	        var performLeave = function () { delayedLeave(); };
	        mergeVNodeHook(data, 'afterEnter', performLeave, key);
	        mergeVNodeHook(data, 'enterCancelled', performLeave, key);
	        mergeVNodeHook(oldData, 'delayLeave', function (leave) {
	          delayedLeave = leave;
	        }, key);
	      }
	    }

	    return rawChild
	  }
	};

	/*  */

	// Provides transition support for list items.
	// supports move transitions using the FLIP technique.

	// Because the vdom's children update algorithm is "unstable" - i.e.
	// it doesn't guarantee the relative positioning of removed elements,
	// we force transition-group to update its children into two passes:
	// in the first pass, we remove all nodes that need to be removed,
	// triggering their leaving transition; in the second pass, we insert/move
	// into the final disired state. This way in the second pass removed
	// nodes will remain where they should be.

	var props = extend({
	  tag: String,
	  moveClass: String
	}, transitionProps);

	delete props.mode;

	var TransitionGroup = {
	  props: props,

	  render: function render (h) {
	    var tag = this.tag || this.$vnode.data.tag || 'span';
	    var map = Object.create(null);
	    var prevChildren = this.prevChildren = this.children;
	    var rawChildren = this.$slots.default || [];
	    var children = this.children = [];
	    var transitionData = extractTransitionData(this);

	    for (var i = 0; i < rawChildren.length; i++) {
	      var c = rawChildren[i];
	      if (c.tag) {
	        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
	          children.push(c);
	          map[c.key] = c
	          ;(c.data || (c.data = {})).transition = transitionData;
	        } else {
	          var opts = c.componentOptions;
	          var name = opts
	            ? (opts.Ctor.options.name || opts.tag)
	            : c.tag;
	          warn(("<transition-group> children must be keyed: <" + name + ">"));
	        }
	      }
	    }

	    if (prevChildren) {
	      var kept = [];
	      var removed = [];
	      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
	        var c$1 = prevChildren[i$1];
	        c$1.data.transition = transitionData;
	        c$1.data.pos = c$1.elm.getBoundingClientRect();
	        if (map[c$1.key]) {
	          kept.push(c$1);
	        } else {
	          removed.push(c$1);
	        }
	      }
	      this.kept = h(tag, null, kept);
	      this.removed = removed;
	    }

	    return h(tag, null, children)
	  },

	  beforeUpdate: function beforeUpdate () {
	    // force removing pass
	    this.__patch__(
	      this._vnode,
	      this.kept,
	      false, // hydrating
	      true // removeOnly (!important, avoids unnecessary moves)
	    );
	    this._vnode = this.kept;
	  },

	  updated: function updated () {
	    var children = this.prevChildren;
	    var moveClass = this.moveClass || (this.name + '-move');
	    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
	      return
	    }

	    // we divide the work into three loops to avoid mixing DOM reads and writes
	    // in each iteration - which helps prevent layout thrashing.
	    children.forEach(callPendingCbs);
	    children.forEach(recordPosition);
	    children.forEach(applyTranslation);

	    // force reflow to put everything in position
	    var f = document.body.offsetHeight; // eslint-disable-line

	    children.forEach(function (c) {
	      if (c.data.moved) {
	        var el = c.elm;
	        var s = el.style;
	        addTransitionClass(el, moveClass);
	        s.transform = s.WebkitTransform = s.transitionDuration = '';
	        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {
	          if (!e || /transform$/.test(e.propertyName)) {
	            el.removeEventListener(transitionEndEvent, cb);
	            el._moveCb = null;
	            removeTransitionClass(el, moveClass);
	          }
	        });
	      }
	    });
	  },

	  methods: {
	    hasMove: function hasMove (el, moveClass) {
	      /* istanbul ignore if */
	      if (!hasTransition) {
	        return false
	      }
	      if (this._hasMove != null) {
	        return this._hasMove
	      }
	      addTransitionClass(el, moveClass);
	      var info = getTransitionInfo(el);
	      removeTransitionClass(el, moveClass);
	      return (this._hasMove = info.hasTransform)
	    }
	  }
	};

	function callPendingCbs (c) {
	  /* istanbul ignore if */
	  if (c.elm._moveCb) {
	    c.elm._moveCb();
	  }
	  /* istanbul ignore if */
	  if (c.elm._enterCb) {
	    c.elm._enterCb();
	  }
	}

	function recordPosition (c) {
	  c.data.newPos = c.elm.getBoundingClientRect();
	}

	function applyTranslation (c) {
	  var oldPos = c.data.pos;
	  var newPos = c.data.newPos;
	  var dx = oldPos.left - newPos.left;
	  var dy = oldPos.top - newPos.top;
	  if (dx || dy) {
	    c.data.moved = true;
	    var s = c.elm.style;
	    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
	    s.transitionDuration = '0s';
	  }
	}

	var platformComponents = {
	  Transition: Transition,
	  TransitionGroup: TransitionGroup
	};

	/*  */

	// install platform specific utils
	Vue$2.config.isUnknownElement = isUnknownElement;
	Vue$2.config.isReservedTag = isReservedTag;
	Vue$2.config.getTagNamespace = getTagNamespace;
	Vue$2.config.mustUseProp = mustUseProp;

	// install platform runtime directives & components
	extend(Vue$2.options.directives, platformDirectives);
	extend(Vue$2.options.components, platformComponents);

	// install platform patch function
	Vue$2.prototype.__patch__ = config._isServer ? noop : patch$1;

	// wrap mount
	Vue$2.prototype.$mount = function (
	  el,
	  hydrating
	) {
	  el = el && !config._isServer ? query(el) : undefined;
	  return this._mount(el, hydrating)
	};

	// devtools global hook
	/* istanbul ignore next */
	setTimeout(function () {
	  if (config.devtools) {
	    if (devtools) {
	      devtools.emit('init', Vue$2);
	    } else if (
	      "development" !== 'production' &&
	      inBrowser && /Chrome\/\d+/.test(window.navigator.userAgent)
	    ) {
	      console.log(
	        'Download the Vue Devtools for a better development experience:\n' +
	        'https://github.com/vuejs/vue-devtools'
	      );
	    }
	  }
	}, 0);

	/*  */

	// check whether current browser encodes a char inside attribute values
	function shouldDecode (content, encoded) {
	  var div = document.createElement('div');
	  div.innerHTML = "<div a=\"" + content + "\">";
	  return div.innerHTML.indexOf(encoded) > 0
	}

	// #3663
	// IE encodes newlines inside attribute values while other browsers don't
	var shouldDecodeNewlines = inBrowser ? shouldDecode('\n', '&#10;') : false;

	/*  */

	var decoder = document.createElement('div');

	function decode (html) {
	  decoder.innerHTML = html;
	  return decoder.textContent
	}

	/**
	 * Not type-checking this file because it's mostly vendor code.
	 */

	/*!
	 * HTML Parser By John Resig (ejohn.org)
	 * Modified by Juriy "kangax" Zaytsev
	 * Original code by Erik Arvidsson, Mozilla Public License
	 * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
	 */

	// Regular Expressions for parsing tags and attributes
	var singleAttrIdentifier = /([^\s"'<>/=]+)/;
	var singleAttrAssign = /(?:=)/;
	var singleAttrValues = [
	  // attr value double quotes
	  /"([^"]*)"+/.source,
	  // attr value, single quotes
	  /'([^']*)'+/.source,
	  // attr value, no quotes
	  /([^\s"'=<>`]+)/.source
	];
	var attribute = new RegExp(
	  '^\\s*' + singleAttrIdentifier.source +
	  '(?:\\s*(' + singleAttrAssign.source + ')' +
	  '\\s*(?:' + singleAttrValues.join('|') + '))?'
	);

	// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName
	// but for Vue templates we can enforce a simple charset
	var ncname = '[a-zA-Z_][\\w\\-\\.]*';
	var qnameCapture = '((?:' + ncname + '\\:)?' + ncname + ')';
	var startTagOpen = new RegExp('^<' + qnameCapture);
	var startTagClose = /^\s*(\/?)>/;
	var endTag = new RegExp('^<\\/' + qnameCapture + '[^>]*>');
	var doctype = /^<!DOCTYPE [^>]+>/i;
	var comment = /^<!--/;
	var conditionalComment = /^<!\[/;

	var IS_REGEX_CAPTURING_BROKEN = false;
	'x'.replace(/x(.)?/g, function (m, g) {
	  IS_REGEX_CAPTURING_BROKEN = g === '';
	});

	// Special Elements (can contain anything)
	var isScriptOrStyle = makeMap('script,style', true);
	var hasLang = function (attr) { return attr.name === 'lang' && attr.value !== 'html'; };
	var isSpecialTag = function (tag, isSFC, stack) {
	  if (isScriptOrStyle(tag)) {
	    return true
	  }
	  // top-level template that has a pre-processor
	  if (
	    isSFC &&
	    tag === 'template' &&
	    stack.length === 1 &&
	    stack[0].attrs.some(hasLang)
	  ) {
	    return true
	  }
	  return false
	};

	var reCache = {};

	var ltRE = /&lt;/g;
	var gtRE = /&gt;/g;
	var nlRE = /&#10;/g;
	var ampRE = /&amp;/g;
	var quoteRE = /&quot;/g;

	function decodeAttr (value, shouldDecodeNewlines) {
	  if (shouldDecodeNewlines) {
	    value = value.replace(nlRE, '\n');
	  }
	  return value
	    .replace(ltRE, '<')
	    .replace(gtRE, '>')
	    .replace(ampRE, '&')
	    .replace(quoteRE, '"')
	}

	function parseHTML (html, options) {
	  var stack = [];
	  var expectHTML = options.expectHTML;
	  var isUnaryTag$$1 = options.isUnaryTag || no;
	  var index = 0;
	  var last, lastTag;
	  while (html) {
	    last = html;
	    // Make sure we're not in a script or style element
	    if (!lastTag || !isSpecialTag(lastTag, options.sfc, stack)) {
	      var textEnd = html.indexOf('<');
	      if (textEnd === 0) {
	        // Comment:
	        if (comment.test(html)) {
	          var commentEnd = html.indexOf('-->');

	          if (commentEnd >= 0) {
	            advance(commentEnd + 3);
	            continue
	          }
	        }

	        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
	        if (conditionalComment.test(html)) {
	          var conditionalEnd = html.indexOf(']>');

	          if (conditionalEnd >= 0) {
	            advance(conditionalEnd + 2);
	            continue
	          }
	        }

	        // Doctype:
	        var doctypeMatch = html.match(doctype);
	        if (doctypeMatch) {
	          advance(doctypeMatch[0].length);
	          continue
	        }

	        // End tag:
	        var endTagMatch = html.match(endTag);
	        if (endTagMatch) {
	          var curIndex = index;
	          advance(endTagMatch[0].length);
	          parseEndTag(endTagMatch[0], endTagMatch[1], curIndex, index);
	          continue
	        }

	        // Start tag:
	        var startTagMatch = parseStartTag();
	        if (startTagMatch) {
	          handleStartTag(startTagMatch);
	          continue
	        }
	      }

	      var text = void 0, rest$1 = void 0, next = void 0;
	      if (textEnd > 0) {
	        rest$1 = html.slice(textEnd);
	        while (
	          !endTag.test(rest$1) &&
	          !startTagOpen.test(rest$1) &&
	          !comment.test(rest$1) &&
	          !conditionalComment.test(rest$1)
	        ) {
	          // < in plain text, be forgiving and treat it as text
	          next = rest$1.indexOf('<', 1);
	          if (next < 0) { break }
	          textEnd += next;
	          rest$1 = html.slice(textEnd);
	        }
	        text = html.substring(0, textEnd);
	        advance(textEnd);
	      }

	      if (textEnd < 0) {
	        text = html;
	        html = '';
	      }

	      if (options.chars && text) {
	        options.chars(text);
	      }
	    } else {
	      var stackedTag = lastTag.toLowerCase();
	      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));
	      var endTagLength = 0;
	      var rest = html.replace(reStackedTag, function (all, text, endTag) {
	        endTagLength = endTag.length;
	        if (stackedTag !== 'script' && stackedTag !== 'style' && stackedTag !== 'noscript') {
	          text = text
	            .replace(/<!--([\s\S]*?)-->/g, '$1')
	            .replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
	        }
	        if (options.chars) {
	          options.chars(text);
	        }
	        return ''
	      });
	      index += html.length - rest.length;
	      html = rest;
	      parseEndTag('</' + stackedTag + '>', stackedTag, index - endTagLength, index);
	    }

	    if (html === last && options.chars) {
	      options.chars(html);
	      break
	    }
	  }

	  // Clean up any remaining tags
	  parseEndTag();

	  function advance (n) {
	    index += n;
	    html = html.substring(n);
	  }

	  function parseStartTag () {
	    var start = html.match(startTagOpen);
	    if (start) {
	      var match = {
	        tagName: start[1],
	        attrs: [],
	        start: index
	      };
	      advance(start[0].length);
	      var end, attr;
	      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {
	        advance(attr[0].length);
	        match.attrs.push(attr);
	      }
	      if (end) {
	        match.unarySlash = end[1];
	        advance(end[0].length);
	        match.end = index;
	        return match
	      }
	    }
	  }

	  function handleStartTag (match) {
	    var tagName = match.tagName;
	    var unarySlash = match.unarySlash;

	    if (expectHTML) {
	      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
	        parseEndTag('', lastTag);
	      }
	      if (canBeLeftOpenTag(tagName) && lastTag === tagName) {
	        parseEndTag('', tagName);
	      }
	    }

	    var unary = isUnaryTag$$1(tagName) || tagName === 'html' && lastTag === 'head' || !!unarySlash;

	    var l = match.attrs.length;
	    var attrs = new Array(l);
	    for (var i = 0; i < l; i++) {
	      var args = match.attrs[i];
	      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778
	      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('""') === -1) {
	        if (args[3] === '') { delete args[3]; }
	        if (args[4] === '') { delete args[4]; }
	        if (args[5] === '') { delete args[5]; }
	      }
	      var value = args[3] || args[4] || args[5] || '';
	      attrs[i] = {
	        name: args[1],
	        value: decodeAttr(
	          value,
	          options.shouldDecodeNewlines
	        )
	      };
	    }

	    if (!unary) {
	      stack.push({ tag: tagName, attrs: attrs });
	      lastTag = tagName;
	      unarySlash = '';
	    }

	    if (options.start) {
	      options.start(tagName, attrs, unary, match.start, match.end);
	    }
	  }

	  function parseEndTag (tag, tagName, start, end) {
	    var pos;
	    if (start == null) { start = index; }
	    if (end == null) { end = index; }

	    // Find the closest opened tag of the same type
	    if (tagName) {
	      var needle = tagName.toLowerCase();
	      for (pos = stack.length - 1; pos >= 0; pos--) {
	        if (stack[pos].tag.toLowerCase() === needle) {
	          break
	        }
	      }
	    } else {
	      // If no tag name is provided, clean shop
	      pos = 0;
	    }

	    if (pos >= 0) {
	      // Close all the open elements, up the stack
	      for (var i = stack.length - 1; i >= pos; i--) {
	        if (options.end) {
	          options.end(stack[i].tag, start, end);
	        }
	      }

	      // Remove the open elements from the stack
	      stack.length = pos;
	      lastTag = pos && stack[pos - 1].tag;
	    } else if (tagName.toLowerCase() === 'br') {
	      if (options.start) {
	        options.start(tagName, [], true, start, end);
	      }
	    } else if (tagName.toLowerCase() === 'p') {
	      if (options.start) {
	        options.start(tagName, [], false, start, end);
	      }
	      if (options.end) {
	        options.end(tagName, start, end);
	      }
	    }
	  }
	}

	/*  */

	function parseFilters (exp) {
	  var inSingle = false;
	  var inDouble = false;
	  var curly = 0;
	  var square = 0;
	  var paren = 0;
	  var lastFilterIndex = 0;
	  var c, prev, i, expression, filters;

	  for (i = 0; i < exp.length; i++) {
	    prev = c;
	    c = exp.charCodeAt(i);
	    if (inSingle) {
	      // check single quote
	      if (c === 0x27 && prev !== 0x5C) { inSingle = !inSingle; }
	    } else if (inDouble) {
	      // check double quote
	      if (c === 0x22 && prev !== 0x5C) { inDouble = !inDouble; }
	    } else if (
	      c === 0x7C && // pipe
	      exp.charCodeAt(i + 1) !== 0x7C &&
	      exp.charCodeAt(i - 1) !== 0x7C &&
	      !curly && !square && !paren
	    ) {
	      if (expression === undefined) {
	        // first filter, end of expression
	        lastFilterIndex = i + 1;
	        expression = exp.slice(0, i).trim();
	      } else {
	        pushFilter();
	      }
	    } else {
	      switch (c) {
	        case 0x22: inDouble = true; break // "
	        case 0x27: inSingle = true; break // '
	        case 0x28: paren++; break         // (
	        case 0x29: paren--; break         // )
	        case 0x5B: square++; break        // [
	        case 0x5D: square--; break        // ]
	        case 0x7B: curly++; break         // {
	        case 0x7D: curly--; break         // }
	      }
	    }
	  }

	  if (expression === undefined) {
	    expression = exp.slice(0, i).trim();
	  } else if (lastFilterIndex !== 0) {
	    pushFilter();
	  }

	  function pushFilter () {
	    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
	    lastFilterIndex = i + 1;
	  }

	  if (filters) {
	    for (i = 0; i < filters.length; i++) {
	      expression = wrapFilter(expression, filters[i]);
	    }
	  }

	  return expression
	}

	function wrapFilter (exp, filter) {
	  var i = filter.indexOf('(');
	  if (i < 0) {
	    // _f: resolveFilter
	    return ("_f(\"" + filter + "\")(" + exp + ")")
	  } else {
	    var name = filter.slice(0, i);
	    var args = filter.slice(i + 1);
	    return ("_f(\"" + name + "\")(" + exp + "," + args)
	  }
	}

	/*  */

	var defaultTagRE = /\{\{((?:.|\n)+?)\}\}/g;
	var regexEscapeRE = /[-.*+?^${}()|[\]/\\]/g;

	var buildRegex = cached(function (delimiters) {
	  var open = delimiters[0].replace(regexEscapeRE, '\\$&');
	  var close = delimiters[1].replace(regexEscapeRE, '\\$&');
	  return new RegExp(open + '((?:.|\\n)+?)' + close, 'g')
	});

	function parseText (
	  text,
	  delimiters
	) {
	  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;
	  if (!tagRE.test(text)) {
	    return
	  }
	  var tokens = [];
	  var lastIndex = tagRE.lastIndex = 0;
	  var match, index;
	  while ((match = tagRE.exec(text))) {
	    index = match.index;
	    // push text token
	    if (index > lastIndex) {
	      tokens.push(JSON.stringify(text.slice(lastIndex, index)));
	    }
	    // tag token
	    var exp = parseFilters(match[1].trim());
	    tokens.push(("_s(" + exp + ")"));
	    lastIndex = index + match[0].length;
	  }
	  if (lastIndex < text.length) {
	    tokens.push(JSON.stringify(text.slice(lastIndex)));
	  }
	  return tokens.join('+')
	}

	/*  */

	function baseWarn (msg) {
	  console.error(("[Vue parser]: " + msg));
	}

	function pluckModuleFunction (
	  modules,
	  key
	) {
	  return modules
	    ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })
	    : []
	}

	function addProp (el, name, value) {
	  (el.props || (el.props = [])).push({ name: name, value: value });
	}

	function addAttr (el, name, value) {
	  (el.attrs || (el.attrs = [])).push({ name: name, value: value });
	}

	function addDirective (
	  el,
	  name,
	  rawName,
	  value,
	  arg,
	  modifiers
	) {
	  (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });
	}

	function addHandler (
	  el,
	  name,
	  value,
	  modifiers,
	  important
	) {
	  // check capture modifier
	  if (modifiers && modifiers.capture) {
	    delete modifiers.capture;
	    name = '!' + name; // mark the event as captured
	  }
	  var events;
	  if (modifiers && modifiers.native) {
	    delete modifiers.native;
	    events = el.nativeEvents || (el.nativeEvents = {});
	  } else {
	    events = el.events || (el.events = {});
	  }
	  var newHandler = { value: value, modifiers: modifiers };
	  var handlers = events[name];
	  /* istanbul ignore if */
	  if (Array.isArray(handlers)) {
	    important ? handlers.unshift(newHandler) : handlers.push(newHandler);
	  } else if (handlers) {
	    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
	  } else {
	    events[name] = newHandler;
	  }
	}

	function getBindingAttr (
	  el,
	  name,
	  getStatic
	) {
	  var dynamicValue =
	    getAndRemoveAttr(el, ':' + name) ||
	    getAndRemoveAttr(el, 'v-bind:' + name);
	  if (dynamicValue != null) {
	    return dynamicValue
	  } else if (getStatic !== false) {
	    var staticValue = getAndRemoveAttr(el, name);
	    if (staticValue != null) {
	      return JSON.stringify(staticValue)
	    }
	  }
	}

	function getAndRemoveAttr (el, name) {
	  var val;
	  if ((val = el.attrsMap[name]) != null) {
	    var list = el.attrsList;
	    for (var i = 0, l = list.length; i < l; i++) {
	      if (list[i].name === name) {
	        list.splice(i, 1);
	        break
	      }
	    }
	  }
	  return val
	}

	/*  */

	var dirRE = /^v-|^@|^:/;
	var forAliasRE = /(.*?)\s+(?:in|of)\s+(.*)/;
	var forIteratorRE = /\(([^,]*),([^,]*)(?:,([^,]*))?\)/;
	var bindRE = /^:|^v-bind:/;
	var onRE = /^@|^v-on:/;
	var argRE = /:(.*)$/;
	var modifierRE = /\.[^.]+/g;
	var specialNewlineRE = /\u2028|\u2029/g;

	var decodeHTMLCached = cached(decode);

	// configurable state
	var warn$1;
	var platformGetTagNamespace;
	var platformMustUseProp;
	var platformIsPreTag;
	var preTransforms;
	var transforms;
	var postTransforms;
	var delimiters;

	/**
	 * Convert HTML string to AST.
	 */
	function parse (
	  template,
	  options
	) {
	  warn$1 = options.warn || baseWarn;
	  platformGetTagNamespace = options.getTagNamespace || no;
	  platformMustUseProp = options.mustUseProp || no;
	  platformIsPreTag = options.isPreTag || no;
	  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');
	  transforms = pluckModuleFunction(options.modules, 'transformNode');
	  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');
	  delimiters = options.delimiters;
	  var stack = [];
	  var preserveWhitespace = options.preserveWhitespace !== false;
	  var root;
	  var currentParent;
	  var inVPre = false;
	  var inPre = false;
	  var warned = false;
	  parseHTML(template, {
	    expectHTML: options.expectHTML,
	    isUnaryTag: options.isUnaryTag,
	    shouldDecodeNewlines: options.shouldDecodeNewlines,
	    start: function start (tag, attrs, unary) {
	      // check namespace.
	      // inherit parent ns if there is one
	      var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);

	      // handle IE svg bug
	      /* istanbul ignore if */
	      if (options.isIE && ns === 'svg') {
	        attrs = guardIESVGBug(attrs);
	      }

	      var element = {
	        type: 1,
	        tag: tag,
	        attrsList: attrs,
	        attrsMap: makeAttrsMap(attrs, options.isIE),
	        parent: currentParent,
	        children: []
	      };
	      if (ns) {
	        element.ns = ns;
	      }

	      if ("client" !== 'server' && isForbiddenTag(element)) {
	        element.forbidden = true;
	        "development" !== 'production' && warn$1(
	          'Templates should only be responsible for mapping the state to the ' +
	          'UI. Avoid placing tags with side-effects in your templates, such as ' +
	          "<" + tag + ">."
	        );
	      }

	      // apply pre-transforms
	      for (var i = 0; i < preTransforms.length; i++) {
	        preTransforms[i](element, options);
	      }

	      if (!inVPre) {
	        processPre(element);
	        if (element.pre) {
	          inVPre = true;
	        }
	      }
	      if (platformIsPreTag(element.tag)) {
	        inPre = true;
	      }
	      if (inVPre) {
	        processRawAttrs(element);
	      } else {
	        processFor(element);
	        processIf(element);
	        processOnce(element);
	        processKey(element);

	        // determine whether this is a plain element after
	        // removing structural attributes
	        element.plain = !element.key && !attrs.length;

	        processRef(element);
	        processSlot(element);
	        processComponent(element);
	        for (var i$1 = 0; i$1 < transforms.length; i$1++) {
	          transforms[i$1](element, options);
	        }
	        processAttrs(element);
	      }

	      function checkRootConstraints (el) {
	        if ("development" !== 'production' && !warned) {
	          if (el.tag === 'slot' || el.tag === 'template') {
	            warned = true;
	            warn$1(
	              "Cannot use <" + (el.tag) + "> as component root element because it may " +
	              'contain multiple nodes:\n' + template
	            );
	          }
	          if (el.attrsMap.hasOwnProperty('v-for')) {
	            warned = true;
	            warn$1(
	              'Cannot use v-for on stateful component root element because ' +
	              'it renders multiple elements:\n' + template
	            );
	          }
	        }
	      }

	      // tree management
	      if (!root) {
	        root = element;
	        checkRootConstraints(root);
	      } else if (!stack.length) {
	        // allow 2 root elements with v-if and v-else
	        if (root.if && element.else) {
	          checkRootConstraints(element);
	          root.elseBlock = element;
	        } else if ("development" !== 'production' && !warned) {
	          warned = true;
	          warn$1(
	            ("Component template should contain exactly one root element:\n\n" + template)
	          );
	        }
	      }
	      if (currentParent && !element.forbidden) {
	        if (element.else) {
	          processElse(element, currentParent);
	        } else {
	          currentParent.children.push(element);
	          element.parent = currentParent;
	        }
	      }
	      if (!unary) {
	        currentParent = element;
	        stack.push(element);
	      }
	      // apply post-transforms
	      for (var i$2 = 0; i$2 < postTransforms.length; i$2++) {
	        postTransforms[i$2](element, options);
	      }
	    },

	    end: function end () {
	      // remove trailing whitespace
	      var element = stack[stack.length - 1];
	      var lastNode = element.children[element.children.length - 1];
	      if (lastNode && lastNode.type === 3 && lastNode.text === ' ') {
	        element.children.pop();
	      }
	      // pop stack
	      stack.length -= 1;
	      currentParent = stack[stack.length - 1];
	      // check pre state
	      if (element.pre) {
	        inVPre = false;
	      }
	      if (platformIsPreTag(element.tag)) {
	        inPre = false;
	      }
	    },

	    chars: function chars (text) {
	      if (!currentParent) {
	        if ("development" !== 'production' && !warned && text === template) {
	          warned = true;
	          warn$1(
	            'Component template requires a root element, rather than just text:\n\n' + template
	          );
	        }
	        return
	      }
	      text = inPre || text.trim()
	        ? decodeHTMLCached(text)
	        // only preserve whitespace if its not right after a starting tag
	        : preserveWhitespace && currentParent.children.length ? ' ' : '';
	      if (text) {
	        var expression;
	        if (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {
	          currentParent.children.push({
	            type: 2,
	            expression: expression,
	            text: text
	          });
	        } else {
	          // #3895 special character
	          text = text.replace(specialNewlineRE, '');
	          currentParent.children.push({
	            type: 3,
	            text: text
	          });
	        }
	      }
	    }
	  });
	  return root
	}

	function processPre (el) {
	  if (getAndRemoveAttr(el, 'v-pre') != null) {
	    el.pre = true;
	  }
	}

	function processRawAttrs (el) {
	  var l = el.attrsList.length;
	  if (l) {
	    var attrs = el.attrs = new Array(l);
	    for (var i = 0; i < l; i++) {
	      attrs[i] = {
	        name: el.attrsList[i].name,
	        value: JSON.stringify(el.attrsList[i].value)
	      };
	    }
	  } else if (!el.pre) {
	    // non root node in pre blocks with no attributes
	    el.plain = true;
	  }
	}

	function processKey (el) {
	  var exp = getBindingAttr(el, 'key');
	  if (exp) {
	    if ("development" !== 'production' && el.tag === 'template') {
	      warn$1("<template> cannot be keyed. Place the key on real elements instead.");
	    }
	    el.key = exp;
	  }
	}

	function processRef (el) {
	  var ref = getBindingAttr(el, 'ref');
	  if (ref) {
	    el.ref = ref;
	    el.refInFor = checkInFor(el);
	  }
	}

	function processFor (el) {
	  var exp;
	  if ((exp = getAndRemoveAttr(el, 'v-for'))) {
	    var inMatch = exp.match(forAliasRE);
	    if (!inMatch) {
	      "development" !== 'production' && warn$1(
	        ("Invalid v-for expression: " + exp)
	      );
	      return
	    }
	    el.for = inMatch[2].trim();
	    var alias = inMatch[1].trim();
	    var iteratorMatch = alias.match(forIteratorRE);
	    if (iteratorMatch) {
	      el.alias = iteratorMatch[1].trim();
	      el.iterator1 = iteratorMatch[2].trim();
	      if (iteratorMatch[3]) {
	        el.iterator2 = iteratorMatch[3].trim();
	      }
	    } else {
	      el.alias = alias;
	    }
	  }
	}

	function processIf (el) {
	  var exp = getAndRemoveAttr(el, 'v-if');
	  if (exp) {
	    el.if = exp;
	  }
	  if (getAndRemoveAttr(el, 'v-else') != null) {
	    el.else = true;
	  }
	}

	function processElse (el, parent) {
	  var prev = findPrevElement(parent.children);
	  if (prev && prev.if) {
	    prev.elseBlock = el;
	  } else {
	    warn$1(
	      ("v-else used on element <" + (el.tag) + "> without corresponding v-if.")
	    );
	  }
	}

	function processOnce (el) {
	  var once = getAndRemoveAttr(el, 'v-once');
	  if (once != null) {
	    el.once = true;
	  }
	}

	function processSlot (el) {
	  if (el.tag === 'slot') {
	    el.slotName = getBindingAttr(el, 'name');
	  } else {
	    var slotTarget = getBindingAttr(el, 'slot');
	    if (slotTarget) {
	      el.slotTarget = slotTarget;
	    }
	  }
	}

	function processComponent (el) {
	  var binding;
	  if ((binding = getBindingAttr(el, 'is'))) {
	    el.component = binding;
	  }
	  if (getAndRemoveAttr(el, 'inline-template') != null) {
	    el.inlineTemplate = true;
	  }
	}

	function processAttrs (el) {
	  var list = el.attrsList;
	  var i, l, name, rawName, value, arg, modifiers, isProp;
	  for (i = 0, l = list.length; i < l; i++) {
	    name = rawName = list[i].name;
	    value = list[i].value;
	    if (dirRE.test(name)) {
	      // mark element as dynamic
	      el.hasBindings = true;
	      // modifiers
	      modifiers = parseModifiers(name);
	      if (modifiers) {
	        name = name.replace(modifierRE, '');
	      }
	      if (bindRE.test(name)) { // v-bind
	        name = name.replace(bindRE, '');
	        if (modifiers && modifiers.prop) {
	          isProp = true;
	          name = camelize(name);
	          if (name === 'innerHtml') { name = 'innerHTML'; }
	        }
	        if (isProp || platformMustUseProp(name)) {
	          addProp(el, name, value);
	        } else {
	          addAttr(el, name, value);
	        }
	      } else if (onRE.test(name)) { // v-on
	        name = name.replace(onRE, '');
	        addHandler(el, name, value, modifiers);
	      } else { // normal directives
	        name = name.replace(dirRE, '');
	        // parse arg
	        var argMatch = name.match(argRE);
	        if (argMatch && (arg = argMatch[1])) {
	          name = name.slice(0, -(arg.length + 1));
	        }
	        addDirective(el, name, rawName, value, arg, modifiers);
	        if ("development" !== 'production' && name === 'model') {
	          checkForAliasModel(el, value);
	        }
	      }
	    } else {
	      // literal attribute
	      {
	        var expression = parseText(value, delimiters);
	        if (expression) {
	          warn$1(
	            name + "=\"" + value + "\": " +
	            'Interpolation inside attributes has been removed. ' +
	            'Use v-bind or the colon shorthand instead. For example, ' +
	            'instead of <div id="{{ val }}">, use <div :id="val">.'
	          );
	        }
	      }
	      addAttr(el, name, JSON.stringify(value));
	    }
	  }
	}

	function checkInFor (el) {
	  var parent = el;
	  while (parent) {
	    if (parent.for !== undefined) {
	      return true
	    }
	    parent = parent.parent;
	  }
	  return false
	}

	function parseModifiers (name) {
	  var match = name.match(modifierRE);
	  if (match) {
	    var ret = {};
	    match.forEach(function (m) { ret[m.slice(1)] = true; });
	    return ret
	  }
	}

	function makeAttrsMap (attrs, isIE) {
	  var map = {};
	  for (var i = 0, l = attrs.length; i < l; i++) {
	    if ("development" !== 'production' && map[attrs[i].name] && !isIE) {
	      warn$1('duplicate attribute: ' + attrs[i].name);
	    }
	    map[attrs[i].name] = attrs[i].value;
	  }
	  return map
	}

	function findPrevElement (children) {
	  var i = children.length;
	  while (i--) {
	    if (children[i].tag) { return children[i] }
	  }
	}

	function isForbiddenTag (el) {
	  return (
	    el.tag === 'style' ||
	    (el.tag === 'script' && (
	      !el.attrsMap.type ||
	      el.attrsMap.type === 'text/javascript'
	    ))
	  )
	}

	var ieNSBug = /^xmlns:NS\d+/;
	var ieNSPrefix = /^NS\d+:/;

	/* istanbul ignore next */
	function guardIESVGBug (attrs) {
	  var res = [];
	  for (var i = 0; i < attrs.length; i++) {
	    var attr = attrs[i];
	    if (!ieNSBug.test(attr.name)) {
	      attr.name = attr.name.replace(ieNSPrefix, '');
	      res.push(attr);
	    }
	  }
	  return res
	}

	function checkForAliasModel (el, value) {
	  var _el = el;
	  while (_el) {
	    if (_el.for && _el.alias === value) {
	      warn$1(
	        "<" + (el.tag) + " v-model=\"" + value + "\">: " +
	        "You are binding v-model directly to a v-for iteration alias. " +
	        "This will not be able to modify the v-for source array because " +
	        "writing to the alias is like modifying a function local variable. " +
	        "Consider using an array of objects and use v-model on an object property instead."
	      );
	    }
	    _el = _el.parent;
	  }
	}

	/*  */

	var isStaticKey;
	var isPlatformReservedTag;

	var genStaticKeysCached = cached(genStaticKeys$1);

	/**
	 * Goal of the optimizer: walk the generated template AST tree
	 * and detect sub-trees that are purely static, i.e. parts of
	 * the DOM that never needs to change.
	 *
	 * Once we detect these sub-trees, we can:
	 *
	 * 1. Hoist them into constants, so that we no longer need to
	 *    create fresh nodes for them on each re-render;
	 * 2. Completely skip them in the patching process.
	 */
	function optimize (root, options) {
	  if (!root) { return }
	  isStaticKey = genStaticKeysCached(options.staticKeys || '');
	  isPlatformReservedTag = options.isReservedTag || (function () { return false; });
	  // first pass: mark all non-static nodes.
	  markStatic(root);
	  // second pass: mark static roots.
	  markStaticRoots(root, false);
	}

	function genStaticKeys$1 (keys) {
	  return makeMap(
	    'type,tag,attrsList,attrsMap,plain,parent,children,attrs' +
	    (keys ? ',' + keys : '')
	  )
	}

	function markStatic (node) {
	  node.static = isStatic(node);
	  if (node.type === 1) {
	    for (var i = 0, l = node.children.length; i < l; i++) {
	      var child = node.children[i];
	      markStatic(child);
	      if (!child.static) {
	        node.static = false;
	      }
	    }
	  }
	}

	function markStaticRoots (node, isInFor) {
	  if (node.type === 1) {
	    if (node.static || node.once) {
	      node.staticInFor = isInFor;
	    }
	    if (node.static) {
	      node.staticRoot = true;
	      return
	    }
	    if (node.children) {
	      for (var i = 0, l = node.children.length; i < l; i++) {
	        markStaticRoots(node.children[i], isInFor || !!node.for);
	      }
	    }
	  }
	}

	function isStatic (node) {
	  if (node.type === 2) { // expression
	    return false
	  }
	  if (node.type === 3) { // text
	    return true
	  }
	  return !!(node.pre || (
	    !node.hasBindings && // no dynamic bindings
	    !node.if && !node.for && // not v-if or v-for or v-else
	    !isBuiltInTag(node.tag) && // not a built-in
	    isPlatformReservedTag(node.tag) && // not a component
	    !isDirectChildOfTemplateFor(node) &&
	    Object.keys(node).every(isStaticKey)
	  ))
	}

	function isDirectChildOfTemplateFor (node) {
	  while (node.parent) {
	    node = node.parent;
	    if (node.tag !== 'template') {
	      return false
	    }
	    if (node.for) {
	      return true
	    }
	  }
	  return false
	}

	/*  */

	var simplePathRE = /^\s*[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['.*?']|\[".*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*\s*$/;

	// keyCode aliases
	var keyCodes = {
	  esc: 27,
	  tab: 9,
	  enter: 13,
	  space: 32,
	  up: 38,
	  left: 37,
	  right: 39,
	  down: 40,
	  'delete': [8, 46]
	};

	var modifierCode = {
	  stop: '$event.stopPropagation();',
	  prevent: '$event.preventDefault();',
	  self: 'if($event.target !== $event.currentTarget)return;'
	};

	function genHandlers (events, native) {
	  var res = native ? 'nativeOn:{' : 'on:{';
	  for (var name in events) {
	    res += "\"" + name + "\":" + (genHandler(events[name])) + ",";
	  }
	  return res.slice(0, -1) + '}'
	}

	function genHandler (
	  handler
	) {
	  if (!handler) {
	    return 'function(){}'
	  } else if (Array.isArray(handler)) {
	    return ("[" + (handler.map(genHandler).join(',')) + "]")
	  } else if (!handler.modifiers) {
	    return simplePathRE.test(handler.value)
	      ? handler.value
	      : ("function($event){" + (handler.value) + "}")
	  } else {
	    var code = '';
	    var keys = [];
	    for (var key in handler.modifiers) {
	      if (modifierCode[key]) {
	        code += modifierCode[key];
	      } else {
	        keys.push(key);
	      }
	    }
	    if (keys.length) {
	      code = genKeyFilter(keys) + code;
	    }
	    var handlerCode = simplePathRE.test(handler.value)
	      ? handler.value + '($event)'
	      : handler.value;
	    return 'function($event){' + code + handlerCode + '}'
	  }
	}

	function genKeyFilter (keys) {
	  var code = keys.length === 1
	    ? normalizeKeyCode(keys[0])
	    : Array.prototype.concat.apply([], keys.map(normalizeKeyCode));
	  if (Array.isArray(code)) {
	    return ("if(" + (code.map(function (c) { return ("$event.keyCode!==" + c); }).join('&&')) + ")return;")
	  } else {
	    return ("if($event.keyCode!==" + code + ")return;")
	  }
	}

	function normalizeKeyCode (key) {
	  return (
	    parseInt(key, 10) || // number keyCode
	    keyCodes[key] || // built-in alias
	    ("_k(" + (JSON.stringify(key)) + ")") // custom alias
	  )
	}

	/*  */

	function bind$2 (el, dir) {
	  el.wrapData = function (code) {
	    return ("_b(" + code + "," + (dir.value) + (dir.modifiers && dir.modifiers.prop ? ',true' : '') + ")")
	  };
	}

	var baseDirectives = {
	  bind: bind$2,
	  cloak: noop
	};

	/*  */

	// configurable state
	var warn$2;
	var transforms$1;
	var dataGenFns;
	var platformDirectives$1;
	var staticRenderFns;
	var onceCount;
	var currentOptions;

	function generate (
	  ast,
	  options
	) {
	  // save previous staticRenderFns so generate calls can be nested
	  var prevStaticRenderFns = staticRenderFns;
	  var currentStaticRenderFns = staticRenderFns = [];
	  var prevOnceCount = onceCount;
	  onceCount = 0;
	  currentOptions = options;
	  warn$2 = options.warn || baseWarn;
	  transforms$1 = pluckModuleFunction(options.modules, 'transformCode');
	  dataGenFns = pluckModuleFunction(options.modules, 'genData');
	  platformDirectives$1 = options.directives || {};
	  var code = ast ? genElement(ast) : '_h("div")';
	  staticRenderFns = prevStaticRenderFns;
	  onceCount = prevOnceCount;
	  return {
	    render: ("with(this){return " + code + "}"),
	    staticRenderFns: currentStaticRenderFns
	  }
	}

	function genElement (el) {
	  if (el.staticRoot && !el.staticProcessed) {
	    return genStatic(el)
	  } else if (el.once && !el.onceProcessed) {
	    return genOnce(el)
	  } else if (el.for && !el.forProcessed) {
	    return genFor(el)
	  } else if (el.if && !el.ifProcessed) {
	    return genIf(el)
	  } else if (el.tag === 'template' && !el.slotTarget) {
	    return genChildren(el) || 'void 0'
	  } else if (el.tag === 'slot') {
	    return genSlot(el)
	  } else {
	    // component or element
	    var code;
	    if (el.component) {
	      code = genComponent(el.component, el);
	    } else {
	      var data = el.plain ? undefined : genData(el);

	      var children = el.inlineTemplate ? null : genChildren(el);
	      code = "_h('" + (el.tag) + "'" + (data ? ("," + data) : '') + (children ? ("," + children) : '') + ")";
	    }
	    // module transforms
	    for (var i = 0; i < transforms$1.length; i++) {
	      code = transforms$1[i](el, code);
	    }
	    return code
	  }
	}

	// hoist static sub-trees out
	function genStatic (el) {
	  el.staticProcessed = true;
	  staticRenderFns.push(("with(this){return " + (genElement(el)) + "}"));
	  return ("_m(" + (staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + ")")
	}

	// v-once
	function genOnce (el) {
	  el.onceProcessed = true;
	  if (el.staticInFor) {
	    var key = '';
	    var parent = el.parent;
	    while (parent) {
	      if (parent.for) {
	        key = parent.key;
	        break
	      }
	      parent = parent.parent;
	    }
	    if (!key) {
	      "development" !== 'production' && warn$2(
	        "v-once can only be used inside v-for that is keyed. "
	      );
	      return genElement(el)
	    }
	    return ("_o(" + (genElement(el)) + "," + (onceCount++) + (key ? ("," + key) : "") + ")")
	  } else {
	    return genStatic(el)
	  }
	}

	function genIf (el) {
	  var exp = el.if;
	  el.ifProcessed = true; // avoid recursion
	  return ("(" + exp + ")?" + (genElement(el)) + ":" + (genElse(el)))
	}

	function genElse (el) {
	  return el.elseBlock
	    ? genElement(el.elseBlock)
	    : '_e()'
	}

	function genFor (el) {
	  var exp = el.for;
	  var alias = el.alias;
	  var iterator1 = el.iterator1 ? ("," + (el.iterator1)) : '';
	  var iterator2 = el.iterator2 ? ("," + (el.iterator2)) : '';
	  el.forProcessed = true; // avoid recursion
	  return "_l((" + exp + ")," +
	    "function(" + alias + iterator1 + iterator2 + "){" +
	      "return " + (genElement(el)) +
	    '})'
	}

	function genData (el) {
	  var data = '{';

	  // directives first.
	  // directives may mutate the el's other properties before they are generated.
	  var dirs = genDirectives(el);
	  if (dirs) { data += dirs + ','; }

	  // key
	  if (el.key) {
	    data += "key:" + (el.key) + ",";
	  }
	  // ref
	  if (el.ref) {
	    data += "ref:" + (el.ref) + ",";
	  }
	  if (el.refInFor) {
	    data += "refInFor:true,";
	  }
	  // record original tag name for components using "is" attribute
	  if (el.component) {
	    data += "tag:\"" + (el.tag) + "\",";
	  }
	  // slot target
	  if (el.slotTarget) {
	    data += "slot:" + (el.slotTarget) + ",";
	  }
	  // module data generation functions
	  for (var i = 0; i < dataGenFns.length; i++) {
	    data += dataGenFns[i](el);
	  }
	  // attributes
	  if (el.attrs) {
	    data += "attrs:{" + (genProps(el.attrs)) + "},";
	  }
	  // DOM props
	  if (el.props) {
	    data += "domProps:{" + (genProps(el.props)) + "},";
	  }
	  // event handlers
	  if (el.events) {
	    data += (genHandlers(el.events)) + ",";
	  }
	  if (el.nativeEvents) {
	    data += (genHandlers(el.nativeEvents, true)) + ",";
	  }
	  // inline-template
	  if (el.inlineTemplate) {
	    var ast = el.children[0];
	    if ("development" !== 'production' && (
	      el.children.length > 1 || ast.type !== 1
	    )) {
	      warn$2('Inline-template components must have exactly one child element.');
	    }
	    if (ast.type === 1) {
	      var inlineRenderFns = generate(ast, currentOptions);
	      data += "inlineTemplate:{render:function(){" + (inlineRenderFns.render) + "},staticRenderFns:[" + (inlineRenderFns.staticRenderFns.map(function (code) { return ("function(){" + code + "}"); }).join(',')) + "]}";
	    }
	  }
	  data = data.replace(/,$/, '') + '}';
	  // v-bind data wrap
	  if (el.wrapData) {
	    data = el.wrapData(data);
	  }
	  return data
	}

	function genDirectives (el) {
	  var dirs = el.directives;
	  if (!dirs) { return }
	  var res = 'directives:[';
	  var hasRuntime = false;
	  var i, l, dir, needRuntime;
	  for (i = 0, l = dirs.length; i < l; i++) {
	    dir = dirs[i];
	    needRuntime = true;
	    var gen = platformDirectives$1[dir.name] || baseDirectives[dir.name];
	    if (gen) {
	      // compile-time directive that manipulates AST.
	      // returns true if it also needs a runtime counterpart.
	      needRuntime = !!gen(el, dir, warn$2);
	    }
	    if (needRuntime) {
	      hasRuntime = true;
	      res += "{name:\"" + (dir.name) + "\",rawName:\"" + (dir.rawName) + "\"" + (dir.value ? (",value:(" + (dir.value) + "),expression:" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (",arg:\"" + (dir.arg) + "\"") : '') + (dir.modifiers ? (",modifiers:" + (JSON.stringify(dir.modifiers))) : '') + "},";
	    }
	  }
	  if (hasRuntime) {
	    return res.slice(0, -1) + ']'
	  }
	}

	function genChildren (el) {
	  if (el.children.length) {
	    return '[' + el.children.map(genNode).join(',') + ']'
	  }
	}

	function genNode (node) {
	  if (node.type === 1) {
	    return genElement(node)
	  } else {
	    return genText(node)
	  }
	}

	function genText (text) {
	  return text.type === 2
	    ? text.expression // no need for () because already wrapped in _s()
	    : JSON.stringify(text.text)
	}

	function genSlot (el) {
	  var slotName = el.slotName || '"default"';
	  var children = genChildren(el);
	  return ("_t(" + slotName + (children ? ("," + children) : '') + ")")
	}

	// componentName is el.component, take it as argument to shun flow's pessimistic refinement
	function genComponent (componentName, el) {
	  var children = el.inlineTemplate ? null : genChildren(el);
	  return ("_h(" + componentName + "," + (genData(el)) + (children ? ("," + children) : '') + ")")
	}

	function genProps (props) {
	  var res = '';
	  for (var i = 0; i < props.length; i++) {
	    var prop = props[i];
	    res += "\"" + (prop.name) + "\":" + (prop.value) + ",";
	  }
	  return res.slice(0, -1)
	}

	/*  */

	/**
	 * Compile a template.
	 */
	function compile$1 (
	  template,
	  options
	) {
	  var ast = parse(template.trim(), options);
	  optimize(ast, options);
	  var code = generate(ast, options);
	  return {
	    ast: ast,
	    render: code.render,
	    staticRenderFns: code.staticRenderFns
	  }
	}

	/*  */

	// operators like typeof, instanceof and in are allowed
	var prohibitedKeywordRE = new RegExp('\\b' + (
	  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +
	  'super,throw,while,yield,delete,export,import,return,switch,default,' +
	  'extends,finally,continue,debugger,function,arguments'
	).split(',').join('\\b|\\b') + '\\b');
	// check valid identifier for v-for
	var identRE = /[A-Za-z_$][\w$]*/;
	// strip strings in expressions
	var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;

	// detect problematic expressions in a template
	function detectErrors (ast) {
	  var errors = [];
	  if (ast) {
	    checkNode(ast, errors);
	  }
	  return errors
	}

	function checkNode (node, errors) {
	  if (node.type === 1) {
	    for (var name in node.attrsMap) {
	      if (dirRE.test(name)) {
	        var value = node.attrsMap[name];
	        if (value) {
	          if (name === 'v-for') {
	            checkFor(node, ("v-for=\"" + value + "\""), errors);
	          } else {
	            checkExpression(value, (name + "=\"" + value + "\""), errors);
	          }
	        }
	      }
	    }
	    if (node.children) {
	      for (var i = 0; i < node.children.length; i++) {
	        checkNode(node.children[i], errors);
	      }
	    }
	  } else if (node.type === 2) {
	    checkExpression(node.expression, node.text, errors);
	  }
	}

	function checkFor (node, text, errors) {
	  checkExpression(node.for || '', text, errors);
	  checkIdentifier(node.alias, 'v-for alias', text, errors);
	  checkIdentifier(node.iterator1, 'v-for iterator', text, errors);
	  checkIdentifier(node.iterator2, 'v-for iterator', text, errors);
	}

	function checkIdentifier (ident, type, text, errors) {
	  if (typeof ident === 'string' && !identRE.test(ident)) {
	    errors.push(("- invalid " + type + " \"" + ident + "\" in expression: " + text));
	  }
	}

	function checkExpression (exp, text, errors) {
	  try {
	    new Function(("return " + exp));
	  } catch (e) {
	    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);
	    if (keywordMatch) {
	      errors.push(
	        "- avoid using JavaScript keyword as property name: " +
	        "\"" + (keywordMatch[0]) + "\" in expression " + text
	      );
	    } else {
	      errors.push(("- invalid expression: " + text));
	    }
	  }
	}

	/*  */

	function transformNode (el, options) {
	  var warn = options.warn || baseWarn;
	  var staticClass = getAndRemoveAttr(el, 'class');
	  if ("development" !== 'production' && staticClass) {
	    var expression = parseText(staticClass, options.delimiters);
	    if (expression) {
	      warn(
	        "class=\"" + staticClass + "\": " +
	        'Interpolation inside attributes has been removed. ' +
	        'Use v-bind or the colon shorthand instead. For example, ' +
	        'instead of <div class="{{ val }}">, use <div :class="val">.'
	      );
	    }
	  }
	  if (staticClass) {
	    el.staticClass = JSON.stringify(staticClass);
	  }
	  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);
	  if (classBinding) {
	    el.classBinding = classBinding;
	  }
	}

	function genData$1 (el) {
	  var data = '';
	  if (el.staticClass) {
	    data += "staticClass:" + (el.staticClass) + ",";
	  }
	  if (el.classBinding) {
	    data += "class:" + (el.classBinding) + ",";
	  }
	  return data
	}

	var klass$1 = {
	  staticKeys: ['staticClass'],
	  transformNode: transformNode,
	  genData: genData$1
	};

	/*  */

	function transformNode$1 (el) {
	  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);
	  if (styleBinding) {
	    el.styleBinding = styleBinding;
	  }
	}

	function genData$2 (el) {
	  return el.styleBinding
	    ? ("style:(" + (el.styleBinding) + "),")
	    : ''
	}

	var style$1 = {
	  transformNode: transformNode$1,
	  genData: genData$2
	};

	var modules$1 = [
	  klass$1,
	  style$1
	];

	/*  */

	var len;
	var str;
	var chr;
	var index$1;
	var expressionPos;
	var expressionEndPos;

	/**
	 * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)
	 *
	 * for loop possible cases:
	 *
	 * - test
	 * - test[idx]
	 * - test[test1[idx]]
	 * - test["a"][idx]
	 * - xxx.test[a[a].test1[idx]]
	 * - test.xxx.a["asa"][test1[idx]]
	 *
	 */

	function parseModel (val) {
	  str = val;
	  len = str.length;
	  index$1 = expressionPos = expressionEndPos = 0;

	  if (val.indexOf('[') < 0) {
	    return {
	      exp: val,
	      idx: null
	    }
	  }

	  while (!eof()) {
	    chr = next();
	    /* istanbul ignore if */
	    if (isStringStart(chr)) {
	      parseString(chr);
	    } else if (chr === 0x5B) {
	      parseBracket(chr);
	    }
	  }

	  return {
	    exp: val.substring(0, expressionPos),
	    idx: val.substring(expressionPos + 1, expressionEndPos)
	  }
	}

	function next () {
	  return str.charCodeAt(++index$1)
	}

	function eof () {
	  return index$1 >= len
	}

	function isStringStart (chr) {
	  return chr === 0x22 || chr === 0x27
	}

	function parseBracket (chr) {
	  var inBracket = 1;
	  expressionPos = index$1;
	  while (!eof()) {
	    chr = next();
	    if (isStringStart(chr)) {
	      parseString(chr);
	      continue
	    }
	    if (chr === 0x5B) { inBracket++; }
	    if (chr === 0x5D) { inBracket--; }
	    if (inBracket === 0) {
	      expressionEndPos = index$1;
	      break
	    }
	  }
	}

	function parseString (chr) {
	  var stringQuote = chr;
	  while (!eof()) {
	    chr = next();
	    if (chr === stringQuote) {
	      break
	    }
	  }
	}

	/*  */

	var warn$3;

	function model$1 (
	  el,
	  dir,
	  _warn
	) {
	  warn$3 = _warn;
	  var value = dir.value;
	  var modifiers = dir.modifiers;
	  var tag = el.tag;
	  var type = el.attrsMap.type;
	  {
	    var dynamicType = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];
	    if (tag === 'input' && dynamicType) {
	      warn$3(
	        "<input :type=\"" + dynamicType + "\" v-model=\"" + value + "\">:\n" +
	        "v-model does not support dynamic input types. Use v-if branches instead."
	      );
	    }
	  }
	  if (tag === 'select') {
	    genSelect(el, value, modifiers);
	  } else if (tag === 'input' && type === 'checkbox') {
	    genCheckboxModel(el, value, modifiers);
	  } else if (tag === 'input' && type === 'radio') {
	    genRadioModel(el, value, modifiers);
	  } else {
	    genDefaultModel(el, value, modifiers);
	  }
	  // ensure runtime directive metadata
	  return true
	}

	function genCheckboxModel (
	  el,
	  value,
	  modifiers
	) {
	  if ("development" !== 'production' &&
	    el.attrsMap.checked != null) {
	    warn$3(
	      "<" + (el.tag) + " v-model=\"" + value + "\" checked>:\n" +
	      "inline checked attributes will be ignored when using v-model. " +
	      'Declare initial values in the component\'s data option instead.'
	    );
	  }
	  var number = modifiers && modifiers.number;
	  var valueBinding = getBindingAttr(el, 'value') || 'null';
	  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';
	  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';
	  addProp(el, 'checked',
	    "Array.isArray(" + value + ")" +
	      "?_i(" + value + "," + valueBinding + ")>-1" +
	      ":_q(" + value + "," + trueValueBinding + ")"
	  );
	  addHandler(el, 'change',
	    "var $$a=" + value + "," +
	        '$$el=$event.target,' +
	        "$$c=$$el.checked?(" + trueValueBinding + "):(" + falseValueBinding + ");" +
	    'if(Array.isArray($$a)){' +
	      "var $$v=" + (number ? '_n(' + valueBinding + ')' : valueBinding) + "," +
	          '$$i=_i($$a,$$v);' +
	      "if($$c){$$i<0&&(" + value + "=$$a.concat($$v))}" +
	      "else{$$i>-1&&(" + value + "=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}" +
	    "}else{" + value + "=$$c}",
	    null, true
	  );
	}

	function genRadioModel (
	    el,
	    value,
	    modifiers
	) {
	  if ("development" !== 'production' &&
	    el.attrsMap.checked != null) {
	    warn$3(
	      "<" + (el.tag) + " v-model=\"" + value + "\" checked>:\n" +
	      "inline checked attributes will be ignored when using v-model. " +
	      'Declare initial values in the component\'s data option instead.'
	    );
	  }
	  var number = modifiers && modifiers.number;
	  var valueBinding = getBindingAttr(el, 'value') || 'null';
	  valueBinding = number ? ("_n(" + valueBinding + ")") : valueBinding;
	  addProp(el, 'checked', ("_q(" + value + "," + valueBinding + ")"));
	  addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);
	}

	function genDefaultModel (
	  el,
	  value,
	  modifiers
	) {
	  {
	    if (el.tag === 'input' && el.attrsMap.value) {
	      warn$3(
	        "<" + (el.tag) + " v-model=\"" + value + "\" value=\"" + (el.attrsMap.value) + "\">:\n" +
	        'inline value attributes will be ignored when using v-model. ' +
	        'Declare initial values in the component\'s data option instead.'
	      );
	    }
	    if (el.tag === 'textarea' && el.children.length) {
	      warn$3(
	        "<textarea v-model=\"" + value + "\">:\n" +
	        'inline content inside <textarea> will be ignored when using v-model. ' +
	        'Declare initial values in the component\'s data option instead.'
	      );
	    }
	  }

	  var type = el.attrsMap.type;
	  var ref = modifiers || {};
	  var lazy = ref.lazy;
	  var number = ref.number;
	  var trim = ref.trim;
	  var event = lazy || (isIE && type === 'range') ? 'change' : 'input';
	  var needCompositionGuard = !lazy && type !== 'range';
	  var isNative = el.tag === 'input' || el.tag === 'textarea';

	  var valueExpression = isNative
	    ? ("$event.target.value" + (trim ? '.trim()' : ''))
	    : "$event";
	  valueExpression = number || type === 'number'
	    ? ("_n(" + valueExpression + ")")
	    : valueExpression;
	  var code = genAssignmentCode(value, valueExpression);
	  if (isNative && needCompositionGuard) {
	    code = "if($event.target.composing)return;" + code;
	  }
	  // inputs with type="file" are read only and setting the input's
	  // value will throw an error.
	  if ("development" !== 'production' &&
	      type === 'file') {
	    warn$3(
	      "<" + (el.tag) + " v-model=\"" + value + "\" type=\"file\">:\n" +
	      "File inputs are read only. Use a v-on:change listener instead."
	    );
	  }
	  addProp(el, 'value', isNative ? ("_s(" + value + ")") : ("(" + value + ")"));
	  addHandler(el, event, code, null, true);
	}

	function genSelect (
	    el,
	    value,
	    modifiers
	) {
	  {
	    el.children.some(checkOptionWarning);
	  }

	  var number = modifiers && modifiers.number;
	  var assignment = "Array.prototype.filter" +
	    ".call($event.target.options,function(o){return o.selected})" +
	    ".map(function(o){var val = \"_value\" in o ? o._value : o.value;" +
	    "return " + (number ? '_n(val)' : 'val') + "})" +
	    (el.attrsMap.multiple == null ? '[0]' : '');

	  var code = genAssignmentCode(value, assignment);
	  addHandler(el, 'change', code, null, true);
	}

	function checkOptionWarning (option) {
	  if (option.type === 1 &&
	    option.tag === 'option' &&
	    option.attrsMap.selected != null) {
	    warn$3(
	      "<select v-model=\"" + (option.parent.attrsMap['v-model']) + "\">:\n" +
	      'inline selected attributes on <option> will be ignored when using v-model. ' +
	      'Declare initial values in the component\'s data option instead.'
	    );
	    return true
	  }
	  return false
	}

	function genAssignmentCode (value, assignment) {
	  var modelRs = parseModel(value);
	  if (modelRs.idx === null) {
	    return (value + "=" + assignment)
	  } else {
	    return "var $$exp = " + (modelRs.exp) + ", $$idx = " + (modelRs.idx) + ";" +
	      "if (!Array.isArray($$exp)){" +
	        value + "=" + assignment + "}" +
	      "else{$$exp.splice($$idx, 1, " + assignment + ")}"
	  }
	}

	/*  */

	function text (el, dir) {
	  if (dir.value) {
	    addProp(el, 'textContent', ("_s(" + (dir.value) + ")"));
	  }
	}

	/*  */

	function html (el, dir) {
	  if (dir.value) {
	    addProp(el, 'innerHTML', ("_s(" + (dir.value) + ")"));
	  }
	}

	var directives$1 = {
	  model: model$1,
	  text: text,
	  html: html
	};

	/*  */

	var cache = Object.create(null);

	var baseOptions = {
	  isIE: isIE,
	  expectHTML: true,
	  modules: modules$1,
	  staticKeys: genStaticKeys(modules$1),
	  directives: directives$1,
	  isReservedTag: isReservedTag,
	  isUnaryTag: isUnaryTag,
	  mustUseProp: mustUseProp,
	  getTagNamespace: getTagNamespace,
	  isPreTag: isPreTag
	};

	function compile$$1 (
	  template,
	  options
	) {
	  options = options
	    ? extend(extend({}, baseOptions), options)
	    : baseOptions;
	  return compile$1(template, options)
	}

	function compileToFunctions (
	  template,
	  options,
	  vm
	) {
	  var _warn = (options && options.warn) || warn;
	  // detect possible CSP restriction
	  /* istanbul ignore if */
	  {
	    try {
	      new Function('return 1');
	    } catch (e) {
	      if (e.toString().match(/unsafe-eval|CSP/)) {
	        _warn(
	          'It seems you are using the standalone build of Vue.js in an ' +
	          'environment with Content Security Policy that prohibits unsafe-eval. ' +
	          'The template compiler cannot work in this environment. Consider ' +
	          'relaxing the policy to allow unsafe-eval or pre-compiling your ' +
	          'templates into render functions.'
	        );
	      }
	    }
	  }
	  var key = options && options.delimiters
	    ? String(options.delimiters) + template
	    : template;
	  if (cache[key]) {
	    return cache[key]
	  }
	  var res = {};
	  var compiled = compile$$1(template, options);
	  res.render = makeFunction(compiled.render);
	  var l = compiled.staticRenderFns.length;
	  res.staticRenderFns = new Array(l);
	  for (var i = 0; i < l; i++) {
	    res.staticRenderFns[i] = makeFunction(compiled.staticRenderFns[i]);
	  }
	  {
	    if (res.render === noop || res.staticRenderFns.some(function (fn) { return fn === noop; })) {
	      _warn(
	        "failed to compile template:\n\n" + template + "\n\n" +
	        detectErrors(compiled.ast).join('\n') +
	        '\n\n',
	        vm
	      );
	    }
	  }
	  return (cache[key] = res)
	}

	function makeFunction (code) {
	  try {
	    return new Function(code)
	  } catch (e) {
	    return noop
	  }
	}

	/*  */

	var idToTemplate = cached(function (id) {
	  var el = query(id);
	  return el && el.innerHTML
	});

	var mount = Vue$2.prototype.$mount;
	Vue$2.prototype.$mount = function (
	  el,
	  hydrating
	) {
	  el = el && query(el);

	  /* istanbul ignore if */
	  if (el === document.body || el === document.documentElement) {
	    "development" !== 'production' && warn(
	      "Do not mount Vue to <html> or <body> - mount to normal elements instead."
	    );
	    return this
	  }

	  var options = this.$options;
	  // resolve template/el and convert to render function
	  if (!options.render) {
	    var template = options.template;
	    if (template) {
	      if (typeof template === 'string') {
	        if (template.charAt(0) === '#') {
	          template = idToTemplate(template);
	        }
	      } else if (template.nodeType) {
	        template = template.innerHTML;
	      } else {
	        {
	          warn('invalid template option:' + template, this);
	        }
	        return this
	      }
	    } else if (el) {
	      template = getOuterHTML(el);
	    }
	    if (template) {
	      var ref = compileToFunctions(template, {
	        warn: warn,
	        shouldDecodeNewlines: shouldDecodeNewlines,
	        delimiters: options.delimiters
	      }, this);
	      var render = ref.render;
	      var staticRenderFns = ref.staticRenderFns;
	      options.render = render;
	      options.staticRenderFns = staticRenderFns;
	    }
	  }
	  return mount.call(this, el, hydrating)
	};

	/**
	 * Get outerHTML of elements, taking care
	 * of SVG elements in IE as well.
	 */
	function getOuterHTML (el) {
	  if (el.outerHTML) {
	    return el.outerHTML
	  } else {
	    var container = document.createElement('div');
	    container.appendChild(el.cloneNode(true));
	    return container.innerHTML
	  }
	}

	Vue$2.compile = compileToFunctions;

	return Vue$2;

	})));


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	var Vue = __webpack_require__(2);
	new Vue({
	    el: '#gamearea',
	    data: {
	        length: 6,
	        message: 'Hello Vue!',
	    }
	})

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(5);
	var $ = __webpack_require__(6);
	// Global variables
	var boardSize = 6;
	var tunnelLength = 12;
	var maxTunnelLength;
	var numProbes = 0;
	var probesList = [];
	var tunnel = new Tunnel();
	var finalTunnelGuess = [];
	var gameMode = -1;
	// 0 = Regular
	// 1 = Easy Mode
	var player1Name = "";
	var player2Name = "";
	var player1Score = 0;
	var player2Score = 0;
	var round = 1;
	var winningScore = 0;
	var winningPlayer = "";
	var computer = -1;
	// 0 = Humans
	// 1 = AI
	var gameState = -1;
	// 0 = badGuy placing tunnels
	// 1 = detector placing 1st hour probes
	// 2 = detector placing 2nd hour probes
	// 3 = detector placing 3rd hour probes
	// 4 = detector detecting


	// Clear the board before a new game
	var clearBoard = function () {
	    $(".animate").filter(function() {
	        $(this).removeClass("animate");
	    });
	    $(".final").filter(function() {
	        $(this).removeClass("final");
	    });
	    $(".detectedEdge").filter(function() {
	        $(this).removeClass("detectedEdge");
	    });
	    $(".reveal").filter(function() {
	        $(this).removeClass("reveal");
	    });
	}

	function Node(id) {
	    this.edges = [];
	    this.id = id;

	    this.addEdge = function(e0) {
	        this.edges.push(e0);
	    };

	    this.removeEdge = function(e0) {
	        var index = this.edges.indexOf(e0);
	        this.edges.splice(index, 1);
	    }
	}

	Node.prototype.toString = function nodeToString() {
	    var ret = this.id + ": ";
	    for (var i = 0; i < this.edges.length; i++) {
	        ret += (this.edges[i].id + " ");
	    }
	    return ret;
	}

	function Edge(n1, n2, id) {
	    this.n1 = n1;
	    this.n2 = n2;
	    this.id = id;
	    this.allNodes = [];
	}

	Edge.prototype.toString = function edgeToString() {
	    var ret = this.id + ": ";
	    console.log(ret)
	    for (var i = 0; i < this.allNodes.length; i++) {
	        ret += (this.allNodes[i].id + " ");
	    }
	    return ret;
	}

	function Tunnel() {
	    this.edges = {};
	    this.nodes = {};

	    this.addNode = function(node) {
	        var nodeId = node.id;
	        this.nodes[nodeId] = node;
	    };

	    this.removeNode = function(node) {
	        var nodeId = node.id;
	        delete this.nodes[nodeId];
	    };

	    this.addEdge = function(edge) {
	        var edgeId = edge.id;
	        this.edges[edgeId] = edge;
	    };

	    this.removeEdge = function(edge1) {
	        var edgeId = edge1.id;
	        delete this.edges[edgeId];
	    };

	    this.getStartNode = function() {
	        // Get all nodes that are touching the top row
	        var starts = [];
	        for (var nodeId in this.nodes) {
	            if (!this.nodes.hasOwnProperty(nodeId)) {
	                //not direct property of nodes
	                continue;
	            }

	            node = this.nodes[nodeId];
	            if (Number(node.id) < (boardSize + 1)) {
	                starts.push(node);
	            }
	        }

	        // Out of all nodes on top row, get all that have just one edge
	        var validStarts = [];
	        for (var i = 0; i < starts.length; i++) {
	            if (starts[i].edges.length == 1) {
	                validStarts.push(starts[i]);
	                console.log("valid starts: ", validStarts);
	            }
	        }

	        // If there is just one such node, it's our start
	        // Else there isn't a valid start node and tunnel is invalid
	        console.log("length of validStarts: ", validStarts.length);
	        if (validStarts.length == 1) {
	            console.log("validStarts[0] is ", validStarts[0]);
	            return validStarts[0];
	        }
	        else {
	            return null;
	        }
	    };

	    this.getEndNode = function() {
	        // Get all nodes that are touching the bottom row
	        var ends = [];
	        for (var nodeId in this.nodes) {
	            if (!this.nodes.hasOwnProperty(nodeId)) {
	                // Not direct property of nodes
	                continue;
	            }

	            node = this.nodes[nodeId];
	            if (Number(node.id) >= (boardSize * (boardSize + 1))) {
	                ends.push(node);
	            }
	        }

	        // Out of all nodes on top row, get all that have just one edge
	        var validEnds = [];
	        for (var i = 0; i < ends.length; i++) {
	            if (ends[i].edges.length == 1) {
	                validEnds.push(ends[i]);
	            }
	        }

	        // If there is just one such node, it's our start
	        // Else there isn't a valid start node and tunnel is invalid
	        if (validEnds.length == 1) {
	            return validEnds[0];
	        }
	        else {
	            return null;
	        }
	    };

	    this.validTunnel = function() {
	        console.log("EDGE INFO ", this.edges);
	        console.log("NODES ", this.nodes);
	        //duplicate nodes and edges
	        var allEdgeIds = [];
	        for (var item in this.edges) {
	            allEdgeIds.push(item);
	        }
	        console.log("All edge ids: ", allEdgeIds);
	        var allNodeIds = [];
	        for (var item in this.nodes) {
	            allNodeIds.push(item);
	        }
	        console.log("All nodes: ", allNodeIds);

	        var currNode = this.getStartNode();
	        console.log("Start node: ", currNode);

	        //if there is no start node, tunnel is invalid
	        if (currNode == null) {
	            return false;
	        }

	        //if there is no end node, tunnel is invalid
	        if (this.getEndNode() == null) {
	            return false;
	        }
	        console.log("end node: ", this.getEndNode());

	        //remove start node and it's only edge from total
	        allEdgeIds.splice(allEdgeIds.indexOf(currNode.edges[0].id), 1);

	        //get 2nd node
	        if(currNode.edges[0].n1 != currNode) {
	            currNode = currNode.edges[0].n1;
	        }
	        else {
	            currNode = currNode.edges[0].n2;
	        }

	        while (true) {
	            console.log("beg of loop", currNode.id);

	            //end conditions
	            if (currNode == this.getEndNode()) {
	                console.log("Reached end node");
	                //if we've removed all the edges we're good
	                if (allEdgeIds.length == 0) {
	                    return true;
	                }
	                else {
	                    console.log("AllEdgeIds does NOT == 0");
	                    return false;
	                }
	            }

	            //check that each node we reach only has 2 edges
	            if(currNode.edges.length != 2) {
	                console.log(currNode, "doesn't have 2 edges");
	                return false;
	            }

	            //check that one of the two edges is still alive
	            var nextEdge = null;
	            console.log("curr node edges:", currNode.edges);
	            console.log("All edge Ids: ", allEdgeIds);
	            for (var i = 0; i < currNode.edges.length; i++) {
	                console.log("currNode.edges[i].id ", currNode.edges[i].id);
	                if (allEdgeIds.indexOf(currNode.edges[i].id) > -1) {
	                    nextEdge = this.edges[currNode.edges[i].id];
	                }
	            }

	            //neither edge still in total list, tunnel invalid
	            if (nextEdge == null) {
	                console.log(nextEdge, "neither edge still in total list");
	                return false;
	            }

	            //clean up - remove curr node and curr edge
	            allEdgeIds.splice(allEdgeIds.indexOf(nextEdge.id), 1);

	            //get the next node
	            if(nextEdge.n1 != currNode) {
	                currNode = nextEdge.n1;
	            }
	            else {
	                currNode = nextEdge.n2;
	            }
	        }

	    };

	    this.clearTunnel = function() {
	        this.edges = {};
	        this.nodes = {};
	    }
	}

	Tunnel.prototype.toString = function tunnelToString() {
	    var ret = "tunnel: \n";
	    ret += "nodes: ";
	    for (var n in this.nodes) {
	        ret += (this.nodes[n].id + " ");
	    }
	    ret += "\nedges: ";
	    for (var e in this.edges) {
	        ret += (this.edges[e].id + " ");
	    }
	    ret += "\n";
	    return ret;
	}

	// Determine if was clicked before or not and add/remove edge from tunnel class
	var edges = document.getElementsByClassName("edge");

	var edgeClicked = function() {
	    var edgeId = this.getAttribute('x');
	    console.log(edgeId)
	    if (gameState == 0) {
	        $(this).toggleClass("animate");
	        if (edgeId in tunnel.edges) {
	            // Get nodes
	            tunnelLength++;
	            var n1 = tunnel.edges[edgeId].n1;
	            var n2 = tunnel.edges[edgeId].n2;
	            // Remove this edge from each node's edge list
	            n1.removeEdge(tunnel.edges[edgeId]);
	            n2.removeEdge(tunnel.edges[edgeId]);
	            if (n1.edges.length == 0) {
	                tunnel.removeNode(n1);
	            }
	            if (n2.edges.length == 0) {
	                tunnel.removeNode(n2);
	            }
	            tunnel.removeEdge(tunnel.edges[edgeId]);
	        } else {
	            // Check if there are no pieces
	            if (tunnelLength <= 0) {
	                remainingPieces.innerHTML = "There are no remaining edges! Please remove an edge to continue building.";
	                return;
	            }
	            tunnelLength--;
	            if (edgeId[0] == "h") {
	                console.log("slice: ", edgeId.slice(1));
	                var rNum = Math.floor(edgeId.slice(1) / boardSize);
	                console.log("rNum: ", rNum);
	                var n1Id = Number(edgeId.slice(1)) + rNum;
	                var n2Id = (n1Id + 1).toString();
	                console.log("n1Id: ", n1Id);
	                console.log("n2Id: ", n2Id);
	                var n1;
	                var n2;

	                if (n1Id in tunnel.nodes) {
	                    n1 = tunnel.nodes[n1Id];
	                } else {
	                    n1 = new Node(n1Id);
	                    tunnel.addNode(n1);
	                }

	                if (n2Id in tunnel.nodes) {
	                    n2 = tunnel.nodes[n2Id];
	                } else {
	                    n2 = new Node(n2Id);
	                    tunnel.addNode(n2);
	                }

	                var newEdge = new Edge(n1, n2, edgeId);
	                tunnel.addEdge(newEdge);
	                n1.addEdge(newEdge);
	                n2.addEdge(newEdge);
	            } else {
	                var n1Id = edgeId.slice(1);
	                var n2Id = (Number(edgeId.slice(1)) + boardSize + 1).toString();
	                console.log("n1Id: ", n1Id);
	                console.log("n2Id: ", n2Id);
	                var n1;
	                var n2;

	                if (n1Id in tunnel.nodes) {
	                    n1 = tunnel.nodes[n1Id];
	                } else {
	                    n1 = new Node(n1Id);
	                    tunnel.addNode(n1);
	                }

	                if (n2Id in tunnel.nodes) {
	                    n2 = tunnel.nodes[n2Id];
	                } else {
	                    n2 = new Node(n2Id);
	                    tunnel.addNode(n2);
	                }

	                var newEdge = new Edge(n1, n2, edgeId);
	                tunnel.addEdge(newEdge);
	                n1.addEdge(newEdge);
	                n2.addEdge(newEdge);
	            }
	        }

	        // this.style.background = this.style.background=='yellow'? '#63f9ff':'yellow';
	        remainingPieces.innerHTML = "Edges left: " + tunnelLength;
	        console.log(tunnel.edges);
	        console.log("Tunnel nodes: ", tunnel.nodes);
	    } else if (gameState == 4) {
	        if (finalTunnelGuess.indexOf(edgeId) > -1) {
	            finalTunnelGuess.splice(finalTunnelGuess.indexOf(edgeId), 1);
	        } else {
	            finalTunnelGuess.push(edgeId);
	        }
	        $(this).toggleClass("final");
	    }
	};



	// Get probes and add event listener to each one
	var probes = document.getElementsByClassName("probe");

	var probeClicked = function() {
	    if (gameState == 1 || gameState == 2 || gameState == 3) {
	        $(this).toggleClass("animate");
	        probeId = this.id;
	        console.log("Probe id: ", probeId);
	        index = probesList.indexOf(probeId);
	        console.log("Numprobes: " + numProbes);
	        console.log("Index: " + index);
	        if (index < 0) {
	            probesList.push(probeId.slice(1));
	            numProbes++;
	        } else {
	            probesList.splice(index, 1);
	            numProbes--;
	        }
	        // this.style.background = this.style.background == 'red' ? 'blue' : 'red';
	    }
	};

	for(var i=0;i<probes.length;i++){
	    probes[i].addEventListener('click', probeClicked, false);
	}

	var startGameInRegularMode = function () {
	    clearBoard();
	    gameMode = 0;
	    alert("Detector, please look away while Badguy builds a tunnel.");
	    startGame();
	}

	var startGameInEasyMode = function () {
	    clearBoard();
	    gameMode = 1;
	    alert("Detector, please look away while Badguy builds a tunnel.");
	    startGame();
	}

	var startGameAI = function () {
	    computer = 1;
	    gameMode = 0;
	    gameState = 0;
	    console.log("GAME STATE IN START AI ", gameState);
	    tunnel = createAITunnel();
	    startGame();
	}

	var startGameEasyAI = function () {
	    computer = 1;
	    gameMode = 1;
	    gameState = 0;
	    tunnel = createAITunnel();
	    startGame();
	}

	var startGame = function () {
	    clearBoard();
	    if (round == 1) {
	        tunnelLength = Math.floor(Math.random() * 13) + 8;
	        maxTunnelLength = tunnelLength;
	        alert("Maximum tunnel length is " + tunnelLength + ".");
	    } else {
	        tunnelLength = maxTunnelLength;
	    }
	    gameState++;
	    console.log("GAME STATE IS ", gameState);
	    document.getElementById('start').style.display = 'none';
	    document.getElementById('startEasy').style.display = 'none';
	    document.getElementById('startAI').style.display = 'none';
	    document.getElementById('startEasyAI').style.display = 'none';
	    document.getElementById('submitGuess').style.display = 'none';
	    if (gameState == 0) {
	        tunnelInfo.innerHTML = "Tunnel can be up to " + tunnelLength + " edges long.";
	        remainingPieces.innerHTML = "Edges left: " + tunnelLength;
	        document.getElementById('tunnelDone').style.display = 'block';
	    } else if (gameState == 1) {
	        message.innerHTML = "Computer opponent has constructed a tunnel. Detector, begin placing probes.";
	        document.getElementById('probesPlaced1').style.display = 'block';
	    }
	};

	var doneAddingTunnels = function () {
	    var valid = tunnel.validTunnel();
	    console.log(valid);

	    // If the tunnel isn't valid, don't let the game keep going
	    if(!valid) {
	        alert("Your tunnel is invalid. It must start on the top edge, end on the bottom edge, and be a single simple path.");
	        return;
	    }

	    document.getElementById('tunnelDone').style.display = 'none';
	    document.getElementById('probesPlaced1').style.display = 'block';
	    tunnelInfo.innerHTML = "";
	    remainingPieces.innerHTML = "";
	    currentTunnel.innerHTML = "";
	    message.innerHTML = "Done adding tunnels. Time for Detector to place first round of probes.";
	    for (var e in tunnel.edges) {
	        console.log("TRYING TO UNHIGHLIGHT");
	        console.log("tunnel.edges[e].id is ", tunnel.edges[e].id);
	        $("#" + tunnel.edges[e].id).toggleClass("animate");
	    }

	    // tunnelLength = 12;
	    // tunnel = createAITunnel();

	    console.log("final final tunnel:");
	    console.log("nodes");
	    for (var n in tunnel.nodes) {
	        console.log(tunnel.nodes[n] + "");
	    }
	    console.log("edges: ");
	    for (var e in tunnel.edges) {
	        console.log(tunnel.edges[e] + "");
	    }

	    gameState++;
	};

	var doneAddingProbes = function () {
	    message.innerHTML = "Done adding probes. Let's see how you did.";
	    for (var i = 0; i < probesList.length; i++) {
	        console.log("probesList[i] is ", probesList[i]);
	        if (probesList[i] in tunnel.nodes) {
	            console.log("we got in the if statement");
	            for (var j = 0; j < tunnel.nodes[probesList[i]].edges.length; j++) {
	                console.log("Found edge ", tunnel.nodes[probesList[i]].edges[j].id);
	                if (gameMode == 1) {
	                    $("#" + tunnel.nodes[probesList[i]].edges[j].id).addClass("animate");
	                }
	            }
	            $("#p" + probesList[i]).removeClass("animate");
	            $("#p" + probesList[i]).addClass("detectedEdge");
	        }
	    }

	    if (gameState == 1 || gameState == 2) {
	        //update score
	        if (computer == 1) {
	            //only need to update player1 score
	            player1Score += probesList.length;
	        } else {
	            if (round == 1) {
	                player1Score += probesList.length;
	            } else {
	                player2Score += probesList.length;
	            }
	        }

	        console.log("done with probe placement in round " + round);
	        console.log("player 1 score: " + player1Score);
	        console.log("player 2 score: " + player2Score);

	        probesList = [];
	        message.innerHTML = "Detector, please place another round of probes.";
	        document.getElementById('probesPlaced1').style.display = 'none';
	        document.getElementById('probesPlaced2').style.display = 'block';

	        gameState++;

	    } else if (gameState == 3) {
	        // Update score
	        if (computer == 1) {
	            // Only need to update player1 score
	            player1Score += probesList.length;
	        } else {
	            if (round == 1) {
	                player1Score += probesList.length;
	            } else {
	                player2Score += probesList.length;
	            }
	        }

	        console.log("done with probe placement in round " + round);
	        console.log("player 1 score: " + player1Score);
	        console.log("player 2 score: " + player2Score);

	        document.getElementById('probesPlaced2').style.display = 'none';
	        document.getElementById('submitGuess').style.display = 'block';
	        message.innerHTML = "Now, select all edges in the tunnel to submit your final guess.";
	        gameState++;
	    }

	    console.log("probes list after done ", probesList);
	};

	function restartGame() {
	    message.innerHTML = "";
	    round++;
	    if (computer == 1) {
	        if (gameMode == 0) { //regular ai
	            numProbes = 0;
	            probesList = [];
	            tunnel = new Tunnel();
	            finalTunnelGuess = [];
	            gameMode = -1;
	            computer = -1;
	            gameState = -1;
	            startGameAI();
	        } else {
	            numProbes = 0;
	            probesList = [];
	            tunnel = new Tunnel();
	            finalTunnelGuess = [];
	            gameMode = -1;
	            computer = -1;
	            gameState = -1;
	            startGameEasyAI();
	        }
	    } else {
	        if (gameMode == 0) {
	            numProbes = 0;
	            probesList = [];
	            tunnel = new Tunnel();
	            finalTunnelGuess = [];
	            gameMode = -1;
	            computer = -1;
	            gameState = -1;
	            startGameInRegularMode();
	        } else {
	            numProbes = 0;
	            probesList = [];
	            tunnel = new Tunnel();
	            finalTunnelGuess = [];
	            gameMode = -1;
	            computer = -1;
	            gameState = -1;
	            startGameInEasyMode();
	        }
	    }
	}

	var revealTunnel = function () {
	    for (var e in tunnel.edges) {
	        console.log("REVEALING TUNNEL");
	        console.log("tunnel.edges[e].id is ", tunnel.edges[e].id);
	        $("#" + tunnel.edges[e].id).removeClass("final");
	        $("#" + tunnel.edges[e].id).removeClass("animate");
	        $("#" + tunnel.edges[e].id).addClass("reveal");
	    }
	}

	var submitGuess = function () {
	    console.log("Final tunnel guess: ", finalTunnelGuess);
	    console.log("The actual tunnel: ", tunnel.edges);
	    console.log("Final tunnel guess LENGTH: ", finalTunnelGuess.length);
	    console.log("Tunnel length: ", Object.keys(tunnel.edges).length);
	    var clone = finalTunnelGuess.slice(0);
	    if (finalTunnelGuess.length != Object.keys(tunnel.edges).length) {
	        console.log("Tunnel length not the same");
	        if (round == 1) {
	            player1Score = 10000;
	            revealTunnel();
	            alert("You are a horrible Detector. Keep your day job. Your score is infinity.");
	        } else {
	            player2Score = 10000;
	            revealTunnel();
	            alert("You are a horrible Detector. Keep your day job. Your score is infinity.");
	        }
	    } else {
	        console.log("Tunnel length is good");
	        for (var i = 0; i < finalTunnelGuess.length; i++) {
	            console.log("Final tunnel guess: iteration ",i, finalTunnelGuess);
	            if (finalTunnelGuess[i] in tunnel.edges) {
	                console.log("Found match: " + finalTunnelGuess[i]);
	                clone.splice(clone.indexOf(finalTunnelGuess[i]), 1);
	                console.log("Clone: " + clone)
	            }
	        }
	        console.log("clone length ", clone.length);
	        if (!clone.length) {
	            if (round == 1) {
	                alert("Good job. Your score is " + player1Score + ".");
	            } else {
	                alert("Good job. Your score is " + player2Score + ".");
	            }
	        } else {
	            if (round == 1) {
	                player1Score = 10000;
	                revealTunnel();
	                alert("You are a horrible Detector. Keep your day job. Your score is infinity.");
	            } else {
	                player2Score = 10000;
	                revealTunnel();
	                alert("You are a horrible Detector. Keep your day job. Your score is infinity.");
	            }
	        }
	    }

	    if (round == 1 && computer != 1) {
	        // Popup that they need to switch roles
	        alert("Round 1 over. Now switch roles. The game will restart when you click OK.");
	        restartGame();
	    } else if (computer == 1) {
	        alert("Game over. You may submit your score.");
	        document.getElementById('submitGuess').style.display = 'none';
	        message.innerHTML = "";
	        document.getElementById("score").style.display="inline-block";
	    } else {
	        if (player1Score < player2Score ) {
	            winningScore = player1Score;
	            winningPlayer = player1Name;
	        } else {
	            winningScore = player2Score;
	            winningPlayer = player2Name;
	        }
	        if(computer != 1) {
	            if (player1Score < player2Score) {
	                alert("The game is over. Player 1 won with a score of " + player1Score + ". Player 1 can save their score.");
	            } else {
	                alert("The game is over. Player 2 won with a score of " + player2Score + ". Player 2 can save their score.");
	            }
	        } else {
	            alert("The game is over. Your score is " + player1Score + ". You can save your score.");
	            document.getElementById('submitGuess').style.display = 'none';
	            message.innerHTML = "";
	        }
	        document.getElementById('submitGuess').style.display = 'none';
	        message.innerHTML = "";
	        document.getElementById("score").style.display="inline-block";
	    }
	};


	// AI tunnel stuff
	function createAITunnel() {
	    var aiTunnel = new Tunnel();
	    var graph = new Graph();
	    graph.createGraph();
	    var currentTunnelLength = 0;

	    var start = Math.floor(Math.random() * (boardSize+1));
	    var currNodeFromGraph = graph.nodes[start];
	    var currNode = new Node(start);

	    var counter = 0;

	    while(true) {
	        console.log("curr node: " + currNode);

	        // Check if on end and if yes break
	        if (Math.floor(currNode.id / (boardSize+1)) == boardSize) {
	            console.log("on end!")
	            console.log("final tunnel: " + aiTunnel);
	            aiTunnel.addNode(currNode);
	            break;
	        }

	        // Pick an edge from the current nodes edges that's not the incoming edge
	        var potentialEdge = getRandomEdge(currNodeFromGraph, aiTunnel);
	        console.log("first potential edge: " + potentialEdge);

	        // See if adding that edge leaves enough pipes to get to the end
	        while (!potentialEdgeValid(potentialEdge, currNode, aiTunnel)) {
	            //while(false) {
	            potentialEdge = getRandomEdge(currNodeFromGraph, aiTunnel);
	            console.log("edge was invalid, got new one: " + potentialEdge);
	            //sleepFor(1000);
	        }

	        // Now we have a good edge, update it's n1
	        potentialEdge.n1 = currNode;

	        // Add the edge to currNode
	        currNode.addEdge(potentialEdge);

	        // Add them both to the tunnel
	        aiTunnel.addNode(currNode);
	        aiTunnel.addEdge(potentialEdge);

	        // Get the next node
	        var currNodeId = currNode.id;
	        var newNodeId = null;
	        // console.log("curr node id: " + currNodeId);
	        for (var i = 0; i < potentialEdge.allNodes.length; i++) {
	            // console.log("potentialEdge.allNodes[i].id: " + potentialEdge.allNodes[i].id );
	            if (potentialEdge.allNodes[i].id != currNodeId) {
	                newNodeId = potentialEdge.allNodes[i].id;
	            }
	        }
	        // console.log("new node id: " + newNodeId);

	        currNodeFromGraph = graph.nodes[newNodeId];
	        currNode = new Node(newNodeId);
	        currNode.addEdge(potentialEdge);
	        potentialEdge.n2 = currNode;
	        counter++;

	        console.log("tunnel: " + aiTunnel);

	    }

	    return aiTunnel;
	}

	function potentialEdgeValid(potentialEdge, currNode, tunnel) {

	    if(potentialEdge.id in tunnel.edges) {
	        console.log("edge exists, not valid");
	        return false;
	    }

	    tunnel.addEdge(potentialEdge);
	    tunnel.addNode(currNode);

	    var tunnelLengthSoFar = Object.keys(tunnel.edges).length;
	    var edgesLeft = tunnelLength - tunnelLengthSoFar;
	    var rowNum = getRowNum(potentialEdge);


	    console.log();
	    console.log("======= starting validation ========")
	    console.log("checking if edge " + potentialEdge.id + " is valid to add to tunnel: ");
	    console.log(tunnel + "");
	    console.log("tunnel len so far: " + tunnelLengthSoFar);
	    console.log("edges left so far: " + edgesLeft);
	    console.log("row num of edge: " + rowNum);

	    // Check that the other end of the new edge isn't already in the tunnel
	    // (This means we created a loop)
	    var currNodeId = currNode.id;
	    var newNodeId = null;
	    console.log("curr node id: " + currNodeId);
	    for (var i = 0; i < potentialEdge.allNodes.length; i++) {
	        //console.log("potentialEdge.allNodes[i].id: " + potentialEdge.allNodes[i].id );
	        if (potentialEdge.allNodes[i].id != currNodeId) {
	            newNodeId = potentialEdge.allNodes[i].id;
	        }
	    }
	    console.log("new node id: " + newNodeId);

	    if (newNodeId in tunnel.nodes) {
	        console.log("we created a loop, not valid");
	        tunnel.removeEdge(potentialEdge);
	        tunnel.removeNode(currNode);
	        return false;
	    }


	    // If the edge is horizontal then need (remaining pieces - (boardSize - rowNum)) >= 0
	    // Check if have enough nodes to end
	    var neededToEnd = -1;
	    if (potentialEdge.id[0] == "h") {
	        console.log("edge is horiz");
	        // Check if h edge below is already in tunnel
	        var edgeBelowId = Number(potentialEdge.id.slice(1)) + boardSize;
	        var edgeBelow = "h" + edgeBelowId;
	        if (edgeBelow in tunnel.edges) {
	            console.log("can't add this horiz edge because will cause box");
	            tunnel.removeEdge(potentialEdge);
	            tunnel.removeNode(currNode);
	            return false;
	        }
	        neededToEnd = boardSize - rowNum;
	    } else {
	        if (newNodeId > currNodeId) { //edge is going down
	            console.log("edge is v going down")
	            neededToEnd = (boardSize - rowNum) - 1;
	        } else {
	            console.log("edge is v going up");
	            // console.log("so for now returning false");
	            // return false;
	            // can't go up on the edges
	            var potEdgeIdNum = Number(potentialEdge.id.slice(1));
	            if(potEdgeIdNum % (boardSize + 1) == 0 || potEdgeIdNum % (boardSize + 1) == boardSize) {
	                console.log("can't go up on an outside edge");
	                tunnel.removeEdge(potentialEdge);
	                tunnel.removeNode(currNode);
	                return false;
	            }

	            neededToEnd = (boardSize - rowNum) + 1;
	        }
	    }
	    console.log("needed to end: " + neededToEnd);
	    console.log("======== done with check =========");
	    console.log();
	    tunnel.removeEdge(potentialEdge);
	    tunnel.removeNode(currNode);
	    return ((edgesLeft - neededToEnd) >= 0);

	    //if edge is vertical
	    //if edge is downward need (remaining pieces - (boardSize - rownum) - 1) >= 0
	    //else if upward need (remaining pieces - (boardSize - rownum) + 1) >= 0
	}

	function getRowNum(edge) {
	    var edgeId = Number(edge.id.slice(1));
	    if(edge.id[0] == "h") {
	        return Math.floor(edgeId / (boardSize));
	    } else {
	        return Math.floor(edgeId / (boardSize + 1));
	    }
	}

	function getRandomEdge(node, tunnel) {
	    // Given the tunnel and the current node
	    var nodeId = node.id;

	    var existingEdgeId;
	    if (nodeId in tunnel.nodes) {
	        var nodeFromTunnel = tunnel.nodes[nodeId];
	        existingEdgeId = nodeFromTunnel.edges[0];
	    } else {
	        existingEdgeId = "bad"
	    }

	    var potentialEdges = [];

	    for (var i = 0; i < node.edges.length; i++) {
	        if (node.edges[i].id != existingEdgeId) {
	            potentialEdges.push(node.edges[i]);
	        }
	    }

	    console.log("list of potential edge candidates for node " + nodeId);
	    for(var i = 0; i < potentialEdges.length; i++) {
	        console.log(potentialEdges[i].id);
	    }

	    var rand = potentialEdges[Math.floor(Math.random() * potentialEdges.length)];
	    return rand;
	}

	function Graph() {
	    this.nodes = {};
	    this.edges = {};
	    this.nodeIds = [];
	    this.edgeIds = [];

	    this.createGraph = function() {
	        console.log("!23")
	        for(var i = 0; i < ((boardSize+1)*(boardSize+1)); i++) {
	            var node = new Node(i);
	            this.nodes[i] = node;
	            this.nodeIds.push(i);
	            var horizontalEdgeIds = getHorizontalEdgesIds(i);
	            var verticalEdgeIds = getVerticalEdgesIds(i);

	            for(var j = 0; j < horizontalEdgeIds.length; j++) {
	                var edgeId = horizontalEdgeIds[j];
	                if (edgeId in this.edges) {
	                    // Add the node to the edge
	                    this.edges[edgeId].allNodes.push(node);
	                    node.addEdge(this.edges[edgeId]);
	                } else {
	                    // Create new edge and add it to edge object
	                    var edge = new Edge(null, null, edgeId);
	                    edge.allNodes.push(node);
	                    this.edges[edgeId] = edge;
	                    this.edgeIds.push(edgeId);
	                    node.addEdge(edge);
	                }
	            }

	            for (var j = 0; j < verticalEdgeIds.length; j++) {
	                var edgeId = verticalEdgeIds[j];
	                if (edgeId in this.edges) {
	                    // Add the node to it
	                    this.edges[edgeId].allNodes.push(node);
	                    node.addEdge(this.edges[edgeId]);
	                } else {
	                    // Create new edge
	                    var edge = new Edge(null, null, edgeId);
	                    edge.allNodes.push(node);
	                    this.edges[edgeId] = edge;
	                    this.edgeIds.push(edgeId);
	                    node.addEdge(this.edges[edgeId]);
	                }
	            }
	        }
	        console.log("nodes");
	        for (var n in this.nodes) {
	            console.log("" + this.nodes[n]);
	        }
	        console.log("edges");
	        for (var e in this.edges) {
	            console.log("" + this.edges[e]);
	        }
	    }
	}

	function getHorizontalEdgesIds(i) {
	    var horizontalEdgeIds = [];

	    // console.log("getting horizontal edges for node " + i);

	    // Create left and right edges
	    var rowNum = Math.floor(i / (boardSize + 1));
	    var leftEdge = i - (rowNum + 1);
	    var rightEdge = i - rowNum;
	    var leftEdgeId = "h" + leftEdge;
	    var rightEdgeId = "h" + rightEdge;

	    // console.log("row num: " + rowNum);
	    // console.log("left edge: " + leftEdge);
	    // console.log("right edge: " + rightEdge);

	    // If on left border, only has right edge
	    if (i % (boardSize + 1) == 0) {
	        // console.log("on left border");
	        leftEdgeId = null;
	    }

	    // If on right border only has left edge
	    if (i % (boardSize + 1) == 6) {
	        // console.log("on right border");
	        rightEdgeId = null;
	    }

	    // Add non null edges
	    if (leftEdgeId != null) {
	        horizontalEdgeIds.push(leftEdgeId);
	    }

	    if (rightEdgeId != null) {
	        horizontalEdgeIds.push(rightEdgeId);
	    }

	    // console.log("final result: " , horizontalEdgeIds);
	    return horizontalEdgeIds;
	}

	function getVerticalEdgesIds(i) {
	    var verticalEdgeIds = [];
	    // console.log("getting vertical edges for node " + i);

	    // If on the first row only has a down edge
	    if (i <= boardSize) {
	        // console.log("on first row");
	        var edgeId = "v" + i;
	        verticalEdgeIds.push(edgeId);
	        return verticalEdgeIds;
	    }

	    // If on the bottom row only has an up edge
	    if (i >= (boardSize * (boardSize + 1))) {
	        // console.log("on bottom row");
	        var upEdgeIdNum = i - (boardSize + 1);
	        var upEdgeId = "v" + upEdgeIdNum;
	        verticalEdgeIds.push(upEdgeId);
	        return verticalEdgeIds;
	    }

	    // Else has both edges
	    var downEdgeId = "v" + i;
	    var upEdgeIdNum = i - (boardSize + 1);
	    var upEdgeId = "v" + upEdgeIdNum;
	    verticalEdgeIds.push(downEdgeId);
	    verticalEdgeIds.push(upEdgeId);
	    // console.log("final result: ", verticalEdgeIds);
	    return verticalEdgeIds;
	}

	function edgeIsHorizontal(edge) {
	    var edgeId = edge.id;
	    var dir = edgeId.slice(0,1);
	    if (dir == "h") {
	        return true;
	    } else {
	        return false;
	    }
	}


	// Add button event listeners

	// Start game in normal mode
	document.getElementById('start').addEventListener('click', startGameInRegularMode, false);

	// Start game in easy mode
	document.getElementById('startEasy').addEventListener('click', startGameInEasyMode, false);

	// Start game with AI
	document.getElementById('startAI').addEventListener('click', startGameAI, false);

	// Start game with AI in easy mode
	document.getElementById('startEasyAI').addEventListener('click', startGameEasyAI, false);

	document.getElementById('tunnelDone').addEventListener('click', doneAddingTunnels, false);

	document.getElementById('probesPlaced1').addEventListener('click', doneAddingProbes, false);

	document.getElementById('probesPlaced2').addEventListener('click', doneAddingProbes, false);

	document.getElementById('submitGuess').addEventListener('click', submitGuess, false);



/***/ },
/* 5 */
/***/ function(module, exports) {

	for(var i = 0; i < edges.length; i++){
	    edges[i].addEventListener('click', edgeClicked, false);
	}



	/**
	 * Created by yaoyuanliu on 11/22/16.
	 */


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * jQuery JavaScript Library v3.1.1
	 * https://jquery.com/
	 *
	 * Includes Sizzle.js
	 * https://sizzlejs.com/
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license
	 * https://jquery.org/license
	 *
	 * Date: 2016-09-22T22:30Z
	 */
	( function( global, factory ) {

		"use strict";

		if ( typeof module === "object" && typeof module.exports === "object" ) {

			// For CommonJS and CommonJS-like environments where a proper `window`
			// is present, execute the factory and get jQuery.
			// For environments that do not have a `window` with a `document`
			// (such as Node.js), expose a factory as module.exports.
			// This accentuates the need for the creation of a real `window`.
			// e.g. var jQuery = require("jquery")(window);
			// See ticket #14549 for more info.
			module.exports = global.document ?
				factory( global, true ) :
				function( w ) {
					if ( !w.document ) {
						throw new Error( "jQuery requires a window with a document" );
					}
					return factory( w );
				};
		} else {
			factory( global );
		}

	// Pass this if window is not defined yet
	} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

	// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
	// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
	// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
	// enough that all such attempts are guarded in a try block.
	"use strict";

	var arr = [];

	var document = window.document;

	var getProto = Object.getPrototypeOf;

	var slice = arr.slice;

	var concat = arr.concat;

	var push = arr.push;

	var indexOf = arr.indexOf;

	var class2type = {};

	var toString = class2type.toString;

	var hasOwn = class2type.hasOwnProperty;

	var fnToString = hasOwn.toString;

	var ObjectFunctionString = fnToString.call( Object );

	var support = {};



		function DOMEval( code, doc ) {
			doc = doc || document;

			var script = doc.createElement( "script" );

			script.text = code;
			doc.head.appendChild( script ).parentNode.removeChild( script );
		}
	/* global Symbol */
	// Defining this global in .eslintrc.json would create a danger of using the global
	// unguarded in another place, it seems safer to define global only for this module



	var
		version = "3.1.1",

		// Define a local copy of jQuery
		jQuery = function( selector, context ) {

			// The jQuery object is actually just the init constructor 'enhanced'
			// Need init if jQuery is called (just allow error to be thrown if not included)
			return new jQuery.fn.init( selector, context );
		},

		// Support: Android <=4.0 only
		// Make sure we trim BOM and NBSP
		rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

		// Matches dashed string for camelizing
		rmsPrefix = /^-ms-/,
		rdashAlpha = /-([a-z])/g,

		// Used by jQuery.camelCase as callback to replace()
		fcamelCase = function( all, letter ) {
			return letter.toUpperCase();
		};

	jQuery.fn = jQuery.prototype = {

		// The current version of jQuery being used
		jquery: version,

		constructor: jQuery,

		// The default length of a jQuery object is 0
		length: 0,

		toArray: function() {
			return slice.call( this );
		},

		// Get the Nth element in the matched element set OR
		// Get the whole matched element set as a clean array
		get: function( num ) {

			// Return all the elements in a clean array
			if ( num == null ) {
				return slice.call( this );
			}

			// Return just the one element from the set
			return num < 0 ? this[ num + this.length ] : this[ num ];
		},

		// Take an array of elements and push it onto the stack
		// (returning the new matched element set)
		pushStack: function( elems ) {

			// Build a new jQuery matched element set
			var ret = jQuery.merge( this.constructor(), elems );

			// Add the old object onto the stack (as a reference)
			ret.prevObject = this;

			// Return the newly-formed element set
			return ret;
		},

		// Execute a callback for every element in the matched set.
		each: function( callback ) {
			return jQuery.each( this, callback );
		},

		map: function( callback ) {
			return this.pushStack( jQuery.map( this, function( elem, i ) {
				return callback.call( elem, i, elem );
			} ) );
		},

		slice: function() {
			return this.pushStack( slice.apply( this, arguments ) );
		},

		first: function() {
			return this.eq( 0 );
		},

		last: function() {
			return this.eq( -1 );
		},

		eq: function( i ) {
			var len = this.length,
				j = +i + ( i < 0 ? len : 0 );
			return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
		},

		end: function() {
			return this.prevObject || this.constructor();
		},

		// For internal use only.
		// Behaves like an Array's method, not like a jQuery method.
		push: push,
		sort: arr.sort,
		splice: arr.splice
	};

	jQuery.extend = jQuery.fn.extend = function() {
		var options, name, src, copy, copyIsArray, clone,
			target = arguments[ 0 ] || {},
			i = 1,
			length = arguments.length,
			deep = false;

		// Handle a deep copy situation
		if ( typeof target === "boolean" ) {
			deep = target;

			// Skip the boolean and the target
			target = arguments[ i ] || {};
			i++;
		}

		// Handle case when target is a string or something (possible in deep copy)
		if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {
			target = {};
		}

		// Extend jQuery itself if only one argument is passed
		if ( i === length ) {
			target = this;
			i--;
		}

		for ( ; i < length; i++ ) {

			// Only deal with non-null/undefined values
			if ( ( options = arguments[ i ] ) != null ) {

				// Extend the base object
				for ( name in options ) {
					src = target[ name ];
					copy = options[ name ];

					// Prevent never-ending loop
					if ( target === copy ) {
						continue;
					}

					// Recurse if we're merging plain objects or arrays
					if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
						( copyIsArray = jQuery.isArray( copy ) ) ) ) {

						if ( copyIsArray ) {
							copyIsArray = false;
							clone = src && jQuery.isArray( src ) ? src : [];

						} else {
							clone = src && jQuery.isPlainObject( src ) ? src : {};
						}

						// Never move original objects, clone them
						target[ name ] = jQuery.extend( deep, clone, copy );

					// Don't bring in undefined values
					} else if ( copy !== undefined ) {
						target[ name ] = copy;
					}
				}
			}
		}

		// Return the modified object
		return target;
	};

	jQuery.extend( {

		// Unique for each copy of jQuery on the page
		expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

		// Assume jQuery is ready without the ready module
		isReady: true,

		error: function( msg ) {
			throw new Error( msg );
		},

		noop: function() {},

		isFunction: function( obj ) {
			return jQuery.type( obj ) === "function";
		},

		isArray: Array.isArray,

		isWindow: function( obj ) {
			return obj != null && obj === obj.window;
		},

		isNumeric: function( obj ) {

			// As of jQuery 3.0, isNumeric is limited to
			// strings and numbers (primitives or objects)
			// that can be coerced to finite numbers (gh-2662)
			var type = jQuery.type( obj );
			return ( type === "number" || type === "string" ) &&

				// parseFloat NaNs numeric-cast false positives ("")
				// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
				// subtraction forces infinities to NaN
				!isNaN( obj - parseFloat( obj ) );
		},

		isPlainObject: function( obj ) {
			var proto, Ctor;

			// Detect obvious negatives
			// Use toString instead of jQuery.type to catch host objects
			if ( !obj || toString.call( obj ) !== "[object Object]" ) {
				return false;
			}

			proto = getProto( obj );

			// Objects with no prototype (e.g., `Object.create( null )`) are plain
			if ( !proto ) {
				return true;
			}

			// Objects with prototype are plain iff they were constructed by a global Object function
			Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
			return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
		},

		isEmptyObject: function( obj ) {

			/* eslint-disable no-unused-vars */
			// See https://github.com/eslint/eslint/issues/6125
			var name;

			for ( name in obj ) {
				return false;
			}
			return true;
		},

		type: function( obj ) {
			if ( obj == null ) {
				return obj + "";
			}

			// Support: Android <=2.3 only (functionish RegExp)
			return typeof obj === "object" || typeof obj === "function" ?
				class2type[ toString.call( obj ) ] || "object" :
				typeof obj;
		},

		// Evaluates a script in a global context
		globalEval: function( code ) {
			DOMEval( code );
		},

		// Convert dashed to camelCase; used by the css and data modules
		// Support: IE <=9 - 11, Edge 12 - 13
		// Microsoft forgot to hump their vendor prefix (#9572)
		camelCase: function( string ) {
			return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
		},

		nodeName: function( elem, name ) {
			return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
		},

		each: function( obj, callback ) {
			var length, i = 0;

			if ( isArrayLike( obj ) ) {
				length = obj.length;
				for ( ; i < length; i++ ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			}

			return obj;
		},

		// Support: Android <=4.0 only
		trim: function( text ) {
			return text == null ?
				"" :
				( text + "" ).replace( rtrim, "" );
		},

		// results is for internal usage only
		makeArray: function( arr, results ) {
			var ret = results || [];

			if ( arr != null ) {
				if ( isArrayLike( Object( arr ) ) ) {
					jQuery.merge( ret,
						typeof arr === "string" ?
						[ arr ] : arr
					);
				} else {
					push.call( ret, arr );
				}
			}

			return ret;
		},

		inArray: function( elem, arr, i ) {
			return arr == null ? -1 : indexOf.call( arr, elem, i );
		},

		// Support: Android <=4.0 only, PhantomJS 1 only
		// push.apply(_, arraylike) throws on ancient WebKit
		merge: function( first, second ) {
			var len = +second.length,
				j = 0,
				i = first.length;

			for ( ; j < len; j++ ) {
				first[ i++ ] = second[ j ];
			}

			first.length = i;

			return first;
		},

		grep: function( elems, callback, invert ) {
			var callbackInverse,
				matches = [],
				i = 0,
				length = elems.length,
				callbackExpect = !invert;

			// Go through the array, only saving the items
			// that pass the validator function
			for ( ; i < length; i++ ) {
				callbackInverse = !callback( elems[ i ], i );
				if ( callbackInverse !== callbackExpect ) {
					matches.push( elems[ i ] );
				}
			}

			return matches;
		},

		// arg is for internal usage only
		map: function( elems, callback, arg ) {
			var length, value,
				i = 0,
				ret = [];

			// Go through the array, translating each of the items to their new values
			if ( isArrayLike( elems ) ) {
				length = elems.length;
				for ( ; i < length; i++ ) {
					value = callback( elems[ i ], i, arg );

					if ( value != null ) {
						ret.push( value );
					}
				}

			// Go through every key on the object,
			} else {
				for ( i in elems ) {
					value = callback( elems[ i ], i, arg );

					if ( value != null ) {
						ret.push( value );
					}
				}
			}

			// Flatten any nested arrays
			return concat.apply( [], ret );
		},

		// A global GUID counter for objects
		guid: 1,

		// Bind a function to a context, optionally partially applying any
		// arguments.
		proxy: function( fn, context ) {
			var tmp, args, proxy;

			if ( typeof context === "string" ) {
				tmp = fn[ context ];
				context = fn;
				fn = tmp;
			}

			// Quick check to determine if target is callable, in the spec
			// this throws a TypeError, but we will just return undefined.
			if ( !jQuery.isFunction( fn ) ) {
				return undefined;
			}

			// Simulated bind
			args = slice.call( arguments, 2 );
			proxy = function() {
				return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
			};

			// Set the guid of unique handler to the same of original handler, so it can be removed
			proxy.guid = fn.guid = fn.guid || jQuery.guid++;

			return proxy;
		},

		now: Date.now,

		// jQuery.support is not used in Core but other projects attach their
		// properties to it so it needs to exist.
		support: support
	} );

	if ( typeof Symbol === "function" ) {
		jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
	}

	// Populate the class2type map
	jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
	function( i, name ) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	} );

	function isArrayLike( obj ) {

		// Support: real iOS 8.2 only (not reproducible in simulator)
		// `in` check used to prevent JIT error (gh-2145)
		// hasOwn isn't used here due to false negatives
		// regarding Nodelist length in IE
		var length = !!obj && "length" in obj && obj.length,
			type = jQuery.type( obj );

		if ( type === "function" || jQuery.isWindow( obj ) ) {
			return false;
		}

		return type === "array" || length === 0 ||
			typeof length === "number" && length > 0 && ( length - 1 ) in obj;
	}
	var Sizzle =
	/*!
	 * Sizzle CSS Selector Engine v2.3.3
	 * https://sizzlejs.com/
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2016-08-08
	 */
	(function( window ) {

	var i,
		support,
		Expr,
		getText,
		isXML,
		tokenize,
		compile,
		select,
		outermostContext,
		sortInput,
		hasDuplicate,

		// Local document vars
		setDocument,
		document,
		docElem,
		documentIsHTML,
		rbuggyQSA,
		rbuggyMatches,
		matches,
		contains,

		// Instance-specific data
		expando = "sizzle" + 1 * new Date(),
		preferredDoc = window.document,
		dirruns = 0,
		done = 0,
		classCache = createCache(),
		tokenCache = createCache(),
		compilerCache = createCache(),
		sortOrder = function( a, b ) {
			if ( a === b ) {
				hasDuplicate = true;
			}
			return 0;
		},

		// Instance methods
		hasOwn = ({}).hasOwnProperty,
		arr = [],
		pop = arr.pop,
		push_native = arr.push,
		push = arr.push,
		slice = arr.slice,
		// Use a stripped-down indexOf as it's faster than native
		// https://jsperf.com/thor-indexof-vs-for/5
		indexOf = function( list, elem ) {
			var i = 0,
				len = list.length;
			for ( ; i < len; i++ ) {
				if ( list[i] === elem ) {
					return i;
				}
			}
			return -1;
		},

		booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

		// Regular expressions

		// http://www.w3.org/TR/css3-selectors/#whitespace
		whitespace = "[\\x20\\t\\r\\n\\f]",

		// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
		identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

		// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
		attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
			// Operator (capture 2)
			"*([*^$|!~]?=)" + whitespace +
			// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
			"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
			"*\\]",

		pseudos = ":(" + identifier + ")(?:\\((" +
			// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
			// 1. quoted (capture 3; capture 4 or capture 5)
			"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
			// 2. simple (capture 6)
			"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
			// 3. anything else (capture 2)
			".*" +
			")\\)|)",

		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
		rwhitespace = new RegExp( whitespace + "+", "g" ),
		rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

		rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
		rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

		rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

		rpseudo = new RegExp( pseudos ),
		ridentifier = new RegExp( "^" + identifier + "$" ),

		matchExpr = {
			"ID": new RegExp( "^#(" + identifier + ")" ),
			"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
			"TAG": new RegExp( "^(" + identifier + "|[*])" ),
			"ATTR": new RegExp( "^" + attributes ),
			"PSEUDO": new RegExp( "^" + pseudos ),
			"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
				"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
				"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
			"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
			// For use in libraries implementing .is()
			// We use this for POS matching in `select`
			"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
				whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
		},

		rinputs = /^(?:input|select|textarea|button)$/i,
		rheader = /^h\d$/i,

		rnative = /^[^{]+\{\s*\[native \w/,

		// Easily-parseable/retrievable ID or TAG or CLASS selectors
		rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

		rsibling = /[+~]/,

		// CSS escapes
		// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
		runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
		funescape = function( _, escaped, escapedWhitespace ) {
			var high = "0x" + escaped - 0x10000;
			// NaN means non-codepoint
			// Support: Firefox<24
			// Workaround erroneous numeric interpretation of +"0x"
			return high !== high || escapedWhitespace ?
				escaped :
				high < 0 ?
					// BMP codepoint
					String.fromCharCode( high + 0x10000 ) :
					// Supplemental Plane codepoint (surrogate pair)
					String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
		},

		// CSS string/identifier serialization
		// https://drafts.csswg.org/cssom/#common-serializing-idioms
		rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
		fcssescape = function( ch, asCodePoint ) {
			if ( asCodePoint ) {

				// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
				if ( ch === "\0" ) {
					return "\uFFFD";
				}

				// Control characters and (dependent upon position) numbers get escaped as code points
				return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
			}

			// Other potentially-special ASCII characters get backslash-escaped
			return "\\" + ch;
		},

		// Used for iframes
		// See setDocument()
		// Removing the function wrapper causes a "Permission Denied"
		// error in IE
		unloadHandler = function() {
			setDocument();
		},

		disabledAncestor = addCombinator(
			function( elem ) {
				return elem.disabled === true && ("form" in elem || "label" in elem);
			},
			{ dir: "parentNode", next: "legend" }
		);

	// Optimize for push.apply( _, NodeList )
	try {
		push.apply(
			(arr = slice.call( preferredDoc.childNodes )),
			preferredDoc.childNodes
		);
		// Support: Android<4.0
		// Detect silently failing push.apply
		arr[ preferredDoc.childNodes.length ].nodeType;
	} catch ( e ) {
		push = { apply: arr.length ?

			// Leverage slice if possible
			function( target, els ) {
				push_native.apply( target, slice.call(els) );
			} :

			// Support: IE<9
			// Otherwise append directly
			function( target, els ) {
				var j = target.length,
					i = 0;
				// Can't trust NodeList.length
				while ( (target[j++] = els[i++]) ) {}
				target.length = j - 1;
			}
		};
	}

	function Sizzle( selector, context, results, seed ) {
		var m, i, elem, nid, match, groups, newSelector,
			newContext = context && context.ownerDocument,

			// nodeType defaults to 9, since context defaults to document
			nodeType = context ? context.nodeType : 9;

		results = results || [];

		// Return early from calls with invalid selector or context
		if ( typeof selector !== "string" || !selector ||
			nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

			return results;
		}

		// Try to shortcut find operations (as opposed to filters) in HTML documents
		if ( !seed ) {

			if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
				setDocument( context );
			}
			context = context || document;

			if ( documentIsHTML ) {

				// If the selector is sufficiently simple, try using a "get*By*" DOM method
				// (excepting DocumentFragment context, where the methods don't exist)
				if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

					// ID selector
					if ( (m = match[1]) ) {

						// Document context
						if ( nodeType === 9 ) {
							if ( (elem = context.getElementById( m )) ) {

								// Support: IE, Opera, Webkit
								// TODO: identify versions
								// getElementById can match elements by name instead of ID
								if ( elem.id === m ) {
									results.push( elem );
									return results;
								}
							} else {
								return results;
							}

						// Element context
						} else {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( newContext && (elem = newContext.getElementById( m )) &&
								contains( context, elem ) &&
								elem.id === m ) {

								results.push( elem );
								return results;
							}
						}

					// Type selector
					} else if ( match[2] ) {
						push.apply( results, context.getElementsByTagName( selector ) );
						return results;

					// Class selector
					} else if ( (m = match[3]) && support.getElementsByClassName &&
						context.getElementsByClassName ) {

						push.apply( results, context.getElementsByClassName( m ) );
						return results;
					}
				}

				// Take advantage of querySelectorAll
				if ( support.qsa &&
					!compilerCache[ selector + " " ] &&
					(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

					if ( nodeType !== 1 ) {
						newContext = context;
						newSelector = selector;

					// qSA looks outside Element context, which is not what we want
					// Thanks to Andrew Dupont for this workaround technique
					// Support: IE <=8
					// Exclude object elements
					} else if ( context.nodeName.toLowerCase() !== "object" ) {

						// Capture the context ID, setting it first if necessary
						if ( (nid = context.getAttribute( "id" )) ) {
							nid = nid.replace( rcssescape, fcssescape );
						} else {
							context.setAttribute( "id", (nid = expando) );
						}

						// Prefix every selector in the list
						groups = tokenize( selector );
						i = groups.length;
						while ( i-- ) {
							groups[i] = "#" + nid + " " + toSelector( groups[i] );
						}
						newSelector = groups.join( "," );

						// Expand context for sibling selectors
						newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
							context;
					}

					if ( newSelector ) {
						try {
							push.apply( results,
								newContext.querySelectorAll( newSelector )
							);
							return results;
						} catch ( qsaError ) {
						} finally {
							if ( nid === expando ) {
								context.removeAttribute( "id" );
							}
						}
					}
				}
			}
		}

		// All others
		return select( selector.replace( rtrim, "$1" ), context, results, seed );
	}

	/**
	 * Create key-value caches of limited size
	 * @returns {function(string, object)} Returns the Object data after storing it on itself with
	 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
	 *	deleting the oldest entry
	 */
	function createCache() {
		var keys = [];

		function cache( key, value ) {
			// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
			if ( keys.push( key + " " ) > Expr.cacheLength ) {
				// Only keep the most recent entries
				delete cache[ keys.shift() ];
			}
			return (cache[ key + " " ] = value);
		}
		return cache;
	}

	/**
	 * Mark a function for special use by Sizzle
	 * @param {Function} fn The function to mark
	 */
	function markFunction( fn ) {
		fn[ expando ] = true;
		return fn;
	}

	/**
	 * Support testing using an element
	 * @param {Function} fn Passed the created element and returns a boolean result
	 */
	function assert( fn ) {
		var el = document.createElement("fieldset");

		try {
			return !!fn( el );
		} catch (e) {
			return false;
		} finally {
			// Remove from its parent by default
			if ( el.parentNode ) {
				el.parentNode.removeChild( el );
			}
			// release memory in IE
			el = null;
		}
	}

	/**
	 * Adds the same handler for all of the specified attrs
	 * @param {String} attrs Pipe-separated list of attributes
	 * @param {Function} handler The method that will be applied
	 */
	function addHandle( attrs, handler ) {
		var arr = attrs.split("|"),
			i = arr.length;

		while ( i-- ) {
			Expr.attrHandle[ arr[i] ] = handler;
		}
	}

	/**
	 * Checks document order of two siblings
	 * @param {Element} a
	 * @param {Element} b
	 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
	 */
	function siblingCheck( a, b ) {
		var cur = b && a,
			diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
				a.sourceIndex - b.sourceIndex;

		// Use IE sourceIndex if available on both nodes
		if ( diff ) {
			return diff;
		}

		// Check if b follows a
		if ( cur ) {
			while ( (cur = cur.nextSibling) ) {
				if ( cur === b ) {
					return -1;
				}
			}
		}

		return a ? 1 : -1;
	}

	/**
	 * Returns a function to use in pseudos for input types
	 * @param {String} type
	 */
	function createInputPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === type;
		};
	}

	/**
	 * Returns a function to use in pseudos for buttons
	 * @param {String} type
	 */
	function createButtonPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && elem.type === type;
		};
	}

	/**
	 * Returns a function to use in pseudos for :enabled/:disabled
	 * @param {Boolean} disabled true for :disabled; false for :enabled
	 */
	function createDisabledPseudo( disabled ) {

		// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
		return function( elem ) {

			// Only certain elements can match :enabled or :disabled
			// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
			// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
			if ( "form" in elem ) {

				// Check for inherited disabledness on relevant non-disabled elements:
				// * listed form-associated elements in a disabled fieldset
				//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
				//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
				// * option elements in a disabled optgroup
				//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
				// All such elements have a "form" property.
				if ( elem.parentNode && elem.disabled === false ) {

					// Option elements defer to a parent optgroup if present
					if ( "label" in elem ) {
						if ( "label" in elem.parentNode ) {
							return elem.parentNode.disabled === disabled;
						} else {
							return elem.disabled === disabled;
						}
					}

					// Support: IE 6 - 11
					// Use the isDisabled shortcut property to check for disabled fieldset ancestors
					return elem.isDisabled === disabled ||

						// Where there is no isDisabled, check manually
						/* jshint -W018 */
						elem.isDisabled !== !disabled &&
							disabledAncestor( elem ) === disabled;
				}

				return elem.disabled === disabled;

			// Try to winnow out elements that can't be disabled before trusting the disabled property.
			// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
			// even exist on them, let alone have a boolean value.
			} else if ( "label" in elem ) {
				return elem.disabled === disabled;
			}

			// Remaining elements are neither :enabled nor :disabled
			return false;
		};
	}

	/**
	 * Returns a function to use in pseudos for positionals
	 * @param {Function} fn
	 */
	function createPositionalPseudo( fn ) {
		return markFunction(function( argument ) {
			argument = +argument;
			return markFunction(function( seed, matches ) {
				var j,
					matchIndexes = fn( [], seed.length, argument ),
					i = matchIndexes.length;

				// Match elements found at the specified indexes
				while ( i-- ) {
					if ( seed[ (j = matchIndexes[i]) ] ) {
						seed[j] = !(matches[j] = seed[j]);
					}
				}
			});
		});
	}

	/**
	 * Checks a node for validity as a Sizzle context
	 * @param {Element|Object=} context
	 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
	 */
	function testContext( context ) {
		return context && typeof context.getElementsByTagName !== "undefined" && context;
	}

	// Expose support vars for convenience
	support = Sizzle.support = {};

	/**
	 * Detects XML nodes
	 * @param {Element|Object} elem An element or a document
	 * @returns {Boolean} True iff elem is a non-HTML XML node
	 */
	isXML = Sizzle.isXML = function( elem ) {
		// documentElement is verified for cases where it doesn't yet exist
		// (such as loading iframes in IE - #4833)
		var documentElement = elem && (elem.ownerDocument || elem).documentElement;
		return documentElement ? documentElement.nodeName !== "HTML" : false;
	};

	/**
	 * Sets document-related variables once based on the current document
	 * @param {Element|Object} [doc] An element or document object to use to set the document
	 * @returns {Object} Returns the current document
	 */
	setDocument = Sizzle.setDocument = function( node ) {
		var hasCompare, subWindow,
			doc = node ? node.ownerDocument || node : preferredDoc;

		// Return early if doc is invalid or already selected
		if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
			return document;
		}

		// Update global variables
		document = doc;
		docElem = document.documentElement;
		documentIsHTML = !isXML( document );

		// Support: IE 9-11, Edge
		// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
		if ( preferredDoc !== document &&
			(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

			// Support: IE 11, Edge
			if ( subWindow.addEventListener ) {
				subWindow.addEventListener( "unload", unloadHandler, false );

			// Support: IE 9 - 10 only
			} else if ( subWindow.attachEvent ) {
				subWindow.attachEvent( "onunload", unloadHandler );
			}
		}

		/* Attributes
		---------------------------------------------------------------------- */

		// Support: IE<8
		// Verify that getAttribute really returns attributes and not properties
		// (excepting IE8 booleans)
		support.attributes = assert(function( el ) {
			el.className = "i";
			return !el.getAttribute("className");
		});

		/* getElement(s)By*
		---------------------------------------------------------------------- */

		// Check if getElementsByTagName("*") returns only elements
		support.getElementsByTagName = assert(function( el ) {
			el.appendChild( document.createComment("") );
			return !el.getElementsByTagName("*").length;
		});

		// Support: IE<9
		support.getElementsByClassName = rnative.test( document.getElementsByClassName );

		// Support: IE<10
		// Check if getElementById returns elements by name
		// The broken getElementById methods don't pick up programmatically-set names,
		// so use a roundabout getElementsByName test
		support.getById = assert(function( el ) {
			docElem.appendChild( el ).id = expando;
			return !document.getElementsByName || !document.getElementsByName( expando ).length;
		});

		// ID filter and find
		if ( support.getById ) {
			Expr.filter["ID"] = function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					return elem.getAttribute("id") === attrId;
				};
			};
			Expr.find["ID"] = function( id, context ) {
				if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
					var elem = context.getElementById( id );
					return elem ? [ elem ] : [];
				}
			};
		} else {
			Expr.filter["ID"] =  function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					var node = typeof elem.getAttributeNode !== "undefined" &&
						elem.getAttributeNode("id");
					return node && node.value === attrId;
				};
			};

			// Support: IE 6 - 7 only
			// getElementById is not reliable as a find shortcut
			Expr.find["ID"] = function( id, context ) {
				if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
					var node, i, elems,
						elem = context.getElementById( id );

					if ( elem ) {

						// Verify the id attribute
						node = elem.getAttributeNode("id");
						if ( node && node.value === id ) {
							return [ elem ];
						}

						// Fall back on getElementsByName
						elems = context.getElementsByName( id );
						i = 0;
						while ( (elem = elems[i++]) ) {
							node = elem.getAttributeNode("id");
							if ( node && node.value === id ) {
								return [ elem ];
							}
						}
					}

					return [];
				}
			};
		}

		// Tag
		Expr.find["TAG"] = support.getElementsByTagName ?
			function( tag, context ) {
				if ( typeof context.getElementsByTagName !== "undefined" ) {
					return context.getElementsByTagName( tag );

				// DocumentFragment nodes don't have gEBTN
				} else if ( support.qsa ) {
					return context.querySelectorAll( tag );
				}
			} :

			function( tag, context ) {
				var elem,
					tmp = [],
					i = 0,
					// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
					results = context.getElementsByTagName( tag );

				// Filter out possible comments
				if ( tag === "*" ) {
					while ( (elem = results[i++]) ) {
						if ( elem.nodeType === 1 ) {
							tmp.push( elem );
						}
					}

					return tmp;
				}
				return results;
			};

		// Class
		Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
			if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
				return context.getElementsByClassName( className );
			}
		};

		/* QSA/matchesSelector
		---------------------------------------------------------------------- */

		// QSA and matchesSelector support

		// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
		rbuggyMatches = [];

		// qSa(:focus) reports false when true (Chrome 21)
		// We allow this because of a bug in IE8/9 that throws an error
		// whenever `document.activeElement` is accessed on an iframe
		// So, we allow :focus to pass through QSA all the time to avoid the IE error
		// See https://bugs.jquery.com/ticket/13378
		rbuggyQSA = [];

		if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
			// Build QSA regex
			// Regex strategy adopted from Diego Perini
			assert(function( el ) {
				// Select is set to empty string on purpose
				// This is to test IE's treatment of not explicitly
				// setting a boolean content attribute,
				// since its presence should be enough
				// https://bugs.jquery.com/ticket/12359
				docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
					"<select id='" + expando + "-\r\\' msallowcapture=''>" +
					"<option selected=''></option></select>";

				// Support: IE8, Opera 11-12.16
				// Nothing should be selected when empty strings follow ^= or $= or *=
				// The test attribute must be unknown in Opera but "safe" for WinRT
				// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
				if ( el.querySelectorAll("[msallowcapture^='']").length ) {
					rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
				}

				// Support: IE8
				// Boolean attributes and "value" are not treated correctly
				if ( !el.querySelectorAll("[selected]").length ) {
					rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
				}

				// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
				if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
					rbuggyQSA.push("~=");
				}

				// Webkit/Opera - :checked should return selected option elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				// IE8 throws error here and will not see later tests
				if ( !el.querySelectorAll(":checked").length ) {
					rbuggyQSA.push(":checked");
				}

				// Support: Safari 8+, iOS 8+
				// https://bugs.webkit.org/show_bug.cgi?id=136851
				// In-page `selector#id sibling-combinator selector` fails
				if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
					rbuggyQSA.push(".#.+[+~]");
				}
			});

			assert(function( el ) {
				el.innerHTML = "<a href='' disabled='disabled'></a>" +
					"<select disabled='disabled'><option/></select>";

				// Support: Windows 8 Native Apps
				// The type and name attributes are restricted during .innerHTML assignment
				var input = document.createElement("input");
				input.setAttribute( "type", "hidden" );
				el.appendChild( input ).setAttribute( "name", "D" );

				// Support: IE8
				// Enforce case-sensitivity of name attribute
				if ( el.querySelectorAll("[name=d]").length ) {
					rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
				}

				// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
				// IE8 throws error here and will not see later tests
				if ( el.querySelectorAll(":enabled").length !== 2 ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}

				// Support: IE9-11+
				// IE's :disabled selector does not pick up the children of disabled fieldsets
				docElem.appendChild( el ).disabled = true;
				if ( el.querySelectorAll(":disabled").length !== 2 ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}

				// Opera 10-11 does not throw on post-comma invalid pseudos
				el.querySelectorAll("*,:x");
				rbuggyQSA.push(",.*:");
			});
		}

		if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
			docElem.webkitMatchesSelector ||
			docElem.mozMatchesSelector ||
			docElem.oMatchesSelector ||
			docElem.msMatchesSelector) )) ) {

			assert(function( el ) {
				// Check to see if it's possible to do matchesSelector
				// on a disconnected node (IE 9)
				support.disconnectedMatch = matches.call( el, "*" );

				// This should fail with an exception
				// Gecko does not error, returns false instead
				matches.call( el, "[s!='']:x" );
				rbuggyMatches.push( "!=", pseudos );
			});
		}

		rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
		rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

		/* Contains
		---------------------------------------------------------------------- */
		hasCompare = rnative.test( docElem.compareDocumentPosition );

		// Element contains another
		// Purposefully self-exclusive
		// As in, an element does not contain itself
		contains = hasCompare || rnative.test( docElem.contains ) ?
			function( a, b ) {
				var adown = a.nodeType === 9 ? a.documentElement : a,
					bup = b && b.parentNode;
				return a === bup || !!( bup && bup.nodeType === 1 && (
					adown.contains ?
						adown.contains( bup ) :
						a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
				));
			} :
			function( a, b ) {
				if ( b ) {
					while ( (b = b.parentNode) ) {
						if ( b === a ) {
							return true;
						}
					}
				}
				return false;
			};

		/* Sorting
		---------------------------------------------------------------------- */

		// Document order sorting
		sortOrder = hasCompare ?
		function( a, b ) {

			// Flag for duplicate removal
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}

			// Sort on method existence if only one input has compareDocumentPosition
			var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
			if ( compare ) {
				return compare;
			}

			// Calculate position if both inputs belong to the same document
			compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
				a.compareDocumentPosition( b ) :

				// Otherwise we know they are disconnected
				1;

			// Disconnected nodes
			if ( compare & 1 ||
				(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

				// Choose the first element that is related to our preferred document
				if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
					return -1;
				}
				if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
					return 1;
				}

				// Maintain original order
				return sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;
			}

			return compare & 4 ? -1 : 1;
		} :
		function( a, b ) {
			// Exit early if the nodes are identical
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}

			var cur,
				i = 0,
				aup = a.parentNode,
				bup = b.parentNode,
				ap = [ a ],
				bp = [ b ];

			// Parentless nodes are either documents or disconnected
			if ( !aup || !bup ) {
				return a === document ? -1 :
					b === document ? 1 :
					aup ? -1 :
					bup ? 1 :
					sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;

			// If the nodes are siblings, we can do a quick check
			} else if ( aup === bup ) {
				return siblingCheck( a, b );
			}

			// Otherwise we need full lists of their ancestors for comparison
			cur = a;
			while ( (cur = cur.parentNode) ) {
				ap.unshift( cur );
			}
			cur = b;
			while ( (cur = cur.parentNode) ) {
				bp.unshift( cur );
			}

			// Walk down the tree looking for a discrepancy
			while ( ap[i] === bp[i] ) {
				i++;
			}

			return i ?
				// Do a sibling check if the nodes have a common ancestor
				siblingCheck( ap[i], bp[i] ) :

				// Otherwise nodes in our document sort first
				ap[i] === preferredDoc ? -1 :
				bp[i] === preferredDoc ? 1 :
				0;
		};

		return document;
	};

	Sizzle.matches = function( expr, elements ) {
		return Sizzle( expr, null, null, elements );
	};

	Sizzle.matchesSelector = function( elem, expr ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}

		// Make sure that attribute selectors are quoted
		expr = expr.replace( rattributeQuotes, "='$1']" );

		if ( support.matchesSelector && documentIsHTML &&
			!compilerCache[ expr + " " ] &&
			( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
			( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

			try {
				var ret = matches.call( elem, expr );

				// IE 9's matchesSelector returns false on disconnected nodes
				if ( ret || support.disconnectedMatch ||
						// As well, disconnected nodes are said to be in a document
						// fragment in IE 9
						elem.document && elem.document.nodeType !== 11 ) {
					return ret;
				}
			} catch (e) {}
		}

		return Sizzle( expr, document, null, [ elem ] ).length > 0;
	};

	Sizzle.contains = function( context, elem ) {
		// Set document vars if needed
		if ( ( context.ownerDocument || context ) !== document ) {
			setDocument( context );
		}
		return contains( context, elem );
	};

	Sizzle.attr = function( elem, name ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}

		var fn = Expr.attrHandle[ name.toLowerCase() ],
			// Don't get fooled by Object.prototype properties (jQuery #13807)
			val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
				fn( elem, name, !documentIsHTML ) :
				undefined;

		return val !== undefined ?
			val :
			support.attributes || !documentIsHTML ?
				elem.getAttribute( name ) :
				(val = elem.getAttributeNode(name)) && val.specified ?
					val.value :
					null;
	};

	Sizzle.escape = function( sel ) {
		return (sel + "").replace( rcssescape, fcssescape );
	};

	Sizzle.error = function( msg ) {
		throw new Error( "Syntax error, unrecognized expression: " + msg );
	};

	/**
	 * Document sorting and removing duplicates
	 * @param {ArrayLike} results
	 */
	Sizzle.uniqueSort = function( results ) {
		var elem,
			duplicates = [],
			j = 0,
			i = 0;

		// Unless we *know* we can detect duplicates, assume their presence
		hasDuplicate = !support.detectDuplicates;
		sortInput = !support.sortStable && results.slice( 0 );
		results.sort( sortOrder );

		if ( hasDuplicate ) {
			while ( (elem = results[i++]) ) {
				if ( elem === results[ i ] ) {
					j = duplicates.push( i );
				}
			}
			while ( j-- ) {
				results.splice( duplicates[ j ], 1 );
			}
		}

		// Clear input after sorting to release objects
		// See https://github.com/jquery/sizzle/pull/225
		sortInput = null;

		return results;
	};

	/**
	 * Utility function for retrieving the text value of an array of DOM nodes
	 * @param {Array|Element} elem
	 */
	getText = Sizzle.getText = function( elem ) {
		var node,
			ret = "",
			i = 0,
			nodeType = elem.nodeType;

		if ( !nodeType ) {
			// If no nodeType, this is expected to be an array
			while ( (node = elem[i++]) ) {
				// Do not traverse comment nodes
				ret += getText( node );
			}
		} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
			// Use textContent for elements
			// innerText usage removed for consistency of new lines (jQuery #11153)
			if ( typeof elem.textContent === "string" ) {
				return elem.textContent;
			} else {
				// Traverse its children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
		// Do not include comment or processing instruction nodes

		return ret;
	};

	Expr = Sizzle.selectors = {

		// Can be adjusted by the user
		cacheLength: 50,

		createPseudo: markFunction,

		match: matchExpr,

		attrHandle: {},

		find: {},

		relative: {
			">": { dir: "parentNode", first: true },
			" ": { dir: "parentNode" },
			"+": { dir: "previousSibling", first: true },
			"~": { dir: "previousSibling" }
		},

		preFilter: {
			"ATTR": function( match ) {
				match[1] = match[1].replace( runescape, funescape );

				// Move the given value to match[3] whether quoted or unquoted
				match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

				if ( match[2] === "~=" ) {
					match[3] = " " + match[3] + " ";
				}

				return match.slice( 0, 4 );
			},

			"CHILD": function( match ) {
				/* matches from matchExpr["CHILD"]
					1 type (only|nth|...)
					2 what (child|of-type)
					3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
					4 xn-component of xn+y argument ([+-]?\d*n|)
					5 sign of xn-component
					6 x of xn-component
					7 sign of y-component
					8 y of y-component
				*/
				match[1] = match[1].toLowerCase();

				if ( match[1].slice( 0, 3 ) === "nth" ) {
					// nth-* requires argument
					if ( !match[3] ) {
						Sizzle.error( match[0] );
					}

					// numeric x and y parameters for Expr.filter.CHILD
					// remember that false/true cast respectively to 0/1
					match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
					match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

				// other types prohibit arguments
				} else if ( match[3] ) {
					Sizzle.error( match[0] );
				}

				return match;
			},

			"PSEUDO": function( match ) {
				var excess,
					unquoted = !match[6] && match[2];

				if ( matchExpr["CHILD"].test( match[0] ) ) {
					return null;
				}

				// Accept quoted arguments as-is
				if ( match[3] ) {
					match[2] = match[4] || match[5] || "";

				// Strip excess characters from unquoted arguments
				} else if ( unquoted && rpseudo.test( unquoted ) &&
					// Get excess from tokenize (recursively)
					(excess = tokenize( unquoted, true )) &&
					// advance to the next closing parenthesis
					(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

					// excess is a negative index
					match[0] = match[0].slice( 0, excess );
					match[2] = unquoted.slice( 0, excess );
				}

				// Return only captures needed by the pseudo filter method (type and argument)
				return match.slice( 0, 3 );
			}
		},

		filter: {

			"TAG": function( nodeNameSelector ) {
				var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
				return nodeNameSelector === "*" ?
					function() { return true; } :
					function( elem ) {
						return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
					};
			},

			"CLASS": function( className ) {
				var pattern = classCache[ className + " " ];

				return pattern ||
					(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
					classCache( className, function( elem ) {
						return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
					});
			},

			"ATTR": function( name, operator, check ) {
				return function( elem ) {
					var result = Sizzle.attr( elem, name );

					if ( result == null ) {
						return operator === "!=";
					}
					if ( !operator ) {
						return true;
					}

					result += "";

					return operator === "=" ? result === check :
						operator === "!=" ? result !== check :
						operator === "^=" ? check && result.indexOf( check ) === 0 :
						operator === "*=" ? check && result.indexOf( check ) > -1 :
						operator === "$=" ? check && result.slice( -check.length ) === check :
						operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
						operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
						false;
				};
			},

			"CHILD": function( type, what, argument, first, last ) {
				var simple = type.slice( 0, 3 ) !== "nth",
					forward = type.slice( -4 ) !== "last",
					ofType = what === "of-type";

				return first === 1 && last === 0 ?

					// Shortcut for :nth-*(n)
					function( elem ) {
						return !!elem.parentNode;
					} :

					function( elem, context, xml ) {
						var cache, uniqueCache, outerCache, node, nodeIndex, start,
							dir = simple !== forward ? "nextSibling" : "previousSibling",
							parent = elem.parentNode,
							name = ofType && elem.nodeName.toLowerCase(),
							useCache = !xml && !ofType,
							diff = false;

						if ( parent ) {

							// :(first|last|only)-(child|of-type)
							if ( simple ) {
								while ( dir ) {
									node = elem;
									while ( (node = node[ dir ]) ) {
										if ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) {

											return false;
										}
									}
									// Reverse direction for :only-* (if we haven't yet done so)
									start = dir = type === "only" && !start && "nextSibling";
								}
								return true;
							}

							start = [ forward ? parent.firstChild : parent.lastChild ];

							// non-xml :nth-child(...) stores cache data on `parent`
							if ( forward && useCache ) {

								// Seek `elem` from a previously-cached index

								// ...in a gzip-friendly way
								node = parent;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex && cache[ 2 ];
								node = nodeIndex && parent.childNodes[ nodeIndex ];

								while ( (node = ++nodeIndex && node && node[ dir ] ||

									// Fallback to seeking `elem` from the start
									(diff = nodeIndex = 0) || start.pop()) ) {

									// When found, cache indexes on `parent` and break
									if ( node.nodeType === 1 && ++diff && node === elem ) {
										uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
										break;
									}
								}

							} else {
								// Use previously-cached element index if available
								if ( useCache ) {
									// ...in a gzip-friendly way
									node = elem;
									outerCache = node[ expando ] || (node[ expando ] = {});

									// Support: IE <9 only
									// Defend against cloned attroperties (jQuery gh-1709)
									uniqueCache = outerCache[ node.uniqueID ] ||
										(outerCache[ node.uniqueID ] = {});

									cache = uniqueCache[ type ] || [];
									nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
									diff = nodeIndex;
								}

								// xml :nth-child(...)
								// or :nth-last-child(...) or :nth(-last)?-of-type(...)
								if ( diff === false ) {
									// Use the same loop as above to seek `elem` from the start
									while ( (node = ++nodeIndex && node && node[ dir ] ||
										(diff = nodeIndex = 0) || start.pop()) ) {

										if ( ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) &&
											++diff ) {

											// Cache the index of each encountered element
											if ( useCache ) {
												outerCache = node[ expando ] || (node[ expando ] = {});

												// Support: IE <9 only
												// Defend against cloned attroperties (jQuery gh-1709)
												uniqueCache = outerCache[ node.uniqueID ] ||
													(outerCache[ node.uniqueID ] = {});

												uniqueCache[ type ] = [ dirruns, diff ];
											}

											if ( node === elem ) {
												break;
											}
										}
									}
								}
							}

							// Incorporate the offset, then check against cycle size
							diff -= last;
							return diff === first || ( diff % first === 0 && diff / first >= 0 );
						}
					};
			},

			"PSEUDO": function( pseudo, argument ) {
				// pseudo-class names are case-insensitive
				// http://www.w3.org/TR/selectors/#pseudo-classes
				// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
				// Remember that setFilters inherits from pseudos
				var args,
					fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
						Sizzle.error( "unsupported pseudo: " + pseudo );

				// The user may use createPseudo to indicate that
				// arguments are needed to create the filter function
				// just as Sizzle does
				if ( fn[ expando ] ) {
					return fn( argument );
				}

				// But maintain support for old signatures
				if ( fn.length > 1 ) {
					args = [ pseudo, pseudo, "", argument ];
					return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
						markFunction(function( seed, matches ) {
							var idx,
								matched = fn( seed, argument ),
								i = matched.length;
							while ( i-- ) {
								idx = indexOf( seed, matched[i] );
								seed[ idx ] = !( matches[ idx ] = matched[i] );
							}
						}) :
						function( elem ) {
							return fn( elem, 0, args );
						};
				}

				return fn;
			}
		},

		pseudos: {
			// Potentially complex pseudos
			"not": markFunction(function( selector ) {
				// Trim the selector passed to compile
				// to avoid treating leading and trailing
				// spaces as combinators
				var input = [],
					results = [],
					matcher = compile( selector.replace( rtrim, "$1" ) );

				return matcher[ expando ] ?
					markFunction(function( seed, matches, context, xml ) {
						var elem,
							unmatched = matcher( seed, null, xml, [] ),
							i = seed.length;

						// Match elements unmatched by `matcher`
						while ( i-- ) {
							if ( (elem = unmatched[i]) ) {
								seed[i] = !(matches[i] = elem);
							}
						}
					}) :
					function( elem, context, xml ) {
						input[0] = elem;
						matcher( input, null, xml, results );
						// Don't keep the element (issue #299)
						input[0] = null;
						return !results.pop();
					};
			}),

			"has": markFunction(function( selector ) {
				return function( elem ) {
					return Sizzle( selector, elem ).length > 0;
				};
			}),

			"contains": markFunction(function( text ) {
				text = text.replace( runescape, funescape );
				return function( elem ) {
					return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
				};
			}),

			// "Whether an element is represented by a :lang() selector
			// is based solely on the element's language value
			// being equal to the identifier C,
			// or beginning with the identifier C immediately followed by "-".
			// The matching of C against the element's language value is performed case-insensitively.
			// The identifier C does not have to be a valid language name."
			// http://www.w3.org/TR/selectors/#lang-pseudo
			"lang": markFunction( function( lang ) {
				// lang value must be a valid identifier
				if ( !ridentifier.test(lang || "") ) {
					Sizzle.error( "unsupported lang: " + lang );
				}
				lang = lang.replace( runescape, funescape ).toLowerCase();
				return function( elem ) {
					var elemLang;
					do {
						if ( (elemLang = documentIsHTML ?
							elem.lang :
							elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

							elemLang = elemLang.toLowerCase();
							return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
						}
					} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
					return false;
				};
			}),

			// Miscellaneous
			"target": function( elem ) {
				var hash = window.location && window.location.hash;
				return hash && hash.slice( 1 ) === elem.id;
			},

			"root": function( elem ) {
				return elem === docElem;
			},

			"focus": function( elem ) {
				return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
			},

			// Boolean properties
			"enabled": createDisabledPseudo( false ),
			"disabled": createDisabledPseudo( true ),

			"checked": function( elem ) {
				// In CSS3, :checked should return both checked and selected elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				var nodeName = elem.nodeName.toLowerCase();
				return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
			},

			"selected": function( elem ) {
				// Accessing this property makes selected-by-default
				// options in Safari work properly
				if ( elem.parentNode ) {
					elem.parentNode.selectedIndex;
				}

				return elem.selected === true;
			},

			// Contents
			"empty": function( elem ) {
				// http://www.w3.org/TR/selectors/#empty-pseudo
				// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
				//   but not by others (comment: 8; processing instruction: 7; etc.)
				// nodeType < 6 works because attributes (2) do not appear as children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					if ( elem.nodeType < 6 ) {
						return false;
					}
				}
				return true;
			},

			"parent": function( elem ) {
				return !Expr.pseudos["empty"]( elem );
			},

			// Element/input types
			"header": function( elem ) {
				return rheader.test( elem.nodeName );
			},

			"input": function( elem ) {
				return rinputs.test( elem.nodeName );
			},

			"button": function( elem ) {
				var name = elem.nodeName.toLowerCase();
				return name === "input" && elem.type === "button" || name === "button";
			},

			"text": function( elem ) {
				var attr;
				return elem.nodeName.toLowerCase() === "input" &&
					elem.type === "text" &&

					// Support: IE<8
					// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
					( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
			},

			// Position-in-collection
			"first": createPositionalPseudo(function() {
				return [ 0 ];
			}),

			"last": createPositionalPseudo(function( matchIndexes, length ) {
				return [ length - 1 ];
			}),

			"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
				return [ argument < 0 ? argument + length : argument ];
			}),

			"even": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 0;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"odd": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 1;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; --i >= 0; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; ++i < length; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			})
		}
	};

	Expr.pseudos["nth"] = Expr.pseudos["eq"];

	// Add button/input type pseudos
	for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
		Expr.pseudos[ i ] = createInputPseudo( i );
	}
	for ( i in { submit: true, reset: true } ) {
		Expr.pseudos[ i ] = createButtonPseudo( i );
	}

	// Easy API for creating new setFilters
	function setFilters() {}
	setFilters.prototype = Expr.filters = Expr.pseudos;
	Expr.setFilters = new setFilters();

	tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
		var matched, match, tokens, type,
			soFar, groups, preFilters,
			cached = tokenCache[ selector + " " ];

		if ( cached ) {
			return parseOnly ? 0 : cached.slice( 0 );
		}

		soFar = selector;
		groups = [];
		preFilters = Expr.preFilter;

		while ( soFar ) {

			// Comma and first run
			if ( !matched || (match = rcomma.exec( soFar )) ) {
				if ( match ) {
					// Don't consume trailing commas as valid
					soFar = soFar.slice( match[0].length ) || soFar;
				}
				groups.push( (tokens = []) );
			}

			matched = false;

			// Combinators
			if ( (match = rcombinators.exec( soFar )) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					// Cast descendant combinators to space
					type: match[0].replace( rtrim, " " )
				});
				soFar = soFar.slice( matched.length );
			}

			// Filters
			for ( type in Expr.filter ) {
				if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
					(match = preFilters[ type ]( match ))) ) {
					matched = match.shift();
					tokens.push({
						value: matched,
						type: type,
						matches: match
					});
					soFar = soFar.slice( matched.length );
				}
			}

			if ( !matched ) {
				break;
			}
		}

		// Return the length of the invalid excess
		// if we're just parsing
		// Otherwise, throw an error or return tokens
		return parseOnly ?
			soFar.length :
			soFar ?
				Sizzle.error( selector ) :
				// Cache the tokens
				tokenCache( selector, groups ).slice( 0 );
	};

	function toSelector( tokens ) {
		var i = 0,
			len = tokens.length,
			selector = "";
		for ( ; i < len; i++ ) {
			selector += tokens[i].value;
		}
		return selector;
	}

	function addCombinator( matcher, combinator, base ) {
		var dir = combinator.dir,
			skip = combinator.next,
			key = skip || dir,
			checkNonElements = base && key === "parentNode",
			doneName = done++;

		return combinator.first ?
			// Check against closest ancestor/preceding element
			function( elem, context, xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						return matcher( elem, context, xml );
					}
				}
				return false;
			} :

			// Check against all ancestor/preceding elements
			function( elem, context, xml ) {
				var oldCache, uniqueCache, outerCache,
					newCache = [ dirruns, doneName ];

				// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
				if ( xml ) {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							if ( matcher( elem, context, xml ) ) {
								return true;
							}
						}
					}
				} else {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							outerCache = elem[ expando ] || (elem[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

							if ( skip && skip === elem.nodeName.toLowerCase() ) {
								elem = elem[ dir ] || elem;
							} else if ( (oldCache = uniqueCache[ key ]) &&
								oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

								// Assign to newCache so results back-propagate to previous elements
								return (newCache[ 2 ] = oldCache[ 2 ]);
							} else {
								// Reuse newcache so results back-propagate to previous elements
								uniqueCache[ key ] = newCache;

								// A match means we're done; a fail means we have to keep checking
								if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
									return true;
								}
							}
						}
					}
				}
				return false;
			};
	}

	function elementMatcher( matchers ) {
		return matchers.length > 1 ?
			function( elem, context, xml ) {
				var i = matchers.length;
				while ( i-- ) {
					if ( !matchers[i]( elem, context, xml ) ) {
						return false;
					}
				}
				return true;
			} :
			matchers[0];
	}

	function multipleContexts( selector, contexts, results ) {
		var i = 0,
			len = contexts.length;
		for ( ; i < len; i++ ) {
			Sizzle( selector, contexts[i], results );
		}
		return results;
	}

	function condense( unmatched, map, filter, context, xml ) {
		var elem,
			newUnmatched = [],
			i = 0,
			len = unmatched.length,
			mapped = map != null;

		for ( ; i < len; i++ ) {
			if ( (elem = unmatched[i]) ) {
				if ( !filter || filter( elem, context, xml ) ) {
					newUnmatched.push( elem );
					if ( mapped ) {
						map.push( i );
					}
				}
			}
		}

		return newUnmatched;
	}

	function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
		if ( postFilter && !postFilter[ expando ] ) {
			postFilter = setMatcher( postFilter );
		}
		if ( postFinder && !postFinder[ expando ] ) {
			postFinder = setMatcher( postFinder, postSelector );
		}
		return markFunction(function( seed, results, context, xml ) {
			var temp, i, elem,
				preMap = [],
				postMap = [],
				preexisting = results.length,

				// Get initial elements from seed or context
				elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

				// Prefilter to get matcher input, preserving a map for seed-results synchronization
				matcherIn = preFilter && ( seed || !selector ) ?
					condense( elems, preMap, preFilter, context, xml ) :
					elems,

				matcherOut = matcher ?
					// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
					postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

						// ...intermediate processing is necessary
						[] :

						// ...otherwise use results directly
						results :
					matcherIn;

			// Find primary matches
			if ( matcher ) {
				matcher( matcherIn, matcherOut, context, xml );
			}

			// Apply postFilter
			if ( postFilter ) {
				temp = condense( matcherOut, postMap );
				postFilter( temp, [], context, xml );

				// Un-match failing elements by moving them back to matcherIn
				i = temp.length;
				while ( i-- ) {
					if ( (elem = temp[i]) ) {
						matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
					}
				}
			}

			if ( seed ) {
				if ( postFinder || preFilter ) {
					if ( postFinder ) {
						// Get the final matcherOut by condensing this intermediate into postFinder contexts
						temp = [];
						i = matcherOut.length;
						while ( i-- ) {
							if ( (elem = matcherOut[i]) ) {
								// Restore matcherIn since elem is not yet a final match
								temp.push( (matcherIn[i] = elem) );
							}
						}
						postFinder( null, (matcherOut = []), temp, xml );
					}

					// Move matched elements from seed to results to keep them synchronized
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) &&
							(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

							seed[temp] = !(results[temp] = elem);
						}
					}
				}

			// Add elements to results, through postFinder if defined
			} else {
				matcherOut = condense(
					matcherOut === results ?
						matcherOut.splice( preexisting, matcherOut.length ) :
						matcherOut
				);
				if ( postFinder ) {
					postFinder( null, results, matcherOut, xml );
				} else {
					push.apply( results, matcherOut );
				}
			}
		});
	}

	function matcherFromTokens( tokens ) {
		var checkContext, matcher, j,
			len = tokens.length,
			leadingRelative = Expr.relative[ tokens[0].type ],
			implicitRelative = leadingRelative || Expr.relative[" "],
			i = leadingRelative ? 1 : 0,

			// The foundational matcher ensures that elements are reachable from top-level context(s)
			matchContext = addCombinator( function( elem ) {
				return elem === checkContext;
			}, implicitRelative, true ),
			matchAnyContext = addCombinator( function( elem ) {
				return indexOf( checkContext, elem ) > -1;
			}, implicitRelative, true ),
			matchers = [ function( elem, context, xml ) {
				var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
					(checkContext = context).nodeType ?
						matchContext( elem, context, xml ) :
						matchAnyContext( elem, context, xml ) );
				// Avoid hanging onto element (issue #299)
				checkContext = null;
				return ret;
			} ];

		for ( ; i < len; i++ ) {
			if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
				matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
			} else {
				matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

				// Return special upon seeing a positional matcher
				if ( matcher[ expando ] ) {
					// Find the next relative operator (if any) for proper handling
					j = ++i;
					for ( ; j < len; j++ ) {
						if ( Expr.relative[ tokens[j].type ] ) {
							break;
						}
					}
					return setMatcher(
						i > 1 && elementMatcher( matchers ),
						i > 1 && toSelector(
							// If the preceding token was a descendant combinator, insert an implicit any-element `*`
							tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
						).replace( rtrim, "$1" ),
						matcher,
						i < j && matcherFromTokens( tokens.slice( i, j ) ),
						j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
						j < len && toSelector( tokens )
					);
				}
				matchers.push( matcher );
			}
		}

		return elementMatcher( matchers );
	}

	function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
		var bySet = setMatchers.length > 0,
			byElement = elementMatchers.length > 0,
			superMatcher = function( seed, context, xml, results, outermost ) {
				var elem, j, matcher,
					matchedCount = 0,
					i = "0",
					unmatched = seed && [],
					setMatched = [],
					contextBackup = outermostContext,
					// We must always have either seed elements or outermost context
					elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
					// Use integer dirruns iff this is the outermost matcher
					dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
					len = elems.length;

				if ( outermost ) {
					outermostContext = context === document || context || outermost;
				}

				// Add elements passing elementMatchers directly to results
				// Support: IE<9, Safari
				// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
				for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
					if ( byElement && elem ) {
						j = 0;
						if ( !context && elem.ownerDocument !== document ) {
							setDocument( elem );
							xml = !documentIsHTML;
						}
						while ( (matcher = elementMatchers[j++]) ) {
							if ( matcher( elem, context || document, xml) ) {
								results.push( elem );
								break;
							}
						}
						if ( outermost ) {
							dirruns = dirrunsUnique;
						}
					}

					// Track unmatched elements for set filters
					if ( bySet ) {
						// They will have gone through all possible matchers
						if ( (elem = !matcher && elem) ) {
							matchedCount--;
						}

						// Lengthen the array for every element, matched or not
						if ( seed ) {
							unmatched.push( elem );
						}
					}
				}

				// `i` is now the count of elements visited above, and adding it to `matchedCount`
				// makes the latter nonnegative.
				matchedCount += i;

				// Apply set filters to unmatched elements
				// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
				// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
				// no element matchers and no seed.
				// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
				// case, which will result in a "00" `matchedCount` that differs from `i` but is also
				// numerically zero.
				if ( bySet && i !== matchedCount ) {
					j = 0;
					while ( (matcher = setMatchers[j++]) ) {
						matcher( unmatched, setMatched, context, xml );
					}

					if ( seed ) {
						// Reintegrate element matches to eliminate the need for sorting
						if ( matchedCount > 0 ) {
							while ( i-- ) {
								if ( !(unmatched[i] || setMatched[i]) ) {
									setMatched[i] = pop.call( results );
								}
							}
						}

						// Discard index placeholder values to get only actual matches
						setMatched = condense( setMatched );
					}

					// Add matches to results
					push.apply( results, setMatched );

					// Seedless set matches succeeding multiple successful matchers stipulate sorting
					if ( outermost && !seed && setMatched.length > 0 &&
						( matchedCount + setMatchers.length ) > 1 ) {

						Sizzle.uniqueSort( results );
					}
				}

				// Override manipulation of globals by nested matchers
				if ( outermost ) {
					dirruns = dirrunsUnique;
					outermostContext = contextBackup;
				}

				return unmatched;
			};

		return bySet ?
			markFunction( superMatcher ) :
			superMatcher;
	}

	compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
		var i,
			setMatchers = [],
			elementMatchers = [],
			cached = compilerCache[ selector + " " ];

		if ( !cached ) {
			// Generate a function of recursive functions that can be used to check each element
			if ( !match ) {
				match = tokenize( selector );
			}
			i = match.length;
			while ( i-- ) {
				cached = matcherFromTokens( match[i] );
				if ( cached[ expando ] ) {
					setMatchers.push( cached );
				} else {
					elementMatchers.push( cached );
				}
			}

			// Cache the compiled function
			cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

			// Save selector and tokenization
			cached.selector = selector;
		}
		return cached;
	};

	/**
	 * A low-level selection function that works with Sizzle's compiled
	 *  selector functions
	 * @param {String|Function} selector A selector or a pre-compiled
	 *  selector function built with Sizzle.compile
	 * @param {Element} context
	 * @param {Array} [results]
	 * @param {Array} [seed] A set of elements to match against
	 */
	select = Sizzle.select = function( selector, context, results, seed ) {
		var i, tokens, token, type, find,
			compiled = typeof selector === "function" && selector,
			match = !seed && tokenize( (selector = compiled.selector || selector) );

		results = results || [];

		// Try to minimize operations if there is only one selector in the list and no seed
		// (the latter of which guarantees us context)
		if ( match.length === 1 ) {

			// Reduce context if the leading compound selector is an ID
			tokens = match[0] = match[0].slice( 0 );
			if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
					context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {

				context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
				if ( !context ) {
					return results;

				// Precompiled matchers will still verify ancestry, so step up a level
				} else if ( compiled ) {
					context = context.parentNode;
				}

				selector = selector.slice( tokens.shift().value.length );
			}

			// Fetch a seed set for right-to-left matching
			i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
			while ( i-- ) {
				token = tokens[i];

				// Abort if we hit a combinator
				if ( Expr.relative[ (type = token.type) ] ) {
					break;
				}
				if ( (find = Expr.find[ type ]) ) {
					// Search, expanding context for leading sibling combinators
					if ( (seed = find(
						token.matches[0].replace( runescape, funescape ),
						rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
					)) ) {

						// If seed is empty or no tokens remain, we can return early
						tokens.splice( i, 1 );
						selector = seed.length && toSelector( tokens );
						if ( !selector ) {
							push.apply( results, seed );
							return results;
						}

						break;
					}
				}
			}
		}

		// Compile and execute a filtering function if one is not provided
		// Provide `match` to avoid retokenization if we modified the selector above
		( compiled || compile( selector, match ) )(
			seed,
			context,
			!documentIsHTML,
			results,
			!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
		);
		return results;
	};

	// One-time assignments

	// Sort stability
	support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

	// Support: Chrome 14-35+
	// Always assume duplicates if they aren't passed to the comparison function
	support.detectDuplicates = !!hasDuplicate;

	// Initialize against the default document
	setDocument();

	// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
	// Detached nodes confoundingly follow *each other*
	support.sortDetached = assert(function( el ) {
		// Should return 1, but returns 4 (following)
		return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
	});

	// Support: IE<8
	// Prevent attribute/property "interpolation"
	// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
	if ( !assert(function( el ) {
		el.innerHTML = "<a href='#'></a>";
		return el.firstChild.getAttribute("href") === "#" ;
	}) ) {
		addHandle( "type|href|height|width", function( elem, name, isXML ) {
			if ( !isXML ) {
				return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
			}
		});
	}

	// Support: IE<9
	// Use defaultValue in place of getAttribute("value")
	if ( !support.attributes || !assert(function( el ) {
		el.innerHTML = "<input/>";
		el.firstChild.setAttribute( "value", "" );
		return el.firstChild.getAttribute( "value" ) === "";
	}) ) {
		addHandle( "value", function( elem, name, isXML ) {
			if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
				return elem.defaultValue;
			}
		});
	}

	// Support: IE<9
	// Use getAttributeNode to fetch booleans when getAttribute lies
	if ( !assert(function( el ) {
		return el.getAttribute("disabled") == null;
	}) ) {
		addHandle( booleans, function( elem, name, isXML ) {
			var val;
			if ( !isXML ) {
				return elem[ name ] === true ? name.toLowerCase() :
						(val = elem.getAttributeNode( name )) && val.specified ?
						val.value :
					null;
			}
		});
	}

	return Sizzle;

	})( window );



	jQuery.find = Sizzle;
	jQuery.expr = Sizzle.selectors;

	// Deprecated
	jQuery.expr[ ":" ] = jQuery.expr.pseudos;
	jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
	jQuery.text = Sizzle.getText;
	jQuery.isXMLDoc = Sizzle.isXML;
	jQuery.contains = Sizzle.contains;
	jQuery.escapeSelector = Sizzle.escape;




	var dir = function( elem, dir, until ) {
		var matched = [],
			truncate = until !== undefined;

		while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
			if ( elem.nodeType === 1 ) {
				if ( truncate && jQuery( elem ).is( until ) ) {
					break;
				}
				matched.push( elem );
			}
		}
		return matched;
	};


	var siblings = function( n, elem ) {
		var matched = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				matched.push( n );
			}
		}

		return matched;
	};


	var rneedsContext = jQuery.expr.match.needsContext;

	var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



	var risSimple = /^.[^:#\[\.,]*$/;

	// Implement the identical functionality for filter and not
	function winnow( elements, qualifier, not ) {
		if ( jQuery.isFunction( qualifier ) ) {
			return jQuery.grep( elements, function( elem, i ) {
				return !!qualifier.call( elem, i, elem ) !== not;
			} );
		}

		// Single element
		if ( qualifier.nodeType ) {
			return jQuery.grep( elements, function( elem ) {
				return ( elem === qualifier ) !== not;
			} );
		}

		// Arraylike of elements (jQuery, arguments, Array)
		if ( typeof qualifier !== "string" ) {
			return jQuery.grep( elements, function( elem ) {
				return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
			} );
		}

		// Simple selector that can be filtered directly, removing non-Elements
		if ( risSimple.test( qualifier ) ) {
			return jQuery.filter( qualifier, elements, not );
		}

		// Complex selector, compare the two sets, removing non-Elements
		qualifier = jQuery.filter( qualifier, elements );
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not && elem.nodeType === 1;
		} );
	}

	jQuery.filter = function( expr, elems, not ) {
		var elem = elems[ 0 ];

		if ( not ) {
			expr = ":not(" + expr + ")";
		}

		if ( elems.length === 1 && elem.nodeType === 1 ) {
			return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
		}

		return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
			return elem.nodeType === 1;
		} ) );
	};

	jQuery.fn.extend( {
		find: function( selector ) {
			var i, ret,
				len = this.length,
				self = this;

			if ( typeof selector !== "string" ) {
				return this.pushStack( jQuery( selector ).filter( function() {
					for ( i = 0; i < len; i++ ) {
						if ( jQuery.contains( self[ i ], this ) ) {
							return true;
						}
					}
				} ) );
			}

			ret = this.pushStack( [] );

			for ( i = 0; i < len; i++ ) {
				jQuery.find( selector, self[ i ], ret );
			}

			return len > 1 ? jQuery.uniqueSort( ret ) : ret;
		},
		filter: function( selector ) {
			return this.pushStack( winnow( this, selector || [], false ) );
		},
		not: function( selector ) {
			return this.pushStack( winnow( this, selector || [], true ) );
		},
		is: function( selector ) {
			return !!winnow(
				this,

				// If this is a positional/relative selector, check membership in the returned set
				// so $("p:first").is("p:last") won't return true for a doc with two "p".
				typeof selector === "string" && rneedsContext.test( selector ) ?
					jQuery( selector ) :
					selector || [],
				false
			).length;
		}
	} );


	// Initialize a jQuery object


	// A central reference to the root jQuery(document)
	var rootjQuery,

		// A simple way to check for HTML strings
		// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
		// Strict HTML recognition (#11290: must start with <)
		// Shortcut simple #id case for speed
		rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

		init = jQuery.fn.init = function( selector, context, root ) {
			var match, elem;

			// HANDLE: $(""), $(null), $(undefined), $(false)
			if ( !selector ) {
				return this;
			}

			// Method init() accepts an alternate rootjQuery
			// so migrate can support jQuery.sub (gh-2101)
			root = root || rootjQuery;

			// Handle HTML strings
			if ( typeof selector === "string" ) {
				if ( selector[ 0 ] === "<" &&
					selector[ selector.length - 1 ] === ">" &&
					selector.length >= 3 ) {

					// Assume that strings that start and end with <> are HTML and skip the regex check
					match = [ null, selector, null ];

				} else {
					match = rquickExpr.exec( selector );
				}

				// Match html or make sure no context is specified for #id
				if ( match && ( match[ 1 ] || !context ) ) {

					// HANDLE: $(html) -> $(array)
					if ( match[ 1 ] ) {
						context = context instanceof jQuery ? context[ 0 ] : context;

						// Option to run scripts is true for back-compat
						// Intentionally let the error be thrown if parseHTML is not present
						jQuery.merge( this, jQuery.parseHTML(
							match[ 1 ],
							context && context.nodeType ? context.ownerDocument || context : document,
							true
						) );

						// HANDLE: $(html, props)
						if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
							for ( match in context ) {

								// Properties of context are called as methods if possible
								if ( jQuery.isFunction( this[ match ] ) ) {
									this[ match ]( context[ match ] );

								// ...and otherwise set as attributes
								} else {
									this.attr( match, context[ match ] );
								}
							}
						}

						return this;

					// HANDLE: $(#id)
					} else {
						elem = document.getElementById( match[ 2 ] );

						if ( elem ) {

							// Inject the element directly into the jQuery object
							this[ 0 ] = elem;
							this.length = 1;
						}
						return this;
					}

				// HANDLE: $(expr, $(...))
				} else if ( !context || context.jquery ) {
					return ( context || root ).find( selector );

				// HANDLE: $(expr, context)
				// (which is just equivalent to: $(context).find(expr)
				} else {
					return this.constructor( context ).find( selector );
				}

			// HANDLE: $(DOMElement)
			} else if ( selector.nodeType ) {
				this[ 0 ] = selector;
				this.length = 1;
				return this;

			// HANDLE: $(function)
			// Shortcut for document ready
			} else if ( jQuery.isFunction( selector ) ) {
				return root.ready !== undefined ?
					root.ready( selector ) :

					// Execute immediately if ready is not present
					selector( jQuery );
			}

			return jQuery.makeArray( selector, this );
		};

	// Give the init function the jQuery prototype for later instantiation
	init.prototype = jQuery.fn;

	// Initialize central reference
	rootjQuery = jQuery( document );


	var rparentsprev = /^(?:parents|prev(?:Until|All))/,

		// Methods guaranteed to produce a unique set when starting from a unique set
		guaranteedUnique = {
			children: true,
			contents: true,
			next: true,
			prev: true
		};

	jQuery.fn.extend( {
		has: function( target ) {
			var targets = jQuery( target, this ),
				l = targets.length;

			return this.filter( function() {
				var i = 0;
				for ( ; i < l; i++ ) {
					if ( jQuery.contains( this, targets[ i ] ) ) {
						return true;
					}
				}
			} );
		},

		closest: function( selectors, context ) {
			var cur,
				i = 0,
				l = this.length,
				matched = [],
				targets = typeof selectors !== "string" && jQuery( selectors );

			// Positional selectors never match, since there's no _selection_ context
			if ( !rneedsContext.test( selectors ) ) {
				for ( ; i < l; i++ ) {
					for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

						// Always skip document fragments
						if ( cur.nodeType < 11 && ( targets ?
							targets.index( cur ) > -1 :

							// Don't pass non-elements to Sizzle
							cur.nodeType === 1 &&
								jQuery.find.matchesSelector( cur, selectors ) ) ) {

							matched.push( cur );
							break;
						}
					}
				}
			}

			return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
		},

		// Determine the position of an element within the set
		index: function( elem ) {

			// No argument, return index in parent
			if ( !elem ) {
				return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
			}

			// Index in selector
			if ( typeof elem === "string" ) {
				return indexOf.call( jQuery( elem ), this[ 0 ] );
			}

			// Locate the position of the desired element
			return indexOf.call( this,

				// If it receives a jQuery object, the first element is used
				elem.jquery ? elem[ 0 ] : elem
			);
		},

		add: function( selector, context ) {
			return this.pushStack(
				jQuery.uniqueSort(
					jQuery.merge( this.get(), jQuery( selector, context ) )
				)
			);
		},

		addBack: function( selector ) {
			return this.add( selector == null ?
				this.prevObject : this.prevObject.filter( selector )
			);
		}
	} );

	function sibling( cur, dir ) {
		while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
		return cur;
	}

	jQuery.each( {
		parent: function( elem ) {
			var parent = elem.parentNode;
			return parent && parent.nodeType !== 11 ? parent : null;
		},
		parents: function( elem ) {
			return dir( elem, "parentNode" );
		},
		parentsUntil: function( elem, i, until ) {
			return dir( elem, "parentNode", until );
		},
		next: function( elem ) {
			return sibling( elem, "nextSibling" );
		},
		prev: function( elem ) {
			return sibling( elem, "previousSibling" );
		},
		nextAll: function( elem ) {
			return dir( elem, "nextSibling" );
		},
		prevAll: function( elem ) {
			return dir( elem, "previousSibling" );
		},
		nextUntil: function( elem, i, until ) {
			return dir( elem, "nextSibling", until );
		},
		prevUntil: function( elem, i, until ) {
			return dir( elem, "previousSibling", until );
		},
		siblings: function( elem ) {
			return siblings( ( elem.parentNode || {} ).firstChild, elem );
		},
		children: function( elem ) {
			return siblings( elem.firstChild );
		},
		contents: function( elem ) {
			return elem.contentDocument || jQuery.merge( [], elem.childNodes );
		}
	}, function( name, fn ) {
		jQuery.fn[ name ] = function( until, selector ) {
			var matched = jQuery.map( this, fn, until );

			if ( name.slice( -5 ) !== "Until" ) {
				selector = until;
			}

			if ( selector && typeof selector === "string" ) {
				matched = jQuery.filter( selector, matched );
			}

			if ( this.length > 1 ) {

				// Remove duplicates
				if ( !guaranteedUnique[ name ] ) {
					jQuery.uniqueSort( matched );
				}

				// Reverse order for parents* and prev-derivatives
				if ( rparentsprev.test( name ) ) {
					matched.reverse();
				}
			}

			return this.pushStack( matched );
		};
	} );
	var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



	// Convert String-formatted options into Object-formatted ones
	function createOptions( options ) {
		var object = {};
		jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
			object[ flag ] = true;
		} );
		return object;
	}

	/*
	 * Create a callback list using the following parameters:
	 *
	 *	options: an optional list of space-separated options that will change how
	 *			the callback list behaves or a more traditional option object
	 *
	 * By default a callback list will act like an event callback list and can be
	 * "fired" multiple times.
	 *
	 * Possible options:
	 *
	 *	once:			will ensure the callback list can only be fired once (like a Deferred)
	 *
	 *	memory:			will keep track of previous values and will call any callback added
	 *					after the list has been fired right away with the latest "memorized"
	 *					values (like a Deferred)
	 *
	 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
	 *
	 *	stopOnFalse:	interrupt callings when a callback returns false
	 *
	 */
	jQuery.Callbacks = function( options ) {

		// Convert options from String-formatted to Object-formatted if needed
		// (we check in cache first)
		options = typeof options === "string" ?
			createOptions( options ) :
			jQuery.extend( {}, options );

		var // Flag to know if list is currently firing
			firing,

			// Last fire value for non-forgettable lists
			memory,

			// Flag to know if list was already fired
			fired,

			// Flag to prevent firing
			locked,

			// Actual callback list
			list = [],

			// Queue of execution data for repeatable lists
			queue = [],

			// Index of currently firing callback (modified by add/remove as needed)
			firingIndex = -1,

			// Fire callbacks
			fire = function() {

				// Enforce single-firing
				locked = options.once;

				// Execute callbacks for all pending executions,
				// respecting firingIndex overrides and runtime changes
				fired = firing = true;
				for ( ; queue.length; firingIndex = -1 ) {
					memory = queue.shift();
					while ( ++firingIndex < list.length ) {

						// Run callback and check for early termination
						if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
							options.stopOnFalse ) {

							// Jump to end and forget the data so .add doesn't re-fire
							firingIndex = list.length;
							memory = false;
						}
					}
				}

				// Forget the data if we're done with it
				if ( !options.memory ) {
					memory = false;
				}

				firing = false;

				// Clean up if we're done firing for good
				if ( locked ) {

					// Keep an empty list if we have data for future add calls
					if ( memory ) {
						list = [];

					// Otherwise, this object is spent
					} else {
						list = "";
					}
				}
			},

			// Actual Callbacks object
			self = {

				// Add a callback or a collection of callbacks to the list
				add: function() {
					if ( list ) {

						// If we have memory from a past run, we should fire after adding
						if ( memory && !firing ) {
							firingIndex = list.length - 1;
							queue.push( memory );
						}

						( function add( args ) {
							jQuery.each( args, function( _, arg ) {
								if ( jQuery.isFunction( arg ) ) {
									if ( !options.unique || !self.has( arg ) ) {
										list.push( arg );
									}
								} else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {

									// Inspect recursively
									add( arg );
								}
							} );
						} )( arguments );

						if ( memory && !firing ) {
							fire();
						}
					}
					return this;
				},

				// Remove a callback from the list
				remove: function() {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );

							// Handle firing indexes
							if ( index <= firingIndex ) {
								firingIndex--;
							}
						}
					} );
					return this;
				},

				// Check if a given callback is in the list.
				// If no argument is given, return whether or not list has callbacks attached.
				has: function( fn ) {
					return fn ?
						jQuery.inArray( fn, list ) > -1 :
						list.length > 0;
				},

				// Remove all callbacks from the list
				empty: function() {
					if ( list ) {
						list = [];
					}
					return this;
				},

				// Disable .fire and .add
				// Abort any current/pending executions
				// Clear all callbacks and values
				disable: function() {
					locked = queue = [];
					list = memory = "";
					return this;
				},
				disabled: function() {
					return !list;
				},

				// Disable .fire
				// Also disable .add unless we have memory (since it would have no effect)
				// Abort any pending executions
				lock: function() {
					locked = queue = [];
					if ( !memory && !firing ) {
						list = memory = "";
					}
					return this;
				},
				locked: function() {
					return !!locked;
				},

				// Call all callbacks with the given context and arguments
				fireWith: function( context, args ) {
					if ( !locked ) {
						args = args || [];
						args = [ context, args.slice ? args.slice() : args ];
						queue.push( args );
						if ( !firing ) {
							fire();
						}
					}
					return this;
				},

				// Call all the callbacks with the given arguments
				fire: function() {
					self.fireWith( this, arguments );
					return this;
				},

				// To know if the callbacks have already been called at least once
				fired: function() {
					return !!fired;
				}
			};

		return self;
	};


	function Identity( v ) {
		return v;
	}
	function Thrower( ex ) {
		throw ex;
	}

	function adoptValue( value, resolve, reject ) {
		var method;

		try {

			// Check for promise aspect first to privilege synchronous behavior
			if ( value && jQuery.isFunction( ( method = value.promise ) ) ) {
				method.call( value ).done( resolve ).fail( reject );

			// Other thenables
			} else if ( value && jQuery.isFunction( ( method = value.then ) ) ) {
				method.call( value, resolve, reject );

			// Other non-thenables
			} else {

				// Support: Android 4.0 only
				// Strict mode functions invoked without .call/.apply get global-object context
				resolve.call( undefined, value );
			}

		// For Promises/A+, convert exceptions into rejections
		// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
		// Deferred#then to conditionally suppress rejection.
		} catch ( value ) {

			// Support: Android 4.0 only
			// Strict mode functions invoked without .call/.apply get global-object context
			reject.call( undefined, value );
		}
	}

	jQuery.extend( {

		Deferred: function( func ) {
			var tuples = [

					// action, add listener, callbacks,
					// ... .then handlers, argument index, [final state]
					[ "notify", "progress", jQuery.Callbacks( "memory" ),
						jQuery.Callbacks( "memory" ), 2 ],
					[ "resolve", "done", jQuery.Callbacks( "once memory" ),
						jQuery.Callbacks( "once memory" ), 0, "resolved" ],
					[ "reject", "fail", jQuery.Callbacks( "once memory" ),
						jQuery.Callbacks( "once memory" ), 1, "rejected" ]
				],
				state = "pending",
				promise = {
					state: function() {
						return state;
					},
					always: function() {
						deferred.done( arguments ).fail( arguments );
						return this;
					},
					"catch": function( fn ) {
						return promise.then( null, fn );
					},

					// Keep pipe for back-compat
					pipe: function( /* fnDone, fnFail, fnProgress */ ) {
						var fns = arguments;

						return jQuery.Deferred( function( newDefer ) {
							jQuery.each( tuples, function( i, tuple ) {

								// Map tuples (progress, done, fail) to arguments (done, fail, progress)
								var fn = jQuery.isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

								// deferred.progress(function() { bind to newDefer or newDefer.notify })
								// deferred.done(function() { bind to newDefer or newDefer.resolve })
								// deferred.fail(function() { bind to newDefer or newDefer.reject })
								deferred[ tuple[ 1 ] ]( function() {
									var returned = fn && fn.apply( this, arguments );
									if ( returned && jQuery.isFunction( returned.promise ) ) {
										returned.promise()
											.progress( newDefer.notify )
											.done( newDefer.resolve )
											.fail( newDefer.reject );
									} else {
										newDefer[ tuple[ 0 ] + "With" ](
											this,
											fn ? [ returned ] : arguments
										);
									}
								} );
							} );
							fns = null;
						} ).promise();
					},
					then: function( onFulfilled, onRejected, onProgress ) {
						var maxDepth = 0;
						function resolve( depth, deferred, handler, special ) {
							return function() {
								var that = this,
									args = arguments,
									mightThrow = function() {
										var returned, then;

										// Support: Promises/A+ section 2.3.3.3.3
										// https://promisesaplus.com/#point-59
										// Ignore double-resolution attempts
										if ( depth < maxDepth ) {
											return;
										}

										returned = handler.apply( that, args );

										// Support: Promises/A+ section 2.3.1
										// https://promisesaplus.com/#point-48
										if ( returned === deferred.promise() ) {
											throw new TypeError( "Thenable self-resolution" );
										}

										// Support: Promises/A+ sections 2.3.3.1, 3.5
										// https://promisesaplus.com/#point-54
										// https://promisesaplus.com/#point-75
										// Retrieve `then` only once
										then = returned &&

											// Support: Promises/A+ section 2.3.4
											// https://promisesaplus.com/#point-64
											// Only check objects and functions for thenability
											( typeof returned === "object" ||
												typeof returned === "function" ) &&
											returned.then;

										// Handle a returned thenable
										if ( jQuery.isFunction( then ) ) {

											// Special processors (notify) just wait for resolution
											if ( special ) {
												then.call(
													returned,
													resolve( maxDepth, deferred, Identity, special ),
													resolve( maxDepth, deferred, Thrower, special )
												);

											// Normal processors (resolve) also hook into progress
											} else {

												// ...and disregard older resolution values
												maxDepth++;

												then.call(
													returned,
													resolve( maxDepth, deferred, Identity, special ),
													resolve( maxDepth, deferred, Thrower, special ),
													resolve( maxDepth, deferred, Identity,
														deferred.notifyWith )
												);
											}

										// Handle all other returned values
										} else {

											// Only substitute handlers pass on context
											// and multiple values (non-spec behavior)
											if ( handler !== Identity ) {
												that = undefined;
												args = [ returned ];
											}

											// Process the value(s)
											// Default process is resolve
											( special || deferred.resolveWith )( that, args );
										}
									},

									// Only normal processors (resolve) catch and reject exceptions
									process = special ?
										mightThrow :
										function() {
											try {
												mightThrow();
											} catch ( e ) {

												if ( jQuery.Deferred.exceptionHook ) {
													jQuery.Deferred.exceptionHook( e,
														process.stackTrace );
												}

												// Support: Promises/A+ section 2.3.3.3.4.1
												// https://promisesaplus.com/#point-61
												// Ignore post-resolution exceptions
												if ( depth + 1 >= maxDepth ) {

													// Only substitute handlers pass on context
													// and multiple values (non-spec behavior)
													if ( handler !== Thrower ) {
														that = undefined;
														args = [ e ];
													}

													deferred.rejectWith( that, args );
												}
											}
										};

								// Support: Promises/A+ section 2.3.3.3.1
								// https://promisesaplus.com/#point-57
								// Re-resolve promises immediately to dodge false rejection from
								// subsequent errors
								if ( depth ) {
									process();
								} else {

									// Call an optional hook to record the stack, in case of exception
									// since it's otherwise lost when execution goes async
									if ( jQuery.Deferred.getStackHook ) {
										process.stackTrace = jQuery.Deferred.getStackHook();
									}
									window.setTimeout( process );
								}
							};
						}

						return jQuery.Deferred( function( newDefer ) {

							// progress_handlers.add( ... )
							tuples[ 0 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									jQuery.isFunction( onProgress ) ?
										onProgress :
										Identity,
									newDefer.notifyWith
								)
							);

							// fulfilled_handlers.add( ... )
							tuples[ 1 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									jQuery.isFunction( onFulfilled ) ?
										onFulfilled :
										Identity
								)
							);

							// rejected_handlers.add( ... )
							tuples[ 2 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									jQuery.isFunction( onRejected ) ?
										onRejected :
										Thrower
								)
							);
						} ).promise();
					},

					// Get a promise for this deferred
					// If obj is provided, the promise aspect is added to the object
					promise: function( obj ) {
						return obj != null ? jQuery.extend( obj, promise ) : promise;
					}
				},
				deferred = {};

			// Add list-specific methods
			jQuery.each( tuples, function( i, tuple ) {
				var list = tuple[ 2 ],
					stateString = tuple[ 5 ];

				// promise.progress = list.add
				// promise.done = list.add
				// promise.fail = list.add
				promise[ tuple[ 1 ] ] = list.add;

				// Handle state
				if ( stateString ) {
					list.add(
						function() {

							// state = "resolved" (i.e., fulfilled)
							// state = "rejected"
							state = stateString;
						},

						// rejected_callbacks.disable
						// fulfilled_callbacks.disable
						tuples[ 3 - i ][ 2 ].disable,

						// progress_callbacks.lock
						tuples[ 0 ][ 2 ].lock
					);
				}

				// progress_handlers.fire
				// fulfilled_handlers.fire
				// rejected_handlers.fire
				list.add( tuple[ 3 ].fire );

				// deferred.notify = function() { deferred.notifyWith(...) }
				// deferred.resolve = function() { deferred.resolveWith(...) }
				// deferred.reject = function() { deferred.rejectWith(...) }
				deferred[ tuple[ 0 ] ] = function() {
					deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
					return this;
				};

				// deferred.notifyWith = list.fireWith
				// deferred.resolveWith = list.fireWith
				// deferred.rejectWith = list.fireWith
				deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
			} );

			// Make the deferred a promise
			promise.promise( deferred );

			// Call given func if any
			if ( func ) {
				func.call( deferred, deferred );
			}

			// All done!
			return deferred;
		},

		// Deferred helper
		when: function( singleValue ) {
			var

				// count of uncompleted subordinates
				remaining = arguments.length,

				// count of unprocessed arguments
				i = remaining,

				// subordinate fulfillment data
				resolveContexts = Array( i ),
				resolveValues = slice.call( arguments ),

				// the master Deferred
				master = jQuery.Deferred(),

				// subordinate callback factory
				updateFunc = function( i ) {
					return function( value ) {
						resolveContexts[ i ] = this;
						resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
						if ( !( --remaining ) ) {
							master.resolveWith( resolveContexts, resolveValues );
						}
					};
				};

			// Single- and empty arguments are adopted like Promise.resolve
			if ( remaining <= 1 ) {
				adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject );

				// Use .then() to unwrap secondary thenables (cf. gh-3000)
				if ( master.state() === "pending" ||
					jQuery.isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

					return master.then();
				}
			}

			// Multiple arguments are aggregated like Promise.all array elements
			while ( i-- ) {
				adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
			}

			return master.promise();
		}
	} );


	// These usually indicate a programmer mistake during development,
	// warn about them ASAP rather than swallowing them by default.
	var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

	jQuery.Deferred.exceptionHook = function( error, stack ) {

		// Support: IE 8 - 9 only
		// Console exists when dev tools are open, which can happen at any time
		if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
			window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
		}
	};




	jQuery.readyException = function( error ) {
		window.setTimeout( function() {
			throw error;
		} );
	};




	// The deferred used on DOM ready
	var readyList = jQuery.Deferred();

	jQuery.fn.ready = function( fn ) {

		readyList
			.then( fn )

			// Wrap jQuery.readyException in a function so that the lookup
			// happens at the time of error handling instead of callback
			// registration.
			.catch( function( error ) {
				jQuery.readyException( error );
			} );

		return this;
	};

	jQuery.extend( {

		// Is the DOM ready to be used? Set to true once it occurs.
		isReady: false,

		// A counter to track how many items to wait for before
		// the ready event fires. See #6781
		readyWait: 1,

		// Hold (or release) the ready event
		holdReady: function( hold ) {
			if ( hold ) {
				jQuery.readyWait++;
			} else {
				jQuery.ready( true );
			}
		},

		// Handle when the DOM is ready
		ready: function( wait ) {

			// Abort if there are pending holds or we're already ready
			if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
				return;
			}

			// Remember that the DOM is ready
			jQuery.isReady = true;

			// If a normal DOM Ready event fired, decrement, and wait if need be
			if ( wait !== true && --jQuery.readyWait > 0 ) {
				return;
			}

			// If there are functions bound, to execute
			readyList.resolveWith( document, [ jQuery ] );
		}
	} );

	jQuery.ready.then = readyList.then;

	// The ready event handler and self cleanup method
	function completed() {
		document.removeEventListener( "DOMContentLoaded", completed );
		window.removeEventListener( "load", completed );
		jQuery.ready();
	}

	// Catch cases where $(document).ready() is called
	// after the browser event has already occurred.
	// Support: IE <=9 - 10 only
	// Older IE sometimes signals "interactive" too soon
	if ( document.readyState === "complete" ||
		( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

		// Handle it asynchronously to allow scripts the opportunity to delay ready
		window.setTimeout( jQuery.ready );

	} else {

		// Use the handy event callback
		document.addEventListener( "DOMContentLoaded", completed );

		// A fallback to window.onload, that will always work
		window.addEventListener( "load", completed );
	}




	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function
	var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
		var i = 0,
			len = elems.length,
			bulk = key == null;

		// Sets many values
		if ( jQuery.type( key ) === "object" ) {
			chainable = true;
			for ( i in key ) {
				access( elems, fn, i, key[ i ], true, emptyGet, raw );
			}

		// Sets one value
		} else if ( value !== undefined ) {
			chainable = true;

			if ( !jQuery.isFunction( value ) ) {
				raw = true;
			}

			if ( bulk ) {

				// Bulk operations run against the entire set
				if ( raw ) {
					fn.call( elems, value );
					fn = null;

				// ...except when executing function values
				} else {
					bulk = fn;
					fn = function( elem, key, value ) {
						return bulk.call( jQuery( elem ), value );
					};
				}
			}

			if ( fn ) {
				for ( ; i < len; i++ ) {
					fn(
						elems[ i ], key, raw ?
						value :
						value.call( elems[ i ], i, fn( elems[ i ], key ) )
					);
				}
			}
		}

		if ( chainable ) {
			return elems;
		}

		// Gets
		if ( bulk ) {
			return fn.call( elems );
		}

		return len ? fn( elems[ 0 ], key ) : emptyGet;
	};
	var acceptData = function( owner ) {

		// Accepts only:
		//  - Node
		//    - Node.ELEMENT_NODE
		//    - Node.DOCUMENT_NODE
		//  - Object
		//    - Any
		return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
	};




	function Data() {
		this.expando = jQuery.expando + Data.uid++;
	}

	Data.uid = 1;

	Data.prototype = {

		cache: function( owner ) {

			// Check if the owner object already has a cache
			var value = owner[ this.expando ];

			// If not, create one
			if ( !value ) {
				value = {};

				// We can accept data for non-element nodes in modern browsers,
				// but we should not, see #8335.
				// Always return an empty object.
				if ( acceptData( owner ) ) {

					// If it is a node unlikely to be stringify-ed or looped over
					// use plain assignment
					if ( owner.nodeType ) {
						owner[ this.expando ] = value;

					// Otherwise secure it in a non-enumerable property
					// configurable must be true to allow the property to be
					// deleted when data is removed
					} else {
						Object.defineProperty( owner, this.expando, {
							value: value,
							configurable: true
						} );
					}
				}
			}

			return value;
		},
		set: function( owner, data, value ) {
			var prop,
				cache = this.cache( owner );

			// Handle: [ owner, key, value ] args
			// Always use camelCase key (gh-2257)
			if ( typeof data === "string" ) {
				cache[ jQuery.camelCase( data ) ] = value;

			// Handle: [ owner, { properties } ] args
			} else {

				// Copy the properties one-by-one to the cache object
				for ( prop in data ) {
					cache[ jQuery.camelCase( prop ) ] = data[ prop ];
				}
			}
			return cache;
		},
		get: function( owner, key ) {
			return key === undefined ?
				this.cache( owner ) :

				// Always use camelCase key (gh-2257)
				owner[ this.expando ] && owner[ this.expando ][ jQuery.camelCase( key ) ];
		},
		access: function( owner, key, value ) {

			// In cases where either:
			//
			//   1. No key was specified
			//   2. A string key was specified, but no value provided
			//
			// Take the "read" path and allow the get method to determine
			// which value to return, respectively either:
			//
			//   1. The entire cache object
			//   2. The data stored at the key
			//
			if ( key === undefined ||
					( ( key && typeof key === "string" ) && value === undefined ) ) {

				return this.get( owner, key );
			}

			// When the key is not a string, or both a key and value
			// are specified, set or extend (existing objects) with either:
			//
			//   1. An object of properties
			//   2. A key and value
			//
			this.set( owner, key, value );

			// Since the "set" path can have two possible entry points
			// return the expected data based on which path was taken[*]
			return value !== undefined ? value : key;
		},
		remove: function( owner, key ) {
			var i,
				cache = owner[ this.expando ];

			if ( cache === undefined ) {
				return;
			}

			if ( key !== undefined ) {

				// Support array or space separated string of keys
				if ( jQuery.isArray( key ) ) {

					// If key is an array of keys...
					// We always set camelCase keys, so remove that.
					key = key.map( jQuery.camelCase );
				} else {
					key = jQuery.camelCase( key );

					// If a key with the spaces exists, use it.
					// Otherwise, create an array by matching non-whitespace
					key = key in cache ?
						[ key ] :
						( key.match( rnothtmlwhite ) || [] );
				}

				i = key.length;

				while ( i-- ) {
					delete cache[ key[ i ] ];
				}
			}

			// Remove the expando if there's no more data
			if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

				// Support: Chrome <=35 - 45
				// Webkit & Blink performance suffers when deleting properties
				// from DOM nodes, so set to undefined instead
				// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
				if ( owner.nodeType ) {
					owner[ this.expando ] = undefined;
				} else {
					delete owner[ this.expando ];
				}
			}
		},
		hasData: function( owner ) {
			var cache = owner[ this.expando ];
			return cache !== undefined && !jQuery.isEmptyObject( cache );
		}
	};
	var dataPriv = new Data();

	var dataUser = new Data();



	//	Implementation Summary
	//
	//	1. Enforce API surface and semantic compatibility with 1.9.x branch
	//	2. Improve the module's maintainability by reducing the storage
	//		paths to a single mechanism.
	//	3. Use the same single mechanism to support "private" and "user" data.
	//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	//	5. Avoid exposing implementation details on user objects (eg. expando properties)
	//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

	var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
		rmultiDash = /[A-Z]/g;

	function getData( data ) {
		if ( data === "true" ) {
			return true;
		}

		if ( data === "false" ) {
			return false;
		}

		if ( data === "null" ) {
			return null;
		}

		// Only convert to a number if it doesn't change the string
		if ( data === +data + "" ) {
			return +data;
		}

		if ( rbrace.test( data ) ) {
			return JSON.parse( data );
		}

		return data;
	}

	function dataAttr( elem, key, data ) {
		var name;

		// If nothing was found internally, try to fetch any
		// data from the HTML5 data-* attribute
		if ( data === undefined && elem.nodeType === 1 ) {
			name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
			data = elem.getAttribute( name );

			if ( typeof data === "string" ) {
				try {
					data = getData( data );
				} catch ( e ) {}

				// Make sure we set the data so it isn't changed later
				dataUser.set( elem, key, data );
			} else {
				data = undefined;
			}
		}
		return data;
	}

	jQuery.extend( {
		hasData: function( elem ) {
			return dataUser.hasData( elem ) || dataPriv.hasData( elem );
		},

		data: function( elem, name, data ) {
			return dataUser.access( elem, name, data );
		},

		removeData: function( elem, name ) {
			dataUser.remove( elem, name );
		},

		// TODO: Now that all calls to _data and _removeData have been replaced
		// with direct calls to dataPriv methods, these can be deprecated.
		_data: function( elem, name, data ) {
			return dataPriv.access( elem, name, data );
		},

		_removeData: function( elem, name ) {
			dataPriv.remove( elem, name );
		}
	} );

	jQuery.fn.extend( {
		data: function( key, value ) {
			var i, name, data,
				elem = this[ 0 ],
				attrs = elem && elem.attributes;

			// Gets all values
			if ( key === undefined ) {
				if ( this.length ) {
					data = dataUser.get( elem );

					if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
						i = attrs.length;
						while ( i-- ) {

							// Support: IE 11 only
							// The attrs elements can be null (#14894)
							if ( attrs[ i ] ) {
								name = attrs[ i ].name;
								if ( name.indexOf( "data-" ) === 0 ) {
									name = jQuery.camelCase( name.slice( 5 ) );
									dataAttr( elem, name, data[ name ] );
								}
							}
						}
						dataPriv.set( elem, "hasDataAttrs", true );
					}
				}

				return data;
			}

			// Sets multiple values
			if ( typeof key === "object" ) {
				return this.each( function() {
					dataUser.set( this, key );
				} );
			}

			return access( this, function( value ) {
				var data;

				// The calling jQuery object (element matches) is not empty
				// (and therefore has an element appears at this[ 0 ]) and the
				// `value` parameter was not undefined. An empty jQuery object
				// will result in `undefined` for elem = this[ 0 ] which will
				// throw an exception if an attempt to read a data cache is made.
				if ( elem && value === undefined ) {

					// Attempt to get data from the cache
					// The key will always be camelCased in Data
					data = dataUser.get( elem, key );
					if ( data !== undefined ) {
						return data;
					}

					// Attempt to "discover" the data in
					// HTML5 custom data-* attrs
					data = dataAttr( elem, key );
					if ( data !== undefined ) {
						return data;
					}

					// We tried really hard, but the data doesn't exist.
					return;
				}

				// Set the data...
				this.each( function() {

					// We always store the camelCased key
					dataUser.set( this, key, value );
				} );
			}, null, value, arguments.length > 1, null, true );
		},

		removeData: function( key ) {
			return this.each( function() {
				dataUser.remove( this, key );
			} );
		}
	} );


	jQuery.extend( {
		queue: function( elem, type, data ) {
			var queue;

			if ( elem ) {
				type = ( type || "fx" ) + "queue";
				queue = dataPriv.get( elem, type );

				// Speed up dequeue by getting out quickly if this is just a lookup
				if ( data ) {
					if ( !queue || jQuery.isArray( data ) ) {
						queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
					} else {
						queue.push( data );
					}
				}
				return queue || [];
			}
		},

		dequeue: function( elem, type ) {
			type = type || "fx";

			var queue = jQuery.queue( elem, type ),
				startLength = queue.length,
				fn = queue.shift(),
				hooks = jQuery._queueHooks( elem, type ),
				next = function() {
					jQuery.dequeue( elem, type );
				};

			// If the fx queue is dequeued, always remove the progress sentinel
			if ( fn === "inprogress" ) {
				fn = queue.shift();
				startLength--;
			}

			if ( fn ) {

				// Add a progress sentinel to prevent the fx queue from being
				// automatically dequeued
				if ( type === "fx" ) {
					queue.unshift( "inprogress" );
				}

				// Clear up the last queue stop function
				delete hooks.stop;
				fn.call( elem, next, hooks );
			}

			if ( !startLength && hooks ) {
				hooks.empty.fire();
			}
		},

		// Not public - generate a queueHooks object, or return the current one
		_queueHooks: function( elem, type ) {
			var key = type + "queueHooks";
			return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
				empty: jQuery.Callbacks( "once memory" ).add( function() {
					dataPriv.remove( elem, [ type + "queue", key ] );
				} )
			} );
		}
	} );

	jQuery.fn.extend( {
		queue: function( type, data ) {
			var setter = 2;

			if ( typeof type !== "string" ) {
				data = type;
				type = "fx";
				setter--;
			}

			if ( arguments.length < setter ) {
				return jQuery.queue( this[ 0 ], type );
			}

			return data === undefined ?
				this :
				this.each( function() {
					var queue = jQuery.queue( this, type, data );

					// Ensure a hooks for this queue
					jQuery._queueHooks( this, type );

					if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
						jQuery.dequeue( this, type );
					}
				} );
		},
		dequeue: function( type ) {
			return this.each( function() {
				jQuery.dequeue( this, type );
			} );
		},
		clearQueue: function( type ) {
			return this.queue( type || "fx", [] );
		},

		// Get a promise resolved when queues of a certain type
		// are emptied (fx is the type by default)
		promise: function( type, obj ) {
			var tmp,
				count = 1,
				defer = jQuery.Deferred(),
				elements = this,
				i = this.length,
				resolve = function() {
					if ( !( --count ) ) {
						defer.resolveWith( elements, [ elements ] );
					}
				};

			if ( typeof type !== "string" ) {
				obj = type;
				type = undefined;
			}
			type = type || "fx";

			while ( i-- ) {
				tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
				if ( tmp && tmp.empty ) {
					count++;
					tmp.empty.add( resolve );
				}
			}
			resolve();
			return defer.promise( obj );
		}
	} );
	var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

	var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


	var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

	var isHiddenWithinTree = function( elem, el ) {

			// isHiddenWithinTree might be called from jQuery#filter function;
			// in that case, element will be second argument
			elem = el || elem;

			// Inline style trumps all
			return elem.style.display === "none" ||
				elem.style.display === "" &&

				// Otherwise, check computed style
				// Support: Firefox <=43 - 45
				// Disconnected elements can have computed display: none, so first confirm that elem is
				// in the document.
				jQuery.contains( elem.ownerDocument, elem ) &&

				jQuery.css( elem, "display" ) === "none";
		};

	var swap = function( elem, options, callback, args ) {
		var ret, name,
			old = {};

		// Remember the old values, and insert the new ones
		for ( name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}

		ret = callback.apply( elem, args || [] );

		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}

		return ret;
	};




	function adjustCSS( elem, prop, valueParts, tween ) {
		var adjusted,
			scale = 1,
			maxIterations = 20,
			currentValue = tween ?
				function() {
					return tween.cur();
				} :
				function() {
					return jQuery.css( elem, prop, "" );
				},
			initial = currentValue(),
			unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

			// Starting value computation is required for potential unit mismatches
			initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
				rcssNum.exec( jQuery.css( elem, prop ) );

		if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

			// Trust units reported by jQuery.css
			unit = unit || initialInUnit[ 3 ];

			// Make sure we update the tween properties later on
			valueParts = valueParts || [];

			// Iteratively approximate from a nonzero starting point
			initialInUnit = +initial || 1;

			do {

				// If previous iteration zeroed out, double until we get *something*.
				// Use string for doubling so we don't accidentally see scale as unchanged below
				scale = scale || ".5";

				// Adjust and apply
				initialInUnit = initialInUnit / scale;
				jQuery.style( elem, prop, initialInUnit + unit );

			// Update scale, tolerating zero or NaN from tween.cur()
			// Break the loop if scale is unchanged or perfect, or if we've just had enough.
			} while (
				scale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations
			);
		}

		if ( valueParts ) {
			initialInUnit = +initialInUnit || +initial || 0;

			// Apply relative offset (+=/-=) if specified
			adjusted = valueParts[ 1 ] ?
				initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
				+valueParts[ 2 ];
			if ( tween ) {
				tween.unit = unit;
				tween.start = initialInUnit;
				tween.end = adjusted;
			}
		}
		return adjusted;
	}


	var defaultDisplayMap = {};

	function getDefaultDisplay( elem ) {
		var temp,
			doc = elem.ownerDocument,
			nodeName = elem.nodeName,
			display = defaultDisplayMap[ nodeName ];

		if ( display ) {
			return display;
		}

		temp = doc.body.appendChild( doc.createElement( nodeName ) );
		display = jQuery.css( temp, "display" );

		temp.parentNode.removeChild( temp );

		if ( display === "none" ) {
			display = "block";
		}
		defaultDisplayMap[ nodeName ] = display;

		return display;
	}

	function showHide( elements, show ) {
		var display, elem,
			values = [],
			index = 0,
			length = elements.length;

		// Determine new display value for elements that need to change
		for ( ; index < length; index++ ) {
			elem = elements[ index ];
			if ( !elem.style ) {
				continue;
			}

			display = elem.style.display;
			if ( show ) {

				// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
				// check is required in this first loop unless we have a nonempty display value (either
				// inline or about-to-be-restored)
				if ( display === "none" ) {
					values[ index ] = dataPriv.get( elem, "display" ) || null;
					if ( !values[ index ] ) {
						elem.style.display = "";
					}
				}
				if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
					values[ index ] = getDefaultDisplay( elem );
				}
			} else {
				if ( display !== "none" ) {
					values[ index ] = "none";

					// Remember what we're overwriting
					dataPriv.set( elem, "display", display );
				}
			}
		}

		// Set the display of the elements in a second loop to avoid constant reflow
		for ( index = 0; index < length; index++ ) {
			if ( values[ index ] != null ) {
				elements[ index ].style.display = values[ index ];
			}
		}

		return elements;
	}

	jQuery.fn.extend( {
		show: function() {
			return showHide( this, true );
		},
		hide: function() {
			return showHide( this );
		},
		toggle: function( state ) {
			if ( typeof state === "boolean" ) {
				return state ? this.show() : this.hide();
			}

			return this.each( function() {
				if ( isHiddenWithinTree( this ) ) {
					jQuery( this ).show();
				} else {
					jQuery( this ).hide();
				}
			} );
		}
	} );
	var rcheckableType = ( /^(?:checkbox|radio)$/i );

	var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]+)/i );

	var rscriptType = ( /^$|\/(?:java|ecma)script/i );



	// We have to close these tags to support XHTML (#13200)
	var wrapMap = {

		// Support: IE <=9 only
		option: [ 1, "<select multiple='multiple'>", "</select>" ],

		// XHTML parsers do not magically insert elements in the
		// same way that tag soup parsers do. So we cannot shorten
		// this by omitting <tbody> or other required elements.
		thead: [ 1, "<table>", "</table>" ],
		col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

		_default: [ 0, "", "" ]
	};

	// Support: IE <=9 only
	wrapMap.optgroup = wrapMap.option;

	wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
	wrapMap.th = wrapMap.td;


	function getAll( context, tag ) {

		// Support: IE <=9 - 11 only
		// Use typeof to avoid zero-argument method invocation on host objects (#15151)
		var ret;

		if ( typeof context.getElementsByTagName !== "undefined" ) {
			ret = context.getElementsByTagName( tag || "*" );

		} else if ( typeof context.querySelectorAll !== "undefined" ) {
			ret = context.querySelectorAll( tag || "*" );

		} else {
			ret = [];
		}

		if ( tag === undefined || tag && jQuery.nodeName( context, tag ) ) {
			return jQuery.merge( [ context ], ret );
		}

		return ret;
	}


	// Mark scripts as having already been evaluated
	function setGlobalEval( elems, refElements ) {
		var i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			dataPriv.set(
				elems[ i ],
				"globalEval",
				!refElements || dataPriv.get( refElements[ i ], "globalEval" )
			);
		}
	}


	var rhtml = /<|&#?\w+;/;

	function buildFragment( elems, context, scripts, selection, ignored ) {
		var elem, tmp, tag, wrap, contains, j,
			fragment = context.createDocumentFragment(),
			nodes = [],
			i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			elem = elems[ i ];

			if ( elem || elem === 0 ) {

				// Add nodes directly
				if ( jQuery.type( elem ) === "object" ) {

					// Support: Android <=4.0 only, PhantomJS 1 only
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );

				// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

					// Deserialize a standard representation
					tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;
					tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

					// Descend through wrappers to the right content
					j = wrap[ 0 ];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}

					// Support: Android <=4.0 only, PhantomJS 1 only
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, tmp.childNodes );

					// Remember the top-level container
					tmp = fragment.firstChild;

					// Ensure the created nodes are orphaned (#12392)
					tmp.textContent = "";
				}
			}
		}

		// Remove wrapper from fragment
		fragment.textContent = "";

		i = 0;
		while ( ( elem = nodes[ i++ ] ) ) {

			// Skip elements already in the context collection (trac-4087)
			if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
				if ( ignored ) {
					ignored.push( elem );
				}
				continue;
			}

			contains = jQuery.contains( elem.ownerDocument, elem );

			// Append to fragment
			tmp = getAll( fragment.appendChild( elem ), "script" );

			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}

			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( ( elem = tmp[ j++ ] ) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}

		return fragment;
	}


	( function() {
		var fragment = document.createDocumentFragment(),
			div = fragment.appendChild( document.createElement( "div" ) ),
			input = document.createElement( "input" );

		// Support: Android 4.0 - 4.3 only
		// Check state lost if the name is set (#11217)
		// Support: Windows Web Apps (WWA)
		// `name` and `type` must use .setAttribute for WWA (#14901)
		input.setAttribute( "type", "radio" );
		input.setAttribute( "checked", "checked" );
		input.setAttribute( "name", "t" );

		div.appendChild( input );

		// Support: Android <=4.1 only
		// Older WebKit doesn't clone checked state correctly in fragments
		support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

		// Support: IE <=11 only
		// Make sure textarea (and checkbox) defaultValue is properly cloned
		div.innerHTML = "<textarea>x</textarea>";
		support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
	} )();
	var documentElement = document.documentElement;



	var
		rkeyEvent = /^key/,
		rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
		rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

	function returnTrue() {
		return true;
	}

	function returnFalse() {
		return false;
	}

	// Support: IE <=9 only
	// See #13393 for more info
	function safeActiveElement() {
		try {
			return document.activeElement;
		} catch ( err ) { }
	}

	function on( elem, types, selector, data, fn, one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {

			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {

				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				on( elem, type, selector, data, types[ type ], one );
			}
			return elem;
		}

		if ( data == null && fn == null ) {

			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {

				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {

				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return elem;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {

				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};

			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return elem.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		} );
	}

	/*
	 * Helper functions for managing events -- not part of the public interface.
	 * Props to Dean Edwards' addEvent library for many of the ideas.
	 */
	jQuery.event = {

		global: {},

		add: function( elem, types, handler, data, selector ) {

			var handleObjIn, eventHandle, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.get( elem );

			// Don't attach events to noData or text/comment nodes (but allow plain objects)
			if ( !elemData ) {
				return;
			}

			// Caller can pass in an object of custom data in lieu of the handler
			if ( handler.handler ) {
				handleObjIn = handler;
				handler = handleObjIn.handler;
				selector = handleObjIn.selector;
			}

			// Ensure that invalid selectors throw exceptions at attach time
			// Evaluate against documentElement in case elem is a non-element node (e.g., document)
			if ( selector ) {
				jQuery.find.matchesSelector( documentElement, selector );
			}

			// Make sure that the handler has a unique ID, used to find/remove it later
			if ( !handler.guid ) {
				handler.guid = jQuery.guid++;
			}

			// Init the element's event structure and main handler, if this is the first
			if ( !( events = elemData.events ) ) {
				events = elemData.events = {};
			}
			if ( !( eventHandle = elemData.handle ) ) {
				eventHandle = elemData.handle = function( e ) {

					// Discard the second event of a jQuery.event.trigger() and
					// when an event is called after a page has unloaded
					return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
						jQuery.event.dispatch.apply( elem, arguments ) : undefined;
				};
			}

			// Handle multiple events separated by a space
			types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

				// There *must* be a type, no attaching namespace-only handlers
				if ( !type ) {
					continue;
				}

				// If event changes its type, use the special event handlers for the changed type
				special = jQuery.event.special[ type ] || {};

				// If selector defined, determine special event api type, otherwise given type
				type = ( selector ? special.delegateType : special.bindType ) || type;

				// Update special based on newly reset type
				special = jQuery.event.special[ type ] || {};

				// handleObj is passed to all event handlers
				handleObj = jQuery.extend( {
					type: type,
					origType: origType,
					data: data,
					handler: handler,
					guid: handler.guid,
					selector: selector,
					needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
					namespace: namespaces.join( "." )
				}, handleObjIn );

				// Init the event handler queue if we're the first
				if ( !( handlers = events[ type ] ) ) {
					handlers = events[ type ] = [];
					handlers.delegateCount = 0;

					// Only use addEventListener if the special events handler returns false
					if ( !special.setup ||
						special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

						if ( elem.addEventListener ) {
							elem.addEventListener( type, eventHandle );
						}
					}
				}

				if ( special.add ) {
					special.add.call( elem, handleObj );

					if ( !handleObj.handler.guid ) {
						handleObj.handler.guid = handler.guid;
					}
				}

				// Add to the element's handler list, delegates in front
				if ( selector ) {
					handlers.splice( handlers.delegateCount++, 0, handleObj );
				} else {
					handlers.push( handleObj );
				}

				// Keep track of which events have ever been used, for event optimization
				jQuery.event.global[ type ] = true;
			}

		},

		// Detach an event or set of events from an element
		remove: function( elem, types, handler, selector, mappedTypes ) {

			var j, origCount, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

			if ( !elemData || !( events = elemData.events ) ) {
				return;
			}

			// Once for each type.namespace in types; type may be omitted
			types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

				// Unbind all events (on this namespace, if provided) for the element
				if ( !type ) {
					for ( type in events ) {
						jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
					}
					continue;
				}

				special = jQuery.event.special[ type ] || {};
				type = ( selector ? special.delegateType : special.bindType ) || type;
				handlers = events[ type ] || [];
				tmp = tmp[ 2 ] &&
					new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

				// Remove matching events
				origCount = j = handlers.length;
				while ( j-- ) {
					handleObj = handlers[ j ];

					if ( ( mappedTypes || origType === handleObj.origType ) &&
						( !handler || handler.guid === handleObj.guid ) &&
						( !tmp || tmp.test( handleObj.namespace ) ) &&
						( !selector || selector === handleObj.selector ||
							selector === "**" && handleObj.selector ) ) {
						handlers.splice( j, 1 );

						if ( handleObj.selector ) {
							handlers.delegateCount--;
						}
						if ( special.remove ) {
							special.remove.call( elem, handleObj );
						}
					}
				}

				// Remove generic event handler if we removed something and no more handlers exist
				// (avoids potential for endless recursion during removal of special event handlers)
				if ( origCount && !handlers.length ) {
					if ( !special.teardown ||
						special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

						jQuery.removeEvent( elem, type, elemData.handle );
					}

					delete events[ type ];
				}
			}

			// Remove data and the expando if it's no longer used
			if ( jQuery.isEmptyObject( events ) ) {
				dataPriv.remove( elem, "handle events" );
			}
		},

		dispatch: function( nativeEvent ) {

			// Make a writable jQuery.Event from the native event object
			var event = jQuery.event.fix( nativeEvent );

			var i, j, ret, matched, handleObj, handlerQueue,
				args = new Array( arguments.length ),
				handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
				special = jQuery.event.special[ event.type ] || {};

			// Use the fix-ed jQuery.Event rather than the (read-only) native event
			args[ 0 ] = event;

			for ( i = 1; i < arguments.length; i++ ) {
				args[ i ] = arguments[ i ];
			}

			event.delegateTarget = this;

			// Call the preDispatch hook for the mapped type, and let it bail if desired
			if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
				return;
			}

			// Determine handlers
			handlerQueue = jQuery.event.handlers.call( this, event, handlers );

			// Run delegates first; they may want to stop propagation beneath us
			i = 0;
			while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
				event.currentTarget = matched.elem;

				j = 0;
				while ( ( handleObj = matched.handlers[ j++ ] ) &&
					!event.isImmediatePropagationStopped() ) {

					// Triggered event must either 1) have no namespace, or 2) have namespace(s)
					// a subset or equal to those in the bound event (both can have no namespace).
					if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

						event.handleObj = handleObj;
						event.data = handleObj.data;

						ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
							handleObj.handler ).apply( matched.elem, args );

						if ( ret !== undefined ) {
							if ( ( event.result = ret ) === false ) {
								event.preventDefault();
								event.stopPropagation();
							}
						}
					}
				}
			}

			// Call the postDispatch hook for the mapped type
			if ( special.postDispatch ) {
				special.postDispatch.call( this, event );
			}

			return event.result;
		},

		handlers: function( event, handlers ) {
			var i, handleObj, sel, matchedHandlers, matchedSelectors,
				handlerQueue = [],
				delegateCount = handlers.delegateCount,
				cur = event.target;

			// Find delegate handlers
			if ( delegateCount &&

				// Support: IE <=9
				// Black-hole SVG <use> instance trees (trac-13180)
				cur.nodeType &&

				// Support: Firefox <=42
				// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
				// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
				// Support: IE 11 only
				// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
				!( event.type === "click" && event.button >= 1 ) ) {

				for ( ; cur !== this; cur = cur.parentNode || this ) {

					// Don't check non-elements (#13208)
					// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
					if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
						matchedHandlers = [];
						matchedSelectors = {};
						for ( i = 0; i < delegateCount; i++ ) {
							handleObj = handlers[ i ];

							// Don't conflict with Object.prototype properties (#13203)
							sel = handleObj.selector + " ";

							if ( matchedSelectors[ sel ] === undefined ) {
								matchedSelectors[ sel ] = handleObj.needsContext ?
									jQuery( sel, this ).index( cur ) > -1 :
									jQuery.find( sel, this, null, [ cur ] ).length;
							}
							if ( matchedSelectors[ sel ] ) {
								matchedHandlers.push( handleObj );
							}
						}
						if ( matchedHandlers.length ) {
							handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
						}
					}
				}
			}

			// Add the remaining (directly-bound) handlers
			cur = this;
			if ( delegateCount < handlers.length ) {
				handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
			}

			return handlerQueue;
		},

		addProp: function( name, hook ) {
			Object.defineProperty( jQuery.Event.prototype, name, {
				enumerable: true,
				configurable: true,

				get: jQuery.isFunction( hook ) ?
					function() {
						if ( this.originalEvent ) {
								return hook( this.originalEvent );
						}
					} :
					function() {
						if ( this.originalEvent ) {
								return this.originalEvent[ name ];
						}
					},

				set: function( value ) {
					Object.defineProperty( this, name, {
						enumerable: true,
						configurable: true,
						writable: true,
						value: value
					} );
				}
			} );
		},

		fix: function( originalEvent ) {
			return originalEvent[ jQuery.expando ] ?
				originalEvent :
				new jQuery.Event( originalEvent );
		},

		special: {
			load: {

				// Prevent triggered image.load events from bubbling to window.load
				noBubble: true
			},
			focus: {

				// Fire native event if possible so blur/focus sequence is correct
				trigger: function() {
					if ( this !== safeActiveElement() && this.focus ) {
						this.focus();
						return false;
					}
				},
				delegateType: "focusin"
			},
			blur: {
				trigger: function() {
					if ( this === safeActiveElement() && this.blur ) {
						this.blur();
						return false;
					}
				},
				delegateType: "focusout"
			},
			click: {

				// For checkbox, fire native event so checked state will be right
				trigger: function() {
					if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
						this.click();
						return false;
					}
				},

				// For cross-browser consistency, don't fire native .click() on links
				_default: function( event ) {
					return jQuery.nodeName( event.target, "a" );
				}
			},

			beforeunload: {
				postDispatch: function( event ) {

					// Support: Firefox 20+
					// Firefox doesn't alert if the returnValue field is not set.
					if ( event.result !== undefined && event.originalEvent ) {
						event.originalEvent.returnValue = event.result;
					}
				}
			}
		}
	};

	jQuery.removeEvent = function( elem, type, handle ) {

		// This "if" is needed for plain objects
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle );
		}
	};

	jQuery.Event = function( src, props ) {

		// Allow instantiation without the 'new' keyword
		if ( !( this instanceof jQuery.Event ) ) {
			return new jQuery.Event( src, props );
		}

		// Event object
		if ( src && src.type ) {
			this.originalEvent = src;
			this.type = src.type;

			// Events bubbling up the document may have been marked as prevented
			// by a handler lower down the tree; reflect the correct value.
			this.isDefaultPrevented = src.defaultPrevented ||
					src.defaultPrevented === undefined &&

					// Support: Android <=2.3 only
					src.returnValue === false ?
				returnTrue :
				returnFalse;

			// Create target properties
			// Support: Safari <=6 - 7 only
			// Target should not be a text node (#504, #13143)
			this.target = ( src.target && src.target.nodeType === 3 ) ?
				src.target.parentNode :
				src.target;

			this.currentTarget = src.currentTarget;
			this.relatedTarget = src.relatedTarget;

		// Event type
		} else {
			this.type = src;
		}

		// Put explicitly provided properties onto the event object
		if ( props ) {
			jQuery.extend( this, props );
		}

		// Create a timestamp if incoming event doesn't have one
		this.timeStamp = src && src.timeStamp || jQuery.now();

		// Mark it as fixed
		this[ jQuery.expando ] = true;
	};

	// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
	// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
	jQuery.Event.prototype = {
		constructor: jQuery.Event,
		isDefaultPrevented: returnFalse,
		isPropagationStopped: returnFalse,
		isImmediatePropagationStopped: returnFalse,
		isSimulated: false,

		preventDefault: function() {
			var e = this.originalEvent;

			this.isDefaultPrevented = returnTrue;

			if ( e && !this.isSimulated ) {
				e.preventDefault();
			}
		},
		stopPropagation: function() {
			var e = this.originalEvent;

			this.isPropagationStopped = returnTrue;

			if ( e && !this.isSimulated ) {
				e.stopPropagation();
			}
		},
		stopImmediatePropagation: function() {
			var e = this.originalEvent;

			this.isImmediatePropagationStopped = returnTrue;

			if ( e && !this.isSimulated ) {
				e.stopImmediatePropagation();
			}

			this.stopPropagation();
		}
	};

	// Includes all common event props including KeyEvent and MouseEvent specific props
	jQuery.each( {
		altKey: true,
		bubbles: true,
		cancelable: true,
		changedTouches: true,
		ctrlKey: true,
		detail: true,
		eventPhase: true,
		metaKey: true,
		pageX: true,
		pageY: true,
		shiftKey: true,
		view: true,
		"char": true,
		charCode: true,
		key: true,
		keyCode: true,
		button: true,
		buttons: true,
		clientX: true,
		clientY: true,
		offsetX: true,
		offsetY: true,
		pointerId: true,
		pointerType: true,
		screenX: true,
		screenY: true,
		targetTouches: true,
		toElement: true,
		touches: true,

		which: function( event ) {
			var button = event.button;

			// Add which for key events
			if ( event.which == null && rkeyEvent.test( event.type ) ) {
				return event.charCode != null ? event.charCode : event.keyCode;
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
				if ( button & 1 ) {
					return 1;
				}

				if ( button & 2 ) {
					return 3;
				}

				if ( button & 4 ) {
					return 2;
				}

				return 0;
			}

			return event.which;
		}
	}, jQuery.event.addProp );

	// Create mouseenter/leave events using mouseover/out and event-time checks
	// so that event delegation works in jQuery.
	// Do the same for pointerenter/pointerleave and pointerover/pointerout
	//
	// Support: Safari 7 only
	// Safari sends mouseenter too often; see:
	// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
	// for the description of the bug (it existed in older Chrome versions as well).
	jQuery.each( {
		mouseenter: "mouseover",
		mouseleave: "mouseout",
		pointerenter: "pointerover",
		pointerleave: "pointerout"
	}, function( orig, fix ) {
		jQuery.event.special[ orig ] = {
			delegateType: fix,
			bindType: fix,

			handle: function( event ) {
				var ret,
					target = this,
					related = event.relatedTarget,
					handleObj = event.handleObj;

				// For mouseenter/leave call the handler if related is outside the target.
				// NB: No relatedTarget if the mouse left/entered the browser window
				if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
					event.type = handleObj.origType;
					ret = handleObj.handler.apply( this, arguments );
					event.type = fix;
				}
				return ret;
			}
		};
	} );

	jQuery.fn.extend( {

		on: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn );
		},
		one: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn, 1 );
		},
		off: function( types, selector, fn ) {
			var handleObj, type;
			if ( types && types.preventDefault && types.handleObj ) {

				// ( event )  dispatched jQuery.Event
				handleObj = types.handleObj;
				jQuery( types.delegateTarget ).off(
					handleObj.namespace ?
						handleObj.origType + "." + handleObj.namespace :
						handleObj.origType,
					handleObj.selector,
					handleObj.handler
				);
				return this;
			}
			if ( typeof types === "object" ) {

				// ( types-object [, selector] )
				for ( type in types ) {
					this.off( type, selector, types[ type ] );
				}
				return this;
			}
			if ( selector === false || typeof selector === "function" ) {

				// ( types [, fn] )
				fn = selector;
				selector = undefined;
			}
			if ( fn === false ) {
				fn = returnFalse;
			}
			return this.each( function() {
				jQuery.event.remove( this, types, fn, selector );
			} );
		}
	} );


	var

		/* eslint-disable max-len */

		// See https://github.com/eslint/eslint/issues/3229
		rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

		/* eslint-enable */

		// Support: IE <=10 - 11, Edge 12 - 13
		// In IE/Edge using regex groups here causes severe slowdowns.
		// See https://connect.microsoft.com/IE/feedback/details/1736512/
		rnoInnerhtml = /<script|<style|<link/i,

		// checked="checked" or checked
		rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
		rscriptTypeMasked = /^true\/(.*)/,
		rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

	function manipulationTarget( elem, content ) {
		if ( jQuery.nodeName( elem, "table" ) &&
			jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

			return elem.getElementsByTagName( "tbody" )[ 0 ] || elem;
		}

		return elem;
	}

	// Replace/restore the type attribute of script elements for safe DOM manipulation
	function disableScript( elem ) {
		elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
		return elem;
	}
	function restoreScript( elem ) {
		var match = rscriptTypeMasked.exec( elem.type );

		if ( match ) {
			elem.type = match[ 1 ];
		} else {
			elem.removeAttribute( "type" );
		}

		return elem;
	}

	function cloneCopyEvent( src, dest ) {
		var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

		if ( dest.nodeType !== 1 ) {
			return;
		}

		// 1. Copy private data: events, handlers, etc.
		if ( dataPriv.hasData( src ) ) {
			pdataOld = dataPriv.access( src );
			pdataCur = dataPriv.set( dest, pdataOld );
			events = pdataOld.events;

			if ( events ) {
				delete pdataCur.handle;
				pdataCur.events = {};

				for ( type in events ) {
					for ( i = 0, l = events[ type ].length; i < l; i++ ) {
						jQuery.event.add( dest, type, events[ type ][ i ] );
					}
				}
			}
		}

		// 2. Copy user data
		if ( dataUser.hasData( src ) ) {
			udataOld = dataUser.access( src );
			udataCur = jQuery.extend( {}, udataOld );

			dataUser.set( dest, udataCur );
		}
	}

	// Fix IE bugs, see support tests
	function fixInput( src, dest ) {
		var nodeName = dest.nodeName.toLowerCase();

		// Fails to persist the checked state of a cloned checkbox or radio button.
		if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
			dest.checked = src.checked;

		// Fails to return the selected option to the default selected state when cloning options
		} else if ( nodeName === "input" || nodeName === "textarea" ) {
			dest.defaultValue = src.defaultValue;
		}
	}

	function domManip( collection, args, callback, ignored ) {

		// Flatten any nested arrays
		args = concat.apply( [], args );

		var fragment, first, scripts, hasScripts, node, doc,
			i = 0,
			l = collection.length,
			iNoClone = l - 1,
			value = args[ 0 ],
			isFunction = jQuery.isFunction( value );

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( isFunction ||
				( l > 1 && typeof value === "string" &&
					!support.checkClone && rchecked.test( value ) ) ) {
			return collection.each( function( index ) {
				var self = collection.eq( index );
				if ( isFunction ) {
					args[ 0 ] = value.call( this, index, self.html() );
				}
				domManip( self, args, callback, ignored );
			} );
		}

		if ( l ) {
			fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			// Require either new content or an interest in ignored elements to invoke the callback
			if ( first || ignored ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;

				// Use the original fragment for the last item
				// instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;

					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );

						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {

							// Support: Android <=4.0 only, PhantomJS 1 only
							// push.apply(_, arraylike) throws on ancient WebKit
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}

					callback.call( collection[ i ], node, i );
				}

				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;

					// Reenable scripts
					jQuery.map( scripts, restoreScript );

					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!dataPriv.access( node, "globalEval" ) &&
							jQuery.contains( doc, node ) ) {

							if ( node.src ) {

								// Optional AJAX dependency, but won't run scripts if not present
								if ( jQuery._evalUrl ) {
									jQuery._evalUrl( node.src );
								}
							} else {
								DOMEval( node.textContent.replace( rcleanScript, "" ), doc );
							}
						}
					}
				}
			}
		}

		return collection;
	}

	function remove( elem, selector, keepData ) {
		var node,
			nodes = selector ? jQuery.filter( selector, elem ) : elem,
			i = 0;

		for ( ; ( node = nodes[ i ] ) != null; i++ ) {
			if ( !keepData && node.nodeType === 1 ) {
				jQuery.cleanData( getAll( node ) );
			}

			if ( node.parentNode ) {
				if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
					setGlobalEval( getAll( node, "script" ) );
				}
				node.parentNode.removeChild( node );
			}
		}

		return elem;
	}

	jQuery.extend( {
		htmlPrefilter: function( html ) {
			return html.replace( rxhtmlTag, "<$1></$2>" );
		},

		clone: function( elem, dataAndEvents, deepDataAndEvents ) {
			var i, l, srcElements, destElements,
				clone = elem.cloneNode( true ),
				inPage = jQuery.contains( elem.ownerDocument, elem );

			// Fix IE cloning issues
			if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
					!jQuery.isXMLDoc( elem ) ) {

				// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
				destElements = getAll( clone );
				srcElements = getAll( elem );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					fixInput( srcElements[ i ], destElements[ i ] );
				}
			}

			// Copy the events from the original to the clone
			if ( dataAndEvents ) {
				if ( deepDataAndEvents ) {
					srcElements = srcElements || getAll( elem );
					destElements = destElements || getAll( clone );

					for ( i = 0, l = srcElements.length; i < l; i++ ) {
						cloneCopyEvent( srcElements[ i ], destElements[ i ] );
					}
				} else {
					cloneCopyEvent( elem, clone );
				}
			}

			// Preserve script evaluation history
			destElements = getAll( clone, "script" );
			if ( destElements.length > 0 ) {
				setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
			}

			// Return the cloned set
			return clone;
		},

		cleanData: function( elems ) {
			var data, elem, type,
				special = jQuery.event.special,
				i = 0;

			for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
				if ( acceptData( elem ) ) {
					if ( ( data = elem[ dataPriv.expando ] ) ) {
						if ( data.events ) {
							for ( type in data.events ) {
								if ( special[ type ] ) {
									jQuery.event.remove( elem, type );

								// This is a shortcut to avoid jQuery.event.remove's overhead
								} else {
									jQuery.removeEvent( elem, type, data.handle );
								}
							}
						}

						// Support: Chrome <=35 - 45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataPriv.expando ] = undefined;
					}
					if ( elem[ dataUser.expando ] ) {

						// Support: Chrome <=35 - 45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataUser.expando ] = undefined;
					}
				}
			}
		}
	} );

	jQuery.fn.extend( {
		detach: function( selector ) {
			return remove( this, selector, true );
		},

		remove: function( selector ) {
			return remove( this, selector );
		},

		text: function( value ) {
			return access( this, function( value ) {
				return value === undefined ?
					jQuery.text( this ) :
					this.empty().each( function() {
						if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
							this.textContent = value;
						}
					} );
			}, null, value, arguments.length );
		},

		append: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.appendChild( elem );
				}
			} );
		},

		prepend: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.insertBefore( elem, target.firstChild );
				}
			} );
		},

		before: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this );
				}
			} );
		},

		after: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this.nextSibling );
				}
			} );
		},

		empty: function() {
			var elem,
				i = 0;

			for ( ; ( elem = this[ i ] ) != null; i++ ) {
				if ( elem.nodeType === 1 ) {

					// Prevent memory leaks
					jQuery.cleanData( getAll( elem, false ) );

					// Remove any remaining nodes
					elem.textContent = "";
				}
			}

			return this;
		},

		clone: function( dataAndEvents, deepDataAndEvents ) {
			dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
			deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

			return this.map( function() {
				return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
			} );
		},

		html: function( value ) {
			return access( this, function( value ) {
				var elem = this[ 0 ] || {},
					i = 0,
					l = this.length;

				if ( value === undefined && elem.nodeType === 1 ) {
					return elem.innerHTML;
				}

				// See if we can take a shortcut and just use innerHTML
				if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
					!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

					value = jQuery.htmlPrefilter( value );

					try {
						for ( ; i < l; i++ ) {
							elem = this[ i ] || {};

							// Remove element nodes and prevent memory leaks
							if ( elem.nodeType === 1 ) {
								jQuery.cleanData( getAll( elem, false ) );
								elem.innerHTML = value;
							}
						}

						elem = 0;

					// If using innerHTML throws an exception, use the fallback method
					} catch ( e ) {}
				}

				if ( elem ) {
					this.empty().append( value );
				}
			}, null, value, arguments.length );
		},

		replaceWith: function() {
			var ignored = [];

			// Make the changes, replacing each non-ignored context element with the new content
			return domManip( this, arguments, function( elem ) {
				var parent = this.parentNode;

				if ( jQuery.inArray( this, ignored ) < 0 ) {
					jQuery.cleanData( getAll( this ) );
					if ( parent ) {
						parent.replaceChild( elem, this );
					}
				}

			// Force callback invocation
			}, ignored );
		}
	} );

	jQuery.each( {
		appendTo: "append",
		prependTo: "prepend",
		insertBefore: "before",
		insertAfter: "after",
		replaceAll: "replaceWith"
	}, function( name, original ) {
		jQuery.fn[ name ] = function( selector ) {
			var elems,
				ret = [],
				insert = jQuery( selector ),
				last = insert.length - 1,
				i = 0;

			for ( ; i <= last; i++ ) {
				elems = i === last ? this : this.clone( true );
				jQuery( insert[ i ] )[ original ]( elems );

				// Support: Android <=4.0 only, PhantomJS 1 only
				// .get() because push.apply(_, arraylike) throws on ancient WebKit
				push.apply( ret, elems.get() );
			}

			return this.pushStack( ret );
		};
	} );
	var rmargin = ( /^margin/ );

	var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

	var getStyles = function( elem ) {

			// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
			// IE throws on elements created in popups
			// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
			var view = elem.ownerDocument.defaultView;

			if ( !view || !view.opener ) {
				view = window;
			}

			return view.getComputedStyle( elem );
		};



	( function() {

		// Executing both pixelPosition & boxSizingReliable tests require only one layout
		// so they're executed at the same time to save the second computation.
		function computeStyleTests() {

			// This is a singleton, we need to execute it only once
			if ( !div ) {
				return;
			}

			div.style.cssText =
				"box-sizing:border-box;" +
				"position:relative;display:block;" +
				"margin:auto;border:1px;padding:1px;" +
				"top:1%;width:50%";
			div.innerHTML = "";
			documentElement.appendChild( container );

			var divStyle = window.getComputedStyle( div );
			pixelPositionVal = divStyle.top !== "1%";

			// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
			reliableMarginLeftVal = divStyle.marginLeft === "2px";
			boxSizingReliableVal = divStyle.width === "4px";

			// Support: Android 4.0 - 4.3 only
			// Some styles come back with percentage values, even though they shouldn't
			div.style.marginRight = "50%";
			pixelMarginRightVal = divStyle.marginRight === "4px";

			documentElement.removeChild( container );

			// Nullify the div so it wouldn't be stored in the memory and
			// it will also be a sign that checks already performed
			div = null;
		}

		var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,
			container = document.createElement( "div" ),
			div = document.createElement( "div" );

		// Finish early in limited (non-browser) environments
		if ( !div.style ) {
			return;
		}

		// Support: IE <=9 - 11 only
		// Style of cloned element affects source element cloned (#8908)
		div.style.backgroundClip = "content-box";
		div.cloneNode( true ).style.backgroundClip = "";
		support.clearCloneStyle = div.style.backgroundClip === "content-box";

		container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
			"padding:0;margin-top:1px;position:absolute";
		container.appendChild( div );

		jQuery.extend( support, {
			pixelPosition: function() {
				computeStyleTests();
				return pixelPositionVal;
			},
			boxSizingReliable: function() {
				computeStyleTests();
				return boxSizingReliableVal;
			},
			pixelMarginRight: function() {
				computeStyleTests();
				return pixelMarginRightVal;
			},
			reliableMarginLeft: function() {
				computeStyleTests();
				return reliableMarginLeftVal;
			}
		} );
	} )();


	function curCSS( elem, name, computed ) {
		var width, minWidth, maxWidth, ret,
			style = elem.style;

		computed = computed || getStyles( elem );

		// Support: IE <=9 only
		// getPropertyValue is only needed for .css('filter') (#12537)
		if ( computed ) {
			ret = computed.getPropertyValue( name ) || computed[ name ];

			if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
				ret = jQuery.style( elem, name );
			}

			// A tribute to the "awesome hack by Dean Edwards"
			// Android Browser returns percentage for some values,
			// but width seems to be reliably pixels.
			// This is against the CSSOM draft spec:
			// https://drafts.csswg.org/cssom/#resolved-values
			if ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {

				// Remember the original values
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;

				// Put in the new values to get a computed value out
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;

				// Revert the changed values
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}

		return ret !== undefined ?

			// Support: IE <=9 - 11 only
			// IE returns zIndex value as an integer.
			ret + "" :
			ret;
	}


	function addGetHookIf( conditionFn, hookFn ) {

		// Define the hook, we'll check on the first run if it's really needed.
		return {
			get: function() {
				if ( conditionFn() ) {

					// Hook not needed (or it's not possible to use it due
					// to missing dependency), remove it.
					delete this.get;
					return;
				}

				// Hook needed; redefine it so that the support test is not executed again.
				return ( this.get = hookFn ).apply( this, arguments );
			}
		};
	}


	var

		// Swappable if display is none or starts with table
		// except "table", "table-cell", or "table-caption"
		// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
		rdisplayswap = /^(none|table(?!-c[ea]).+)/,
		cssShow = { position: "absolute", visibility: "hidden", display: "block" },
		cssNormalTransform = {
			letterSpacing: "0",
			fontWeight: "400"
		},

		cssPrefixes = [ "Webkit", "Moz", "ms" ],
		emptyStyle = document.createElement( "div" ).style;

	// Return a css property mapped to a potentially vendor prefixed property
	function vendorPropName( name ) {

		// Shortcut for names that are not vendor prefixed
		if ( name in emptyStyle ) {
			return name;
		}

		// Check for vendor prefixed names
		var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
			i = cssPrefixes.length;

		while ( i-- ) {
			name = cssPrefixes[ i ] + capName;
			if ( name in emptyStyle ) {
				return name;
			}
		}
	}

	function setPositiveNumber( elem, value, subtract ) {

		// Any relative (+/-) values have already been
		// normalized at this point
		var matches = rcssNum.exec( value );
		return matches ?

			// Guard against undefined "subtract", e.g., when used as in cssHooks
			Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
			value;
	}

	function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
		var i,
			val = 0;

		// If we already have the right measurement, avoid augmentation
		if ( extra === ( isBorderBox ? "border" : "content" ) ) {
			i = 4;

		// Otherwise initialize for horizontal or vertical properties
		} else {
			i = name === "width" ? 1 : 0;
		}

		for ( ; i < 4; i += 2 ) {

			// Both box models exclude margin, so add it if we want it
			if ( extra === "margin" ) {
				val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
			}

			if ( isBorderBox ) {

				// border-box includes padding, so remove it if we want content
				if ( extra === "content" ) {
					val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
				}

				// At this point, extra isn't border nor margin, so remove border
				if ( extra !== "margin" ) {
					val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			} else {

				// At this point, extra isn't content, so add padding
				val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

				// At this point, extra isn't content nor padding, so add border
				if ( extra !== "padding" ) {
					val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			}
		}

		return val;
	}

	function getWidthOrHeight( elem, name, extra ) {

		// Start with offset property, which is equivalent to the border-box value
		var val,
			valueIsBorderBox = true,
			styles = getStyles( elem ),
			isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Support: IE <=11 only
		// Running getBoundingClientRect on a disconnected node
		// in IE throws an error.
		if ( elem.getClientRects().length ) {
			val = elem.getBoundingClientRect()[ name ];
		}

		// Some non-html elements return undefined for offsetWidth, so check for null/undefined
		// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
		// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
		if ( val <= 0 || val == null ) {

			// Fall back to computed then uncomputed css if necessary
			val = curCSS( elem, name, styles );
			if ( val < 0 || val == null ) {
				val = elem.style[ name ];
			}

			// Computed unit is not pixels. Stop here and return.
			if ( rnumnonpx.test( val ) ) {
				return val;
			}

			// Check for style in case a browser which returns unreliable values
			// for getComputedStyle silently falls back to the reliable elem.style
			valueIsBorderBox = isBorderBox &&
				( support.boxSizingReliable() || val === elem.style[ name ] );

			// Normalize "", auto, and prepare for extra
			val = parseFloat( val ) || 0;
		}

		// Use the active box-sizing model to add/subtract irrelevant styles
		return ( val +
			augmentWidthOrHeight(
				elem,
				name,
				extra || ( isBorderBox ? "border" : "content" ),
				valueIsBorderBox,
				styles
			)
		) + "px";
	}

	jQuery.extend( {

		// Add in style property hooks for overriding the default
		// behavior of getting and setting a style property
		cssHooks: {
			opacity: {
				get: function( elem, computed ) {
					if ( computed ) {

						// We should always get a number back from opacity
						var ret = curCSS( elem, "opacity" );
						return ret === "" ? "1" : ret;
					}
				}
			}
		},

		// Don't automatically add "px" to these possibly-unitless properties
		cssNumber: {
			"animationIterationCount": true,
			"columnCount": true,
			"fillOpacity": true,
			"flexGrow": true,
			"flexShrink": true,
			"fontWeight": true,
			"lineHeight": true,
			"opacity": true,
			"order": true,
			"orphans": true,
			"widows": true,
			"zIndex": true,
			"zoom": true
		},

		// Add in properties whose names you wish to fix before
		// setting or getting the value
		cssProps: {
			"float": "cssFloat"
		},

		// Get and set the style property on a DOM Node
		style: function( elem, name, value, extra ) {

			// Don't set styles on text and comment nodes
			if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
				return;
			}

			// Make sure that we're working with the right name
			var ret, type, hooks,
				origName = jQuery.camelCase( name ),
				style = elem.style;

			name = jQuery.cssProps[ origName ] ||
				( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

			// Gets hook for the prefixed version, then unprefixed version
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

			// Check if we're setting a value
			if ( value !== undefined ) {
				type = typeof value;

				// Convert "+=" or "-=" to relative numbers (#7345)
				if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
					value = adjustCSS( elem, name, ret );

					// Fixes bug #9237
					type = "number";
				}

				// Make sure that null and NaN values aren't set (#7116)
				if ( value == null || value !== value ) {
					return;
				}

				// If a number was passed in, add the unit (except for certain CSS properties)
				if ( type === "number" ) {
					value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
				}

				// background-* props affect original clone's values
				if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
					style[ name ] = "inherit";
				}

				// If a hook was provided, use that value, otherwise just set the specified value
				if ( !hooks || !( "set" in hooks ) ||
					( value = hooks.set( elem, value, extra ) ) !== undefined ) {

					style[ name ] = value;
				}

			} else {

				// If a hook was provided get the non-computed value from there
				if ( hooks && "get" in hooks &&
					( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

					return ret;
				}

				// Otherwise just get the value from the style object
				return style[ name ];
			}
		},

		css: function( elem, name, extra, styles ) {
			var val, num, hooks,
				origName = jQuery.camelCase( name );

			// Make sure that we're working with the right name
			name = jQuery.cssProps[ origName ] ||
				( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

			// Try prefixed name followed by the unprefixed name
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

			// If a hook was provided get the computed value from there
			if ( hooks && "get" in hooks ) {
				val = hooks.get( elem, true, extra );
			}

			// Otherwise, if a way to get the computed value exists, use that
			if ( val === undefined ) {
				val = curCSS( elem, name, styles );
			}

			// Convert "normal" to computed value
			if ( val === "normal" && name in cssNormalTransform ) {
				val = cssNormalTransform[ name ];
			}

			// Make numeric if forced or a qualifier was provided and val looks numeric
			if ( extra === "" || extra ) {
				num = parseFloat( val );
				return extra === true || isFinite( num ) ? num || 0 : val;
			}
			return val;
		}
	} );

	jQuery.each( [ "height", "width" ], function( i, name ) {
		jQuery.cssHooks[ name ] = {
			get: function( elem, computed, extra ) {
				if ( computed ) {

					// Certain elements can have dimension info if we invisibly show them
					// but it must have a current display style that would benefit
					return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

						// Support: Safari 8+
						// Table columns in Safari have non-zero offsetWidth & zero
						// getBoundingClientRect().width unless display is changed.
						// Support: IE <=11 only
						// Running getBoundingClientRect on a disconnected node
						// in IE throws an error.
						( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
							swap( elem, cssShow, function() {
								return getWidthOrHeight( elem, name, extra );
							} ) :
							getWidthOrHeight( elem, name, extra );
				}
			},

			set: function( elem, value, extra ) {
				var matches,
					styles = extra && getStyles( elem ),
					subtract = extra && augmentWidthOrHeight(
						elem,
						name,
						extra,
						jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
						styles
					);

				// Convert to pixels if value adjustment is needed
				if ( subtract && ( matches = rcssNum.exec( value ) ) &&
					( matches[ 3 ] || "px" ) !== "px" ) {

					elem.style[ name ] = value;
					value = jQuery.css( elem, name );
				}

				return setPositiveNumber( elem, value, subtract );
			}
		};
	} );

	jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
		function( elem, computed ) {
			if ( computed ) {
				return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
					elem.getBoundingClientRect().left -
						swap( elem, { marginLeft: 0 }, function() {
							return elem.getBoundingClientRect().left;
						} )
					) + "px";
			}
		}
	);

	// These hooks are used by animate to expand properties
	jQuery.each( {
		margin: "",
		padding: "",
		border: "Width"
	}, function( prefix, suffix ) {
		jQuery.cssHooks[ prefix + suffix ] = {
			expand: function( value ) {
				var i = 0,
					expanded = {},

					// Assumes a single number if not a string
					parts = typeof value === "string" ? value.split( " " ) : [ value ];

				for ( ; i < 4; i++ ) {
					expanded[ prefix + cssExpand[ i ] + suffix ] =
						parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
				}

				return expanded;
			}
		};

		if ( !rmargin.test( prefix ) ) {
			jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
		}
	} );

	jQuery.fn.extend( {
		css: function( name, value ) {
			return access( this, function( elem, name, value ) {
				var styles, len,
					map = {},
					i = 0;

				if ( jQuery.isArray( name ) ) {
					styles = getStyles( elem );
					len = name.length;

					for ( ; i < len; i++ ) {
						map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
					}

					return map;
				}

				return value !== undefined ?
					jQuery.style( elem, name, value ) :
					jQuery.css( elem, name );
			}, name, value, arguments.length > 1 );
		}
	} );


	function Tween( elem, options, prop, end, easing ) {
		return new Tween.prototype.init( elem, options, prop, end, easing );
	}
	jQuery.Tween = Tween;

	Tween.prototype = {
		constructor: Tween,
		init: function( elem, options, prop, end, easing, unit ) {
			this.elem = elem;
			this.prop = prop;
			this.easing = easing || jQuery.easing._default;
			this.options = options;
			this.start = this.now = this.cur();
			this.end = end;
			this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
		},
		cur: function() {
			var hooks = Tween.propHooks[ this.prop ];

			return hooks && hooks.get ?
				hooks.get( this ) :
				Tween.propHooks._default.get( this );
		},
		run: function( percent ) {
			var eased,
				hooks = Tween.propHooks[ this.prop ];

			if ( this.options.duration ) {
				this.pos = eased = jQuery.easing[ this.easing ](
					percent, this.options.duration * percent, 0, 1, this.options.duration
				);
			} else {
				this.pos = eased = percent;
			}
			this.now = ( this.end - this.start ) * eased + this.start;

			if ( this.options.step ) {
				this.options.step.call( this.elem, this.now, this );
			}

			if ( hooks && hooks.set ) {
				hooks.set( this );
			} else {
				Tween.propHooks._default.set( this );
			}
			return this;
		}
	};

	Tween.prototype.init.prototype = Tween.prototype;

	Tween.propHooks = {
		_default: {
			get: function( tween ) {
				var result;

				// Use a property on the element directly when it is not a DOM element,
				// or when there is no matching style property that exists.
				if ( tween.elem.nodeType !== 1 ||
					tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
					return tween.elem[ tween.prop ];
				}

				// Passing an empty string as a 3rd parameter to .css will automatically
				// attempt a parseFloat and fallback to a string if the parse fails.
				// Simple values such as "10px" are parsed to Float;
				// complex values such as "rotate(1rad)" are returned as-is.
				result = jQuery.css( tween.elem, tween.prop, "" );

				// Empty strings, null, undefined and "auto" are converted to 0.
				return !result || result === "auto" ? 0 : result;
			},
			set: function( tween ) {

				// Use step hook for back compat.
				// Use cssHook if its there.
				// Use .style if available and use plain properties where available.
				if ( jQuery.fx.step[ tween.prop ] ) {
					jQuery.fx.step[ tween.prop ]( tween );
				} else if ( tween.elem.nodeType === 1 &&
					( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
						jQuery.cssHooks[ tween.prop ] ) ) {
					jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
				} else {
					tween.elem[ tween.prop ] = tween.now;
				}
			}
		}
	};

	// Support: IE <=9 only
	// Panic based approach to setting things on disconnected nodes
	Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
		set: function( tween ) {
			if ( tween.elem.nodeType && tween.elem.parentNode ) {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	};

	jQuery.easing = {
		linear: function( p ) {
			return p;
		},
		swing: function( p ) {
			return 0.5 - Math.cos( p * Math.PI ) / 2;
		},
		_default: "swing"
	};

	jQuery.fx = Tween.prototype.init;

	// Back compat <1.8 extension point
	jQuery.fx.step = {};




	var
		fxNow, timerId,
		rfxtypes = /^(?:toggle|show|hide)$/,
		rrun = /queueHooks$/;

	function raf() {
		if ( timerId ) {
			window.requestAnimationFrame( raf );
			jQuery.fx.tick();
		}
	}

	// Animations created synchronously will run synchronously
	function createFxNow() {
		window.setTimeout( function() {
			fxNow = undefined;
		} );
		return ( fxNow = jQuery.now() );
	}

	// Generate parameters to create a standard animation
	function genFx( type, includeWidth ) {
		var which,
			i = 0,
			attrs = { height: type };

		// If we include width, step value is 1 to do all cssExpand values,
		// otherwise step value is 2 to skip over Left and Right
		includeWidth = includeWidth ? 1 : 0;
		for ( ; i < 4; i += 2 - includeWidth ) {
			which = cssExpand[ i ];
			attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
		}

		if ( includeWidth ) {
			attrs.opacity = attrs.width = type;
		}

		return attrs;
	}

	function createTween( value, prop, animation ) {
		var tween,
			collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
			index = 0,
			length = collection.length;
		for ( ; index < length; index++ ) {
			if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

				// We're done with this property
				return tween;
			}
		}
	}

	function defaultPrefilter( elem, props, opts ) {
		var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
			isBox = "width" in props || "height" in props,
			anim = this,
			orig = {},
			style = elem.style,
			hidden = elem.nodeType && isHiddenWithinTree( elem ),
			dataShow = dataPriv.get( elem, "fxshow" );

		// Queue-skipping animations hijack the fx hooks
		if ( !opts.queue ) {
			hooks = jQuery._queueHooks( elem, "fx" );
			if ( hooks.unqueued == null ) {
				hooks.unqueued = 0;
				oldfire = hooks.empty.fire;
				hooks.empty.fire = function() {
					if ( !hooks.unqueued ) {
						oldfire();
					}
				};
			}
			hooks.unqueued++;

			anim.always( function() {

				// Ensure the complete handler is called before this completes
				anim.always( function() {
					hooks.unqueued--;
					if ( !jQuery.queue( elem, "fx" ).length ) {
						hooks.empty.fire();
					}
				} );
			} );
		}

		// Detect show/hide animations
		for ( prop in props ) {
			value = props[ prop ];
			if ( rfxtypes.test( value ) ) {
				delete props[ prop ];
				toggle = toggle || value === "toggle";
				if ( value === ( hidden ? "hide" : "show" ) ) {

					// Pretend to be hidden if this is a "show" and
					// there is still data from a stopped show/hide
					if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
						hidden = true;

					// Ignore all other no-op show/hide data
					} else {
						continue;
					}
				}
				orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
			}
		}

		// Bail out if this is a no-op like .hide().hide()
		propTween = !jQuery.isEmptyObject( props );
		if ( !propTween && jQuery.isEmptyObject( orig ) ) {
			return;
		}

		// Restrict "overflow" and "display" styles during box animations
		if ( isBox && elem.nodeType === 1 ) {

			// Support: IE <=9 - 11, Edge 12 - 13
			// Record all 3 overflow attributes because IE does not infer the shorthand
			// from identically-valued overflowX and overflowY
			opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

			// Identify a display type, preferring old show/hide data over the CSS cascade
			restoreDisplay = dataShow && dataShow.display;
			if ( restoreDisplay == null ) {
				restoreDisplay = dataPriv.get( elem, "display" );
			}
			display = jQuery.css( elem, "display" );
			if ( display === "none" ) {
				if ( restoreDisplay ) {
					display = restoreDisplay;
				} else {

					// Get nonempty value(s) by temporarily forcing visibility
					showHide( [ elem ], true );
					restoreDisplay = elem.style.display || restoreDisplay;
					display = jQuery.css( elem, "display" );
					showHide( [ elem ] );
				}
			}

			// Animate inline elements as inline-block
			if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
				if ( jQuery.css( elem, "float" ) === "none" ) {

					// Restore the original display value at the end of pure show/hide animations
					if ( !propTween ) {
						anim.done( function() {
							style.display = restoreDisplay;
						} );
						if ( restoreDisplay == null ) {
							display = style.display;
							restoreDisplay = display === "none" ? "" : display;
						}
					}
					style.display = "inline-block";
				}
			}
		}

		if ( opts.overflow ) {
			style.overflow = "hidden";
			anim.always( function() {
				style.overflow = opts.overflow[ 0 ];
				style.overflowX = opts.overflow[ 1 ];
				style.overflowY = opts.overflow[ 2 ];
			} );
		}

		// Implement show/hide animations
		propTween = false;
		for ( prop in orig ) {

			// General show/hide setup for this element animation
			if ( !propTween ) {
				if ( dataShow ) {
					if ( "hidden" in dataShow ) {
						hidden = dataShow.hidden;
					}
				} else {
					dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
				}

				// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
				if ( toggle ) {
					dataShow.hidden = !hidden;
				}

				// Show elements before animating them
				if ( hidden ) {
					showHide( [ elem ], true );
				}

				/* eslint-disable no-loop-func */

				anim.done( function() {

				/* eslint-enable no-loop-func */

					// The final step of a "hide" animation is actually hiding the element
					if ( !hidden ) {
						showHide( [ elem ] );
					}
					dataPriv.remove( elem, "fxshow" );
					for ( prop in orig ) {
						jQuery.style( elem, prop, orig[ prop ] );
					}
				} );
			}

			// Per-property setup
			propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = propTween.start;
				if ( hidden ) {
					propTween.end = propTween.start;
					propTween.start = 0;
				}
			}
		}
	}

	function propFilter( props, specialEasing ) {
		var index, name, easing, value, hooks;

		// camelCase, specialEasing and expand cssHook pass
		for ( index in props ) {
			name = jQuery.camelCase( index );
			easing = specialEasing[ name ];
			value = props[ index ];
			if ( jQuery.isArray( value ) ) {
				easing = value[ 1 ];
				value = props[ index ] = value[ 0 ];
			}

			if ( index !== name ) {
				props[ name ] = value;
				delete props[ index ];
			}

			hooks = jQuery.cssHooks[ name ];
			if ( hooks && "expand" in hooks ) {
				value = hooks.expand( value );
				delete props[ name ];

				// Not quite $.extend, this won't overwrite existing keys.
				// Reusing 'index' because we have the correct "name"
				for ( index in value ) {
					if ( !( index in props ) ) {
						props[ index ] = value[ index ];
						specialEasing[ index ] = easing;
					}
				}
			} else {
				specialEasing[ name ] = easing;
			}
		}
	}

	function Animation( elem, properties, options ) {
		var result,
			stopped,
			index = 0,
			length = Animation.prefilters.length,
			deferred = jQuery.Deferred().always( function() {

				// Don't match elem in the :animated selector
				delete tick.elem;
			} ),
			tick = function() {
				if ( stopped ) {
					return false;
				}
				var currentTime = fxNow || createFxNow(),
					remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

					// Support: Android 2.3 only
					// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
					temp = remaining / animation.duration || 0,
					percent = 1 - temp,
					index = 0,
					length = animation.tweens.length;

				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( percent );
				}

				deferred.notifyWith( elem, [ animation, percent, remaining ] );

				if ( percent < 1 && length ) {
					return remaining;
				} else {
					deferred.resolveWith( elem, [ animation ] );
					return false;
				}
			},
			animation = deferred.promise( {
				elem: elem,
				props: jQuery.extend( {}, properties ),
				opts: jQuery.extend( true, {
					specialEasing: {},
					easing: jQuery.easing._default
				}, options ),
				originalProperties: properties,
				originalOptions: options,
				startTime: fxNow || createFxNow(),
				duration: options.duration,
				tweens: [],
				createTween: function( prop, end ) {
					var tween = jQuery.Tween( elem, animation.opts, prop, end,
							animation.opts.specialEasing[ prop ] || animation.opts.easing );
					animation.tweens.push( tween );
					return tween;
				},
				stop: function( gotoEnd ) {
					var index = 0,

						// If we are going to the end, we want to run all the tweens
						// otherwise we skip this part
						length = gotoEnd ? animation.tweens.length : 0;
					if ( stopped ) {
						return this;
					}
					stopped = true;
					for ( ; index < length; index++ ) {
						animation.tweens[ index ].run( 1 );
					}

					// Resolve when we played the last frame; otherwise, reject
					if ( gotoEnd ) {
						deferred.notifyWith( elem, [ animation, 1, 0 ] );
						deferred.resolveWith( elem, [ animation, gotoEnd ] );
					} else {
						deferred.rejectWith( elem, [ animation, gotoEnd ] );
					}
					return this;
				}
			} ),
			props = animation.props;

		propFilter( props, animation.opts.specialEasing );

		for ( ; index < length; index++ ) {
			result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
			if ( result ) {
				if ( jQuery.isFunction( result.stop ) ) {
					jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
						jQuery.proxy( result.stop, result );
				}
				return result;
			}
		}

		jQuery.map( props, createTween, animation );

		if ( jQuery.isFunction( animation.opts.start ) ) {
			animation.opts.start.call( elem, animation );
		}

		jQuery.fx.timer(
			jQuery.extend( tick, {
				elem: elem,
				anim: animation,
				queue: animation.opts.queue
			} )
		);

		// attach callbacks from options
		return animation.progress( animation.opts.progress )
			.done( animation.opts.done, animation.opts.complete )
			.fail( animation.opts.fail )
			.always( animation.opts.always );
	}

	jQuery.Animation = jQuery.extend( Animation, {

		tweeners: {
			"*": [ function( prop, value ) {
				var tween = this.createTween( prop, value );
				adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
				return tween;
			} ]
		},

		tweener: function( props, callback ) {
			if ( jQuery.isFunction( props ) ) {
				callback = props;
				props = [ "*" ];
			} else {
				props = props.match( rnothtmlwhite );
			}

			var prop,
				index = 0,
				length = props.length;

			for ( ; index < length; index++ ) {
				prop = props[ index ];
				Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
				Animation.tweeners[ prop ].unshift( callback );
			}
		},

		prefilters: [ defaultPrefilter ],

		prefilter: function( callback, prepend ) {
			if ( prepend ) {
				Animation.prefilters.unshift( callback );
			} else {
				Animation.prefilters.push( callback );
			}
		}
	} );

	jQuery.speed = function( speed, easing, fn ) {
		var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
			complete: fn || !fn && easing ||
				jQuery.isFunction( speed ) && speed,
			duration: speed,
			easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
		};

		// Go to the end state if fx are off or if document is hidden
		if ( jQuery.fx.off || document.hidden ) {
			opt.duration = 0;

		} else {
			if ( typeof opt.duration !== "number" ) {
				if ( opt.duration in jQuery.fx.speeds ) {
					opt.duration = jQuery.fx.speeds[ opt.duration ];

				} else {
					opt.duration = jQuery.fx.speeds._default;
				}
			}
		}

		// Normalize opt.queue - true/undefined/null -> "fx"
		if ( opt.queue == null || opt.queue === true ) {
			opt.queue = "fx";
		}

		// Queueing
		opt.old = opt.complete;

		opt.complete = function() {
			if ( jQuery.isFunction( opt.old ) ) {
				opt.old.call( this );
			}

			if ( opt.queue ) {
				jQuery.dequeue( this, opt.queue );
			}
		};

		return opt;
	};

	jQuery.fn.extend( {
		fadeTo: function( speed, to, easing, callback ) {

			// Show any hidden elements after setting opacity to 0
			return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

				// Animate to the value specified
				.end().animate( { opacity: to }, speed, easing, callback );
		},
		animate: function( prop, speed, easing, callback ) {
			var empty = jQuery.isEmptyObject( prop ),
				optall = jQuery.speed( speed, easing, callback ),
				doAnimation = function() {

					// Operate on a copy of prop so per-property easing won't be lost
					var anim = Animation( this, jQuery.extend( {}, prop ), optall );

					// Empty animations, or finishing resolves immediately
					if ( empty || dataPriv.get( this, "finish" ) ) {
						anim.stop( true );
					}
				};
				doAnimation.finish = doAnimation;

			return empty || optall.queue === false ?
				this.each( doAnimation ) :
				this.queue( optall.queue, doAnimation );
		},
		stop: function( type, clearQueue, gotoEnd ) {
			var stopQueue = function( hooks ) {
				var stop = hooks.stop;
				delete hooks.stop;
				stop( gotoEnd );
			};

			if ( typeof type !== "string" ) {
				gotoEnd = clearQueue;
				clearQueue = type;
				type = undefined;
			}
			if ( clearQueue && type !== false ) {
				this.queue( type || "fx", [] );
			}

			return this.each( function() {
				var dequeue = true,
					index = type != null && type + "queueHooks",
					timers = jQuery.timers,
					data = dataPriv.get( this );

				if ( index ) {
					if ( data[ index ] && data[ index ].stop ) {
						stopQueue( data[ index ] );
					}
				} else {
					for ( index in data ) {
						if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
							stopQueue( data[ index ] );
						}
					}
				}

				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this &&
						( type == null || timers[ index ].queue === type ) ) {

						timers[ index ].anim.stop( gotoEnd );
						dequeue = false;
						timers.splice( index, 1 );
					}
				}

				// Start the next in the queue if the last step wasn't forced.
				// Timers currently will call their complete callbacks, which
				// will dequeue but only if they were gotoEnd.
				if ( dequeue || !gotoEnd ) {
					jQuery.dequeue( this, type );
				}
			} );
		},
		finish: function( type ) {
			if ( type !== false ) {
				type = type || "fx";
			}
			return this.each( function() {
				var index,
					data = dataPriv.get( this ),
					queue = data[ type + "queue" ],
					hooks = data[ type + "queueHooks" ],
					timers = jQuery.timers,
					length = queue ? queue.length : 0;

				// Enable finishing flag on private data
				data.finish = true;

				// Empty the queue first
				jQuery.queue( this, type, [] );

				if ( hooks && hooks.stop ) {
					hooks.stop.call( this, true );
				}

				// Look for any active animations, and finish them
				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
						timers[ index ].anim.stop( true );
						timers.splice( index, 1 );
					}
				}

				// Look for any animations in the old queue and finish them
				for ( index = 0; index < length; index++ ) {
					if ( queue[ index ] && queue[ index ].finish ) {
						queue[ index ].finish.call( this );
					}
				}

				// Turn off finishing flag
				delete data.finish;
			} );
		}
	} );

	jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
		var cssFn = jQuery.fn[ name ];
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return speed == null || typeof speed === "boolean" ?
				cssFn.apply( this, arguments ) :
				this.animate( genFx( name, true ), speed, easing, callback );
		};
	} );

	// Generate shortcuts for custom animations
	jQuery.each( {
		slideDown: genFx( "show" ),
		slideUp: genFx( "hide" ),
		slideToggle: genFx( "toggle" ),
		fadeIn: { opacity: "show" },
		fadeOut: { opacity: "hide" },
		fadeToggle: { opacity: "toggle" }
	}, function( name, props ) {
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return this.animate( props, speed, easing, callback );
		};
	} );

	jQuery.timers = [];
	jQuery.fx.tick = function() {
		var timer,
			i = 0,
			timers = jQuery.timers;

		fxNow = jQuery.now();

		for ( ; i < timers.length; i++ ) {
			timer = timers[ i ];

			// Checks the timer has not already been removed
			if ( !timer() && timers[ i ] === timer ) {
				timers.splice( i--, 1 );
			}
		}

		if ( !timers.length ) {
			jQuery.fx.stop();
		}
		fxNow = undefined;
	};

	jQuery.fx.timer = function( timer ) {
		jQuery.timers.push( timer );
		if ( timer() ) {
			jQuery.fx.start();
		} else {
			jQuery.timers.pop();
		}
	};

	jQuery.fx.interval = 13;
	jQuery.fx.start = function() {
		if ( !timerId ) {
			timerId = window.requestAnimationFrame ?
				window.requestAnimationFrame( raf ) :
				window.setInterval( jQuery.fx.tick, jQuery.fx.interval );
		}
	};

	jQuery.fx.stop = function() {
		if ( window.cancelAnimationFrame ) {
			window.cancelAnimationFrame( timerId );
		} else {
			window.clearInterval( timerId );
		}

		timerId = null;
	};

	jQuery.fx.speeds = {
		slow: 600,
		fast: 200,

		// Default speed
		_default: 400
	};


	// Based off of the plugin by Clint Helfers, with permission.
	// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
	jQuery.fn.delay = function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";

		return this.queue( type, function( next, hooks ) {
			var timeout = window.setTimeout( next, time );
			hooks.stop = function() {
				window.clearTimeout( timeout );
			};
		} );
	};


	( function() {
		var input = document.createElement( "input" ),
			select = document.createElement( "select" ),
			opt = select.appendChild( document.createElement( "option" ) );

		input.type = "checkbox";

		// Support: Android <=4.3 only
		// Default value for a checkbox should be "on"
		support.checkOn = input.value !== "";

		// Support: IE <=11 only
		// Must access selectedIndex to make default options select
		support.optSelected = opt.selected;

		// Support: IE <=11 only
		// An input loses its value after becoming a radio
		input = document.createElement( "input" );
		input.value = "t";
		input.type = "radio";
		support.radioValue = input.value === "t";
	} )();


	var boolHook,
		attrHandle = jQuery.expr.attrHandle;

	jQuery.fn.extend( {
		attr: function( name, value ) {
			return access( this, jQuery.attr, name, value, arguments.length > 1 );
		},

		removeAttr: function( name ) {
			return this.each( function() {
				jQuery.removeAttr( this, name );
			} );
		}
	} );

	jQuery.extend( {
		attr: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;

			// Don't get/set attributes on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}

			// Fallback to prop when attributes are not supported
			if ( typeof elem.getAttribute === "undefined" ) {
				return jQuery.prop( elem, name, value );
			}

			// Attribute hooks are determined by the lowercase version
			// Grab necessary hook if one is defined
			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
				hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
					( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
			}

			if ( value !== undefined ) {
				if ( value === null ) {
					jQuery.removeAttr( elem, name );
					return;
				}

				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}

				elem.setAttribute( name, value + "" );
				return value;
			}

			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}

			ret = jQuery.find.attr( elem, name );

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ? undefined : ret;
		},

		attrHooks: {
			type: {
				set: function( elem, value ) {
					if ( !support.radioValue && value === "radio" &&
						jQuery.nodeName( elem, "input" ) ) {
						var val = elem.value;
						elem.setAttribute( "type", value );
						if ( val ) {
							elem.value = val;
						}
						return value;
					}
				}
			}
		},

		removeAttr: function( elem, value ) {
			var name,
				i = 0,

				// Attribute names can contain non-HTML whitespace characters
				// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
				attrNames = value && value.match( rnothtmlwhite );

			if ( attrNames && elem.nodeType === 1 ) {
				while ( ( name = attrNames[ i++ ] ) ) {
					elem.removeAttribute( name );
				}
			}
		}
	} );

	// Hooks for boolean attributes
	boolHook = {
		set: function( elem, value, name ) {
			if ( value === false ) {

				// Remove boolean attributes when set to false
				jQuery.removeAttr( elem, name );
			} else {
				elem.setAttribute( name, name );
			}
			return name;
		}
	};

	jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
		var getter = attrHandle[ name ] || jQuery.find.attr;

		attrHandle[ name ] = function( elem, name, isXML ) {
			var ret, handle,
				lowercaseName = name.toLowerCase();

			if ( !isXML ) {

				// Avoid an infinite loop by temporarily removing this function from the getter
				handle = attrHandle[ lowercaseName ];
				attrHandle[ lowercaseName ] = ret;
				ret = getter( elem, name, isXML ) != null ?
					lowercaseName :
					null;
				attrHandle[ lowercaseName ] = handle;
			}
			return ret;
		};
	} );




	var rfocusable = /^(?:input|select|textarea|button)$/i,
		rclickable = /^(?:a|area)$/i;

	jQuery.fn.extend( {
		prop: function( name, value ) {
			return access( this, jQuery.prop, name, value, arguments.length > 1 );
		},

		removeProp: function( name ) {
			return this.each( function() {
				delete this[ jQuery.propFix[ name ] || name ];
			} );
		}
	} );

	jQuery.extend( {
		prop: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;

			// Don't get/set properties on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}

			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

				// Fix name and attach hooks
				name = jQuery.propFix[ name ] || name;
				hooks = jQuery.propHooks[ name ];
			}

			if ( value !== undefined ) {
				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}

				return ( elem[ name ] = value );
			}

			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}

			return elem[ name ];
		},

		propHooks: {
			tabIndex: {
				get: function( elem ) {

					// Support: IE <=9 - 11 only
					// elem.tabIndex doesn't always return the
					// correct value when it hasn't been explicitly set
					// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
					// Use proper attribute retrieval(#12072)
					var tabindex = jQuery.find.attr( elem, "tabindex" );

					if ( tabindex ) {
						return parseInt( tabindex, 10 );
					}

					if (
						rfocusable.test( elem.nodeName ) ||
						rclickable.test( elem.nodeName ) &&
						elem.href
					) {
						return 0;
					}

					return -1;
				}
			}
		},

		propFix: {
			"for": "htmlFor",
			"class": "className"
		}
	} );

	// Support: IE <=11 only
	// Accessing the selectedIndex property
	// forces the browser to respect setting selected
	// on the option
	// The getter ensures a default option is selected
	// when in an optgroup
	// eslint rule "no-unused-expressions" is disabled for this code
	// since it considers such accessions noop
	if ( !support.optSelected ) {
		jQuery.propHooks.selected = {
			get: function( elem ) {

				/* eslint no-unused-expressions: "off" */

				var parent = elem.parentNode;
				if ( parent && parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
				return null;
			},
			set: function( elem ) {

				/* eslint no-unused-expressions: "off" */

				var parent = elem.parentNode;
				if ( parent ) {
					parent.selectedIndex;

					if ( parent.parentNode ) {
						parent.parentNode.selectedIndex;
					}
				}
			}
		};
	}

	jQuery.each( [
		"tabIndex",
		"readOnly",
		"maxLength",
		"cellSpacing",
		"cellPadding",
		"rowSpan",
		"colSpan",
		"useMap",
		"frameBorder",
		"contentEditable"
	], function() {
		jQuery.propFix[ this.toLowerCase() ] = this;
	} );




		// Strip and collapse whitespace according to HTML spec
		// https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace
		function stripAndCollapse( value ) {
			var tokens = value.match( rnothtmlwhite ) || [];
			return tokens.join( " " );
		}


	function getClass( elem ) {
		return elem.getAttribute && elem.getAttribute( "class" ) || "";
	}

	jQuery.fn.extend( {
		addClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;

			if ( jQuery.isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
				} );
			}

			if ( typeof value === "string" && value ) {
				classes = value.match( rnothtmlwhite ) || [];

				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );
					cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {
							if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
								cur += clazz + " ";
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = stripAndCollapse( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}

			return this;
		},

		removeClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;

			if ( jQuery.isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
				} );
			}

			if ( !arguments.length ) {
				return this.attr( "class", "" );
			}

			if ( typeof value === "string" && value ) {
				classes = value.match( rnothtmlwhite ) || [];

				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );

					// This expression is here for better compressibility (see addClass)
					cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {

							// Remove *all* instances
							while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
								cur = cur.replace( " " + clazz + " ", " " );
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = stripAndCollapse( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}

			return this;
		},

		toggleClass: function( value, stateVal ) {
			var type = typeof value;

			if ( typeof stateVal === "boolean" && type === "string" ) {
				return stateVal ? this.addClass( value ) : this.removeClass( value );
			}

			if ( jQuery.isFunction( value ) ) {
				return this.each( function( i ) {
					jQuery( this ).toggleClass(
						value.call( this, i, getClass( this ), stateVal ),
						stateVal
					);
				} );
			}

			return this.each( function() {
				var className, i, self, classNames;

				if ( type === "string" ) {

					// Toggle individual class names
					i = 0;
					self = jQuery( this );
					classNames = value.match( rnothtmlwhite ) || [];

					while ( ( className = classNames[ i++ ] ) ) {

						// Check each className given, space separated list
						if ( self.hasClass( className ) ) {
							self.removeClass( className );
						} else {
							self.addClass( className );
						}
					}

				// Toggle whole class name
				} else if ( value === undefined || type === "boolean" ) {
					className = getClass( this );
					if ( className ) {

						// Store className if set
						dataPriv.set( this, "__className__", className );
					}

					// If the element has a class name or if we're passed `false`,
					// then remove the whole classname (if there was one, the above saved it).
					// Otherwise bring back whatever was previously saved (if anything),
					// falling back to the empty string if nothing was stored.
					if ( this.setAttribute ) {
						this.setAttribute( "class",
							className || value === false ?
							"" :
							dataPriv.get( this, "__className__" ) || ""
						);
					}
				}
			} );
		},

		hasClass: function( selector ) {
			var className, elem,
				i = 0;

			className = " " + selector + " ";
			while ( ( elem = this[ i++ ] ) ) {
				if ( elem.nodeType === 1 &&
					( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
						return true;
				}
			}

			return false;
		}
	} );




	var rreturn = /\r/g;

	jQuery.fn.extend( {
		val: function( value ) {
			var hooks, ret, isFunction,
				elem = this[ 0 ];

			if ( !arguments.length ) {
				if ( elem ) {
					hooks = jQuery.valHooks[ elem.type ] ||
						jQuery.valHooks[ elem.nodeName.toLowerCase() ];

					if ( hooks &&
						"get" in hooks &&
						( ret = hooks.get( elem, "value" ) ) !== undefined
					) {
						return ret;
					}

					ret = elem.value;

					// Handle most common string cases
					if ( typeof ret === "string" ) {
						return ret.replace( rreturn, "" );
					}

					// Handle cases where value is null/undef or number
					return ret == null ? "" : ret;
				}

				return;
			}

			isFunction = jQuery.isFunction( value );

			return this.each( function( i ) {
				var val;

				if ( this.nodeType !== 1 ) {
					return;
				}

				if ( isFunction ) {
					val = value.call( this, i, jQuery( this ).val() );
				} else {
					val = value;
				}

				// Treat null/undefined as ""; convert numbers to string
				if ( val == null ) {
					val = "";

				} else if ( typeof val === "number" ) {
					val += "";

				} else if ( jQuery.isArray( val ) ) {
					val = jQuery.map( val, function( value ) {
						return value == null ? "" : value + "";
					} );
				}

				hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

				// If set returns undefined, fall back to normal setting
				if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
					this.value = val;
				}
			} );
		}
	} );

	jQuery.extend( {
		valHooks: {
			option: {
				get: function( elem ) {

					var val = jQuery.find.attr( elem, "value" );
					return val != null ?
						val :

						// Support: IE <=10 - 11 only
						// option.text throws exceptions (#14686, #14858)
						// Strip and collapse whitespace
						// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
						stripAndCollapse( jQuery.text( elem ) );
				}
			},
			select: {
				get: function( elem ) {
					var value, option, i,
						options = elem.options,
						index = elem.selectedIndex,
						one = elem.type === "select-one",
						values = one ? null : [],
						max = one ? index + 1 : options.length;

					if ( index < 0 ) {
						i = max;

					} else {
						i = one ? index : 0;
					}

					// Loop through all the selected options
					for ( ; i < max; i++ ) {
						option = options[ i ];

						// Support: IE <=9 only
						// IE8-9 doesn't update selected after form reset (#2551)
						if ( ( option.selected || i === index ) &&

								// Don't return options that are disabled or in a disabled optgroup
								!option.disabled &&
								( !option.parentNode.disabled ||
									!jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

							// Get the specific value for the option
							value = jQuery( option ).val();

							// We don't need an array for one selects
							if ( one ) {
								return value;
							}

							// Multi-Selects return an array
							values.push( value );
						}
					}

					return values;
				},

				set: function( elem, value ) {
					var optionSet, option,
						options = elem.options,
						values = jQuery.makeArray( value ),
						i = options.length;

					while ( i-- ) {
						option = options[ i ];

						/* eslint-disable no-cond-assign */

						if ( option.selected =
							jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
						) {
							optionSet = true;
						}

						/* eslint-enable no-cond-assign */
					}

					// Force browsers to behave consistently when non-matching value is set
					if ( !optionSet ) {
						elem.selectedIndex = -1;
					}
					return values;
				}
			}
		}
	} );

	// Radios and checkboxes getter/setter
	jQuery.each( [ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
			set: function( elem, value ) {
				if ( jQuery.isArray( value ) ) {
					return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
				}
			}
		};
		if ( !support.checkOn ) {
			jQuery.valHooks[ this ].get = function( elem ) {
				return elem.getAttribute( "value" ) === null ? "on" : elem.value;
			};
		}
	} );




	// Return jQuery for attributes-only inclusion


	var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;

	jQuery.extend( jQuery.event, {

		trigger: function( event, data, elem, onlyHandlers ) {

			var i, cur, tmp, bubbleType, ontype, handle, special,
				eventPath = [ elem || document ],
				type = hasOwn.call( event, "type" ) ? event.type : event,
				namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

			cur = tmp = elem = elem || document;

			// Don't do events on text and comment nodes
			if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
				return;
			}

			// focus/blur morphs to focusin/out; ensure we're not firing them right now
			if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
				return;
			}

			if ( type.indexOf( "." ) > -1 ) {

				// Namespaced trigger; create a regexp to match event type in handle()
				namespaces = type.split( "." );
				type = namespaces.shift();
				namespaces.sort();
			}
			ontype = type.indexOf( ":" ) < 0 && "on" + type;

			// Caller can pass in a jQuery.Event object, Object, or just an event type string
			event = event[ jQuery.expando ] ?
				event :
				new jQuery.Event( type, typeof event === "object" && event );

			// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
			event.isTrigger = onlyHandlers ? 2 : 3;
			event.namespace = namespaces.join( "." );
			event.rnamespace = event.namespace ?
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
				null;

			// Clean up the event in case it is being reused
			event.result = undefined;
			if ( !event.target ) {
				event.target = elem;
			}

			// Clone any incoming data and prepend the event, creating the handler arg list
			data = data == null ?
				[ event ] :
				jQuery.makeArray( data, [ event ] );

			// Allow special events to draw outside the lines
			special = jQuery.event.special[ type ] || {};
			if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
				return;
			}

			// Determine event propagation path in advance, per W3C events spec (#9951)
			// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
			if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

				bubbleType = special.delegateType || type;
				if ( !rfocusMorph.test( bubbleType + type ) ) {
					cur = cur.parentNode;
				}
				for ( ; cur; cur = cur.parentNode ) {
					eventPath.push( cur );
					tmp = cur;
				}

				// Only add window if we got to document (e.g., not plain obj or detached DOM)
				if ( tmp === ( elem.ownerDocument || document ) ) {
					eventPath.push( tmp.defaultView || tmp.parentWindow || window );
				}
			}

			// Fire handlers on the event path
			i = 0;
			while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {

				event.type = i > 1 ?
					bubbleType :
					special.bindType || type;

				// jQuery handler
				handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
					dataPriv.get( cur, "handle" );
				if ( handle ) {
					handle.apply( cur, data );
				}

				// Native handler
				handle = ontype && cur[ ontype ];
				if ( handle && handle.apply && acceptData( cur ) ) {
					event.result = handle.apply( cur, data );
					if ( event.result === false ) {
						event.preventDefault();
					}
				}
			}
			event.type = type;

			// If nobody prevented the default action, do it now
			if ( !onlyHandlers && !event.isDefaultPrevented() ) {

				if ( ( !special._default ||
					special._default.apply( eventPath.pop(), data ) === false ) &&
					acceptData( elem ) ) {

					// Call a native DOM method on the target with the same name as the event.
					// Don't do default actions on window, that's where global variables be (#6170)
					if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

						// Don't re-trigger an onFOO event when we call its FOO() method
						tmp = elem[ ontype ];

						if ( tmp ) {
							elem[ ontype ] = null;
						}

						// Prevent re-triggering of the same event, since we already bubbled it above
						jQuery.event.triggered = type;
						elem[ type ]();
						jQuery.event.triggered = undefined;

						if ( tmp ) {
							elem[ ontype ] = tmp;
						}
					}
				}
			}

			return event.result;
		},

		// Piggyback on a donor event to simulate a different one
		// Used only for `focus(in | out)` events
		simulate: function( type, elem, event ) {
			var e = jQuery.extend(
				new jQuery.Event(),
				event,
				{
					type: type,
					isSimulated: true
				}
			);

			jQuery.event.trigger( e, null, elem );
		}

	} );

	jQuery.fn.extend( {

		trigger: function( type, data ) {
			return this.each( function() {
				jQuery.event.trigger( type, data, this );
			} );
		},
		triggerHandler: function( type, data ) {
			var elem = this[ 0 ];
			if ( elem ) {
				return jQuery.event.trigger( type, data, elem, true );
			}
		}
	} );


	jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
		"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
		"change select submit keydown keypress keyup contextmenu" ).split( " " ),
		function( i, name ) {

		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	} );

	jQuery.fn.extend( {
		hover: function( fnOver, fnOut ) {
			return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
		}
	} );




	support.focusin = "onfocusin" in window;


	// Support: Firefox <=44
	// Firefox doesn't have focus(in | out) events
	// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
	//
	// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
	// focus(in | out) events fire after focus & blur events,
	// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
	// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
	if ( !support.focusin ) {
		jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

			// Attach a single capturing handler on the document while someone wants focusin/focusout
			var handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
			};

			jQuery.event.special[ fix ] = {
				setup: function() {
					var doc = this.ownerDocument || this,
						attaches = dataPriv.access( doc, fix );

					if ( !attaches ) {
						doc.addEventListener( orig, handler, true );
					}
					dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
				},
				teardown: function() {
					var doc = this.ownerDocument || this,
						attaches = dataPriv.access( doc, fix ) - 1;

					if ( !attaches ) {
						doc.removeEventListener( orig, handler, true );
						dataPriv.remove( doc, fix );

					} else {
						dataPriv.access( doc, fix, attaches );
					}
				}
			};
		} );
	}
	var location = window.location;

	var nonce = jQuery.now();

	var rquery = ( /\?/ );



	// Cross-browser xml parsing
	jQuery.parseXML = function( data ) {
		var xml;
		if ( !data || typeof data !== "string" ) {
			return null;
		}

		// Support: IE 9 - 11 only
		// IE throws on parseFromString with invalid input.
		try {
			xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
		} catch ( e ) {
			xml = undefined;
		}

		if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	};


	var
		rbracket = /\[\]$/,
		rCRLF = /\r?\n/g,
		rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
		rsubmittable = /^(?:input|select|textarea|keygen)/i;

	function buildParams( prefix, obj, traditional, add ) {
		var name;

		if ( jQuery.isArray( obj ) ) {

			// Serialize array item.
			jQuery.each( obj, function( i, v ) {
				if ( traditional || rbracket.test( prefix ) ) {

					// Treat each array item as a scalar.
					add( prefix, v );

				} else {

					// Item is non-scalar (array or object), encode its numeric index.
					buildParams(
						prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
						v,
						traditional,
						add
					);
				}
			} );

		} else if ( !traditional && jQuery.type( obj ) === "object" ) {

			// Serialize object item.
			for ( name in obj ) {
				buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
			}

		} else {

			// Serialize scalar item.
			add( prefix, obj );
		}
	}

	// Serialize an array of form elements or a set of
	// key/values into a query string
	jQuery.param = function( a, traditional ) {
		var prefix,
			s = [],
			add = function( key, valueOrFunction ) {

				// If value is a function, invoke it and use its return value
				var value = jQuery.isFunction( valueOrFunction ) ?
					valueOrFunction() :
					valueOrFunction;

				s[ s.length ] = encodeURIComponent( key ) + "=" +
					encodeURIComponent( value == null ? "" : value );
			};

		// If an array was passed in, assume that it is an array of form elements.
		if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

			// Serialize the form elements
			jQuery.each( a, function() {
				add( this.name, this.value );
			} );

		} else {

			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for ( prefix in a ) {
				buildParams( prefix, a[ prefix ], traditional, add );
			}
		}

		// Return the resulting serialization
		return s.join( "&" );
	};

	jQuery.fn.extend( {
		serialize: function() {
			return jQuery.param( this.serializeArray() );
		},
		serializeArray: function() {
			return this.map( function() {

				// Can add propHook for "elements" to filter or add form elements
				var elements = jQuery.prop( this, "elements" );
				return elements ? jQuery.makeArray( elements ) : this;
			} )
			.filter( function() {
				var type = this.type;

				// Use .is( ":disabled" ) so that fieldset[disabled] works
				return this.name && !jQuery( this ).is( ":disabled" ) &&
					rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
					( this.checked || !rcheckableType.test( type ) );
			} )
			.map( function( i, elem ) {
				var val = jQuery( this ).val();

				if ( val == null ) {
					return null;
				}

				if ( jQuery.isArray( val ) ) {
					return jQuery.map( val, function( val ) {
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					} );
				}

				return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
			} ).get();
		}
	} );


	var
		r20 = /%20/g,
		rhash = /#.*$/,
		rantiCache = /([?&])_=[^&]*/,
		rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

		// #7653, #8125, #8152: local protocol detection
		rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
		rnoContent = /^(?:GET|HEAD)$/,
		rprotocol = /^\/\//,

		/* Prefilters
		 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
		 * 2) These are called:
		 *    - BEFORE asking for a transport
		 *    - AFTER param serialization (s.data is a string if s.processData is true)
		 * 3) key is the dataType
		 * 4) the catchall symbol "*" can be used
		 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
		 */
		prefilters = {},

		/* Transports bindings
		 * 1) key is the dataType
		 * 2) the catchall symbol "*" can be used
		 * 3) selection will start with transport dataType and THEN go to "*" if needed
		 */
		transports = {},

		// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
		allTypes = "*/".concat( "*" ),

		// Anchor tag for parsing the document origin
		originAnchor = document.createElement( "a" );
		originAnchor.href = location.href;

	// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
	function addToPrefiltersOrTransports( structure ) {

		// dataTypeExpression is optional and defaults to "*"
		return function( dataTypeExpression, func ) {

			if ( typeof dataTypeExpression !== "string" ) {
				func = dataTypeExpression;
				dataTypeExpression = "*";
			}

			var dataType,
				i = 0,
				dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

			if ( jQuery.isFunction( func ) ) {

				// For each dataType in the dataTypeExpression
				while ( ( dataType = dataTypes[ i++ ] ) ) {

					// Prepend if requested
					if ( dataType[ 0 ] === "+" ) {
						dataType = dataType.slice( 1 ) || "*";
						( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

					// Otherwise append
					} else {
						( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
					}
				}
			}
		};
	}

	// Base inspection function for prefilters and transports
	function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

		var inspected = {},
			seekingTransport = ( structure === transports );

		function inspect( dataType ) {
			var selected;
			inspected[ dataType ] = true;
			jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
				var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
				if ( typeof dataTypeOrTransport === "string" &&
					!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

					options.dataTypes.unshift( dataTypeOrTransport );
					inspect( dataTypeOrTransport );
					return false;
				} else if ( seekingTransport ) {
					return !( selected = dataTypeOrTransport );
				}
			} );
			return selected;
		}

		return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
	}

	// A special extend for ajax options
	// that takes "flat" options (not to be deep extended)
	// Fixes #9887
	function ajaxExtend( target, src ) {
		var key, deep,
			flatOptions = jQuery.ajaxSettings.flatOptions || {};

		for ( key in src ) {
			if ( src[ key ] !== undefined ) {
				( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
			}
		}
		if ( deep ) {
			jQuery.extend( true, target, deep );
		}

		return target;
	}

	/* Handles responses to an ajax request:
	 * - finds the right dataType (mediates between content-type and expected dataType)
	 * - returns the corresponding response
	 */
	function ajaxHandleResponses( s, jqXHR, responses ) {

		var ct, type, finalDataType, firstDataType,
			contents = s.contents,
			dataTypes = s.dataTypes;

		// Remove auto dataType and get content-type in the process
		while ( dataTypes[ 0 ] === "*" ) {
			dataTypes.shift();
			if ( ct === undefined ) {
				ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
			}
		}

		// Check if we're dealing with a known content-type
		if ( ct ) {
			for ( type in contents ) {
				if ( contents[ type ] && contents[ type ].test( ct ) ) {
					dataTypes.unshift( type );
					break;
				}
			}
		}

		// Check to see if we have a response for the expected dataType
		if ( dataTypes[ 0 ] in responses ) {
			finalDataType = dataTypes[ 0 ];
		} else {

			// Try convertible dataTypes
			for ( type in responses ) {
				if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
					finalDataType = type;
					break;
				}
				if ( !firstDataType ) {
					firstDataType = type;
				}
			}

			// Or just use first one
			finalDataType = finalDataType || firstDataType;
		}

		// If we found a dataType
		// We add the dataType to the list if needed
		// and return the corresponding response
		if ( finalDataType ) {
			if ( finalDataType !== dataTypes[ 0 ] ) {
				dataTypes.unshift( finalDataType );
			}
			return responses[ finalDataType ];
		}
	}

	/* Chain conversions given the request and the original response
	 * Also sets the responseXXX fields on the jqXHR instance
	 */
	function ajaxConvert( s, response, jqXHR, isSuccess ) {
		var conv2, current, conv, tmp, prev,
			converters = {},

			// Work with a copy of dataTypes in case we need to modify it for conversion
			dataTypes = s.dataTypes.slice();

		// Create converters map with lowercased keys
		if ( dataTypes[ 1 ] ) {
			for ( conv in s.converters ) {
				converters[ conv.toLowerCase() ] = s.converters[ conv ];
			}
		}

		current = dataTypes.shift();

		// Convert to each sequential dataType
		while ( current ) {

			if ( s.responseFields[ current ] ) {
				jqXHR[ s.responseFields[ current ] ] = response;
			}

			// Apply the dataFilter if provided
			if ( !prev && isSuccess && s.dataFilter ) {
				response = s.dataFilter( response, s.dataType );
			}

			prev = current;
			current = dataTypes.shift();

			if ( current ) {

				// There's only work to do if current dataType is non-auto
				if ( current === "*" ) {

					current = prev;

				// Convert response if prev dataType is non-auto and differs from current
				} else if ( prev !== "*" && prev !== current ) {

					// Seek a direct converter
					conv = converters[ prev + " " + current ] || converters[ "* " + current ];

					// If none found, seek a pair
					if ( !conv ) {
						for ( conv2 in converters ) {

							// If conv2 outputs current
							tmp = conv2.split( " " );
							if ( tmp[ 1 ] === current ) {

								// If prev can be converted to accepted input
								conv = converters[ prev + " " + tmp[ 0 ] ] ||
									converters[ "* " + tmp[ 0 ] ];
								if ( conv ) {

									// Condense equivalence converters
									if ( conv === true ) {
										conv = converters[ conv2 ];

									// Otherwise, insert the intermediate dataType
									} else if ( converters[ conv2 ] !== true ) {
										current = tmp[ 0 ];
										dataTypes.unshift( tmp[ 1 ] );
									}
									break;
								}
							}
						}
					}

					// Apply converter (if not an equivalence)
					if ( conv !== true ) {

						// Unless errors are allowed to bubble, catch and return them
						if ( conv && s.throws ) {
							response = conv( response );
						} else {
							try {
								response = conv( response );
							} catch ( e ) {
								return {
									state: "parsererror",
									error: conv ? e : "No conversion from " + prev + " to " + current
								};
							}
						}
					}
				}
			}
		}

		return { state: "success", data: response };
	}

	jQuery.extend( {

		// Counter for holding the number of active queries
		active: 0,

		// Last-Modified header cache for next request
		lastModified: {},
		etag: {},

		ajaxSettings: {
			url: location.href,
			type: "GET",
			isLocal: rlocalProtocol.test( location.protocol ),
			global: true,
			processData: true,
			async: true,
			contentType: "application/x-www-form-urlencoded; charset=UTF-8",

			/*
			timeout: 0,
			data: null,
			dataType: null,
			username: null,
			password: null,
			cache: null,
			throws: false,
			traditional: false,
			headers: {},
			*/

			accepts: {
				"*": allTypes,
				text: "text/plain",
				html: "text/html",
				xml: "application/xml, text/xml",
				json: "application/json, text/javascript"
			},

			contents: {
				xml: /\bxml\b/,
				html: /\bhtml/,
				json: /\bjson\b/
			},

			responseFields: {
				xml: "responseXML",
				text: "responseText",
				json: "responseJSON"
			},

			// Data converters
			// Keys separate source (or catchall "*") and destination types with a single space
			converters: {

				// Convert anything to text
				"* text": String,

				// Text to html (true = no transformation)
				"text html": true,

				// Evaluate text as a json expression
				"text json": JSON.parse,

				// Parse text as xml
				"text xml": jQuery.parseXML
			},

			// For options that shouldn't be deep extended:
			// you can add your own custom options here if
			// and when you create one that shouldn't be
			// deep extended (see ajaxExtend)
			flatOptions: {
				url: true,
				context: true
			}
		},

		// Creates a full fledged settings object into target
		// with both ajaxSettings and settings fields.
		// If target is omitted, writes into ajaxSettings.
		ajaxSetup: function( target, settings ) {
			return settings ?

				// Building a settings object
				ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

				// Extending ajaxSettings
				ajaxExtend( jQuery.ajaxSettings, target );
		},

		ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
		ajaxTransport: addToPrefiltersOrTransports( transports ),

		// Main method
		ajax: function( url, options ) {

			// If url is an object, simulate pre-1.5 signature
			if ( typeof url === "object" ) {
				options = url;
				url = undefined;
			}

			// Force options to be an object
			options = options || {};

			var transport,

				// URL without anti-cache param
				cacheURL,

				// Response headers
				responseHeadersString,
				responseHeaders,

				// timeout handle
				timeoutTimer,

				// Url cleanup var
				urlAnchor,

				// Request state (becomes false upon send and true upon completion)
				completed,

				// To know if global events are to be dispatched
				fireGlobals,

				// Loop variable
				i,

				// uncached part of the url
				uncached,

				// Create the final options object
				s = jQuery.ajaxSetup( {}, options ),

				// Callbacks context
				callbackContext = s.context || s,

				// Context for global events is callbackContext if it is a DOM node or jQuery collection
				globalEventContext = s.context &&
					( callbackContext.nodeType || callbackContext.jquery ) ?
						jQuery( callbackContext ) :
						jQuery.event,

				// Deferreds
				deferred = jQuery.Deferred(),
				completeDeferred = jQuery.Callbacks( "once memory" ),

				// Status-dependent callbacks
				statusCode = s.statusCode || {},

				// Headers (they are sent all at once)
				requestHeaders = {},
				requestHeadersNames = {},

				// Default abort message
				strAbort = "canceled",

				// Fake xhr
				jqXHR = {
					readyState: 0,

					// Builds headers hashtable if needed
					getResponseHeader: function( key ) {
						var match;
						if ( completed ) {
							if ( !responseHeaders ) {
								responseHeaders = {};
								while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
									responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
								}
							}
							match = responseHeaders[ key.toLowerCase() ];
						}
						return match == null ? null : match;
					},

					// Raw string
					getAllResponseHeaders: function() {
						return completed ? responseHeadersString : null;
					},

					// Caches the header
					setRequestHeader: function( name, value ) {
						if ( completed == null ) {
							name = requestHeadersNames[ name.toLowerCase() ] =
								requestHeadersNames[ name.toLowerCase() ] || name;
							requestHeaders[ name ] = value;
						}
						return this;
					},

					// Overrides response content-type header
					overrideMimeType: function( type ) {
						if ( completed == null ) {
							s.mimeType = type;
						}
						return this;
					},

					// Status-dependent callbacks
					statusCode: function( map ) {
						var code;
						if ( map ) {
							if ( completed ) {

								// Execute the appropriate callbacks
								jqXHR.always( map[ jqXHR.status ] );
							} else {

								// Lazy-add the new callbacks in a way that preserves old ones
								for ( code in map ) {
									statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
								}
							}
						}
						return this;
					},

					// Cancel the request
					abort: function( statusText ) {
						var finalText = statusText || strAbort;
						if ( transport ) {
							transport.abort( finalText );
						}
						done( 0, finalText );
						return this;
					}
				};

			// Attach deferreds
			deferred.promise( jqXHR );

			// Add protocol if not provided (prefilters might expect it)
			// Handle falsy url in the settings object (#10093: consistency with old signature)
			// We also use the url parameter if available
			s.url = ( ( url || s.url || location.href ) + "" )
				.replace( rprotocol, location.protocol + "//" );

			// Alias method option to type as per ticket #12004
			s.type = options.method || options.type || s.method || s.type;

			// Extract dataTypes list
			s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

			// A cross-domain request is in order when the origin doesn't match the current origin.
			if ( s.crossDomain == null ) {
				urlAnchor = document.createElement( "a" );

				// Support: IE <=8 - 11, Edge 12 - 13
				// IE throws exception on accessing the href property if url is malformed,
				// e.g. http://example.com:80x/
				try {
					urlAnchor.href = s.url;

					// Support: IE <=8 - 11 only
					// Anchor's host property isn't correctly set when s.url is relative
					urlAnchor.href = urlAnchor.href;
					s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
						urlAnchor.protocol + "//" + urlAnchor.host;
				} catch ( e ) {

					// If there is an error parsing the URL, assume it is crossDomain,
					// it can be rejected by the transport if it is invalid
					s.crossDomain = true;
				}
			}

			// Convert data if not already a string
			if ( s.data && s.processData && typeof s.data !== "string" ) {
				s.data = jQuery.param( s.data, s.traditional );
			}

			// Apply prefilters
			inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

			// If request was aborted inside a prefilter, stop there
			if ( completed ) {
				return jqXHR;
			}

			// We can fire global events as of now if asked to
			// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
			fireGlobals = jQuery.event && s.global;

			// Watch for a new set of requests
			if ( fireGlobals && jQuery.active++ === 0 ) {
				jQuery.event.trigger( "ajaxStart" );
			}

			// Uppercase the type
			s.type = s.type.toUpperCase();

			// Determine if request has content
			s.hasContent = !rnoContent.test( s.type );

			// Save the URL in case we're toying with the If-Modified-Since
			// and/or If-None-Match header later on
			// Remove hash to simplify url manipulation
			cacheURL = s.url.replace( rhash, "" );

			// More options handling for requests with no content
			if ( !s.hasContent ) {

				// Remember the hash so we can put it back
				uncached = s.url.slice( cacheURL.length );

				// If data is available, append data to url
				if ( s.data ) {
					cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

					// #9682: remove data so that it's not used in an eventual retry
					delete s.data;
				}

				// Add or update anti-cache param if needed
				if ( s.cache === false ) {
					cacheURL = cacheURL.replace( rantiCache, "$1" );
					uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
				}

				// Put hash and anti-cache on the URL that will be requested (gh-1732)
				s.url = cacheURL + uncached;

			// Change '%20' to '+' if this is encoded form body content (gh-2658)
			} else if ( s.data && s.processData &&
				( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
				s.data = s.data.replace( r20, "+" );
			}

			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
			if ( s.ifModified ) {
				if ( jQuery.lastModified[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
				}
				if ( jQuery.etag[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
				}
			}

			// Set the correct header, if data is being sent
			if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
				jqXHR.setRequestHeader( "Content-Type", s.contentType );
			}

			// Set the Accepts header for the server, depending on the dataType
			jqXHR.setRequestHeader(
				"Accept",
				s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
					s.accepts[ s.dataTypes[ 0 ] ] +
						( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
					s.accepts[ "*" ]
			);

			// Check for headers option
			for ( i in s.headers ) {
				jqXHR.setRequestHeader( i, s.headers[ i ] );
			}

			// Allow custom headers/mimetypes and early abort
			if ( s.beforeSend &&
				( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

				// Abort if not done already and return
				return jqXHR.abort();
			}

			// Aborting is no longer a cancellation
			strAbort = "abort";

			// Install callbacks on deferreds
			completeDeferred.add( s.complete );
			jqXHR.done( s.success );
			jqXHR.fail( s.error );

			// Get transport
			transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

			// If no transport, we auto-abort
			if ( !transport ) {
				done( -1, "No Transport" );
			} else {
				jqXHR.readyState = 1;

				// Send global event
				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
				}

				// If request was aborted inside ajaxSend, stop there
				if ( completed ) {
					return jqXHR;
				}

				// Timeout
				if ( s.async && s.timeout > 0 ) {
					timeoutTimer = window.setTimeout( function() {
						jqXHR.abort( "timeout" );
					}, s.timeout );
				}

				try {
					completed = false;
					transport.send( requestHeaders, done );
				} catch ( e ) {

					// Rethrow post-completion exceptions
					if ( completed ) {
						throw e;
					}

					// Propagate others as results
					done( -1, e );
				}
			}

			// Callback for when everything is done
			function done( status, nativeStatusText, responses, headers ) {
				var isSuccess, success, error, response, modified,
					statusText = nativeStatusText;

				// Ignore repeat invocations
				if ( completed ) {
					return;
				}

				completed = true;

				// Clear timeout if it exists
				if ( timeoutTimer ) {
					window.clearTimeout( timeoutTimer );
				}

				// Dereference transport for early garbage collection
				// (no matter how long the jqXHR object will be used)
				transport = undefined;

				// Cache response headers
				responseHeadersString = headers || "";

				// Set readyState
				jqXHR.readyState = status > 0 ? 4 : 0;

				// Determine if successful
				isSuccess = status >= 200 && status < 300 || status === 304;

				// Get response data
				if ( responses ) {
					response = ajaxHandleResponses( s, jqXHR, responses );
				}

				// Convert no matter what (that way responseXXX fields are always set)
				response = ajaxConvert( s, response, jqXHR, isSuccess );

				// If successful, handle type chaining
				if ( isSuccess ) {

					// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
					if ( s.ifModified ) {
						modified = jqXHR.getResponseHeader( "Last-Modified" );
						if ( modified ) {
							jQuery.lastModified[ cacheURL ] = modified;
						}
						modified = jqXHR.getResponseHeader( "etag" );
						if ( modified ) {
							jQuery.etag[ cacheURL ] = modified;
						}
					}

					// if no content
					if ( status === 204 || s.type === "HEAD" ) {
						statusText = "nocontent";

					// if not modified
					} else if ( status === 304 ) {
						statusText = "notmodified";

					// If we have data, let's convert it
					} else {
						statusText = response.state;
						success = response.data;
						error = response.error;
						isSuccess = !error;
					}
				} else {

					// Extract error from statusText and normalize for non-aborts
					error = statusText;
					if ( status || !statusText ) {
						statusText = "error";
						if ( status < 0 ) {
							status = 0;
						}
					}
				}

				// Set data for the fake xhr object
				jqXHR.status = status;
				jqXHR.statusText = ( nativeStatusText || statusText ) + "";

				// Success/Error
				if ( isSuccess ) {
					deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
				} else {
					deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
				}

				// Status-dependent callbacks
				jqXHR.statusCode( statusCode );
				statusCode = undefined;

				if ( fireGlobals ) {
					globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
						[ jqXHR, s, isSuccess ? success : error ] );
				}

				// Complete
				completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

					// Handle the global AJAX counter
					if ( !( --jQuery.active ) ) {
						jQuery.event.trigger( "ajaxStop" );
					}
				}
			}

			return jqXHR;
		},

		getJSON: function( url, data, callback ) {
			return jQuery.get( url, data, callback, "json" );
		},

		getScript: function( url, callback ) {
			return jQuery.get( url, undefined, callback, "script" );
		}
	} );

	jQuery.each( [ "get", "post" ], function( i, method ) {
		jQuery[ method ] = function( url, data, callback, type ) {

			// Shift arguments if data argument was omitted
			if ( jQuery.isFunction( data ) ) {
				type = type || callback;
				callback = data;
				data = undefined;
			}

			// The url can be an options object (which then must have .url)
			return jQuery.ajax( jQuery.extend( {
				url: url,
				type: method,
				dataType: type,
				data: data,
				success: callback
			}, jQuery.isPlainObject( url ) && url ) );
		};
	} );


	jQuery._evalUrl = function( url ) {
		return jQuery.ajax( {
			url: url,

			// Make this explicit, since user can override this through ajaxSetup (#11264)
			type: "GET",
			dataType: "script",
			cache: true,
			async: false,
			global: false,
			"throws": true
		} );
	};


	jQuery.fn.extend( {
		wrapAll: function( html ) {
			var wrap;

			if ( this[ 0 ] ) {
				if ( jQuery.isFunction( html ) ) {
					html = html.call( this[ 0 ] );
				}

				// The elements to wrap the target around
				wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

				if ( this[ 0 ].parentNode ) {
					wrap.insertBefore( this[ 0 ] );
				}

				wrap.map( function() {
					var elem = this;

					while ( elem.firstElementChild ) {
						elem = elem.firstElementChild;
					}

					return elem;
				} ).append( this );
			}

			return this;
		},

		wrapInner: function( html ) {
			if ( jQuery.isFunction( html ) ) {
				return this.each( function( i ) {
					jQuery( this ).wrapInner( html.call( this, i ) );
				} );
			}

			return this.each( function() {
				var self = jQuery( this ),
					contents = self.contents();

				if ( contents.length ) {
					contents.wrapAll( html );

				} else {
					self.append( html );
				}
			} );
		},

		wrap: function( html ) {
			var isFunction = jQuery.isFunction( html );

			return this.each( function( i ) {
				jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );
			} );
		},

		unwrap: function( selector ) {
			this.parent( selector ).not( "body" ).each( function() {
				jQuery( this ).replaceWith( this.childNodes );
			} );
			return this;
		}
	} );


	jQuery.expr.pseudos.hidden = function( elem ) {
		return !jQuery.expr.pseudos.visible( elem );
	};
	jQuery.expr.pseudos.visible = function( elem ) {
		return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
	};




	jQuery.ajaxSettings.xhr = function() {
		try {
			return new window.XMLHttpRequest();
		} catch ( e ) {}
	};

	var xhrSuccessStatus = {

			// File protocol always yields status code 0, assume 200
			0: 200,

			// Support: IE <=9 only
			// #1450: sometimes IE returns 1223 when it should be 204
			1223: 204
		},
		xhrSupported = jQuery.ajaxSettings.xhr();

	support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
	support.ajax = xhrSupported = !!xhrSupported;

	jQuery.ajaxTransport( function( options ) {
		var callback, errorCallback;

		// Cross domain only allowed if supported through XMLHttpRequest
		if ( support.cors || xhrSupported && !options.crossDomain ) {
			return {
				send: function( headers, complete ) {
					var i,
						xhr = options.xhr();

					xhr.open(
						options.type,
						options.url,
						options.async,
						options.username,
						options.password
					);

					// Apply custom fields if provided
					if ( options.xhrFields ) {
						for ( i in options.xhrFields ) {
							xhr[ i ] = options.xhrFields[ i ];
						}
					}

					// Override mime type if needed
					if ( options.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( options.mimeType );
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
						headers[ "X-Requested-With" ] = "XMLHttpRequest";
					}

					// Set headers
					for ( i in headers ) {
						xhr.setRequestHeader( i, headers[ i ] );
					}

					// Callback
					callback = function( type ) {
						return function() {
							if ( callback ) {
								callback = errorCallback = xhr.onload =
									xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;

								if ( type === "abort" ) {
									xhr.abort();
								} else if ( type === "error" ) {

									// Support: IE <=9 only
									// On a manual native abort, IE9 throws
									// errors on any property access that is not readyState
									if ( typeof xhr.status !== "number" ) {
										complete( 0, "error" );
									} else {
										complete(

											// File: protocol always yields status 0; see #8605, #14207
											xhr.status,
											xhr.statusText
										);
									}
								} else {
									complete(
										xhrSuccessStatus[ xhr.status ] || xhr.status,
										xhr.statusText,

										// Support: IE <=9 only
										// IE9 has no XHR2 but throws on binary (trac-11426)
										// For XHR2 non-text, let the caller handle it (gh-2498)
										( xhr.responseType || "text" ) !== "text"  ||
										typeof xhr.responseText !== "string" ?
											{ binary: xhr.response } :
											{ text: xhr.responseText },
										xhr.getAllResponseHeaders()
									);
								}
							}
						};
					};

					// Listen to events
					xhr.onload = callback();
					errorCallback = xhr.onerror = callback( "error" );

					// Support: IE 9 only
					// Use onreadystatechange to replace onabort
					// to handle uncaught aborts
					if ( xhr.onabort !== undefined ) {
						xhr.onabort = errorCallback;
					} else {
						xhr.onreadystatechange = function() {

							// Check readyState before timeout as it changes
							if ( xhr.readyState === 4 ) {

								// Allow onerror to be called first,
								// but that will not handle a native abort
								// Also, save errorCallback to a variable
								// as xhr.onerror cannot be accessed
								window.setTimeout( function() {
									if ( callback ) {
										errorCallback();
									}
								} );
							}
						};
					}

					// Create the abort callback
					callback = callback( "abort" );

					try {

						// Do send the request (this may raise an exception)
						xhr.send( options.hasContent && options.data || null );
					} catch ( e ) {

						// #14683: Only rethrow if this hasn't been notified as an error yet
						if ( callback ) {
							throw e;
						}
					}
				},

				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );




	// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
	jQuery.ajaxPrefilter( function( s ) {
		if ( s.crossDomain ) {
			s.contents.script = false;
		}
	} );

	// Install script dataType
	jQuery.ajaxSetup( {
		accepts: {
			script: "text/javascript, application/javascript, " +
				"application/ecmascript, application/x-ecmascript"
		},
		contents: {
			script: /\b(?:java|ecma)script\b/
		},
		converters: {
			"text script": function( text ) {
				jQuery.globalEval( text );
				return text;
			}
		}
	} );

	// Handle cache's special case and crossDomain
	jQuery.ajaxPrefilter( "script", function( s ) {
		if ( s.cache === undefined ) {
			s.cache = false;
		}
		if ( s.crossDomain ) {
			s.type = "GET";
		}
	} );

	// Bind script tag hack transport
	jQuery.ajaxTransport( "script", function( s ) {

		// This transport only deals with cross domain requests
		if ( s.crossDomain ) {
			var script, callback;
			return {
				send: function( _, complete ) {
					script = jQuery( "<script>" ).prop( {
						charset: s.scriptCharset,
						src: s.url
					} ).on(
						"load error",
						callback = function( evt ) {
							script.remove();
							callback = null;
							if ( evt ) {
								complete( evt.type === "error" ? 404 : 200, evt.type );
							}
						}
					);

					// Use native DOM manipulation to avoid our domManip AJAX trickery
					document.head.appendChild( script[ 0 ] );
				},
				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );




	var oldCallbacks = [],
		rjsonp = /(=)\?(?=&|$)|\?\?/;

	// Default jsonp settings
	jQuery.ajaxSetup( {
		jsonp: "callback",
		jsonpCallback: function() {
			var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
			this[ callback ] = true;
			return callback;
		}
	} );

	// Detect, normalize options and install callbacks for jsonp requests
	jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

		var callbackName, overwritten, responseContainer,
			jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
				"url" :
				typeof s.data === "string" &&
					( s.contentType || "" )
						.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
					rjsonp.test( s.data ) && "data"
			);

		// Handle iff the expected data type is "jsonp" or we have a parameter to set
		if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

			// Get callback name, remembering preexisting value associated with it
			callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
				s.jsonpCallback() :
				s.jsonpCallback;

			// Insert callback into url or form data
			if ( jsonProp ) {
				s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
			} else if ( s.jsonp !== false ) {
				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
			}

			// Use data converter to retrieve json after script execution
			s.converters[ "script json" ] = function() {
				if ( !responseContainer ) {
					jQuery.error( callbackName + " was not called" );
				}
				return responseContainer[ 0 ];
			};

			// Force json dataType
			s.dataTypes[ 0 ] = "json";

			// Install callback
			overwritten = window[ callbackName ];
			window[ callbackName ] = function() {
				responseContainer = arguments;
			};

			// Clean-up function (fires after converters)
			jqXHR.always( function() {

				// If previous value didn't exist - remove it
				if ( overwritten === undefined ) {
					jQuery( window ).removeProp( callbackName );

				// Otherwise restore preexisting value
				} else {
					window[ callbackName ] = overwritten;
				}

				// Save back as free
				if ( s[ callbackName ] ) {

					// Make sure that re-using the options doesn't screw things around
					s.jsonpCallback = originalSettings.jsonpCallback;

					// Save the callback name for future use
					oldCallbacks.push( callbackName );
				}

				// Call if it was a function and we have a response
				if ( responseContainer && jQuery.isFunction( overwritten ) ) {
					overwritten( responseContainer[ 0 ] );
				}

				responseContainer = overwritten = undefined;
			} );

			// Delegate to script
			return "script";
		}
	} );




	// Support: Safari 8 only
	// In Safari 8 documents created via document.implementation.createHTMLDocument
	// collapse sibling forms: the second one becomes a child of the first one.
	// Because of that, this security measure has to be disabled in Safari 8.
	// https://bugs.webkit.org/show_bug.cgi?id=137337
	support.createHTMLDocument = ( function() {
		var body = document.implementation.createHTMLDocument( "" ).body;
		body.innerHTML = "<form></form><form></form>";
		return body.childNodes.length === 2;
	} )();


	// Argument "data" should be string of html
	// context (optional): If specified, the fragment will be created in this context,
	// defaults to document
	// keepScripts (optional): If true, will include scripts passed in the html string
	jQuery.parseHTML = function( data, context, keepScripts ) {
		if ( typeof data !== "string" ) {
			return [];
		}
		if ( typeof context === "boolean" ) {
			keepScripts = context;
			context = false;
		}

		var base, parsed, scripts;

		if ( !context ) {

			// Stop scripts or inline event handlers from being executed immediately
			// by using document.implementation
			if ( support.createHTMLDocument ) {
				context = document.implementation.createHTMLDocument( "" );

				// Set the base href for the created document
				// so any parsed elements with URLs
				// are based on the document's URL (gh-2965)
				base = context.createElement( "base" );
				base.href = document.location.href;
				context.head.appendChild( base );
			} else {
				context = document;
			}
		}

		parsed = rsingleTag.exec( data );
		scripts = !keepScripts && [];

		// Single tag
		if ( parsed ) {
			return [ context.createElement( parsed[ 1 ] ) ];
		}

		parsed = buildFragment( [ data ], context, scripts );

		if ( scripts && scripts.length ) {
			jQuery( scripts ).remove();
		}

		return jQuery.merge( [], parsed.childNodes );
	};


	/**
	 * Load a url into a page
	 */
	jQuery.fn.load = function( url, params, callback ) {
		var selector, type, response,
			self = this,
			off = url.indexOf( " " );

		if ( off > -1 ) {
			selector = stripAndCollapse( url.slice( off ) );
			url = url.slice( 0, off );
		}

		// If it's a function
		if ( jQuery.isFunction( params ) ) {

			// We assume that it's the callback
			callback = params;
			params = undefined;

		// Otherwise, build a param string
		} else if ( params && typeof params === "object" ) {
			type = "POST";
		}

		// If we have elements to modify, make the request
		if ( self.length > 0 ) {
			jQuery.ajax( {
				url: url,

				// If "type" variable is undefined, then "GET" method will be used.
				// Make value of this field explicit since
				// user can override it through ajaxSetup method
				type: type || "GET",
				dataType: "html",
				data: params
			} ).done( function( responseText ) {

				// Save response for use in complete callback
				response = arguments;

				self.html( selector ?

					// If a selector was specified, locate the right elements in a dummy div
					// Exclude scripts to avoid IE 'Permission Denied' errors
					jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

					// Otherwise use the full result
					responseText );

			// If the request succeeds, this function gets "data", "status", "jqXHR"
			// but they are ignored because response was set above.
			// If it fails, this function gets "jqXHR", "status", "error"
			} ).always( callback && function( jqXHR, status ) {
				self.each( function() {
					callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
				} );
			} );
		}

		return this;
	};




	// Attach a bunch of functions for handling common AJAX events
	jQuery.each( [
		"ajaxStart",
		"ajaxStop",
		"ajaxComplete",
		"ajaxError",
		"ajaxSuccess",
		"ajaxSend"
	], function( i, type ) {
		jQuery.fn[ type ] = function( fn ) {
			return this.on( type, fn );
		};
	} );




	jQuery.expr.pseudos.animated = function( elem ) {
		return jQuery.grep( jQuery.timers, function( fn ) {
			return elem === fn.elem;
		} ).length;
	};




	/**
	 * Gets a window from an element
	 */
	function getWindow( elem ) {
		return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
	}

	jQuery.offset = {
		setOffset: function( elem, options, i ) {
			var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
				position = jQuery.css( elem, "position" ),
				curElem = jQuery( elem ),
				props = {};

			// Set position first, in-case top/left are set even on static elem
			if ( position === "static" ) {
				elem.style.position = "relative";
			}

			curOffset = curElem.offset();
			curCSSTop = jQuery.css( elem, "top" );
			curCSSLeft = jQuery.css( elem, "left" );
			calculatePosition = ( position === "absolute" || position === "fixed" ) &&
				( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

			// Need to be able to calculate position if either
			// top or left is auto and position is either absolute or fixed
			if ( calculatePosition ) {
				curPosition = curElem.position();
				curTop = curPosition.top;
				curLeft = curPosition.left;

			} else {
				curTop = parseFloat( curCSSTop ) || 0;
				curLeft = parseFloat( curCSSLeft ) || 0;
			}

			if ( jQuery.isFunction( options ) ) {

				// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
				options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
			}

			if ( options.top != null ) {
				props.top = ( options.top - curOffset.top ) + curTop;
			}
			if ( options.left != null ) {
				props.left = ( options.left - curOffset.left ) + curLeft;
			}

			if ( "using" in options ) {
				options.using.call( elem, props );

			} else {
				curElem.css( props );
			}
		}
	};

	jQuery.fn.extend( {
		offset: function( options ) {

			// Preserve chaining for setter
			if ( arguments.length ) {
				return options === undefined ?
					this :
					this.each( function( i ) {
						jQuery.offset.setOffset( this, options, i );
					} );
			}

			var docElem, win, rect, doc,
				elem = this[ 0 ];

			if ( !elem ) {
				return;
			}

			// Support: IE <=11 only
			// Running getBoundingClientRect on a
			// disconnected node in IE throws an error
			if ( !elem.getClientRects().length ) {
				return { top: 0, left: 0 };
			}

			rect = elem.getBoundingClientRect();

			// Make sure element is not hidden (display: none)
			if ( rect.width || rect.height ) {
				doc = elem.ownerDocument;
				win = getWindow( doc );
				docElem = doc.documentElement;

				return {
					top: rect.top + win.pageYOffset - docElem.clientTop,
					left: rect.left + win.pageXOffset - docElem.clientLeft
				};
			}

			// Return zeros for disconnected and hidden elements (gh-2310)
			return rect;
		},

		position: function() {
			if ( !this[ 0 ] ) {
				return;
			}

			var offsetParent, offset,
				elem = this[ 0 ],
				parentOffset = { top: 0, left: 0 };

			// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
			// because it is its only offset parent
			if ( jQuery.css( elem, "position" ) === "fixed" ) {

				// Assume getBoundingClientRect is there when computed position is fixed
				offset = elem.getBoundingClientRect();

			} else {

				// Get *real* offsetParent
				offsetParent = this.offsetParent();

				// Get correct offsets
				offset = this.offset();
				if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
					parentOffset = offsetParent.offset();
				}

				// Add offsetParent borders
				parentOffset = {
					top: parentOffset.top + jQuery.css( offsetParent[ 0 ], "borderTopWidth", true ),
					left: parentOffset.left + jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true )
				};
			}

			// Subtract parent offsets and element margins
			return {
				top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
				left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
			};
		},

		// This method will return documentElement in the following cases:
		// 1) For the element inside the iframe without offsetParent, this method will return
		//    documentElement of the parent window
		// 2) For the hidden or detached element
		// 3) For body or html element, i.e. in case of the html node - it will return itself
		//
		// but those exceptions were never presented as a real life use-cases
		// and might be considered as more preferable results.
		//
		// This logic, however, is not guaranteed and can change at any point in the future
		offsetParent: function() {
			return this.map( function() {
				var offsetParent = this.offsetParent;

				while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
					offsetParent = offsetParent.offsetParent;
				}

				return offsetParent || documentElement;
			} );
		}
	} );

	// Create scrollLeft and scrollTop methods
	jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
		var top = "pageYOffset" === prop;

		jQuery.fn[ method ] = function( val ) {
			return access( this, function( elem, method, val ) {
				var win = getWindow( elem );

				if ( val === undefined ) {
					return win ? win[ prop ] : elem[ method ];
				}

				if ( win ) {
					win.scrollTo(
						!top ? val : win.pageXOffset,
						top ? val : win.pageYOffset
					);

				} else {
					elem[ method ] = val;
				}
			}, method, val, arguments.length );
		};
	} );

	// Support: Safari <=7 - 9.1, Chrome <=37 - 49
	// Add the top/left cssHooks using jQuery.fn.position
	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
	// getComputedStyle returns percent when specified for top/left/bottom/right;
	// rather than make the css module depend on the offset module, just check for it here
	jQuery.each( [ "top", "left" ], function( i, prop ) {
		jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
			function( elem, computed ) {
				if ( computed ) {
					computed = curCSS( elem, prop );

					// If curCSS returns percentage, fallback to offset
					return rnumnonpx.test( computed ) ?
						jQuery( elem ).position()[ prop ] + "px" :
						computed;
				}
			}
		);
	} );


	// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
	jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
		jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
			function( defaultExtra, funcName ) {

			// Margin is only for outerHeight, outerWidth
			jQuery.fn[ funcName ] = function( margin, value ) {
				var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
					extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

				return access( this, function( elem, type, value ) {
					var doc;

					if ( jQuery.isWindow( elem ) ) {

						// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
						return funcName.indexOf( "outer" ) === 0 ?
							elem[ "inner" + name ] :
							elem.document.documentElement[ "client" + name ];
					}

					// Get document width or height
					if ( elem.nodeType === 9 ) {
						doc = elem.documentElement;

						// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
						// whichever is greatest
						return Math.max(
							elem.body[ "scroll" + name ], doc[ "scroll" + name ],
							elem.body[ "offset" + name ], doc[ "offset" + name ],
							doc[ "client" + name ]
						);
					}

					return value === undefined ?

						// Get width or height on the element, requesting but not forcing parseFloat
						jQuery.css( elem, type, extra ) :

						// Set width or height on the element
						jQuery.style( elem, type, value, extra );
				}, type, chainable ? margin : undefined, chainable );
			};
		} );
	} );


	jQuery.fn.extend( {

		bind: function( types, data, fn ) {
			return this.on( types, null, data, fn );
		},
		unbind: function( types, fn ) {
			return this.off( types, null, fn );
		},

		delegate: function( selector, types, data, fn ) {
			return this.on( types, selector, data, fn );
		},
		undelegate: function( selector, types, fn ) {

			// ( namespace ) or ( selector, types [, fn] )
			return arguments.length === 1 ?
				this.off( selector, "**" ) :
				this.off( types, selector || "**", fn );
		}
	} );

	jQuery.parseJSON = JSON.parse;




	// Register as a named AMD module, since jQuery can be concatenated with other
	// files that may use define, but not via a proper concatenation script that
	// understands anonymous AMD modules. A named AMD is safest and most robust
	// way to register. Lowercase jquery is used because AMD module names are
	// derived from file names, and jQuery is normally delivered in a lowercase
	// file name. Do this after creating the global so that if an AMD module wants
	// to call noConflict to hide this version of jQuery, it will work.

	// Note that for maximum portability, libraries that are not jQuery should
	// declare themselves as anonymous modules, and avoid setting a global if an
	// AMD loader is present. jQuery is a special case. For more information, see
	// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

	if ( true ) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
			return jQuery;
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}




	var

		// Map over jQuery in case of overwrite
		_jQuery = window.jQuery,

		// Map over the $ in case of overwrite
		_$ = window.$;

	jQuery.noConflict = function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}

		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	};

	// Expose jQuery and $ identifiers, even in AMD
	// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
	// and CommonJS for browser emulators (#13566)
	if ( !noGlobal ) {
		window.jQuery = window.$ = jQuery;
	}





	return jQuery;
	} );


/***/ },
/* 7 */
/***/ function(module, exports) {

	/******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};

	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {

	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId])
	/******/ 			return installedModules[moduleId].exports;

	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			exports: {},
	/******/ 			id: moduleId,
	/******/ 			loaded: false
	/******/ 		};

	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

	/******/ 		// Flag the module as loaded
	/******/ 		module.loaded = true;

	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}


	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;

	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;

	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "";

	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(0);
	/******/ })
	/************************************************************************/
	/******/ ([
	/* 0 */
	/***/ function(module, exports, __webpack_require__) {

		__webpack_require__(1);
		__webpack_require__(1);
		module.exports = __webpack_require__(6);


	/***/ },
	/* 1 */
	/***/ function(module, exports, __webpack_require__) {

		var Vue = __webpack_require__(2);
		var app1 = __webpack_require__(3);
		var logic = __webpack_require__(4);

	/***/ },
	/* 2 */
	/***/ function(module, exports, __webpack_require__) {

		/*!
		 * Vue.js v2.0.5
		 * (c) 2014-2016 Evan You
		 * Released under the MIT License.
		 */
		(function (global, factory) {
		   true ? module.exports = factory() :
		  typeof define === 'function' && define.amd ? define(factory) :
		  (global.Vue = factory());
		}(this, (function () { 'use strict';

		/*  */

		/**
		 * Convert a value to a string that is actually rendered.
		 */
		function _toString (val) {
		  return val == null
		    ? ''
		    : typeof val === 'object'
		      ? JSON.stringify(val, null, 2)
		      : String(val)
		}

		/**
		 * Convert a input value to a number for persistence.
		 * If the conversion fails, return original string.
		 */
		function toNumber (val) {
		  var n = parseFloat(val, 10);
		  return (n || n === 0) ? n : val
		}

		/**
		 * Make a map and return a function for checking if a key
		 * is in that map.
		 */
		function makeMap (
		  str,
		  expectsLowerCase
		) {
		  var map = Object.create(null);
		  var list = str.split(',');
		  for (var i = 0; i < list.length; i++) {
		    map[list[i]] = true;
		  }
		  return expectsLowerCase
		    ? function (val) { return map[val.toLowerCase()]; }
		    : function (val) { return map[val]; }
		}

		/**
		 * Check if a tag is a built-in tag.
		 */
		var isBuiltInTag = makeMap('slot,component', true);

		/**
		 * Remove an item from an array
		 */
		function remove$1 (arr, item) {
		  if (arr.length) {
		    var index = arr.indexOf(item);
		    if (index > -1) {
		      return arr.splice(index, 1)
		    }
		  }
		}

		/**
		 * Check whether the object has the property.
		 */
		var hasOwnProperty = Object.prototype.hasOwnProperty;
		function hasOwn (obj, key) {
		  return hasOwnProperty.call(obj, key)
		}

		/**
		 * Check if value is primitive
		 */
		function isPrimitive (value) {
		  return typeof value === 'string' || typeof value === 'number'
		}

		/**
		 * Create a cached version of a pure function.
		 */
		function cached (fn) {
		  var cache = Object.create(null);
		  return function cachedFn (str) {
		    var hit = cache[str];
		    return hit || (cache[str] = fn(str))
		  }
		}

		/**
		 * Camelize a hyphen-delmited string.
		 */
		var camelizeRE = /-(\w)/g;
		var camelize = cached(function (str) {
		  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })
		});

		/**
		 * Capitalize a string.
		 */
		var capitalize = cached(function (str) {
		  return str.charAt(0).toUpperCase() + str.slice(1)
		});

		/**
		 * Hyphenate a camelCase string.
		 */
		var hyphenateRE = /([^-])([A-Z])/g;
		var hyphenate = cached(function (str) {
		  return str
		    .replace(hyphenateRE, '$1-$2')
		    .replace(hyphenateRE, '$1-$2')
		    .toLowerCase()
		});

		/**
		 * Simple bind, faster than native
		 */
		function bind$1 (fn, ctx) {
		  function boundFn (a) {
		    var l = arguments.length;
		    return l
		      ? l > 1
		        ? fn.apply(ctx, arguments)
		        : fn.call(ctx, a)
		      : fn.call(ctx)
		  }
		  // record original fn length
		  boundFn._length = fn.length;
		  return boundFn
		}

		/**
		 * Convert an Array-like object to a real Array.
		 */
		function toArray (list, start) {
		  start = start || 0;
		  var i = list.length - start;
		  var ret = new Array(i);
		  while (i--) {
		    ret[i] = list[i + start];
		  }
		  return ret
		}

		/**
		 * Mix properties into target object.
		 */
		function extend (to, _from) {
		  for (var key in _from) {
		    to[key] = _from[key];
		  }
		  return to
		}

		/**
		 * Quick object check - this is primarily used to tell
		 * Objects from primitive values when we know the value
		 * is a JSON-compliant type.
		 */
		function isObject (obj) {
		  return obj !== null && typeof obj === 'object'
		}

		/**
		 * Strict object type check. Only returns true
		 * for plain JavaScript objects.
		 */
		var toString = Object.prototype.toString;
		var OBJECT_STRING = '[object Object]';
		function isPlainObject (obj) {
		  return toString.call(obj) === OBJECT_STRING
		}

		/**
		 * Merge an Array of Objects into a single Object.
		 */
		function toObject (arr) {
		  var res = {};
		  for (var i = 0; i < arr.length; i++) {
		    if (arr[i]) {
		      extend(res, arr[i]);
		    }
		  }
		  return res
		}

		/**
		 * Perform no operation.
		 */
		function noop () {}

		/**
		 * Always return false.
		 */
		var no = function () { return false; };

		/**
		 * Generate a static keys string from compiler modules.
		 */
		function genStaticKeys (modules) {
		  return modules.reduce(function (keys, m) {
		    return keys.concat(m.staticKeys || [])
		  }, []).join(',')
		}

		/**
		 * Check if two values are loosely equal - that is,
		 * if they are plain objects, do they have the same shape?
		 */
		function looseEqual (a, b) {
		  /* eslint-disable eqeqeq */
		  return a == b || (
		    isObject(a) && isObject(b)
		      ? JSON.stringify(a) === JSON.stringify(b)
		      : false
		  )
		  /* eslint-enable eqeqeq */
		}

		function looseIndexOf (arr, val) {
		  for (var i = 0; i < arr.length; i++) {
		    if (looseEqual(arr[i], val)) { return i }
		  }
		  return -1
		}

		/*  */

		var config = {
		  /**
		   * Option merge strategies (used in core/util/options)
		   */
		  optionMergeStrategies: Object.create(null),

		  /**
		   * Whether to suppress warnings.
		   */
		  silent: false,

		  /**
		   * Whether to enable devtools
		   */
		  devtools: "development" !== 'production',

		  /**
		   * Error handler for watcher errors
		   */
		  errorHandler: null,

		  /**
		   * Ignore certain custom elements
		   */
		  ignoredElements: null,

		  /**
		   * Custom user key aliases for v-on
		   */
		  keyCodes: Object.create(null),

		  /**
		   * Check if a tag is reserved so that it cannot be registered as a
		   * component. This is platform-dependent and may be overwritten.
		   */
		  isReservedTag: no,

		  /**
		   * Check if a tag is an unknown element.
		   * Platform-dependent.
		   */
		  isUnknownElement: no,

		  /**
		   * Get the namespace of an element
		   */
		  getTagNamespace: noop,

		  /**
		   * Check if an attribute must be bound using property, e.g. value
		   * Platform-dependent.
		   */
		  mustUseProp: no,

		  /**
		   * List of asset types that a component can own.
		   */
		  _assetTypes: [
		    'component',
		    'directive',
		    'filter'
		  ],

		  /**
		   * List of lifecycle hooks.
		   */
		  _lifecycleHooks: [
		    'beforeCreate',
		    'created',
		    'beforeMount',
		    'mounted',
		    'beforeUpdate',
		    'updated',
		    'beforeDestroy',
		    'destroyed',
		    'activated',
		    'deactivated'
		  ],

		  /**
		   * Max circular updates allowed in a scheduler flush cycle.
		   */
		  _maxUpdateCount: 100,

		  /**
		   * Server rendering?
		   */
		  _isServer: "client" === 'server'
		};

		/*  */

		/**
		 * Check if a string starts with $ or _
		 */
		function isReserved (str) {
		  var c = (str + '').charCodeAt(0);
		  return c === 0x24 || c === 0x5F
		}

		/**
		 * Define a property.
		 */
		function def (obj, key, val, enumerable) {
		  Object.defineProperty(obj, key, {
		    value: val,
		    enumerable: !!enumerable,
		    writable: true,
		    configurable: true
		  });
		}

		/**
		 * Parse simple path.
		 */
		var bailRE = /[^\w.$]/;
		function parsePath (path) {
		  if (bailRE.test(path)) {
		    return
		  } else {
		    var segments = path.split('.');
		    return function (obj) {
		      for (var i = 0; i < segments.length; i++) {
		        if (!obj) { return }
		        obj = obj[segments[i]];
		      }
		      return obj
		    }
		  }
		}

		/*  */
		/* globals MutationObserver */

		// can we use __proto__?
		var hasProto = '__proto__' in {};

		// Browser environment sniffing
		var inBrowser =
		  typeof window !== 'undefined' &&
		  Object.prototype.toString.call(window) !== '[object Object]';

		var UA = inBrowser && window.navigator.userAgent.toLowerCase();
		var isIE = UA && /msie|trident/.test(UA);
		var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
		var isEdge = UA && UA.indexOf('edge/') > 0;
		var isAndroid = UA && UA.indexOf('android') > 0;
		var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);

		// detect devtools
		var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

		/* istanbul ignore next */
		function isNative (Ctor) {
		  return /native code/.test(Ctor.toString())
		}

		/**
		 * Defer a task to execute it asynchronously.
		 */
		var nextTick = (function () {
		  var callbacks = [];
		  var pending = false;
		  var timerFunc;

		  function nextTickHandler () {
		    pending = false;
		    var copies = callbacks.slice(0);
		    callbacks.length = 0;
		    for (var i = 0; i < copies.length; i++) {
		      copies[i]();
		    }
		  }

		  // the nextTick behavior leverages the microtask queue, which can be accessed
		  // via either native Promise.then or MutationObserver.
		  // MutationObserver has wider support, however it is seriously bugged in
		  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
		  // completely stops working after triggering a few times... so, if native
		  // Promise is available, we will use it:
		  /* istanbul ignore if */
		  if (typeof Promise !== 'undefined' && isNative(Promise)) {
		    var p = Promise.resolve();
		    timerFunc = function () {
		      p.then(nextTickHandler);
		      // in problematic UIWebViews, Promise.then doesn't completely break, but
		      // it can get stuck in a weird state where callbacks are pushed into the
		      // microtask queue but the queue isn't being flushed, until the browser
		      // needs to do some other work, e.g. handle a timer. Therefore we can
		      // "force" the microtask queue to be flushed by adding an empty timer.
		      if (isIOS) { setTimeout(noop); }
		    };
		  } else if (typeof MutationObserver !== 'undefined' && (
		    isNative(MutationObserver) ||
		    // PhantomJS and iOS 7.x
		    MutationObserver.toString() === '[object MutationObserverConstructor]'
		  )) {
		    // use MutationObserver where native Promise is not available,
		    // e.g. PhantomJS IE11, iOS7, Android 4.4
		    var counter = 1;
		    var observer = new MutationObserver(nextTickHandler);
		    var textNode = document.createTextNode(String(counter));
		    observer.observe(textNode, {
		      characterData: true
		    });
		    timerFunc = function () {
		      counter = (counter + 1) % 2;
		      textNode.data = String(counter);
		    };
		  } else {
		    // fallback to setTimeout
		    /* istanbul ignore next */
		    timerFunc = function () {
		      setTimeout(nextTickHandler, 0);
		    };
		  }

		  return function queueNextTick (cb, ctx) {
		    var func = ctx
		      ? function () { cb.call(ctx); }
		      : cb;
		    callbacks.push(func);
		    if (!pending) {
		      pending = true;
		      timerFunc();
		    }
		  }
		})();

		var _Set;
		/* istanbul ignore if */
		if (typeof Set !== 'undefined' && isNative(Set)) {
		  // use native Set when available.
		  _Set = Set;
		} else {
		  // a non-standard Set polyfill that only works with primitive keys.
		  _Set = (function () {
		    function Set () {
		      this.set = Object.create(null);
		    }
		    Set.prototype.has = function has (key) {
		      return this.set[key] !== undefined
		    };
		    Set.prototype.add = function add (key) {
		      this.set[key] = 1;
		    };
		    Set.prototype.clear = function clear () {
		      this.set = Object.create(null);
		    };

		    return Set;
		  }());
		}

		/* not type checking this file because flow doesn't play well with Proxy */

		var hasProxy;
		var proxyHandlers;
		var initProxy;

		{
		  var allowedGlobals = makeMap(
		    'Infinity,undefined,NaN,isFinite,isNaN,' +
		    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +
		    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +
		    'require' // for Webpack/Browserify
		  );

		  hasProxy =
		    typeof Proxy !== 'undefined' &&
		    Proxy.toString().match(/native code/);

		  proxyHandlers = {
		    has: function has (target, key) {
		      var has = key in target;
		      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';
		      if (!has && !isAllowed) {
		        warn(
		          "Property or method \"" + key + "\" is not defined on the instance but " +
		          "referenced during render. Make sure to declare reactive data " +
		          "properties in the data option.",
		          target
		        );
		      }
		      return has || !isAllowed
		    }
		  };

		  initProxy = function initProxy (vm) {
		    if (hasProxy) {
		      vm._renderProxy = new Proxy(vm, proxyHandlers);
		    } else {
		      vm._renderProxy = vm;
		    }
		  };
		}

		/*  */


		var uid$2 = 0;

		/**
		 * A dep is an observable that can have multiple
		 * directives subscribing to it.
		 */
		var Dep = function Dep () {
		  this.id = uid$2++;
		  this.subs = [];
		};

		Dep.prototype.addSub = function addSub (sub) {
		  this.subs.push(sub);
		};

		Dep.prototype.removeSub = function removeSub (sub) {
		  remove$1(this.subs, sub);
		};

		Dep.prototype.depend = function depend () {
		  if (Dep.target) {
		    Dep.target.addDep(this);
		  }
		};

		Dep.prototype.notify = function notify () {
		  // stablize the subscriber list first
		  var subs = this.subs.slice();
		  for (var i = 0, l = subs.length; i < l; i++) {
		    subs[i].update();
		  }
		};

		// the current target watcher being evaluated.
		// this is globally unique because there could be only one
		// watcher being evaluated at any time.
		Dep.target = null;
		var targetStack = [];

		function pushTarget (_target) {
		  if (Dep.target) { targetStack.push(Dep.target); }
		  Dep.target = _target;
		}

		function popTarget () {
		  Dep.target = targetStack.pop();
		}

		/*  */


		var queue = [];
		var has$1 = {};
		var circular = {};
		var waiting = false;
		var flushing = false;
		var index = 0;

		/**
		 * Reset the scheduler's state.
		 */
		function resetSchedulerState () {
		  queue.length = 0;
		  has$1 = {};
		  {
		    circular = {};
		  }
		  waiting = flushing = false;
		}

		/**
		 * Flush both queues and run the watchers.
		 */
		function flushSchedulerQueue () {
		  flushing = true;

		  // Sort queue before flush.
		  // This ensures that:
		  // 1. Components are updated from parent to child. (because parent is always
		  //    created before the child)
		  // 2. A component's user watchers are run before its render watcher (because
		  //    user watchers are created before the render watcher)
		  // 3. If a component is destroyed during a parent component's watcher run,
		  //    its watchers can be skipped.
		  queue.sort(function (a, b) { return a.id - b.id; });

		  // do not cache length because more watchers might be pushed
		  // as we run existing watchers
		  for (index = 0; index < queue.length; index++) {
		    var watcher = queue[index];
		    var id = watcher.id;
		    has$1[id] = null;
		    watcher.run();
		    // in dev build, check and stop circular updates.
		    if ("development" !== 'production' && has$1[id] != null) {
		      circular[id] = (circular[id] || 0) + 1;
		      if (circular[id] > config._maxUpdateCount) {
		        warn(
		          'You may have an infinite update loop ' + (
		            watcher.user
		              ? ("in watcher with expression \"" + (watcher.expression) + "\"")
		              : "in a component render function."
		          ),
		          watcher.vm
		        );
		        break
		      }
		    }
		  }

		  // devtool hook
		  /* istanbul ignore if */
		  if (devtools && config.devtools) {
		    devtools.emit('flush');
		  }

		  resetSchedulerState();
		}

		/**
		 * Push a watcher into the watcher queue.
		 * Jobs with duplicate IDs will be skipped unless it's
		 * pushed when the queue is being flushed.
		 */
		function queueWatcher (watcher) {
		  var id = watcher.id;
		  if (has$1[id] == null) {
		    has$1[id] = true;
		    if (!flushing) {
		      queue.push(watcher);
		    } else {
		      // if already flushing, splice the watcher based on its id
		      // if already past its id, it will be run next immediately.
		      var i = queue.length - 1;
		      while (i >= 0 && queue[i].id > watcher.id) {
		        i--;
		      }
		      queue.splice(Math.max(i, index) + 1, 0, watcher);
		    }
		    // queue the flush
		    if (!waiting) {
		      waiting = true;
		      nextTick(flushSchedulerQueue);
		    }
		  }
		}

		/*  */

		var uid$1 = 0;

		/**
		 * A watcher parses an expression, collects dependencies,
		 * and fires callback when the expression value changes.
		 * This is used for both the $watch() api and directives.
		 */
		var Watcher = function Watcher (
		  vm,
		  expOrFn,
		  cb,
		  options
		) {
		  if ( options === void 0 ) options = {};

		  this.vm = vm;
		  vm._watchers.push(this);
		  // options
		  this.deep = !!options.deep;
		  this.user = !!options.user;
		  this.lazy = !!options.lazy;
		  this.sync = !!options.sync;
		  this.expression = expOrFn.toString();
		  this.cb = cb;
		  this.id = ++uid$1; // uid for batching
		  this.active = true;
		  this.dirty = this.lazy; // for lazy watchers
		  this.deps = [];
		  this.newDeps = [];
		  this.depIds = new _Set();
		  this.newDepIds = new _Set();
		  // parse expression for getter
		  if (typeof expOrFn === 'function') {
		    this.getter = expOrFn;
		  } else {
		    this.getter = parsePath(expOrFn);
		    if (!this.getter) {
		      this.getter = function () {};
		      "development" !== 'production' && warn(
		        "Failed watching path: \"" + expOrFn + "\" " +
		        'Watcher only accepts simple dot-delimited paths. ' +
		        'For full control, use a function instead.',
		        vm
		      );
		    }
		  }
		  this.value = this.lazy
		    ? undefined
		    : this.get();
		};

		/**
		 * Evaluate the getter, and re-collect dependencies.
		 */
		Watcher.prototype.get = function get () {
		  pushTarget(this);
		  var value = this.getter.call(this.vm, this.vm);
		  // "touch" every property so they are all tracked as
		  // dependencies for deep watching
		  if (this.deep) {
		    traverse(value);
		  }
		  popTarget();
		  this.cleanupDeps();
		  return value
		};

		/**
		 * Add a dependency to this directive.
		 */
		Watcher.prototype.addDep = function addDep (dep) {
		  var id = dep.id;
		  if (!this.newDepIds.has(id)) {
		    this.newDepIds.add(id);
		    this.newDeps.push(dep);
		    if (!this.depIds.has(id)) {
		      dep.addSub(this);
		    }
		  }
		};

		/**
		 * Clean up for dependency collection.
		 */
		Watcher.prototype.cleanupDeps = function cleanupDeps () {
		    var this$1 = this;

		  var i = this.deps.length;
		  while (i--) {
		    var dep = this$1.deps[i];
		    if (!this$1.newDepIds.has(dep.id)) {
		      dep.removeSub(this$1);
		    }
		  }
		  var tmp = this.depIds;
		  this.depIds = this.newDepIds;
		  this.newDepIds = tmp;
		  this.newDepIds.clear();
		  tmp = this.deps;
		  this.deps = this.newDeps;
		  this.newDeps = tmp;
		  this.newDeps.length = 0;
		};

		/**
		 * Subscriber interface.
		 * Will be called when a dependency changes.
		 */
		Watcher.prototype.update = function update () {
		  /* istanbul ignore else */
		  if (this.lazy) {
		    this.dirty = true;
		  } else if (this.sync) {
		    this.run();
		  } else {
		    queueWatcher(this);
		  }
		};

		/**
		 * Scheduler job interface.
		 * Will be called by the scheduler.
		 */
		Watcher.prototype.run = function run () {
		  if (this.active) {
		    var value = this.get();
		      if (
		        value !== this.value ||
		      // Deep watchers and watchers on Object/Arrays should fire even
		      // when the value is the same, because the value may
		      // have mutated.
		      isObject(value) ||
		      this.deep
		    ) {
		      // set new value
		      var oldValue = this.value;
		      this.value = value;
		      if (this.user) {
		        try {
		          this.cb.call(this.vm, value, oldValue);
		        } catch (e) {
		          "development" !== 'production' && warn(
		            ("Error in watcher \"" + (this.expression) + "\""),
		            this.vm
		          );
		          /* istanbul ignore else */
		          if (config.errorHandler) {
		            config.errorHandler.call(null, e, this.vm);
		          } else {
		            throw e
		          }
		        }
		      } else {
		        this.cb.call(this.vm, value, oldValue);
		      }
		    }
		  }
		};

		/**
		 * Evaluate the value of the watcher.
		 * This only gets called for lazy watchers.
		 */
		Watcher.prototype.evaluate = function evaluate () {
		  this.value = this.get();
		  this.dirty = false;
		};

		/**
		 * Depend on all deps collected by this watcher.
		 */
		Watcher.prototype.depend = function depend () {
		    var this$1 = this;

		  var i = this.deps.length;
		  while (i--) {
		    this$1.deps[i].depend();
		  }
		};

		/**
		 * Remove self from all dependencies' subscriber list.
		 */
		Watcher.prototype.teardown = function teardown () {
		    var this$1 = this;

		  if (this.active) {
		    // remove self from vm's watcher list
		    // this is a somewhat expensive operation so we skip it
		    // if the vm is being destroyed or is performing a v-for
		    // re-render (the watcher list is then filtered by v-for).
		    if (!this.vm._isBeingDestroyed && !this.vm._vForRemoving) {
		      remove$1(this.vm._watchers, this);
		    }
		    var i = this.deps.length;
		    while (i--) {
		      this$1.deps[i].removeSub(this$1);
		    }
		    this.active = false;
		  }
		};

		/**
		 * Recursively traverse an object to evoke all converted
		 * getters, so that every nested property inside the object
		 * is collected as a "deep" dependency.
		 */
		var seenObjects = new _Set();
		function traverse (val) {
		  seenObjects.clear();
		  _traverse(val, seenObjects);
		}

		function _traverse (val, seen) {
		  var i, keys;
		  var isA = Array.isArray(val);
		  if ((!isA && !isObject(val)) || !Object.isExtensible(val)) {
		    return
		  }
		  if (val.__ob__) {
		    var depId = val.__ob__.dep.id;
		    if (seen.has(depId)) {
		      return
		    }
		    seen.add(depId);
		  }
		  if (isA) {
		    i = val.length;
		    while (i--) { _traverse(val[i], seen); }
		  } else {
		    keys = Object.keys(val);
		    i = keys.length;
		    while (i--) { _traverse(val[keys[i]], seen); }
		  }
		}

		/*
		 * not type checking this file because flow doesn't play well with
		 * dynamically accessing methods on Array prototype
		 */

		var arrayProto = Array.prototype;
		var arrayMethods = Object.create(arrayProto);[
		  'push',
		  'pop',
		  'shift',
		  'unshift',
		  'splice',
		  'sort',
		  'reverse'
		]
		.forEach(function (method) {
		  // cache original method
		  var original = arrayProto[method];
		  def(arrayMethods, method, function mutator () {
		    var arguments$1 = arguments;

		    // avoid leaking arguments:
		    // http://jsperf.com/closure-with-arguments
		    var i = arguments.length;
		    var args = new Array(i);
		    while (i--) {
		      args[i] = arguments$1[i];
		    }
		    var result = original.apply(this, args);
		    var ob = this.__ob__;
		    var inserted;
		    switch (method) {
		      case 'push':
		        inserted = args;
		        break
		      case 'unshift':
		        inserted = args;
		        break
		      case 'splice':
		        inserted = args.slice(2);
		        break
		    }
		    if (inserted) { ob.observeArray(inserted); }
		    // notify change
		    ob.dep.notify();
		    return result
		  });
		});

		/*  */

		var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

		/**
		 * By default, when a reactive property is set, the new value is
		 * also converted to become reactive. However when passing down props,
		 * we don't want to force conversion because the value may be a nested value
		 * under a frozen data structure. Converting it would defeat the optimization.
		 */
		var observerState = {
		  shouldConvert: true,
		  isSettingProps: false
		};

		/**
		 * Observer class that are attached to each observed
		 * object. Once attached, the observer converts target
		 * object's property keys into getter/setters that
		 * collect dependencies and dispatches updates.
		 */
		var Observer = function Observer (value) {
		  this.value = value;
		  this.dep = new Dep();
		  this.vmCount = 0;
		  def(value, '__ob__', this);
		  if (Array.isArray(value)) {
		    var augment = hasProto
		      ? protoAugment
		      : copyAugment;
		    augment(value, arrayMethods, arrayKeys);
		    this.observeArray(value);
		  } else {
		    this.walk(value);
		  }
		};

		/**
		 * Walk through each property and convert them into
		 * getter/setters. This method should only be called when
		 * value type is Object.
		 */
		Observer.prototype.walk = function walk (obj) {
		  var keys = Object.keys(obj);
		  for (var i = 0; i < keys.length; i++) {
		    defineReactive$$1(obj, keys[i], obj[keys[i]]);
		  }
		};

		/**
		 * Observe a list of Array items.
		 */
		Observer.prototype.observeArray = function observeArray (items) {
		  for (var i = 0, l = items.length; i < l; i++) {
		    observe(items[i]);
		  }
		};

		// helpers

		/**
		 * Augment an target Object or Array by intercepting
		 * the prototype chain using __proto__
		 */
		function protoAugment (target, src) {
		  /* eslint-disable no-proto */
		  target.__proto__ = src;
		  /* eslint-enable no-proto */
		}

		/**
		 * Augment an target Object or Array by defining
		 * hidden properties.
		 *
		 * istanbul ignore next
		 */
		function copyAugment (target, src, keys) {
		  for (var i = 0, l = keys.length; i < l; i++) {
		    var key = keys[i];
		    def(target, key, src[key]);
		  }
		}

		/**
		 * Attempt to create an observer instance for a value,
		 * returns the new observer if successfully observed,
		 * or the existing observer if the value already has one.
		 */
		function observe (value) {
		  if (!isObject(value)) {
		    return
		  }
		  var ob;
		  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
		    ob = value.__ob__;
		  } else if (
		    observerState.shouldConvert &&
		    !config._isServer &&
		    (Array.isArray(value) || isPlainObject(value)) &&
		    Object.isExtensible(value) &&
		    !value._isVue
		  ) {
		    ob = new Observer(value);
		  }
		  return ob
		}

		/**
		 * Define a reactive property on an Object.
		 */
		function defineReactive$$1 (
		  obj,
		  key,
		  val,
		  customSetter
		) {
		  var dep = new Dep();

		  var property = Object.getOwnPropertyDescriptor(obj, key);
		  if (property && property.configurable === false) {
		    return
		  }

		  // cater for pre-defined getter/setters
		  var getter = property && property.get;
		  var setter = property && property.set;

		  var childOb = observe(val);
		  Object.defineProperty(obj, key, {
		    enumerable: true,
		    configurable: true,
		    get: function reactiveGetter () {
		      var value = getter ? getter.call(obj) : val;
		      if (Dep.target) {
		        dep.depend();
		        if (childOb) {
		          childOb.dep.depend();
		        }
		        if (Array.isArray(value)) {
		          dependArray(value);
		        }
		      }
		      return value
		    },
		    set: function reactiveSetter (newVal) {
		      var value = getter ? getter.call(obj) : val;
		      if (newVal === value) {
		        return
		      }
		      if ("development" !== 'production' && customSetter) {
		        customSetter();
		      }
		      if (setter) {
		        setter.call(obj, newVal);
		      } else {
		        val = newVal;
		      }
		      childOb = observe(newVal);
		      dep.notify();
		    }
		  });
		}

		/**
		 * Set a property on an object. Adds the new property and
		 * triggers change notification if the property doesn't
		 * already exist.
		 */
		function set (obj, key, val) {
		  if (Array.isArray(obj)) {
		    obj.length = Math.max(obj.length, key);
		    obj.splice(key, 1, val);
		    return val
		  }
		  if (hasOwn(obj, key)) {
		    obj[key] = val;
		    return
		  }
		  var ob = obj.__ob__;
		  if (obj._isVue || (ob && ob.vmCount)) {
		    "development" !== 'production' && warn(
		      'Avoid adding reactive properties to a Vue instance or its root $data ' +
		      'at runtime - declare it upfront in the data option.'
		    );
		    return
		  }
		  if (!ob) {
		    obj[key] = val;
		    return
		  }
		  defineReactive$$1(ob.value, key, val);
		  ob.dep.notify();
		  return val
		}

		/**
		 * Delete a property and trigger change if necessary.
		 */
		function del (obj, key) {
		  var ob = obj.__ob__;
		  if (obj._isVue || (ob && ob.vmCount)) {
		    "development" !== 'production' && warn(
		      'Avoid deleting properties on a Vue instance or its root $data ' +
		      '- just set it to null.'
		    );
		    return
		  }
		  if (!hasOwn(obj, key)) {
		    return
		  }
		  delete obj[key];
		  if (!ob) {
		    return
		  }
		  ob.dep.notify();
		}

		/**
		 * Collect dependencies on array elements when the array is touched, since
		 * we cannot intercept array element access like property getters.
		 */
		function dependArray (value) {
		  for (var e = void 0, i = 0, l = value.length; i < l; i++) {
		    e = value[i];
		    e && e.__ob__ && e.__ob__.dep.depend();
		    if (Array.isArray(e)) {
		      dependArray(e);
		    }
		  }
		}

		/*  */

		function initState (vm) {
		  vm._watchers = [];
		  initProps(vm);
		  initData(vm);
		  initComputed(vm);
		  initMethods(vm);
		  initWatch(vm);
		}

		function initProps (vm) {
		  var props = vm.$options.props;
		  if (props) {
		    var propsData = vm.$options.propsData || {};
		    var keys = vm.$options._propKeys = Object.keys(props);
		    var isRoot = !vm.$parent;
		    // root instance props should be converted
		    observerState.shouldConvert = isRoot;
		    var loop = function ( i ) {
		      var key = keys[i];
		      /* istanbul ignore else */
		      {
		        defineReactive$$1(vm, key, validateProp(key, props, propsData, vm), function () {
		          if (vm.$parent && !observerState.isSettingProps) {
		            warn(
		              "Avoid mutating a prop directly since the value will be " +
		              "overwritten whenever the parent component re-renders. " +
		              "Instead, use a data or computed property based on the prop's " +
		              "value. Prop being mutated: \"" + key + "\"",
		              vm
		            );
		          }
		        });
		      }
		    };

		    for (var i = 0; i < keys.length; i++) loop( i );
		    observerState.shouldConvert = true;
		  }
		}

		function initData (vm) {
		  var data = vm.$options.data;
		  data = vm._data = typeof data === 'function'
		    ? data.call(vm)
		    : data || {};
		  if (!isPlainObject(data)) {
		    data = {};
		    "development" !== 'production' && warn(
		      'data functions should return an object.',
		      vm
		    );
		  }
		  // proxy data on instance
		  var keys = Object.keys(data);
		  var props = vm.$options.props;
		  var i = keys.length;
		  while (i--) {
		    if (props && hasOwn(props, keys[i])) {
		      "development" !== 'production' && warn(
		        "The data property \"" + (keys[i]) + "\" is already declared as a prop. " +
		        "Use prop default value instead.",
		        vm
		      );
		    } else {
		      proxy(vm, keys[i]);
		    }
		  }
		  // observe data
		  observe(data);
		  data.__ob__ && data.__ob__.vmCount++;
		}

		var computedSharedDefinition = {
		  enumerable: true,
		  configurable: true,
		  get: noop,
		  set: noop
		};

		function initComputed (vm) {
		  var computed = vm.$options.computed;
		  if (computed) {
		    for (var key in computed) {
		      var userDef = computed[key];
		      if (typeof userDef === 'function') {
		        computedSharedDefinition.get = makeComputedGetter(userDef, vm);
		        computedSharedDefinition.set = noop;
		      } else {
		        computedSharedDefinition.get = userDef.get
		          ? userDef.cache !== false
		            ? makeComputedGetter(userDef.get, vm)
		            : bind$1(userDef.get, vm)
		          : noop;
		        computedSharedDefinition.set = userDef.set
		          ? bind$1(userDef.set, vm)
		          : noop;
		      }
		      Object.defineProperty(vm, key, computedSharedDefinition);
		    }
		  }
		}

		function makeComputedGetter (getter, owner) {
		  var watcher = new Watcher(owner, getter, noop, {
		    lazy: true
		  });
		  return function computedGetter () {
		    if (watcher.dirty) {
		      watcher.evaluate();
		    }
		    if (Dep.target) {
		      watcher.depend();
		    }
		    return watcher.value
		  }
		}

		function initMethods (vm) {
		  var methods = vm.$options.methods;
		  if (methods) {
		    for (var key in methods) {
		      vm[key] = methods[key] == null ? noop : bind$1(methods[key], vm);
		      {
		        methods[key] == null && warn(
		          "method \"" + key + "\" has an undefined value in the component definition. " +
		          "Did you reference the function correctly?",
		          vm
		        );
		        hasOwn(Vue$2.prototype, key) && warn(
		          ("Avoid overriding Vue's internal method \"" + key + "\"."),
		          vm
		        );
		      }
		    }
		  }
		}

		function initWatch (vm) {
		  var watch = vm.$options.watch;
		  if (watch) {
		    for (var key in watch) {
		      var handler = watch[key];
		      if (Array.isArray(handler)) {
		        for (var i = 0; i < handler.length; i++) {
		          createWatcher(vm, key, handler[i]);
		        }
		      } else {
		        createWatcher(vm, key, handler);
		      }
		    }
		  }
		}

		function createWatcher (vm, key, handler) {
		  var options;
		  if (isPlainObject(handler)) {
		    options = handler;
		    handler = handler.handler;
		  }
		  if (typeof handler === 'string') {
		    handler = vm[handler];
		  }
		  vm.$watch(key, handler, options);
		}

		function stateMixin (Vue) {
		  // flow somehow has problems with directly declared definition object
		  // when using Object.defineProperty, so we have to procedurally build up
		  // the object here.
		  var dataDef = {};
		  dataDef.get = function () {
		    return this._data
		  };
		  {
		    dataDef.set = function (newData) {
		      warn(
		        'Avoid replacing instance root $data. ' +
		        'Use nested data properties instead.',
		        this
		      );
		    };
		  }
		  Object.defineProperty(Vue.prototype, '$data', dataDef);

		  Vue.prototype.$set = set;
		  Vue.prototype.$delete = del;

		  Vue.prototype.$watch = function (
		    expOrFn,
		    cb,
		    options
		  ) {
		    var vm = this;
		    options = options || {};
		    options.user = true;
		    var watcher = new Watcher(vm, expOrFn, cb, options);
		    if (options.immediate) {
		      cb.call(vm, watcher.value);
		    }
		    return function unwatchFn () {
		      watcher.teardown();
		    }
		  };
		}

		function proxy (vm, key) {
		  if (!isReserved(key)) {
		    Object.defineProperty(vm, key, {
		      configurable: true,
		      enumerable: true,
		      get: function proxyGetter () {
		        return vm._data[key]
		      },
		      set: function proxySetter (val) {
		        vm._data[key] = val;
		      }
		    });
		  }
		}

		/*  */

		var VNode = function VNode (
		  tag,
		  data,
		  children,
		  text,
		  elm,
		  ns,
		  context,
		  componentOptions
		) {
		  this.tag = tag;
		  this.data = data;
		  this.children = children;
		  this.text = text;
		  this.elm = elm;
		  this.ns = ns;
		  this.context = context;
		  this.functionalContext = undefined;
		  this.key = data && data.key;
		  this.componentOptions = componentOptions;
		  this.child = undefined;
		  this.parent = undefined;
		  this.raw = false;
		  this.isStatic = false;
		  this.isRootInsert = true;
		  this.isComment = false;
		  this.isCloned = false;
		  this.isOnce = false;
		};

		var emptyVNode = function () {
		  var node = new VNode();
		  node.text = '';
		  node.isComment = true;
		  return node
		};

		// optimized shallow clone
		// used for static nodes and slot nodes because they may be reused across
		// multiple renders, cloning them avoids errors when DOM manipulations rely
		// on their elm reference.
		function cloneVNode (vnode) {
		  var cloned = new VNode(
		    vnode.tag,
		    vnode.data,
		    vnode.children,
		    vnode.text,
		    vnode.elm,
		    vnode.ns,
		    vnode.context,
		    vnode.componentOptions
		  );
		  cloned.isStatic = vnode.isStatic;
		  cloned.key = vnode.key;
		  cloned.isCloned = true;
		  return cloned
		}

		function cloneVNodes (vnodes) {
		  var res = new Array(vnodes.length);
		  for (var i = 0; i < vnodes.length; i++) {
		    res[i] = cloneVNode(vnodes[i]);
		  }
		  return res
		}

		/*  */

		function mergeVNodeHook (def, hookKey, hook, key) {
		  key = key + hookKey;
		  var injectedHash = def.__injected || (def.__injected = {});
		  if (!injectedHash[key]) {
		    injectedHash[key] = true;
		    var oldHook = def[hookKey];
		    if (oldHook) {
		      def[hookKey] = function () {
		        oldHook.apply(this, arguments);
		        hook.apply(this, arguments);
		      };
		    } else {
		      def[hookKey] = hook;
		    }
		  }
		}

		/*  */

		function updateListeners (
		  on,
		  oldOn,
		  add,
		  remove$$1,
		  vm
		) {
		  var name, cur, old, fn, event, capture;
		  for (name in on) {
		    cur = on[name];
		    old = oldOn[name];
		    if (!cur) {
		      "development" !== 'production' && warn(
		        "Invalid handler for event \"" + name + "\": got " + String(cur),
		        vm
		      );
		    } else if (!old) {
		      capture = name.charAt(0) === '!';
		      event = capture ? name.slice(1) : name;
		      if (Array.isArray(cur)) {
		        add(event, (cur.invoker = arrInvoker(cur)), capture);
		      } else {
		        if (!cur.invoker) {
		          fn = cur;
		          cur = on[name] = {};
		          cur.fn = fn;
		          cur.invoker = fnInvoker(cur);
		        }
		        add(event, cur.invoker, capture);
		      }
		    } else if (cur !== old) {
		      if (Array.isArray(old)) {
		        old.length = cur.length;
		        for (var i = 0; i < old.length; i++) { old[i] = cur[i]; }
		        on[name] = old;
		      } else {
		        old.fn = cur;
		        on[name] = old;
		      }
		    }
		  }
		  for (name in oldOn) {
		    if (!on[name]) {
		      event = name.charAt(0) === '!' ? name.slice(1) : name;
		      remove$$1(event, oldOn[name].invoker);
		    }
		  }
		}

		function arrInvoker (arr) {
		  return function (ev) {
		    var arguments$1 = arguments;

		    var single = arguments.length === 1;
		    for (var i = 0; i < arr.length; i++) {
		      single ? arr[i](ev) : arr[i].apply(null, arguments$1);
		    }
		  }
		}

		function fnInvoker (o) {
		  return function (ev) {
		    var single = arguments.length === 1;
		    single ? o.fn(ev) : o.fn.apply(null, arguments);
		  }
		}

		/*  */

		function normalizeChildren (
		  children,
		  ns,
		  nestedIndex
		) {
		  if (isPrimitive(children)) {
		    return [createTextVNode(children)]
		  }
		  if (Array.isArray(children)) {
		    var res = [];
		    for (var i = 0, l = children.length; i < l; i++) {
		      var c = children[i];
		      var last = res[res.length - 1];
		      //  nested
		      if (Array.isArray(c)) {
		        res.push.apply(res, normalizeChildren(c, ns, ((nestedIndex || '') + "_" + i)));
		      } else if (isPrimitive(c)) {
		        if (last && last.text) {
		          last.text += String(c);
		        } else if (c !== '') {
		          // convert primitive to vnode
		          res.push(createTextVNode(c));
		        }
		      } else if (c instanceof VNode) {
		        if (c.text && last && last.text) {
		          last.text += c.text;
		        } else {
		          // inherit parent namespace
		          if (ns) {
		            applyNS(c, ns);
		          }
		          // default key for nested array children (likely generated by v-for)
		          if (c.tag && c.key == null && nestedIndex != null) {
		            c.key = "__vlist" + nestedIndex + "_" + i + "__";
		          }
		          res.push(c);
		        }
		      }
		    }
		    return res
		  }
		}

		function createTextVNode (val) {
		  return new VNode(undefined, undefined, undefined, String(val))
		}

		function applyNS (vnode, ns) {
		  if (vnode.tag && !vnode.ns) {
		    vnode.ns = ns;
		    if (vnode.children) {
		      for (var i = 0, l = vnode.children.length; i < l; i++) {
		        applyNS(vnode.children[i], ns);
		      }
		    }
		  }
		}

		/*  */

		function getFirstComponentChild (children) {
		  return children && children.filter(function (c) { return c && c.componentOptions; })[0]
		}

		/*  */

		var activeInstance = null;

		function initLifecycle (vm) {
		  var options = vm.$options;

		  // locate first non-abstract parent
		  var parent = options.parent;
		  if (parent && !options.abstract) {
		    while (parent.$options.abstract && parent.$parent) {
		      parent = parent.$parent;
		    }
		    parent.$children.push(vm);
		  }

		  vm.$parent = parent;
		  vm.$root = parent ? parent.$root : vm;

		  vm.$children = [];
		  vm.$refs = {};

		  vm._watcher = null;
		  vm._inactive = false;
		  vm._isMounted = false;
		  vm._isDestroyed = false;
		  vm._isBeingDestroyed = false;
		}

		function lifecycleMixin (Vue) {
		  Vue.prototype._mount = function (
		    el,
		    hydrating
		  ) {
		    var vm = this;
		    vm.$el = el;
		    if (!vm.$options.render) {
		      vm.$options.render = emptyVNode;
		      {
		        /* istanbul ignore if */
		        if (vm.$options.template) {
		          warn(
		            'You are using the runtime-only build of Vue where the template ' +
		            'option is not available. Either pre-compile the templates into ' +
		            'render functions, or use the compiler-included build.',
		            vm
		          );
		        } else {
		          warn(
		            'Failed to mount component: template or render function not defined.',
		            vm
		          );
		        }
		      }
		    }
		    callHook(vm, 'beforeMount');
		    vm._watcher = new Watcher(vm, function () {
		      vm._update(vm._render(), hydrating);
		    }, noop);
		    hydrating = false;
		    // manually mounted instance, call mounted on self
		    // mounted is called for render-created child components in its inserted hook
		    if (vm.$vnode == null) {
		      vm._isMounted = true;
		      callHook(vm, 'mounted');
		    }
		    return vm
		  };

		  Vue.prototype._update = function (vnode, hydrating) {
		    var vm = this;
		    if (vm._isMounted) {
		      callHook(vm, 'beforeUpdate');
		    }
		    var prevEl = vm.$el;
		    var prevActiveInstance = activeInstance;
		    activeInstance = vm;
		    var prevVnode = vm._vnode;
		    vm._vnode = vnode;
		    if (!prevVnode) {
		      // Vue.prototype.__patch__ is injected in entry points
		      // based on the rendering backend used.
		      vm.$el = vm.__patch__(vm.$el, vnode, hydrating);
		    } else {
		      vm.$el = vm.__patch__(prevVnode, vnode);
		    }
		    activeInstance = prevActiveInstance;
		    // update __vue__ reference
		    if (prevEl) {
		      prevEl.__vue__ = null;
		    }
		    if (vm.$el) {
		      vm.$el.__vue__ = vm;
		    }
		    // if parent is an HOC, update its $el as well
		    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
		      vm.$parent.$el = vm.$el;
		    }
		    if (vm._isMounted) {
		      callHook(vm, 'updated');
		    }
		  };

		  Vue.prototype._updateFromParent = function (
		    propsData,
		    listeners,
		    parentVnode,
		    renderChildren
		  ) {
		    var vm = this;
		    var hasChildren = !!(vm.$options._renderChildren || renderChildren);
		    vm.$options._parentVnode = parentVnode;
		    vm.$options._renderChildren = renderChildren;
		    // update props
		    if (propsData && vm.$options.props) {
		      observerState.shouldConvert = false;
		      {
		        observerState.isSettingProps = true;
		      }
		      var propKeys = vm.$options._propKeys || [];
		      for (var i = 0; i < propKeys.length; i++) {
		        var key = propKeys[i];
		        vm[key] = validateProp(key, vm.$options.props, propsData, vm);
		      }
		      observerState.shouldConvert = true;
		      {
		        observerState.isSettingProps = false;
		      }
		      vm.$options.propsData = propsData;
		    }
		    // update listeners
		    if (listeners) {
		      var oldListeners = vm.$options._parentListeners;
		      vm.$options._parentListeners = listeners;
		      vm._updateListeners(listeners, oldListeners);
		    }
		    // resolve slots + force update if has children
		    if (hasChildren) {
		      vm.$slots = resolveSlots(renderChildren, vm._renderContext);
		      vm.$forceUpdate();
		    }
		  };

		  Vue.prototype.$forceUpdate = function () {
		    var vm = this;
		    if (vm._watcher) {
		      vm._watcher.update();
		    }
		  };

		  Vue.prototype.$destroy = function () {
		    var vm = this;
		    if (vm._isBeingDestroyed) {
		      return
		    }
		    callHook(vm, 'beforeDestroy');
		    vm._isBeingDestroyed = true;
		    // remove self from parent
		    var parent = vm.$parent;
		    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
		      remove$1(parent.$children, vm);
		    }
		    // teardown watchers
		    if (vm._watcher) {
		      vm._watcher.teardown();
		    }
		    var i = vm._watchers.length;
		    while (i--) {
		      vm._watchers[i].teardown();
		    }
		    // remove reference from data ob
		    // frozen object may not have observer.
		    if (vm._data.__ob__) {
		      vm._data.__ob__.vmCount--;
		    }
		    // call the last hook...
		    vm._isDestroyed = true;
		    callHook(vm, 'destroyed');
		    // turn off all instance listeners.
		    vm.$off();
		    // remove __vue__ reference
		    if (vm.$el) {
		      vm.$el.__vue__ = null;
		    }
		    // invoke destroy hooks on current rendered tree
		    vm.__patch__(vm._vnode, null);
		  };
		}

		function callHook (vm, hook) {
		  var handlers = vm.$options[hook];
		  if (handlers) {
		    for (var i = 0, j = handlers.length; i < j; i++) {
		      handlers[i].call(vm);
		    }
		  }
		  vm.$emit('hook:' + hook);
		}

		/*  */

		var hooks = { init: init, prepatch: prepatch, insert: insert, destroy: destroy$1 };
		var hooksToMerge = Object.keys(hooks);

		function createComponent (
		  Ctor,
		  data,
		  context,
		  children,
		  tag
		) {
		  if (!Ctor) {
		    return
		  }

		  if (isObject(Ctor)) {
		    Ctor = Vue$2.extend(Ctor);
		  }

		  if (typeof Ctor !== 'function') {
		    {
		      warn(("Invalid Component definition: " + (String(Ctor))), context);
		    }
		    return
		  }

		  // resolve constructor options in case global mixins are applied after
		  // component constructor creation
		  resolveConstructorOptions(Ctor);

		  // async component
		  if (!Ctor.cid) {
		    if (Ctor.resolved) {
		      Ctor = Ctor.resolved;
		    } else {
		      Ctor = resolveAsyncComponent(Ctor, function () {
		        // it's ok to queue this on every render because
		        // $forceUpdate is buffered by the scheduler.
		        context.$forceUpdate();
		      });
		      if (!Ctor) {
		        // return nothing if this is indeed an async component
		        // wait for the callback to trigger parent update.
		        return
		      }
		    }
		  }

		  data = data || {};

		  // extract props
		  var propsData = extractProps(data, Ctor);

		  // functional component
		  if (Ctor.options.functional) {
		    return createFunctionalComponent(Ctor, propsData, data, context, children)
		  }

		  // extract listeners, since these needs to be treated as
		  // child component listeners instead of DOM listeners
		  var listeners = data.on;
		  // replace with listeners with .native modifier
		  data.on = data.nativeOn;

		  if (Ctor.options.abstract) {
		    // abstract components do not keep anything
		    // other than props & listeners
		    data = {};
		  }

		  // merge component management hooks onto the placeholder node
		  mergeHooks(data);

		  // return a placeholder vnode
		  var name = Ctor.options.name || tag;
		  var vnode = new VNode(
		    ("vue-component-" + (Ctor.cid) + (name ? ("-" + name) : '')),
		    data, undefined, undefined, undefined, undefined, context,
		    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }
		  );
		  return vnode
		}

		function createFunctionalComponent (
		  Ctor,
		  propsData,
		  data,
		  context,
		  children
		) {
		  var props = {};
		  var propOptions = Ctor.options.props;
		  if (propOptions) {
		    for (var key in propOptions) {
		      props[key] = validateProp(key, propOptions, propsData);
		    }
		  }
		  var vnode = Ctor.options.render.call(
		    null,
		    // ensure the createElement function in functional components
		    // gets a unique context - this is necessary for correct named slot check
		    bind$1(createElement, { _self: Object.create(context) }),
		    {
		      props: props,
		      data: data,
		      parent: context,
		      children: normalizeChildren(children),
		      slots: function () { return resolveSlots(children, context); }
		    }
		  );
		  if (vnode instanceof VNode) {
		    vnode.functionalContext = context;
		    if (data.slot) {
		      (vnode.data || (vnode.data = {})).slot = data.slot;
		    }
		  }
		  return vnode
		}

		function createComponentInstanceForVnode (
		  vnode, // we know it's MountedComponentVNode but flow doesn't
		  parent // activeInstance in lifecycle state
		) {
		  var vnodeComponentOptions = vnode.componentOptions;
		  var options = {
		    _isComponent: true,
		    parent: parent,
		    propsData: vnodeComponentOptions.propsData,
		    _componentTag: vnodeComponentOptions.tag,
		    _parentVnode: vnode,
		    _parentListeners: vnodeComponentOptions.listeners,
		    _renderChildren: vnodeComponentOptions.children
		  };
		  // check inline-template render functions
		  var inlineTemplate = vnode.data.inlineTemplate;
		  if (inlineTemplate) {
		    options.render = inlineTemplate.render;
		    options.staticRenderFns = inlineTemplate.staticRenderFns;
		  }
		  return new vnodeComponentOptions.Ctor(options)
		}

		function init (vnode, hydrating) {
		  if (!vnode.child || vnode.child._isDestroyed) {
		    var child = vnode.child = createComponentInstanceForVnode(vnode, activeInstance);
		    child.$mount(hydrating ? vnode.elm : undefined, hydrating);
		  }
		}

		function prepatch (
		  oldVnode,
		  vnode
		) {
		  var options = vnode.componentOptions;
		  var child = vnode.child = oldVnode.child;
		  child._updateFromParent(
		    options.propsData, // updated props
		    options.listeners, // updated listeners
		    vnode, // new parent vnode
		    options.children // new children
		  );
		}

		function insert (vnode) {
		  if (!vnode.child._isMounted) {
		    vnode.child._isMounted = true;
		    callHook(vnode.child, 'mounted');
		  }
		  if (vnode.data.keepAlive) {
		    vnode.child._inactive = false;
		    callHook(vnode.child, 'activated');
		  }
		}

		function destroy$1 (vnode) {
		  if (!vnode.child._isDestroyed) {
		    if (!vnode.data.keepAlive) {
		      vnode.child.$destroy();
		    } else {
		      vnode.child._inactive = true;
		      callHook(vnode.child, 'deactivated');
		    }
		  }
		}

		function resolveAsyncComponent (
		  factory,
		  cb
		) {
		  if (factory.requested) {
		    // pool callbacks
		    factory.pendingCallbacks.push(cb);
		  } else {
		    factory.requested = true;
		    var cbs = factory.pendingCallbacks = [cb];
		    var sync = true;

		    var resolve = function (res) {
		      if (isObject(res)) {
		        res = Vue$2.extend(res);
		      }
		      // cache resolved
		      factory.resolved = res;
		      // invoke callbacks only if this is not a synchronous resolve
		      // (async resolves are shimmed as synchronous during SSR)
		      if (!sync) {
		        for (var i = 0, l = cbs.length; i < l; i++) {
		          cbs[i](res);
		        }
		      }
		    };

		    var reject = function (reason) {
		      "development" !== 'production' && warn(
		        "Failed to resolve async component: " + (String(factory)) +
		        (reason ? ("\nReason: " + reason) : '')
		      );
		    };

		    var res = factory(resolve, reject);

		    // handle promise
		    if (res && typeof res.then === 'function' && !factory.resolved) {
		      res.then(resolve, reject);
		    }

		    sync = false;
		    // return in case resolved synchronously
		    return factory.resolved
		  }
		}

		function extractProps (data, Ctor) {
		  // we are only extracting raw values here.
		  // validation and default values are handled in the child
		  // component itself.
		  var propOptions = Ctor.options.props;
		  if (!propOptions) {
		    return
		  }
		  var res = {};
		  var attrs = data.attrs;
		  var props = data.props;
		  var domProps = data.domProps;
		  if (attrs || props || domProps) {
		    for (var key in propOptions) {
		      var altKey = hyphenate(key);
		      checkProp(res, props, key, altKey, true) ||
		      checkProp(res, attrs, key, altKey) ||
		      checkProp(res, domProps, key, altKey);
		    }
		  }
		  return res
		}

		function checkProp (
		  res,
		  hash,
		  key,
		  altKey,
		  preserve
		) {
		  if (hash) {
		    if (hasOwn(hash, key)) {
		      res[key] = hash[key];
		      if (!preserve) {
		        delete hash[key];
		      }
		      return true
		    } else if (hasOwn(hash, altKey)) {
		      res[key] = hash[altKey];
		      if (!preserve) {
		        delete hash[altKey];
		      }
		      return true
		    }
		  }
		  return false
		}

		function mergeHooks (data) {
		  if (!data.hook) {
		    data.hook = {};
		  }
		  for (var i = 0; i < hooksToMerge.length; i++) {
		    var key = hooksToMerge[i];
		    var fromParent = data.hook[key];
		    var ours = hooks[key];
		    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;
		  }
		}

		function mergeHook$1 (a, b) {
		  // since all hooks have at most two args, use fixed args
		  // to avoid having to use fn.apply().
		  return function (_, __) {
		    a(_, __);
		    b(_, __);
		  }
		}

		/*  */

		// wrapper function for providing a more flexible interface
		// without getting yelled at by flow
		function createElement (
		  tag,
		  data,
		  children
		) {
		  if (data && (Array.isArray(data) || typeof data !== 'object')) {
		    children = data;
		    data = undefined;
		  }
		  // make sure to use real instance instead of proxy as context
		  return _createElement(this._self, tag, data, children)
		}

		function _createElement (
		  context,
		  tag,
		  data,
		  children
		) {
		  if (data && data.__ob__) {
		    "development" !== 'production' && warn(
		      "Avoid using observed data object as vnode data: " + (JSON.stringify(data)) + "\n" +
		      'Always create fresh vnode data objects in each render!',
		      context
		    );
		    return
		  }
		  if (!tag) {
		    // in case of component :is set to falsy value
		    return emptyVNode()
		  }
		  if (typeof tag === 'string') {
		    var Ctor;
		    var ns = config.getTagNamespace(tag);
		    if (config.isReservedTag(tag)) {
		      // platform built-in elements
		      return new VNode(
		        tag, data, normalizeChildren(children, ns),
		        undefined, undefined, ns, context
		      )
		    } else if ((Ctor = resolveAsset(context.$options, 'components', tag))) {
		      // component
		      return createComponent(Ctor, data, context, children, tag)
		    } else {
		      // unknown or unlisted namespaced elements
		      // check at runtime because it may get assigned a namespace when its
		      // parent normalizes children
		      var childNs = tag === 'foreignObject' ? 'xhtml' : ns;
		      return new VNode(
		        tag, data, normalizeChildren(children, childNs),
		        undefined, undefined, ns, context
		      )
		    }
		  } else {
		    // direct component options / constructor
		    return createComponent(tag, data, context, children)
		  }
		}

		/*  */

		function initRender (vm) {
		  vm.$vnode = null; // the placeholder node in parent tree
		  vm._vnode = null; // the root of the child tree
		  vm._staticTrees = null;
		  vm._renderContext = vm.$options._parentVnode && vm.$options._parentVnode.context;
		  vm.$slots = resolveSlots(vm.$options._renderChildren, vm._renderContext);
		  // bind the public createElement fn to this instance
		  // so that we get proper render context inside it.
		  vm.$createElement = bind$1(createElement, vm);
		  if (vm.$options.el) {
		    vm.$mount(vm.$options.el);
		  }
		}

		function renderMixin (Vue) {
		  Vue.prototype.$nextTick = function (fn) {
		    nextTick(fn, this);
		  };

		  Vue.prototype._render = function () {
		    var vm = this;
		    var ref = vm.$options;
		    var render = ref.render;
		    var staticRenderFns = ref.staticRenderFns;
		    var _parentVnode = ref._parentVnode;

		    if (vm._isMounted) {
		      // clone slot nodes on re-renders
		      for (var key in vm.$slots) {
		        vm.$slots[key] = cloneVNodes(vm.$slots[key]);
		      }
		    }

		    if (staticRenderFns && !vm._staticTrees) {
		      vm._staticTrees = [];
		    }
		    // set parent vnode. this allows render functions to have access
		    // to the data on the placeholder node.
		    vm.$vnode = _parentVnode;
		    // render self
		    var vnode;
		    try {
		      vnode = render.call(vm._renderProxy, vm.$createElement);
		    } catch (e) {
		      {
		        warn(("Error when rendering " + (formatComponentName(vm)) + ":"));
		      }
		      /* istanbul ignore else */
		      if (config.errorHandler) {
		        config.errorHandler.call(null, e, vm);
		      } else {
		        if (config._isServer) {
		          throw e
		        } else {
		          console.error(e);
		        }
		      }
		      // return previous vnode to prevent render error causing blank component
		      vnode = vm._vnode;
		    }
		    // return empty vnode in case the render function errored out
		    if (!(vnode instanceof VNode)) {
		      if ("development" !== 'production' && Array.isArray(vnode)) {
		        warn(
		          'Multiple root nodes returned from render function. Render function ' +
		          'should return a single root node.',
		          vm
		        );
		      }
		      vnode = emptyVNode();
		    }
		    // set parent
		    vnode.parent = _parentVnode;
		    return vnode
		  };

		  // shorthands used in render functions
		  Vue.prototype._h = createElement;
		  // toString for mustaches
		  Vue.prototype._s = _toString;
		  // number conversion
		  Vue.prototype._n = toNumber;
		  // empty vnode
		  Vue.prototype._e = emptyVNode;
		  // loose equal
		  Vue.prototype._q = looseEqual;
		  // loose indexOf
		  Vue.prototype._i = looseIndexOf;

		  // render static tree by index
		  Vue.prototype._m = function renderStatic (
		    index,
		    isInFor
		  ) {
		    var tree = this._staticTrees[index];
		    // if has already-rendered static tree and not inside v-for,
		    // we can reuse the same tree by doing a shallow clone.
		    if (tree && !isInFor) {
		      return Array.isArray(tree)
		        ? cloneVNodes(tree)
		        : cloneVNode(tree)
		    }
		    // otherwise, render a fresh tree.
		    tree = this._staticTrees[index] = this.$options.staticRenderFns[index].call(this._renderProxy);
		    markStatic(tree, ("__static__" + index), false);
		    return tree
		  };

		  // mark node as static (v-once)
		  Vue.prototype._o = function markOnce (
		    tree,
		    index,
		    key
		  ) {
		    markStatic(tree, ("__once__" + index + (key ? ("_" + key) : "")), true);
		    return tree
		  };

		  function markStatic (tree, key, isOnce) {
		    if (Array.isArray(tree)) {
		      for (var i = 0; i < tree.length; i++) {
		        if (tree[i] && typeof tree[i] !== 'string') {
		          markStaticNode(tree[i], (key + "_" + i), isOnce);
		        }
		      }
		    } else {
		      markStaticNode(tree, key, isOnce);
		    }
		  }

		  function markStaticNode (node, key, isOnce) {
		    node.isStatic = true;
		    node.key = key;
		    node.isOnce = isOnce;
		  }

		  // filter resolution helper
		  var identity = function (_) { return _; };
		  Vue.prototype._f = function resolveFilter (id) {
		    return resolveAsset(this.$options, 'filters', id, true) || identity
		  };

		  // render v-for
		  Vue.prototype._l = function renderList (
		    val,
		    render
		  ) {
		    var ret, i, l, keys, key;
		    if (Array.isArray(val)) {
		      ret = new Array(val.length);
		      for (i = 0, l = val.length; i < l; i++) {
		        ret[i] = render(val[i], i);
		      }
		    } else if (typeof val === 'number') {
		      ret = new Array(val);
		      for (i = 0; i < val; i++) {
		        ret[i] = render(i + 1, i);
		      }
		    } else if (isObject(val)) {
		      keys = Object.keys(val);
		      ret = new Array(keys.length);
		      for (i = 0, l = keys.length; i < l; i++) {
		        key = keys[i];
		        ret[i] = render(val[key], key, i);
		      }
		    }
		    return ret
		  };

		  // renderSlot
		  Vue.prototype._t = function (
		    name,
		    fallback
		  ) {
		    var slotNodes = this.$slots[name];
		    // warn duplicate slot usage
		    if (slotNodes && "development" !== 'production') {
		      slotNodes._rendered && warn(
		        "Duplicate presence of slot \"" + name + "\" found in the same render tree " +
		        "- this will likely cause render errors.",
		        this
		      );
		      slotNodes._rendered = true;
		    }
		    return slotNodes || fallback
		  };

		  // apply v-bind object
		  Vue.prototype._b = function bindProps (
		    data,
		    value,
		    asProp
		  ) {
		    if (value) {
		      if (!isObject(value)) {
		        "development" !== 'production' && warn(
		          'v-bind without argument expects an Object or Array value',
		          this
		        );
		      } else {
		        if (Array.isArray(value)) {
		          value = toObject(value);
		        }
		        for (var key in value) {
		          if (key === 'class' || key === 'style') {
		            data[key] = value[key];
		          } else {
		            var hash = asProp || config.mustUseProp(key)
		              ? data.domProps || (data.domProps = {})
		              : data.attrs || (data.attrs = {});
		            hash[key] = value[key];
		          }
		        }
		      }
		    }
		    return data
		  };

		  // expose v-on keyCodes
		  Vue.prototype._k = function getKeyCodes (key) {
		    return config.keyCodes[key]
		  };
		}

		function resolveSlots (
		  renderChildren,
		  context
		) {
		  var slots = {};
		  if (!renderChildren) {
		    return slots
		  }
		  var children = normalizeChildren(renderChildren) || [];
		  var defaultSlot = [];
		  var name, child;
		  for (var i = 0, l = children.length; i < l; i++) {
		    child = children[i];
		    // named slots should only be respected if the vnode was rendered in the
		    // same context.
		    if ((child.context === context || child.functionalContext === context) &&
		        child.data && (name = child.data.slot)) {
		      var slot = (slots[name] || (slots[name] = []));
		      if (child.tag === 'template') {
		        slot.push.apply(slot, child.children);
		      } else {
		        slot.push(child);
		      }
		    } else {
		      defaultSlot.push(child);
		    }
		  }
		  // ignore single whitespace
		  if (defaultSlot.length && !(
		    defaultSlot.length === 1 &&
		    (defaultSlot[0].text === ' ' || defaultSlot[0].isComment)
		  )) {
		    slots.default = defaultSlot;
		  }
		  return slots
		}

		/*  */

		function initEvents (vm) {
		  vm._events = Object.create(null);
		  // init parent attached events
		  var listeners = vm.$options._parentListeners;
		  var on = bind$1(vm.$on, vm);
		  var off = bind$1(vm.$off, vm);
		  vm._updateListeners = function (listeners, oldListeners) {
		    updateListeners(listeners, oldListeners || {}, on, off, vm);
		  };
		  if (listeners) {
		    vm._updateListeners(listeners);
		  }
		}

		function eventsMixin (Vue) {
		  Vue.prototype.$on = function (event, fn) {
		    var vm = this;(vm._events[event] || (vm._events[event] = [])).push(fn);
		    return vm
		  };

		  Vue.prototype.$once = function (event, fn) {
		    var vm = this;
		    function on () {
		      vm.$off(event, on);
		      fn.apply(vm, arguments);
		    }
		    on.fn = fn;
		    vm.$on(event, on);
		    return vm
		  };

		  Vue.prototype.$off = function (event, fn) {
		    var vm = this;
		    // all
		    if (!arguments.length) {
		      vm._events = Object.create(null);
		      return vm
		    }
		    // specific event
		    var cbs = vm._events[event];
		    if (!cbs) {
		      return vm
		    }
		    if (arguments.length === 1) {
		      vm._events[event] = null;
		      return vm
		    }
		    // specific handler
		    var cb;
		    var i = cbs.length;
		    while (i--) {
		      cb = cbs[i];
		      if (cb === fn || cb.fn === fn) {
		        cbs.splice(i, 1);
		        break
		      }
		    }
		    return vm
		  };

		  Vue.prototype.$emit = function (event) {
		    var vm = this;
		    var cbs = vm._events[event];
		    if (cbs) {
		      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
		      var args = toArray(arguments, 1);
		      for (var i = 0, l = cbs.length; i < l; i++) {
		        cbs[i].apply(vm, args);
		      }
		    }
		    return vm
		  };
		}

		/*  */

		var uid = 0;

		function initMixin (Vue) {
		  Vue.prototype._init = function (options) {
		    var vm = this;
		    // a uid
		    vm._uid = uid++;
		    // a flag to avoid this being observed
		    vm._isVue = true;
		    // merge options
		    if (options && options._isComponent) {
		      // optimize internal component instantiation
		      // since dynamic options merging is pretty slow, and none of the
		      // internal component options needs special treatment.
		      initInternalComponent(vm, options);
		    } else {
		      vm.$options = mergeOptions(
		        resolveConstructorOptions(vm.constructor),
		        options || {},
		        vm
		      );
		    }
		    /* istanbul ignore else */
		    {
		      initProxy(vm);
		    }
		    // expose real self
		    vm._self = vm;
		    initLifecycle(vm);
		    initEvents(vm);
		    callHook(vm, 'beforeCreate');
		    initState(vm);
		    callHook(vm, 'created');
		    initRender(vm);
		  };
		}

		function initInternalComponent (vm, options) {
		  var opts = vm.$options = Object.create(vm.constructor.options);
		  // doing this because it's faster than dynamic enumeration.
		  opts.parent = options.parent;
		  opts.propsData = options.propsData;
		  opts._parentVnode = options._parentVnode;
		  opts._parentListeners = options._parentListeners;
		  opts._renderChildren = options._renderChildren;
		  opts._componentTag = options._componentTag;
		  if (options.render) {
		    opts.render = options.render;
		    opts.staticRenderFns = options.staticRenderFns;
		  }
		}

		function resolveConstructorOptions (Ctor) {
		  var options = Ctor.options;
		  if (Ctor.super) {
		    var superOptions = Ctor.super.options;
		    var cachedSuperOptions = Ctor.superOptions;
		    var extendOptions = Ctor.extendOptions;
		    if (superOptions !== cachedSuperOptions) {
		      // super option changed
		      Ctor.superOptions = superOptions;
		      extendOptions.render = options.render;
		      extendOptions.staticRenderFns = options.staticRenderFns;
		      options = Ctor.options = mergeOptions(superOptions, extendOptions);
		      if (options.name) {
		        options.components[options.name] = Ctor;
		      }
		    }
		  }
		  return options
		}

		function Vue$2 (options) {
		  if ("development" !== 'production' &&
		    !(this instanceof Vue$2)) {
		    warn('Vue is a constructor and should be called with the `new` keyword');
		  }
		  this._init(options);
		}

		initMixin(Vue$2);
		stateMixin(Vue$2);
		eventsMixin(Vue$2);
		lifecycleMixin(Vue$2);
		renderMixin(Vue$2);

		var warn = noop;
		var formatComponentName;

		{
		  var hasConsole = typeof console !== 'undefined';

		  warn = function (msg, vm) {
		    if (hasConsole && (!config.silent)) {
		      console.error("[Vue warn]: " + msg + " " + (
		        vm ? formatLocation(formatComponentName(vm)) : ''
		      ));
		    }
		  };

		  formatComponentName = function (vm) {
		    if (vm.$root === vm) {
		      return 'root instance'
		    }
		    var name = vm._isVue
		      ? vm.$options.name || vm.$options._componentTag
		      : vm.name;
		    return (
		      (name ? ("component <" + name + ">") : "anonymous component") +
		      (vm._isVue && vm.$options.__file ? (" at " + (vm.$options.__file)) : '')
		    )
		  };

		  var formatLocation = function (str) {
		    if (str === 'anonymous component') {
		      str += " - use the \"name\" option for better debugging messages.";
		    }
		    return ("\n(found in " + str + ")")
		  };
		}

		/*  */

		/**
		 * Option overwriting strategies are functions that handle
		 * how to merge a parent option value and a child option
		 * value into the final value.
		 */
		var strats = config.optionMergeStrategies;

		/**
		 * Options with restrictions
		 */
		{
		  strats.el = strats.propsData = function (parent, child, vm, key) {
		    if (!vm) {
		      warn(
		        "option \"" + key + "\" can only be used during instance " +
		        'creation with the `new` keyword.'
		      );
		    }
		    return defaultStrat(parent, child)
		  };
		}

		/**
		 * Helper that recursively merges two data objects together.
		 */
		function mergeData (to, from) {
		  var key, toVal, fromVal;
		  for (key in from) {
		    toVal = to[key];
		    fromVal = from[key];
		    if (!hasOwn(to, key)) {
		      set(to, key, fromVal);
		    } else if (isObject(toVal) && isObject(fromVal)) {
		      mergeData(toVal, fromVal);
		    }
		  }
		  return to
		}

		/**
		 * Data
		 */
		strats.data = function (
		  parentVal,
		  childVal,
		  vm
		) {
		  if (!vm) {
		    // in a Vue.extend merge, both should be functions
		    if (!childVal) {
		      return parentVal
		    }
		    if (typeof childVal !== 'function') {
		      "development" !== 'production' && warn(
		        'The "data" option should be a function ' +
		        'that returns a per-instance value in component ' +
		        'definitions.',
		        vm
		      );
		      return parentVal
		    }
		    if (!parentVal) {
		      return childVal
		    }
		    // when parentVal & childVal are both present,
		    // we need to return a function that returns the
		    // merged result of both functions... no need to
		    // check if parentVal is a function here because
		    // it has to be a function to pass previous merges.
		    return function mergedDataFn () {
		      return mergeData(
		        childVal.call(this),
		        parentVal.call(this)
		      )
		    }
		  } else if (parentVal || childVal) {
		    return function mergedInstanceDataFn () {
		      // instance merge
		      var instanceData = typeof childVal === 'function'
		        ? childVal.call(vm)
		        : childVal;
		      var defaultData = typeof parentVal === 'function'
		        ? parentVal.call(vm)
		        : undefined;
		      if (instanceData) {
		        return mergeData(instanceData, defaultData)
		      } else {
		        return defaultData
		      }
		    }
		  }
		};

		/**
		 * Hooks and param attributes are merged as arrays.
		 */
		function mergeHook (
		  parentVal,
		  childVal
		) {
		  return childVal
		    ? parentVal
		      ? parentVal.concat(childVal)
		      : Array.isArray(childVal)
		        ? childVal
		        : [childVal]
		    : parentVal
		}

		config._lifecycleHooks.forEach(function (hook) {
		  strats[hook] = mergeHook;
		});

		/**
		 * Assets
		 *
		 * When a vm is present (instance creation), we need to do
		 * a three-way merge between constructor options, instance
		 * options and parent options.
		 */
		function mergeAssets (parentVal, childVal) {
		  var res = Object.create(parentVal || null);
		  return childVal
		    ? extend(res, childVal)
		    : res
		}

		config._assetTypes.forEach(function (type) {
		  strats[type + 's'] = mergeAssets;
		});

		/**
		 * Watchers.
		 *
		 * Watchers hashes should not overwrite one
		 * another, so we merge them as arrays.
		 */
		strats.watch = function (parentVal, childVal) {
		  /* istanbul ignore if */
		  if (!childVal) { return parentVal }
		  if (!parentVal) { return childVal }
		  var ret = {};
		  extend(ret, parentVal);
		  for (var key in childVal) {
		    var parent = ret[key];
		    var child = childVal[key];
		    if (parent && !Array.isArray(parent)) {
		      parent = [parent];
		    }
		    ret[key] = parent
		      ? parent.concat(child)
		      : [child];
		  }
		  return ret
		};

		/**
		 * Other object hashes.
		 */
		strats.props =
		strats.methods =
		strats.computed = function (parentVal, childVal) {
		  if (!childVal) { return parentVal }
		  if (!parentVal) { return childVal }
		  var ret = Object.create(null);
		  extend(ret, parentVal);
		  extend(ret, childVal);
		  return ret
		};

		/**
		 * Default strategy.
		 */
		var defaultStrat = function (parentVal, childVal) {
		  return childVal === undefined
		    ? parentVal
		    : childVal
		};

		/**
		 * Validate component names
		 */
		function checkComponents (options) {
		  for (var key in options.components) {
		    var lower = key.toLowerCase();
		    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {
		      warn(
		        'Do not use built-in or reserved HTML elements as component ' +
		        'id: ' + key
		      );
		    }
		  }
		}

		/**
		 * Ensure all props option syntax are normalized into the
		 * Object-based format.
		 */
		function normalizeProps (options) {
		  var props = options.props;
		  if (!props) { return }
		  var res = {};
		  var i, val, name;
		  if (Array.isArray(props)) {
		    i = props.length;
		    while (i--) {
		      val = props[i];
		      if (typeof val === 'string') {
		        name = camelize(val);
		        res[name] = { type: null };
		      } else {
		        warn('props must be strings when using array syntax.');
		      }
		    }
		  } else if (isPlainObject(props)) {
		    for (var key in props) {
		      val = props[key];
		      name = camelize(key);
		      res[name] = isPlainObject(val)
		        ? val
		        : { type: val };
		    }
		  }
		  options.props = res;
		}

		/**
		 * Normalize raw function directives into object format.
		 */
		function normalizeDirectives (options) {
		  var dirs = options.directives;
		  if (dirs) {
		    for (var key in dirs) {
		      var def = dirs[key];
		      if (typeof def === 'function') {
		        dirs[key] = { bind: def, update: def };
		      }
		    }
		  }
		}

		/**
		 * Merge two option objects into a new one.
		 * Core utility used in both instantiation and inheritance.
		 */
		function mergeOptions (
		  parent,
		  child,
		  vm
		) {
		  {
		    checkComponents(child);
		  }
		  normalizeProps(child);
		  normalizeDirectives(child);
		  var extendsFrom = child.extends;
		  if (extendsFrom) {
		    parent = typeof extendsFrom === 'function'
		      ? mergeOptions(parent, extendsFrom.options, vm)
		      : mergeOptions(parent, extendsFrom, vm);
		  }
		  if (child.mixins) {
		    for (var i = 0, l = child.mixins.length; i < l; i++) {
		      var mixin = child.mixins[i];
		      if (mixin.prototype instanceof Vue$2) {
		        mixin = mixin.options;
		      }
		      parent = mergeOptions(parent, mixin, vm);
		    }
		  }
		  var options = {};
		  var key;
		  for (key in parent) {
		    mergeField(key);
		  }
		  for (key in child) {
		    if (!hasOwn(parent, key)) {
		      mergeField(key);
		    }
		  }
		  function mergeField (key) {
		    var strat = strats[key] || defaultStrat;
		    options[key] = strat(parent[key], child[key], vm, key);
		  }
		  return options
		}

		/**
		 * Resolve an asset.
		 * This function is used because child instances need access
		 * to assets defined in its ancestor chain.
		 */
		function resolveAsset (
		  options,
		  type,
		  id,
		  warnMissing
		) {
		  /* istanbul ignore if */
		  if (typeof id !== 'string') {
		    return
		  }
		  var assets = options[type];
		  var res = assets[id] ||
		    // camelCase ID
		    assets[camelize(id)] ||
		    // Pascal Case ID
		    assets[capitalize(camelize(id))];
		  if ("development" !== 'production' && warnMissing && !res) {
		    warn(
		      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,
		      options
		    );
		  }
		  return res
		}

		/*  */

		function validateProp (
		  key,
		  propOptions,
		  propsData,
		  vm
		) {
		  var prop = propOptions[key];
		  var absent = !hasOwn(propsData, key);
		  var value = propsData[key];
		  // handle boolean props
		  if (isBooleanType(prop.type)) {
		    if (absent && !hasOwn(prop, 'default')) {
		      value = false;
		    } else if (value === '' || value === hyphenate(key)) {
		      value = true;
		    }
		  }
		  // check default value
		  if (value === undefined) {
		    value = getPropDefaultValue(vm, prop, key);
		    // since the default value is a fresh copy,
		    // make sure to observe it.
		    var prevShouldConvert = observerState.shouldConvert;
		    observerState.shouldConvert = true;
		    observe(value);
		    observerState.shouldConvert = prevShouldConvert;
		  }
		  {
		    assertProp(prop, key, value, vm, absent);
		  }
		  return value
		}

		/**
		 * Get the default value of a prop.
		 */
		function getPropDefaultValue (vm, prop, key) {
		  // no default, return undefined
		  if (!hasOwn(prop, 'default')) {
		    return undefined
		  }
		  var def = prop.default;
		  // warn against non-factory defaults for Object & Array
		  if (isObject(def)) {
		    "development" !== 'production' && warn(
		      'Invalid default value for prop "' + key + '": ' +
		      'Props with type Object/Array must use a factory function ' +
		      'to return the default value.',
		      vm
		    );
		  }
		  // the raw prop value was also undefined from previous render,
		  // return previous default value to avoid unnecessary watcher trigger
		  if (vm && vm.$options.propsData &&
		    vm.$options.propsData[key] === undefined &&
		    vm[key] !== undefined) {
		    return vm[key]
		  }
		  // call factory function for non-Function types
		  return typeof def === 'function' && prop.type !== Function
		    ? def.call(vm)
		    : def
		}

		/**
		 * Assert whether a prop is valid.
		 */
		function assertProp (
		  prop,
		  name,
		  value,
		  vm,
		  absent
		) {
		  if (prop.required && absent) {
		    warn(
		      'Missing required prop: "' + name + '"',
		      vm
		    );
		    return
		  }
		  if (value == null && !prop.required) {
		    return
		  }
		  var type = prop.type;
		  var valid = !type || type === true;
		  var expectedTypes = [];
		  if (type) {
		    if (!Array.isArray(type)) {
		      type = [type];
		    }
		    for (var i = 0; i < type.length && !valid; i++) {
		      var assertedType = assertType(value, type[i]);
		      expectedTypes.push(assertedType.expectedType);
		      valid = assertedType.valid;
		    }
		  }
		  if (!valid) {
		    warn(
		      'Invalid prop: type check failed for prop "' + name + '".' +
		      ' Expected ' + expectedTypes.map(capitalize).join(', ') +
		      ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.',
		      vm
		    );
		    return
		  }
		  var validator = prop.validator;
		  if (validator) {
		    if (!validator(value)) {
		      warn(
		        'Invalid prop: custom validator check failed for prop "' + name + '".',
		        vm
		      );
		    }
		  }
		}

		/**
		 * Assert the type of a value
		 */
		function assertType (value, type) {
		  var valid;
		  var expectedType = getType(type);
		  if (expectedType === 'String') {
		    valid = typeof value === (expectedType = 'string');
		  } else if (expectedType === 'Number') {
		    valid = typeof value === (expectedType = 'number');
		  } else if (expectedType === 'Boolean') {
		    valid = typeof value === (expectedType = 'boolean');
		  } else if (expectedType === 'Function') {
		    valid = typeof value === (expectedType = 'function');
		  } else if (expectedType === 'Object') {
		    valid = isPlainObject(value);
		  } else if (expectedType === 'Array') {
		    valid = Array.isArray(value);
		  } else {
		    valid = value instanceof type;
		  }
		  return {
		    valid: valid,
		    expectedType: expectedType
		  }
		}

		/**
		 * Use function string name to check built-in types,
		 * because a simple equality check will fail when running
		 * across different vms / iframes.
		 */
		function getType (fn) {
		  var match = fn && fn.toString().match(/^\s*function (\w+)/);
		  return match && match[1]
		}

		function isBooleanType (fn) {
		  if (!Array.isArray(fn)) {
		    return getType(fn) === 'Boolean'
		  }
		  for (var i = 0, len = fn.length; i < len; i++) {
		    if (getType(fn[i]) === 'Boolean') {
		      return true
		    }
		  }
		  /* istanbul ignore next */
		  return false
		}



		var util = Object.freeze({
			defineReactive: defineReactive$$1,
			_toString: _toString,
			toNumber: toNumber,
			makeMap: makeMap,
			isBuiltInTag: isBuiltInTag,
			remove: remove$1,
			hasOwn: hasOwn,
			isPrimitive: isPrimitive,
			cached: cached,
			camelize: camelize,
			capitalize: capitalize,
			hyphenate: hyphenate,
			bind: bind$1,
			toArray: toArray,
			extend: extend,
			isObject: isObject,
			isPlainObject: isPlainObject,
			toObject: toObject,
			noop: noop,
			no: no,
			genStaticKeys: genStaticKeys,
			looseEqual: looseEqual,
			looseIndexOf: looseIndexOf,
			isReserved: isReserved,
			def: def,
			parsePath: parsePath,
			hasProto: hasProto,
			inBrowser: inBrowser,
			UA: UA,
			isIE: isIE,
			isIE9: isIE9,
			isEdge: isEdge,
			isAndroid: isAndroid,
			isIOS: isIOS,
			devtools: devtools,
			nextTick: nextTick,
			get _Set () { return _Set; },
			mergeOptions: mergeOptions,
			resolveAsset: resolveAsset,
			get warn () { return warn; },
			get formatComponentName () { return formatComponentName; },
			validateProp: validateProp
		});

		/*  */

		function initUse (Vue) {
		  Vue.use = function (plugin) {
		    /* istanbul ignore if */
		    if (plugin.installed) {
		      return
		    }
		    // additional parameters
		    var args = toArray(arguments, 1);
		    args.unshift(this);
		    if (typeof plugin.install === 'function') {
		      plugin.install.apply(plugin, args);
		    } else {
		      plugin.apply(null, args);
		    }
		    plugin.installed = true;
		    return this
		  };
		}

		/*  */

		function initMixin$1 (Vue) {
		  Vue.mixin = function (mixin) {
		    Vue.options = mergeOptions(Vue.options, mixin);
		  };
		}

		/*  */

		function initExtend (Vue) {
		  /**
		   * Each instance constructor, including Vue, has a unique
		   * cid. This enables us to create wrapped "child
		   * constructors" for prototypal inheritance and cache them.
		   */
		  Vue.cid = 0;
		  var cid = 1;

		  /**
		   * Class inheritance
		   */
		  Vue.extend = function (extendOptions) {
		    extendOptions = extendOptions || {};
		    var Super = this;
		    var isFirstExtend = Super.cid === 0;
		    if (isFirstExtend && extendOptions._Ctor) {
		      return extendOptions._Ctor
		    }
		    var name = extendOptions.name || Super.options.name;
		    {
		      if (!/^[a-zA-Z][\w-]*$/.test(name)) {
		        warn(
		          'Invalid component name: "' + name + '". Component names ' +
		          'can only contain alphanumeric characaters and the hyphen.'
		        );
		      }
		    }
		    var Sub = function VueComponent (options) {
		      this._init(options);
		    };
		    Sub.prototype = Object.create(Super.prototype);
		    Sub.prototype.constructor = Sub;
		    Sub.cid = cid++;
		    Sub.options = mergeOptions(
		      Super.options,
		      extendOptions
		    );
		    Sub['super'] = Super;
		    // allow further extension
		    Sub.extend = Super.extend;
		    // create asset registers, so extended classes
		    // can have their private assets too.
		    config._assetTypes.forEach(function (type) {
		      Sub[type] = Super[type];
		    });
		    // enable recursive self-lookup
		    if (name) {
		      Sub.options.components[name] = Sub;
		    }
		    // keep a reference to the super options at extension time.
		    // later at instantiation we can check if Super's options have
		    // been updated.
		    Sub.superOptions = Super.options;
		    Sub.extendOptions = extendOptions;
		    // cache constructor
		    if (isFirstExtend) {
		      extendOptions._Ctor = Sub;
		    }
		    return Sub
		  };
		}

		/*  */

		function initAssetRegisters (Vue) {
		  /**
		   * Create asset registration methods.
		   */
		  config._assetTypes.forEach(function (type) {
		    Vue[type] = function (
		      id,
		      definition
		    ) {
		      if (!definition) {
		        return this.options[type + 's'][id]
		      } else {
		        /* istanbul ignore if */
		        {
		          if (type === 'component' && config.isReservedTag(id)) {
		            warn(
		              'Do not use built-in or reserved HTML elements as component ' +
		              'id: ' + id
		            );
		          }
		        }
		        if (type === 'component' && isPlainObject(definition)) {
		          definition.name = definition.name || id;
		          definition = Vue.extend(definition);
		        }
		        if (type === 'directive' && typeof definition === 'function') {
		          definition = { bind: definition, update: definition };
		        }
		        this.options[type + 's'][id] = definition;
		        return definition
		      }
		    };
		  });
		}

		var KeepAlive = {
		  name: 'keep-alive',
		  abstract: true,
		  created: function created () {
		    this.cache = Object.create(null);
		  },
		  render: function render () {
		    var vnode = getFirstComponentChild(this.$slots.default);
		    if (vnode && vnode.componentOptions) {
		      var opts = vnode.componentOptions;
		      var key = vnode.key == null
		        // same constructor may get registered as different local components
		        // so cid alone is not enough (#3269)
		        ? opts.Ctor.cid + '::' + opts.tag
		        : vnode.key;
		      if (this.cache[key]) {
		        vnode.child = this.cache[key].child;
		      } else {
		        this.cache[key] = vnode;
		      }
		      vnode.data.keepAlive = true;
		    }
		    return vnode
		  },
		  destroyed: function destroyed () {
		    var this$1 = this;

		    for (var key in this.cache) {
		      var vnode = this$1.cache[key];
		      callHook(vnode.child, 'deactivated');
		      vnode.child.$destroy();
		    }
		  }
		};

		var builtInComponents = {
		  KeepAlive: KeepAlive
		};

		/*  */

		function initGlobalAPI (Vue) {
		  // config
		  var configDef = {};
		  configDef.get = function () { return config; };
		  {
		    configDef.set = function () {
		      warn(
		        'Do not replace the Vue.config object, set individual fields instead.'
		      );
		    };
		  }
		  Object.defineProperty(Vue, 'config', configDef);
		  Vue.util = util;
		  Vue.set = set;
		  Vue.delete = del;
		  Vue.nextTick = nextTick;

		  Vue.options = Object.create(null);
		  config._assetTypes.forEach(function (type) {
		    Vue.options[type + 's'] = Object.create(null);
		  });

		  extend(Vue.options.components, builtInComponents);

		  initUse(Vue);
		  initMixin$1(Vue);
		  initExtend(Vue);
		  initAssetRegisters(Vue);
		}

		initGlobalAPI(Vue$2);

		Object.defineProperty(Vue$2.prototype, '$isServer', {
		  get: function () { return config._isServer; }
		});

		Vue$2.version = '2.0.5';

		/*  */

		// attributes that should be using props for binding
		var mustUseProp = makeMap('value,selected,checked,muted');

		var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');

		var isBooleanAttr = makeMap(
		  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +
		  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +
		  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +
		  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +
		  'required,reversed,scoped,seamless,selected,sortable,translate,' +
		  'truespeed,typemustmatch,visible'
		);

		var isAttr = makeMap(
		  'accept,accept-charset,accesskey,action,align,alt,async,autocomplete,' +
		  'autofocus,autoplay,autosave,bgcolor,border,buffered,challenge,charset,' +
		  'checked,cite,class,code,codebase,color,cols,colspan,content,http-equiv,' +
		  'name,contenteditable,contextmenu,controls,coords,data,datetime,default,' +
		  'defer,dir,dirname,disabled,download,draggable,dropzone,enctype,method,for,' +
		  'form,formaction,headers,<th>,height,hidden,high,href,hreflang,http-equiv,' +
		  'icon,id,ismap,itemprop,keytype,kind,label,lang,language,list,loop,low,' +
		  'manifest,max,maxlength,media,method,GET,POST,min,multiple,email,file,' +
		  'muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,' +
		  'preload,radiogroup,readonly,rel,required,reversed,rows,rowspan,sandbox,' +
		  'scope,scoped,seamless,selected,shape,size,type,text,password,sizes,span,' +
		  'spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,' +
		  'target,title,type,usemap,value,width,wrap'
		);



		var xlinkNS = 'http://www.w3.org/1999/xlink';

		var isXlink = function (name) {
		  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'
		};

		var getXlinkProp = function (name) {
		  return isXlink(name) ? name.slice(6, name.length) : ''
		};

		var isFalsyAttrValue = function (val) {
		  return val == null || val === false
		};

		/*  */

		function genClassForVnode (vnode) {
		  var data = vnode.data;
		  var parentNode = vnode;
		  var childNode = vnode;
		  while (childNode.child) {
		    childNode = childNode.child._vnode;
		    if (childNode.data) {
		      data = mergeClassData(childNode.data, data);
		    }
		  }
		  while ((parentNode = parentNode.parent)) {
		    if (parentNode.data) {
		      data = mergeClassData(data, parentNode.data);
		    }
		  }
		  return genClassFromData(data)
		}

		function mergeClassData (child, parent) {
		  return {
		    staticClass: concat(child.staticClass, parent.staticClass),
		    class: child.class
		      ? [child.class, parent.class]
		      : parent.class
		  }
		}

		function genClassFromData (data) {
		  var dynamicClass = data.class;
		  var staticClass = data.staticClass;
		  if (staticClass || dynamicClass) {
		    return concat(staticClass, stringifyClass(dynamicClass))
		  }
		  /* istanbul ignore next */
		  return ''
		}

		function concat (a, b) {
		  return a ? b ? (a + ' ' + b) : a : (b || '')
		}

		function stringifyClass (value) {
		  var res = '';
		  if (!value) {
		    return res
		  }
		  if (typeof value === 'string') {
		    return value
		  }
		  if (Array.isArray(value)) {
		    var stringified;
		    for (var i = 0, l = value.length; i < l; i++) {
		      if (value[i]) {
		        if ((stringified = stringifyClass(value[i]))) {
		          res += stringified + ' ';
		        }
		      }
		    }
		    return res.slice(0, -1)
		  }
		  if (isObject(value)) {
		    for (var key in value) {
		      if (value[key]) { res += key + ' '; }
		    }
		    return res.slice(0, -1)
		  }
		  /* istanbul ignore next */
		  return res
		}

		/*  */

		var namespaceMap = {
		  svg: 'http://www.w3.org/2000/svg',
		  math: 'http://www.w3.org/1998/Math/MathML',
		  xhtml: 'http://www.w3.org/1999/xhtm'
		};

		var isHTMLTag = makeMap(
		  'html,body,base,head,link,meta,style,title,' +
		  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +
		  'div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,' +
		  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +
		  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +
		  'embed,object,param,source,canvas,script,noscript,del,ins,' +
		  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +
		  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +
		  'output,progress,select,textarea,' +
		  'details,dialog,menu,menuitem,summary,' +
		  'content,element,shadow,template'
		);

		var isUnaryTag = makeMap(
		  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +
		  'link,meta,param,source,track,wbr',
		  true
		);

		// Elements that you can, intentionally, leave open
		// (and which close themselves)
		var canBeLeftOpenTag = makeMap(
		  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source',
		  true
		);

		// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
		// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content
		var isNonPhrasingTag = makeMap(
		  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +
		  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +
		  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +
		  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +
		  'title,tr,track',
		  true
		);

		// this map is intentionally selective, only covering SVG elements that may
		// contain child elements.
		var isSVG = makeMap(
		  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font,' +
		  'font-face,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +
		  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',
		  true
		);

		var isPreTag = function (tag) { return tag === 'pre'; };

		var isReservedTag = function (tag) {
		  return isHTMLTag(tag) || isSVG(tag)
		};

		function getTagNamespace (tag) {
		  if (isSVG(tag)) {
		    return 'svg'
		  }
		  // basic support for MathML
		  // note it doesn't support other MathML elements being component roots
		  if (tag === 'math') {
		    return 'math'
		  }
		}

		var unknownElementCache = Object.create(null);
		function isUnknownElement (tag) {
		  /* istanbul ignore if */
		  if (!inBrowser) {
		    return true
		  }
		  if (isReservedTag(tag)) {
		    return false
		  }
		  tag = tag.toLowerCase();
		  /* istanbul ignore if */
		  if (unknownElementCache[tag] != null) {
		    return unknownElementCache[tag]
		  }
		  var el = document.createElement(tag);
		  if (tag.indexOf('-') > -1) {
		    // http://stackoverflow.com/a/28210364/1070244
		    return (unknownElementCache[tag] = (
		      el.constructor === window.HTMLUnknownElement ||
		      el.constructor === window.HTMLElement
		    ))
		  } else {
		    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))
		  }
		}

		/*  */

		/**
		 * Query an element selector if it's not an element already.
		 */
		function query (el) {
		  if (typeof el === 'string') {
		    var selector = el;
		    el = document.querySelector(el);
		    if (!el) {
		      "development" !== 'production' && warn(
		        'Cannot find element: ' + selector
		      );
		      return document.createElement('div')
		    }
		  }
		  return el
		}

		/*  */

		function createElement$1 (tagName, vnode) {
		  var elm = document.createElement(tagName);
		  if (tagName !== 'select') {
		    return elm
		  }
		  if (vnode.data && vnode.data.attrs && 'multiple' in vnode.data.attrs) {
		    elm.setAttribute('multiple', 'multiple');
		  }
		  return elm
		}

		function createElementNS (namespace, tagName) {
		  return document.createElementNS(namespaceMap[namespace], tagName)
		}

		function createTextNode (text) {
		  return document.createTextNode(text)
		}

		function createComment (text) {
		  return document.createComment(text)
		}

		function insertBefore (parentNode, newNode, referenceNode) {
		  parentNode.insertBefore(newNode, referenceNode);
		}

		function removeChild (node, child) {
		  node.removeChild(child);
		}

		function appendChild (node, child) {
		  node.appendChild(child);
		}

		function parentNode (node) {
		  return node.parentNode
		}

		function nextSibling (node) {
		  return node.nextSibling
		}

		function tagName (node) {
		  return node.tagName
		}

		function setTextContent (node, text) {
		  node.textContent = text;
		}

		function childNodes (node) {
		  return node.childNodes
		}

		function setAttribute (node, key, val) {
		  node.setAttribute(key, val);
		}


		var nodeOps = Object.freeze({
			createElement: createElement$1,
			createElementNS: createElementNS,
			createTextNode: createTextNode,
			createComment: createComment,
			insertBefore: insertBefore,
			removeChild: removeChild,
			appendChild: appendChild,
			parentNode: parentNode,
			nextSibling: nextSibling,
			tagName: tagName,
			setTextContent: setTextContent,
			childNodes: childNodes,
			setAttribute: setAttribute
		});

		/*  */

		var ref = {
		  create: function create (_, vnode) {
		    registerRef(vnode);
		  },
		  update: function update (oldVnode, vnode) {
		    if (oldVnode.data.ref !== vnode.data.ref) {
		      registerRef(oldVnode, true);
		      registerRef(vnode);
		    }
		  },
		  destroy: function destroy (vnode) {
		    registerRef(vnode, true);
		  }
		};

		function registerRef (vnode, isRemoval) {
		  var key = vnode.data.ref;
		  if (!key) { return }

		  var vm = vnode.context;
		  var ref = vnode.child || vnode.elm;
		  var refs = vm.$refs;
		  if (isRemoval) {
		    if (Array.isArray(refs[key])) {
		      remove$1(refs[key], ref);
		    } else if (refs[key] === ref) {
		      refs[key] = undefined;
		    }
		  } else {
		    if (vnode.data.refInFor) {
		      if (Array.isArray(refs[key])) {
		        refs[key].push(ref);
		      } else {
		        refs[key] = [ref];
		      }
		    } else {
		      refs[key] = ref;
		    }
		  }
		}

		/**
		 * Virtual DOM patching algorithm based on Snabbdom by
		 * Simon Friis Vindum (@paldepind)
		 * Licensed under the MIT License
		 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
		 *
		 * modified by Evan You (@yyx990803)
		 *

		/*
		 * Not type-checking this because this file is perf-critical and the cost
		 * of making flow understand it is not worth it.
		 */

		var emptyNode = new VNode('', {}, []);

		var hooks$1 = ['create', 'update', 'remove', 'destroy'];

		function isUndef (s) {
		  return s == null
		}

		function isDef (s) {
		  return s != null
		}

		function sameVnode (vnode1, vnode2) {
		  return (
		    vnode1.key === vnode2.key &&
		    vnode1.tag === vnode2.tag &&
		    vnode1.isComment === vnode2.isComment &&
		    !vnode1.data === !vnode2.data
		  )
		}

		function createKeyToOldIdx (children, beginIdx, endIdx) {
		  var i, key;
		  var map = {};
		  for (i = beginIdx; i <= endIdx; ++i) {
		    key = children[i].key;
		    if (isDef(key)) { map[key] = i; }
		  }
		  return map
		}

		function createPatchFunction (backend) {
		  var i, j;
		  var cbs = {};

		  var modules = backend.modules;
		  var nodeOps = backend.nodeOps;

		  for (i = 0; i < hooks$1.length; ++i) {
		    cbs[hooks$1[i]] = [];
		    for (j = 0; j < modules.length; ++j) {
		      if (modules[j][hooks$1[i]] !== undefined) { cbs[hooks$1[i]].push(modules[j][hooks$1[i]]); }
		    }
		  }

		  function emptyNodeAt (elm) {
		    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)
		  }

		  function createRmCb (childElm, listeners) {
		    function remove$$1 () {
		      if (--remove$$1.listeners === 0) {
		        removeElement(childElm);
		      }
		    }
		    remove$$1.listeners = listeners;
		    return remove$$1
		  }

		  function removeElement (el) {
		    var parent = nodeOps.parentNode(el);
		    // element may have already been removed due to v-html
		    if (parent) {
		      nodeOps.removeChild(parent, el);
		    }
		  }

		  function createElm (vnode, insertedVnodeQueue, nested) {
		    var i;
		    var data = vnode.data;
		    vnode.isRootInsert = !nested;
		    if (isDef(data)) {
		      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode); }
		      // after calling the init hook, if the vnode is a child component
		      // it should've created a child instance and mounted it. the child
		      // component also has set the placeholder vnode's elm.
		      // in that case we can just return the element and be done.
		      if (isDef(i = vnode.child)) {
		        initComponent(vnode, insertedVnodeQueue);
		        return vnode.elm
		      }
		    }
		    var children = vnode.children;
		    var tag = vnode.tag;
		    if (isDef(tag)) {
		      {
		        if (
		          !vnode.ns &&
		          !(config.ignoredElements && config.ignoredElements.indexOf(tag) > -1) &&
		          config.isUnknownElement(tag)
		        ) {
		          warn(
		            'Unknown custom element: <' + tag + '> - did you ' +
		            'register the component correctly? For recursive components, ' +
		            'make sure to provide the "name" option.',
		            vnode.context
		          );
		        }
		      }
		      vnode.elm = vnode.ns
		        ? nodeOps.createElementNS(vnode.ns, tag)
		        : nodeOps.createElement(tag, vnode);
		      setScope(vnode);
		      createChildren(vnode, children, insertedVnodeQueue);
		      if (isDef(data)) {
		        invokeCreateHooks(vnode, insertedVnodeQueue);
		      }
		    } else if (vnode.isComment) {
		      vnode.elm = nodeOps.createComment(vnode.text);
		    } else {
		      vnode.elm = nodeOps.createTextNode(vnode.text);
		    }
		    return vnode.elm
		  }

		  function createChildren (vnode, children, insertedVnodeQueue) {
		    if (Array.isArray(children)) {
		      for (var i = 0; i < children.length; ++i) {
		        nodeOps.appendChild(vnode.elm, createElm(children[i], insertedVnodeQueue, true));
		      }
		    } else if (isPrimitive(vnode.text)) {
		      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));
		    }
		  }

		  function isPatchable (vnode) {
		    while (vnode.child) {
		      vnode = vnode.child._vnode;
		    }
		    return isDef(vnode.tag)
		  }

		  function invokeCreateHooks (vnode, insertedVnodeQueue) {
		    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
		      cbs.create[i$1](emptyNode, vnode);
		    }
		    i = vnode.data.hook; // Reuse variable
		    if (isDef(i)) {
		      if (i.create) { i.create(emptyNode, vnode); }
		      if (i.insert) { insertedVnodeQueue.push(vnode); }
		    }
		  }

		  function initComponent (vnode, insertedVnodeQueue) {
		    if (vnode.data.pendingInsert) {
		      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
		    }
		    vnode.elm = vnode.child.$el;
		    if (isPatchable(vnode)) {
		      invokeCreateHooks(vnode, insertedVnodeQueue);
		      setScope(vnode);
		    } else {
		      // empty component root.
		      // skip all element-related modules except for ref (#3455)
		      registerRef(vnode);
		      // make sure to invoke the insert hook
		      insertedVnodeQueue.push(vnode);
		    }
		  }

		  // set scope id attribute for scoped CSS.
		  // this is implemented as a special case to avoid the overhead
		  // of going through the normal attribute patching process.
		  function setScope (vnode) {
		    var i;
		    if (isDef(i = vnode.context) && isDef(i = i.$options._scopeId)) {
		      nodeOps.setAttribute(vnode.elm, i, '');
		    }
		    if (isDef(i = activeInstance) &&
		        i !== vnode.context &&
		        isDef(i = i.$options._scopeId)) {
		      nodeOps.setAttribute(vnode.elm, i, '');
		    }
		  }

		  function addVnodes (parentElm, before, vnodes, startIdx, endIdx, insertedVnodeQueue) {
		    for (; startIdx <= endIdx; ++startIdx) {
		      nodeOps.insertBefore(parentElm, createElm(vnodes[startIdx], insertedVnodeQueue), before);
		    }
		  }

		  function invokeDestroyHook (vnode) {
		    var i, j;
		    var data = vnode.data;
		    if (isDef(data)) {
		      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }
		      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }
		    }
		    if (isDef(i = vnode.children)) {
		      for (j = 0; j < vnode.children.length; ++j) {
		        invokeDestroyHook(vnode.children[j]);
		      }
		    }
		  }

		  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {
		    for (; startIdx <= endIdx; ++startIdx) {
		      var ch = vnodes[startIdx];
		      if (isDef(ch)) {
		        if (isDef(ch.tag)) {
		          removeAndInvokeRemoveHook(ch);
		          invokeDestroyHook(ch);
		        } else { // Text node
		          nodeOps.removeChild(parentElm, ch.elm);
		        }
		      }
		    }
		  }

		  function removeAndInvokeRemoveHook (vnode, rm) {
		    if (rm || isDef(vnode.data)) {
		      var listeners = cbs.remove.length + 1;
		      if (!rm) {
		        // directly removing
		        rm = createRmCb(vnode.elm, listeners);
		      } else {
		        // we have a recursively passed down rm callback
		        // increase the listeners count
		        rm.listeners += listeners;
		      }
		      // recursively invoke hooks on child component root node
		      if (isDef(i = vnode.child) && isDef(i = i._vnode) && isDef(i.data)) {
		        removeAndInvokeRemoveHook(i, rm);
		      }
		      for (i = 0; i < cbs.remove.length; ++i) {
		        cbs.remove[i](vnode, rm);
		      }
		      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
		        i(vnode, rm);
		      } else {
		        rm();
		      }
		    } else {
		      removeElement(vnode.elm);
		    }
		  }

		  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
		    var oldStartIdx = 0;
		    var newStartIdx = 0;
		    var oldEndIdx = oldCh.length - 1;
		    var oldStartVnode = oldCh[0];
		    var oldEndVnode = oldCh[oldEndIdx];
		    var newEndIdx = newCh.length - 1;
		    var newStartVnode = newCh[0];
		    var newEndVnode = newCh[newEndIdx];
		    var oldKeyToIdx, idxInOld, elmToMove, before;

		    // removeOnly is a special flag used only by <transition-group>
		    // to ensure removed elements stay in correct relative positions
		    // during leaving transitions
		    var canMove = !removeOnly;

		    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
		      if (isUndef(oldStartVnode)) {
		        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
		      } else if (isUndef(oldEndVnode)) {
		        oldEndVnode = oldCh[--oldEndIdx];
		      } else if (sameVnode(oldStartVnode, newStartVnode)) {
		        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
		        oldStartVnode = oldCh[++oldStartIdx];
		        newStartVnode = newCh[++newStartIdx];
		      } else if (sameVnode(oldEndVnode, newEndVnode)) {
		        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
		        oldEndVnode = oldCh[--oldEndIdx];
		        newEndVnode = newCh[--newEndIdx];
		      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
		        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
		        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
		        oldStartVnode = oldCh[++oldStartIdx];
		        newEndVnode = newCh[--newEndIdx];
		      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
		        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
		        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
		        oldEndVnode = oldCh[--oldEndIdx];
		        newStartVnode = newCh[++newStartIdx];
		      } else {
		        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }
		        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;
		        if (isUndef(idxInOld)) { // New element
		          nodeOps.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
		          newStartVnode = newCh[++newStartIdx];
		        } else {
		          elmToMove = oldCh[idxInOld];
		          /* istanbul ignore if */
		          if ("development" !== 'production' && !elmToMove) {
		            warn(
		              'It seems there are duplicate keys that is causing an update error. ' +
		              'Make sure each v-for item has a unique key.'
		            );
		          }
		          if (elmToMove.tag !== newStartVnode.tag) {
		            // same key but different element. treat as new element
		            nodeOps.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
		            newStartVnode = newCh[++newStartIdx];
		          } else {
		            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
		            oldCh[idxInOld] = undefined;
		            canMove && nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);
		            newStartVnode = newCh[++newStartIdx];
		          }
		        }
		      }
		    }
		    if (oldStartIdx > oldEndIdx) {
		      before = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
		      addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
		    } else if (newStartIdx > newEndIdx) {
		      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
		    }
		  }

		  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {
		    if (oldVnode === vnode) {
		      return
		    }
		    // reuse element for static trees.
		    // note we only do this if the vnode is cloned -
		    // if the new node is not cloned it means the render functions have been
		    // reset by the hot-reload-api and we need to do a proper re-render.
		    if (vnode.isStatic &&
		        oldVnode.isStatic &&
		        vnode.key === oldVnode.key &&
		        (vnode.isCloned || vnode.isOnce)) {
		      vnode.elm = oldVnode.elm;
		      return
		    }
		    var i;
		    var data = vnode.data;
		    var hasData = isDef(data);
		    if (hasData && isDef(i = data.hook) && isDef(i = i.prepatch)) {
		      i(oldVnode, vnode);
		    }
		    var elm = vnode.elm = oldVnode.elm;
		    var oldCh = oldVnode.children;
		    var ch = vnode.children;
		    if (hasData && isPatchable(vnode)) {
		      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }
		      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }
		    }
		    if (isUndef(vnode.text)) {
		      if (isDef(oldCh) && isDef(ch)) {
		        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }
		      } else if (isDef(ch)) {
		        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }
		        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
		      } else if (isDef(oldCh)) {
		        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
		      } else if (isDef(oldVnode.text)) {
		        nodeOps.setTextContent(elm, '');
		      }
		    } else if (oldVnode.text !== vnode.text) {
		      nodeOps.setTextContent(elm, vnode.text);
		    }
		    if (hasData) {
		      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }
		    }
		  }

		  function invokeInsertHook (vnode, queue, initial) {
		    // delay insert hooks for component root nodes, invoke them after the
		    // element is really inserted
		    if (initial && vnode.parent) {
		      vnode.parent.data.pendingInsert = queue;
		    } else {
		      for (var i = 0; i < queue.length; ++i) {
		        queue[i].data.hook.insert(queue[i]);
		      }
		    }
		  }

		  var bailed = false;
		  function hydrate (elm, vnode, insertedVnodeQueue) {
		    {
		      if (!assertNodeMatch(elm, vnode)) {
		        return false
		      }
		    }
		    vnode.elm = elm;
		    var tag = vnode.tag;
		    var data = vnode.data;
		    var children = vnode.children;
		    if (isDef(data)) {
		      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }
		      if (isDef(i = vnode.child)) {
		        // child component. it should have hydrated its own tree.
		        initComponent(vnode, insertedVnodeQueue);
		        return true
		      }
		    }
		    if (isDef(tag)) {
		      if (isDef(children)) {
		        var childNodes = nodeOps.childNodes(elm);
		        // empty element, allow client to pick up and populate children
		        if (!childNodes.length) {
		          createChildren(vnode, children, insertedVnodeQueue);
		        } else {
		          var childrenMatch = true;
		          if (childNodes.length !== children.length) {
		            childrenMatch = false;
		          } else {
		            for (var i$1 = 0; i$1 < children.length; i$1++) {
		              if (!hydrate(childNodes[i$1], children[i$1], insertedVnodeQueue)) {
		                childrenMatch = false;
		                break
		              }
		            }
		          }
		          if (!childrenMatch) {
		            if ("development" !== 'production' &&
		                typeof console !== 'undefined' &&
		                !bailed) {
		              bailed = true;
		              console.warn('Parent: ', elm);
		              console.warn('Mismatching childNodes vs. VNodes: ', childNodes, children);
		            }
		            return false
		          }
		        }
		      }
		      if (isDef(data)) {
		        invokeCreateHooks(vnode, insertedVnodeQueue);
		      }
		    }
		    return true
		  }

		  function assertNodeMatch (node, vnode) {
		    if (vnode.tag) {
		      return (
		        vnode.tag.indexOf('vue-component') === 0 ||
		        vnode.tag === nodeOps.tagName(node).toLowerCase()
		      )
		    } else {
		      return _toString(vnode.text) === node.data
		    }
		  }

		  return function patch (oldVnode, vnode, hydrating, removeOnly) {
		    if (!vnode) {
		      if (oldVnode) { invokeDestroyHook(oldVnode); }
		      return
		    }

		    var elm, parent;
		    var isInitialPatch = false;
		    var insertedVnodeQueue = [];

		    if (!oldVnode) {
		      // empty mount, create new root element
		      isInitialPatch = true;
		      createElm(vnode, insertedVnodeQueue);
		    } else {
		      var isRealElement = isDef(oldVnode.nodeType);
		      if (!isRealElement && sameVnode(oldVnode, vnode)) {
		        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);
		      } else {
		        if (isRealElement) {
		          // mounting to a real element
		          // check if this is server-rendered content and if we can perform
		          // a successful hydration.
		          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute('server-rendered')) {
		            oldVnode.removeAttribute('server-rendered');
		            hydrating = true;
		          }
		          if (hydrating) {
		            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
		              invokeInsertHook(vnode, insertedVnodeQueue, true);
		              return oldVnode
		            } else {
		              warn(
		                'The client-side rendered virtual DOM tree is not matching ' +
		                'server-rendered content. This is likely caused by incorrect ' +
		                'HTML markup, for example nesting block-level elements inside ' +
		                '<p>, or missing <tbody>. Bailing hydration and performing ' +
		                'full client-side render.'
		              );
		            }
		          }
		          // either not server-rendered, or hydration failed.
		          // create an empty node and replace it
		          oldVnode = emptyNodeAt(oldVnode);
		        }
		        elm = oldVnode.elm;
		        parent = nodeOps.parentNode(elm);

		        createElm(vnode, insertedVnodeQueue);

		        // component root element replaced.
		        // update parent placeholder node element.
		        if (vnode.parent) {
		          vnode.parent.elm = vnode.elm;
		          if (isPatchable(vnode)) {
		            for (var i = 0; i < cbs.create.length; ++i) {
		              cbs.create[i](emptyNode, vnode.parent);
		            }
		          }
		        }

		        if (parent !== null) {
		          nodeOps.insertBefore(parent, vnode.elm, nodeOps.nextSibling(elm));
		          removeVnodes(parent, [oldVnode], 0, 0);
		        } else if (isDef(oldVnode.tag)) {
		          invokeDestroyHook(oldVnode);
		        }
		      }
		    }

		    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
		    return vnode.elm
		  }
		}

		/*  */

		var directives = {
		  create: updateDirectives,
		  update: updateDirectives,
		  destroy: function unbindDirectives (vnode) {
		    updateDirectives(vnode, emptyNode);
		  }
		};

		function updateDirectives (
		  oldVnode,
		  vnode
		) {
		  if (!oldVnode.data.directives && !vnode.data.directives) {
		    return
		  }
		  var isCreate = oldVnode === emptyNode;
		  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
		  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);

		  var dirsWithInsert = [];
		  var dirsWithPostpatch = [];

		  var key, oldDir, dir;
		  for (key in newDirs) {
		    oldDir = oldDirs[key];
		    dir = newDirs[key];
		    if (!oldDir) {
		      // new directive, bind
		      callHook$1(dir, 'bind', vnode, oldVnode);
		      if (dir.def && dir.def.inserted) {
		        dirsWithInsert.push(dir);
		      }
		    } else {
		      // existing directive, update
		      dir.oldValue = oldDir.value;
		      callHook$1(dir, 'update', vnode, oldVnode);
		      if (dir.def && dir.def.componentUpdated) {
		        dirsWithPostpatch.push(dir);
		      }
		    }
		  }

		  if (dirsWithInsert.length) {
		    var callInsert = function () {
		      dirsWithInsert.forEach(function (dir) {
		        callHook$1(dir, 'inserted', vnode, oldVnode);
		      });
		    };
		    if (isCreate) {
		      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert, 'dir-insert');
		    } else {
		      callInsert();
		    }
		  }

		  if (dirsWithPostpatch.length) {
		    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {
		      dirsWithPostpatch.forEach(function (dir) {
		        callHook$1(dir, 'componentUpdated', vnode, oldVnode);
		      });
		    }, 'dir-postpatch');
		  }

		  if (!isCreate) {
		    for (key in oldDirs) {
		      if (!newDirs[key]) {
		        // no longer present, unbind
		        callHook$1(oldDirs[key], 'unbind', oldVnode);
		      }
		    }
		  }
		}

		var emptyModifiers = Object.create(null);

		function normalizeDirectives$1 (
		  dirs,
		  vm
		) {
		  var res = Object.create(null);
		  if (!dirs) {
		    return res
		  }
		  var i, dir;
		  for (i = 0; i < dirs.length; i++) {
		    dir = dirs[i];
		    if (!dir.modifiers) {
		      dir.modifiers = emptyModifiers;
		    }
		    res[getRawDirName(dir)] = dir;
		    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
		  }
		  return res
		}

		function getRawDirName (dir) {
		  return dir.rawName || ((dir.name) + "." + (Object.keys(dir.modifiers || {}).join('.')))
		}

		function callHook$1 (dir, hook, vnode, oldVnode) {
		  var fn = dir.def && dir.def[hook];
		  if (fn) {
		    fn(vnode.elm, dir, vnode, oldVnode);
		  }
		}

		var baseModules = [
		  ref,
		  directives
		];

		/*  */

		function updateAttrs (oldVnode, vnode) {
		  if (!oldVnode.data.attrs && !vnode.data.attrs) {
		    return
		  }
		  var key, cur, old;
		  var elm = vnode.elm;
		  var oldAttrs = oldVnode.data.attrs || {};
		  var attrs = vnode.data.attrs || {};
		  // clone observed objects, as the user probably wants to mutate it
		  if (attrs.__ob__) {
		    attrs = vnode.data.attrs = extend({}, attrs);
		  }

		  for (key in attrs) {
		    cur = attrs[key];
		    old = oldAttrs[key];
		    if (old !== cur) {
		      setAttr(elm, key, cur);
		    }
		  }
		  for (key in oldAttrs) {
		    if (attrs[key] == null) {
		      if (isXlink(key)) {
		        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
		      } else if (!isEnumeratedAttr(key)) {
		        elm.removeAttribute(key);
		      }
		    }
		  }
		}

		function setAttr (el, key, value) {
		  if (isBooleanAttr(key)) {
		    // set attribute for blank value
		    // e.g. <option disabled>Select one</option>
		    if (isFalsyAttrValue(value)) {
		      el.removeAttribute(key);
		    } else {
		      el.setAttribute(key, key);
		    }
		  } else if (isEnumeratedAttr(key)) {
		    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');
		  } else if (isXlink(key)) {
		    if (isFalsyAttrValue(value)) {
		      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
		    } else {
		      el.setAttributeNS(xlinkNS, key, value);
		    }
		  } else {
		    if (isFalsyAttrValue(value)) {
		      el.removeAttribute(key);
		    } else {
		      el.setAttribute(key, value);
		    }
		  }
		}

		var attrs = {
		  create: updateAttrs,
		  update: updateAttrs
		};

		/*  */

		function updateClass (oldVnode, vnode) {
		  var el = vnode.elm;
		  var data = vnode.data;
		  var oldData = oldVnode.data;
		  if (!data.staticClass && !data.class &&
		      (!oldData || (!oldData.staticClass && !oldData.class))) {
		    return
		  }

		  var cls = genClassForVnode(vnode);

		  // handle transition classes
		  var transitionClass = el._transitionClasses;
		  if (transitionClass) {
		    cls = concat(cls, stringifyClass(transitionClass));
		  }

		  // set the class
		  if (cls !== el._prevClass) {
		    el.setAttribute('class', cls);
		    el._prevClass = cls;
		  }
		}

		var klass = {
		  create: updateClass,
		  update: updateClass
		};

		// skip type checking this file because we need to attach private properties
		// to elements

		function updateDOMListeners (oldVnode, vnode) {
		  if (!oldVnode.data.on && !vnode.data.on) {
		    return
		  }
		  var on = vnode.data.on || {};
		  var oldOn = oldVnode.data.on || {};
		  var add = vnode.elm._v_add || (vnode.elm._v_add = function (event, handler, capture) {
		    vnode.elm.addEventListener(event, handler, capture);
		  });
		  var remove = vnode.elm._v_remove || (vnode.elm._v_remove = function (event, handler) {
		    vnode.elm.removeEventListener(event, handler);
		  });
		  updateListeners(on, oldOn, add, remove, vnode.context);
		}

		var events = {
		  create: updateDOMListeners,
		  update: updateDOMListeners
		};

		/*  */

		function updateDOMProps (oldVnode, vnode) {
		  if (!oldVnode.data.domProps && !vnode.data.domProps) {
		    return
		  }
		  var key, cur;
		  var elm = vnode.elm;
		  var oldProps = oldVnode.data.domProps || {};
		  var props = vnode.data.domProps || {};
		  // clone observed objects, as the user probably wants to mutate it
		  if (props.__ob__) {
		    props = vnode.data.domProps = extend({}, props);
		  }

		  for (key in oldProps) {
		    if (props[key] == null) {
		      elm[key] = '';
		    }
		  }
		  for (key in props) {
		    // ignore children if the node has textContent or innerHTML,
		    // as these will throw away existing DOM nodes and cause removal errors
		    // on subsequent patches (#3360)
		    if ((key === 'textContent' || key === 'innerHTML') && vnode.children) {
		      vnode.children.length = 0;
		    }
		    cur = props[key];
		    if (key === 'value') {
		      // store value as _value as well since
		      // non-string values will be stringified
		      elm._value = cur;
		      // avoid resetting cursor position when value is the same
		      var strCur = cur == null ? '' : String(cur);
		      if (elm.value !== strCur && !elm.composing) {
		        elm.value = strCur;
		      }
		    } else {
		      elm[key] = cur;
		    }
		  }
		}

		var domProps = {
		  create: updateDOMProps,
		  update: updateDOMProps
		};

		/*  */

		var cssVarRE = /^--/;
		var setProp = function (el, name, val) {
		  /* istanbul ignore if */
		  if (cssVarRE.test(name)) {
		    el.style.setProperty(name, val);
		  } else {
		    el.style[normalize(name)] = val;
		  }
		};

		var prefixes = ['Webkit', 'Moz', 'ms'];

		var testEl;
		var normalize = cached(function (prop) {
		  testEl = testEl || document.createElement('div');
		  prop = camelize(prop);
		  if (prop !== 'filter' && (prop in testEl.style)) {
		    return prop
		  }
		  var upper = prop.charAt(0).toUpperCase() + prop.slice(1);
		  for (var i = 0; i < prefixes.length; i++) {
		    var prefixed = prefixes[i] + upper;
		    if (prefixed in testEl.style) {
		      return prefixed
		    }
		  }
		});

		function updateStyle (oldVnode, vnode) {
		  if ((!oldVnode.data || !oldVnode.data.style) && !vnode.data.style) {
		    return
		  }
		  var cur, name;
		  var el = vnode.elm;
		  var oldStyle = oldVnode.data.style || {};
		  var style = vnode.data.style || {};

		  // handle string
		  if (typeof style === 'string') {
		    el.style.cssText = style;
		    return
		  }

		  var needClone = style.__ob__;

		  // handle array syntax
		  if (Array.isArray(style)) {
		    style = vnode.data.style = toObject(style);
		  }

		  // clone the style for future updates,
		  // in case the user mutates the style object in-place.
		  if (needClone) {
		    style = vnode.data.style = extend({}, style);
		  }

		  for (name in oldStyle) {
		    if (style[name] == null) {
		      setProp(el, name, '');
		    }
		  }
		  for (name in style) {
		    cur = style[name];
		    if (cur !== oldStyle[name]) {
		      // ie9 setting to null has no effect, must use empty string
		      setProp(el, name, cur == null ? '' : cur);
		    }
		  }
		}

		var style = {
		  create: updateStyle,
		  update: updateStyle
		};

		/*  */

		/**
		 * Add class with compatibility for SVG since classList is not supported on
		 * SVG elements in IE
		 */
		function addClass (el, cls) {
		  /* istanbul ignore if */
		  if (!cls || !cls.trim()) {
		    return
		  }

		  /* istanbul ignore else */
		  if (el.classList) {
		    if (cls.indexOf(' ') > -1) {
		      cls.split(/\s+/).forEach(function (c) { return el.classList.add(c); });
		    } else {
		      el.classList.add(cls);
		    }
		  } else {
		    var cur = ' ' + el.getAttribute('class') + ' ';
		    if (cur.indexOf(' ' + cls + ' ') < 0) {
		      el.setAttribute('class', (cur + cls).trim());
		    }
		  }
		}

		/**
		 * Remove class with compatibility for SVG since classList is not supported on
		 * SVG elements in IE
		 */
		function removeClass (el, cls) {
		  /* istanbul ignore if */
		  if (!cls || !cls.trim()) {
		    return
		  }

		  /* istanbul ignore else */
		  if (el.classList) {
		    if (cls.indexOf(' ') > -1) {
		      cls.split(/\s+/).forEach(function (c) { return el.classList.remove(c); });
		    } else {
		      el.classList.remove(cls);
		    }
		  } else {
		    var cur = ' ' + el.getAttribute('class') + ' ';
		    var tar = ' ' + cls + ' ';
		    while (cur.indexOf(tar) >= 0) {
		      cur = cur.replace(tar, ' ');
		    }
		    el.setAttribute('class', cur.trim());
		  }
		}

		/*  */

		var hasTransition = inBrowser && !isIE9;
		var TRANSITION = 'transition';
		var ANIMATION = 'animation';

		// Transition property/event sniffing
		var transitionProp = 'transition';
		var transitionEndEvent = 'transitionend';
		var animationProp = 'animation';
		var animationEndEvent = 'animationend';
		if (hasTransition) {
		  /* istanbul ignore if */
		  if (window.ontransitionend === undefined &&
		    window.onwebkittransitionend !== undefined) {
		    transitionProp = 'WebkitTransition';
		    transitionEndEvent = 'webkitTransitionEnd';
		  }
		  if (window.onanimationend === undefined &&
		    window.onwebkitanimationend !== undefined) {
		    animationProp = 'WebkitAnimation';
		    animationEndEvent = 'webkitAnimationEnd';
		  }
		}

		var raf = (inBrowser && window.requestAnimationFrame) || setTimeout;
		function nextFrame (fn) {
		  raf(function () {
		    raf(fn);
		  });
		}

		function addTransitionClass (el, cls) {
		  (el._transitionClasses || (el._transitionClasses = [])).push(cls);
		  addClass(el, cls);
		}

		function removeTransitionClass (el, cls) {
		  if (el._transitionClasses) {
		    remove$1(el._transitionClasses, cls);
		  }
		  removeClass(el, cls);
		}

		function whenTransitionEnds (
		  el,
		  expectedType,
		  cb
		) {
		  var ref = getTransitionInfo(el, expectedType);
		  var type = ref.type;
		  var timeout = ref.timeout;
		  var propCount = ref.propCount;
		  if (!type) { return cb() }
		  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
		  var ended = 0;
		  var end = function () {
		    el.removeEventListener(event, onEnd);
		    cb();
		  };
		  var onEnd = function (e) {
		    if (e.target === el) {
		      if (++ended >= propCount) {
		        end();
		      }
		    }
		  };
		  setTimeout(function () {
		    if (ended < propCount) {
		      end();
		    }
		  }, timeout + 1);
		  el.addEventListener(event, onEnd);
		}

		var transformRE = /\b(transform|all)(,|$)/;

		function getTransitionInfo (el, expectedType) {
		  var styles = window.getComputedStyle(el);
		  var transitioneDelays = styles[transitionProp + 'Delay'].split(', ');
		  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');
		  var transitionTimeout = getTimeout(transitioneDelays, transitionDurations);
		  var animationDelays = styles[animationProp + 'Delay'].split(', ');
		  var animationDurations = styles[animationProp + 'Duration'].split(', ');
		  var animationTimeout = getTimeout(animationDelays, animationDurations);

		  var type;
		  var timeout = 0;
		  var propCount = 0;
		  /* istanbul ignore if */
		  if (expectedType === TRANSITION) {
		    if (transitionTimeout > 0) {
		      type = TRANSITION;
		      timeout = transitionTimeout;
		      propCount = transitionDurations.length;
		    }
		  } else if (expectedType === ANIMATION) {
		    if (animationTimeout > 0) {
		      type = ANIMATION;
		      timeout = animationTimeout;
		      propCount = animationDurations.length;
		    }
		  } else {
		    timeout = Math.max(transitionTimeout, animationTimeout);
		    type = timeout > 0
		      ? transitionTimeout > animationTimeout
		        ? TRANSITION
		        : ANIMATION
		      : null;
		    propCount = type
		      ? type === TRANSITION
		        ? transitionDurations.length
		        : animationDurations.length
		      : 0;
		  }
		  var hasTransform =
		    type === TRANSITION &&
		    transformRE.test(styles[transitionProp + 'Property']);
		  return {
		    type: type,
		    timeout: timeout,
		    propCount: propCount,
		    hasTransform: hasTransform
		  }
		}

		function getTimeout (delays, durations) {
		  /* istanbul ignore next */
		  while (delays.length < durations.length) {
		    delays = delays.concat(delays);
		  }

		  return Math.max.apply(null, durations.map(function (d, i) {
		    return toMs(d) + toMs(delays[i])
		  }))
		}

		function toMs (s) {
		  return Number(s.slice(0, -1)) * 1000
		}

		/*  */

		function enter (vnode) {
		  var el = vnode.elm;

		  // call leave callback now
		  if (el._leaveCb) {
		    el._leaveCb.cancelled = true;
		    el._leaveCb();
		  }

		  var data = resolveTransition(vnode.data.transition);
		  if (!data) {
		    return
		  }

		  /* istanbul ignore if */
		  if (el._enterCb || el.nodeType !== 1) {
		    return
		  }

		  var css = data.css;
		  var type = data.type;
		  var enterClass = data.enterClass;
		  var enterActiveClass = data.enterActiveClass;
		  var appearClass = data.appearClass;
		  var appearActiveClass = data.appearActiveClass;
		  var beforeEnter = data.beforeEnter;
		  var enter = data.enter;
		  var afterEnter = data.afterEnter;
		  var enterCancelled = data.enterCancelled;
		  var beforeAppear = data.beforeAppear;
		  var appear = data.appear;
		  var afterAppear = data.afterAppear;
		  var appearCancelled = data.appearCancelled;

		  // activeInstance will always be the <transition> component managing this
		  // transition. One edge case to check is when the <transition> is placed
		  // as the root node of a child component. In that case we need to check
		  // <transition>'s parent for appear check.
		  var transitionNode = activeInstance.$vnode;
		  var context = transitionNode && transitionNode.parent
		    ? transitionNode.parent.context
		    : activeInstance;

		  var isAppear = !context._isMounted || !vnode.isRootInsert;

		  if (isAppear && !appear && appear !== '') {
		    return
		  }

		  var startClass = isAppear ? appearClass : enterClass;
		  var activeClass = isAppear ? appearActiveClass : enterActiveClass;
		  var beforeEnterHook = isAppear ? (beforeAppear || beforeEnter) : beforeEnter;
		  var enterHook = isAppear ? (typeof appear === 'function' ? appear : enter) : enter;
		  var afterEnterHook = isAppear ? (afterAppear || afterEnter) : afterEnter;
		  var enterCancelledHook = isAppear ? (appearCancelled || enterCancelled) : enterCancelled;

		  var expectsCSS = css !== false && !isIE9;
		  var userWantsControl =
		    enterHook &&
		    // enterHook may be a bound method which exposes
		    // the length of original fn as _length
		    (enterHook._length || enterHook.length) > 1;

		  var cb = el._enterCb = once(function () {
		    if (expectsCSS) {
		      removeTransitionClass(el, activeClass);
		    }
		    if (cb.cancelled) {
		      if (expectsCSS) {
		        removeTransitionClass(el, startClass);
		      }
		      enterCancelledHook && enterCancelledHook(el);
		    } else {
		      afterEnterHook && afterEnterHook(el);
		    }
		    el._enterCb = null;
		  });

		  if (!vnode.data.show) {
		    // remove pending leave element on enter by injecting an insert hook
		    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {
		      var parent = el.parentNode;
		      var pendingNode = parent && parent._pending && parent._pending[vnode.key];
		      if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {
		        pendingNode.elm._leaveCb();
		      }
		      enterHook && enterHook(el, cb);
		    }, 'transition-insert');
		  }

		  // start enter transition
		  beforeEnterHook && beforeEnterHook(el);
		  if (expectsCSS) {
		    addTransitionClass(el, startClass);
		    addTransitionClass(el, activeClass);
		    nextFrame(function () {
		      removeTransitionClass(el, startClass);
		      if (!cb.cancelled && !userWantsControl) {
		        whenTransitionEnds(el, type, cb);
		      }
		    });
		  }

		  if (vnode.data.show) {
		    enterHook && enterHook(el, cb);
		  }

		  if (!expectsCSS && !userWantsControl) {
		    cb();
		  }
		}

		function leave (vnode, rm) {
		  var el = vnode.elm;

		  // call enter callback now
		  if (el._enterCb) {
		    el._enterCb.cancelled = true;
		    el._enterCb();
		  }

		  var data = resolveTransition(vnode.data.transition);
		  if (!data) {
		    return rm()
		  }

		  /* istanbul ignore if */
		  if (el._leaveCb || el.nodeType !== 1) {
		    return
		  }

		  var css = data.css;
		  var type = data.type;
		  var leaveClass = data.leaveClass;
		  var leaveActiveClass = data.leaveActiveClass;
		  var beforeLeave = data.beforeLeave;
		  var leave = data.leave;
		  var afterLeave = data.afterLeave;
		  var leaveCancelled = data.leaveCancelled;
		  var delayLeave = data.delayLeave;

		  var expectsCSS = css !== false && !isIE9;
		  var userWantsControl =
		    leave &&
		    // leave hook may be a bound method which exposes
		    // the length of original fn as _length
		    (leave._length || leave.length) > 1;

		  var cb = el._leaveCb = once(function () {
		    if (el.parentNode && el.parentNode._pending) {
		      el.parentNode._pending[vnode.key] = null;
		    }
		    if (expectsCSS) {
		      removeTransitionClass(el, leaveActiveClass);
		    }
		    if (cb.cancelled) {
		      if (expectsCSS) {
		        removeTransitionClass(el, leaveClass);
		      }
		      leaveCancelled && leaveCancelled(el);
		    } else {
		      rm();
		      afterLeave && afterLeave(el);
		    }
		    el._leaveCb = null;
		  });

		  if (delayLeave) {
		    delayLeave(performLeave);
		  } else {
		    performLeave();
		  }

		  function performLeave () {
		    // the delayed leave may have already been cancelled
		    if (cb.cancelled) {
		      return
		    }
		    // record leaving element
		    if (!vnode.data.show) {
		      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
		    }
		    beforeLeave && beforeLeave(el);
		    if (expectsCSS) {
		      addTransitionClass(el, leaveClass);
		      addTransitionClass(el, leaveActiveClass);
		      nextFrame(function () {
		        removeTransitionClass(el, leaveClass);
		        if (!cb.cancelled && !userWantsControl) {
		          whenTransitionEnds(el, type, cb);
		        }
		      });
		    }
		    leave && leave(el, cb);
		    if (!expectsCSS && !userWantsControl) {
		      cb();
		    }
		  }
		}

		function resolveTransition (def$$1) {
		  if (!def$$1) {
		    return
		  }
		  /* istanbul ignore else */
		  if (typeof def$$1 === 'object') {
		    var res = {};
		    if (def$$1.css !== false) {
		      extend(res, autoCssTransition(def$$1.name || 'v'));
		    }
		    extend(res, def$$1);
		    return res
		  } else if (typeof def$$1 === 'string') {
		    return autoCssTransition(def$$1)
		  }
		}

		var autoCssTransition = cached(function (name) {
		  return {
		    enterClass: (name + "-enter"),
		    leaveClass: (name + "-leave"),
		    appearClass: (name + "-enter"),
		    enterActiveClass: (name + "-enter-active"),
		    leaveActiveClass: (name + "-leave-active"),
		    appearActiveClass: (name + "-enter-active")
		  }
		});

		function once (fn) {
		  var called = false;
		  return function () {
		    if (!called) {
		      called = true;
		      fn();
		    }
		  }
		}

		var transition = inBrowser ? {
		  create: function create (_, vnode) {
		    if (!vnode.data.show) {
		      enter(vnode);
		    }
		  },
		  remove: function remove (vnode, rm) {
		    /* istanbul ignore else */
		    if (!vnode.data.show) {
		      leave(vnode, rm);
		    } else {
		      rm();
		    }
		  }
		} : {};

		var platformModules = [
		  attrs,
		  klass,
		  events,
		  domProps,
		  style,
		  transition
		];

		/*  */

		// the directive module should be applied last, after all
		// built-in modules have been applied.
		var modules = platformModules.concat(baseModules);

		var patch$1 = createPatchFunction({ nodeOps: nodeOps, modules: modules });

		/**
		 * Not type checking this file because flow doesn't like attaching
		 * properties to Elements.
		 */

		var modelableTagRE = /^input|select|textarea|vue-component-[0-9]+(-[0-9a-zA-Z_-]*)?$/;

		/* istanbul ignore if */
		if (isIE9) {
		  // http://www.matts411.com/post/internet-explorer-9-oninput/
		  document.addEventListener('selectionchange', function () {
		    var el = document.activeElement;
		    if (el && el.vmodel) {
		      trigger(el, 'input');
		    }
		  });
		}

		var model = {
		  inserted: function inserted (el, binding, vnode) {
		    {
		      if (!modelableTagRE.test(vnode.tag)) {
		        warn(
		          "v-model is not supported on element type: <" + (vnode.tag) + ">. " +
		          'If you are working with contenteditable, it\'s recommended to ' +
		          'wrap a library dedicated for that purpose inside a custom component.',
		          vnode.context
		        );
		      }
		    }
		    if (vnode.tag === 'select') {
		      var cb = function () {
		        setSelected(el, binding, vnode.context);
		      };
		      cb();
		      /* istanbul ignore if */
		      if (isIE || isEdge) {
		        setTimeout(cb, 0);
		      }
		    } else if (
		      (vnode.tag === 'textarea' || el.type === 'text') &&
		      !binding.modifiers.lazy
		    ) {
		      if (!isAndroid) {
		        el.addEventListener('compositionstart', onCompositionStart);
		        el.addEventListener('compositionend', onCompositionEnd);
		      }
		      /* istanbul ignore if */
		      if (isIE9) {
		        el.vmodel = true;
		      }
		    }
		  },
		  componentUpdated: function componentUpdated (el, binding, vnode) {
		    if (vnode.tag === 'select') {
		      setSelected(el, binding, vnode.context);
		      // in case the options rendered by v-for have changed,
		      // it's possible that the value is out-of-sync with the rendered options.
		      // detect such cases and filter out values that no longer has a matching
		      // option in the DOM.
		      var needReset = el.multiple
		        ? binding.value.some(function (v) { return hasNoMatchingOption(v, el.options); })
		        : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, el.options);
		      if (needReset) {
		        trigger(el, 'change');
		      }
		    }
		  }
		};

		function setSelected (el, binding, vm) {
		  var value = binding.value;
		  var isMultiple = el.multiple;
		  if (isMultiple && !Array.isArray(value)) {
		    "development" !== 'production' && warn(
		      "<select multiple v-model=\"" + (binding.expression) + "\"> " +
		      "expects an Array value for its binding, but got " + (Object.prototype.toString.call(value).slice(8, -1)),
		      vm
		    );
		    return
		  }
		  var selected, option;
		  for (var i = 0, l = el.options.length; i < l; i++) {
		    option = el.options[i];
		    if (isMultiple) {
		      selected = looseIndexOf(value, getValue(option)) > -1;
		      if (option.selected !== selected) {
		        option.selected = selected;
		      }
		    } else {
		      if (looseEqual(getValue(option), value)) {
		        if (el.selectedIndex !== i) {
		          el.selectedIndex = i;
		        }
		        return
		      }
		    }
		  }
		  if (!isMultiple) {
		    el.selectedIndex = -1;
		  }
		}

		function hasNoMatchingOption (value, options) {
		  for (var i = 0, l = options.length; i < l; i++) {
		    if (looseEqual(getValue(options[i]), value)) {
		      return false
		    }
		  }
		  return true
		}

		function getValue (option) {
		  return '_value' in option
		    ? option._value
		    : option.value
		}

		function onCompositionStart (e) {
		  e.target.composing = true;
		}

		function onCompositionEnd (e) {
		  e.target.composing = false;
		  trigger(e.target, 'input');
		}

		function trigger (el, type) {
		  var e = document.createEvent('HTMLEvents');
		  e.initEvent(type, true, true);
		  el.dispatchEvent(e);
		}

		/*  */

		// recursively search for possible transition defined inside the component root
		function locateNode (vnode) {
		  return vnode.child && (!vnode.data || !vnode.data.transition)
		    ? locateNode(vnode.child._vnode)
		    : vnode
		}

		var show = {
		  bind: function bind (el, ref, vnode) {
		    var value = ref.value;

		    vnode = locateNode(vnode);
		    var transition = vnode.data && vnode.data.transition;
		    if (value && transition && !isIE9) {
		      enter(vnode);
		    }
		    var originalDisplay = el.style.display === 'none' ? '' : el.style.display;
		    el.style.display = value ? originalDisplay : 'none';
		    el.__vOriginalDisplay = originalDisplay;
		  },
		  update: function update (el, ref, vnode) {
		    var value = ref.value;
		    var oldValue = ref.oldValue;

		    /* istanbul ignore if */
		    if (value === oldValue) { return }
		    vnode = locateNode(vnode);
		    var transition = vnode.data && vnode.data.transition;
		    if (transition && !isIE9) {
		      if (value) {
		        enter(vnode);
		        el.style.display = el.__vOriginalDisplay;
		      } else {
		        leave(vnode, function () {
		          el.style.display = 'none';
		        });
		      }
		    } else {
		      el.style.display = value ? el.__vOriginalDisplay : 'none';
		    }
		  }
		};

		var platformDirectives = {
		  model: model,
		  show: show
		};

		/*  */

		// Provides transition support for a single element/component.
		// supports transition mode (out-in / in-out)

		var transitionProps = {
		  name: String,
		  appear: Boolean,
		  css: Boolean,
		  mode: String,
		  type: String,
		  enterClass: String,
		  leaveClass: String,
		  enterActiveClass: String,
		  leaveActiveClass: String,
		  appearClass: String,
		  appearActiveClass: String
		};

		// in case the child is also an abstract component, e.g. <keep-alive>
		// we want to recursively retrieve the real component to be rendered
		function getRealChild (vnode) {
		  var compOptions = vnode && vnode.componentOptions;
		  if (compOptions && compOptions.Ctor.options.abstract) {
		    return getRealChild(getFirstComponentChild(compOptions.children))
		  } else {
		    return vnode
		  }
		}

		function extractTransitionData (comp) {
		  var data = {};
		  var options = comp.$options;
		  // props
		  for (var key in options.propsData) {
		    data[key] = comp[key];
		  }
		  // events.
		  // extract listeners and pass them directly to the transition methods
		  var listeners = options._parentListeners;
		  for (var key$1 in listeners) {
		    data[camelize(key$1)] = listeners[key$1].fn;
		  }
		  return data
		}

		function placeholder (h, rawChild) {
		  return /\d-keep-alive$/.test(rawChild.tag)
		    ? h('keep-alive')
		    : null
		}

		function hasParentTransition (vnode) {
		  while ((vnode = vnode.parent)) {
		    if (vnode.data.transition) {
		      return true
		    }
		  }
		}

		var Transition = {
		  name: 'transition',
		  props: transitionProps,
		  abstract: true,
		  render: function render (h) {
		    var this$1 = this;

		    var children = this.$slots.default;
		    if (!children) {
		      return
		    }

		    // filter out text nodes (possible whitespaces)
		    children = children.filter(function (c) { return c.tag; });
		    /* istanbul ignore if */
		    if (!children.length) {
		      return
		    }

		    // warn multiple elements
		    if ("development" !== 'production' && children.length > 1) {
		      warn(
		        '<transition> can only be used on a single element. Use ' +
		        '<transition-group> for lists.',
		        this.$parent
		      );
		    }

		    var mode = this.mode;

		    // warn invalid mode
		    if ("development" !== 'production' &&
		        mode && mode !== 'in-out' && mode !== 'out-in') {
		      warn(
		        'invalid <transition> mode: ' + mode,
		        this.$parent
		      );
		    }

		    var rawChild = children[0];

		    // if this is a component root node and the component's
		    // parent container node also has transition, skip.
		    if (hasParentTransition(this.$vnode)) {
		      return rawChild
		    }

		    // apply transition data to child
		    // use getRealChild() to ignore abstract components e.g. keep-alive
		    var child = getRealChild(rawChild);
		    /* istanbul ignore if */
		    if (!child) {
		      return rawChild
		    }

		    if (this._leaving) {
		      return placeholder(h, rawChild)
		    }

		    var key = child.key = child.key == null || child.isStatic
		      ? ("__v" + (child.tag + this._uid) + "__")
		      : child.key;
		    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
		    var oldRawChild = this._vnode;
		    var oldChild = getRealChild(oldRawChild);

		    // mark v-show
		    // so that the transition module can hand over the control to the directive
		    if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {
		      child.data.show = true;
		    }

		    if (oldChild && oldChild.data && oldChild.key !== key) {
		      // replace old child transition data with fresh one
		      // important for dynamic transitions!
		      var oldData = oldChild.data.transition = extend({}, data);

		      // handle transition mode
		      if (mode === 'out-in') {
		        // return placeholder node and queue update when leave finishes
		        this._leaving = true;
		        mergeVNodeHook(oldData, 'afterLeave', function () {
		          this$1._leaving = false;
		          this$1.$forceUpdate();
		        }, key);
		        return placeholder(h, rawChild)
		      } else if (mode === 'in-out') {
		        var delayedLeave;
		        var performLeave = function () { delayedLeave(); };
		        mergeVNodeHook(data, 'afterEnter', performLeave, key);
		        mergeVNodeHook(data, 'enterCancelled', performLeave, key);
		        mergeVNodeHook(oldData, 'delayLeave', function (leave) {
		          delayedLeave = leave;
		        }, key);
		      }
		    }

		    return rawChild
		  }
		};

		/*  */

		// Provides transition support for list items.
		// supports move transitions using the FLIP technique.

		// Because the vdom's children update algorithm is "unstable" - i.e.
		// it doesn't guarantee the relative positioning of removed elements,
		// we force transition-group to update its children into two passes:
		// in the first pass, we remove all nodes that need to be removed,
		// triggering their leaving transition; in the second pass, we insert/move
		// into the final disired state. This way in the second pass removed
		// nodes will remain where they should be.

		var props = extend({
		  tag: String,
		  moveClass: String
		}, transitionProps);

		delete props.mode;

		var TransitionGroup = {
		  props: props,

		  render: function render (h) {
		    var tag = this.tag || this.$vnode.data.tag || 'span';
		    var map = Object.create(null);
		    var prevChildren = this.prevChildren = this.children;
		    var rawChildren = this.$slots.default || [];
		    var children = this.children = [];
		    var transitionData = extractTransitionData(this);

		    for (var i = 0; i < rawChildren.length; i++) {
		      var c = rawChildren[i];
		      if (c.tag) {
		        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
		          children.push(c);
		          map[c.key] = c
		          ;(c.data || (c.data = {})).transition = transitionData;
		        } else {
		          var opts = c.componentOptions;
		          var name = opts
		            ? (opts.Ctor.options.name || opts.tag)
		            : c.tag;
		          warn(("<transition-group> children must be keyed: <" + name + ">"));
		        }
		      }
		    }

		    if (prevChildren) {
		      var kept = [];
		      var removed = [];
		      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
		        var c$1 = prevChildren[i$1];
		        c$1.data.transition = transitionData;
		        c$1.data.pos = c$1.elm.getBoundingClientRect();
		        if (map[c$1.key]) {
		          kept.push(c$1);
		        } else {
		          removed.push(c$1);
		        }
		      }
		      this.kept = h(tag, null, kept);
		      this.removed = removed;
		    }

		    return h(tag, null, children)
		  },

		  beforeUpdate: function beforeUpdate () {
		    // force removing pass
		    this.__patch__(
		      this._vnode,
		      this.kept,
		      false, // hydrating
		      true // removeOnly (!important, avoids unnecessary moves)
		    );
		    this._vnode = this.kept;
		  },

		  updated: function updated () {
		    var children = this.prevChildren;
		    var moveClass = this.moveClass || (this.name + '-move');
		    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
		      return
		    }

		    // we divide the work into three loops to avoid mixing DOM reads and writes
		    // in each iteration - which helps prevent layout thrashing.
		    children.forEach(callPendingCbs);
		    children.forEach(recordPosition);
		    children.forEach(applyTranslation);

		    // force reflow to put everything in position
		    var f = document.body.offsetHeight; // eslint-disable-line

		    children.forEach(function (c) {
		      if (c.data.moved) {
		        var el = c.elm;
		        var s = el.style;
		        addTransitionClass(el, moveClass);
		        s.transform = s.WebkitTransform = s.transitionDuration = '';
		        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {
		          if (!e || /transform$/.test(e.propertyName)) {
		            el.removeEventListener(transitionEndEvent, cb);
		            el._moveCb = null;
		            removeTransitionClass(el, moveClass);
		          }
		        });
		      }
		    });
		  },

		  methods: {
		    hasMove: function hasMove (el, moveClass) {
		      /* istanbul ignore if */
		      if (!hasTransition) {
		        return false
		      }
		      if (this._hasMove != null) {
		        return this._hasMove
		      }
		      addTransitionClass(el, moveClass);
		      var info = getTransitionInfo(el);
		      removeTransitionClass(el, moveClass);
		      return (this._hasMove = info.hasTransform)
		    }
		  }
		};

		function callPendingCbs (c) {
		  /* istanbul ignore if */
		  if (c.elm._moveCb) {
		    c.elm._moveCb();
		  }
		  /* istanbul ignore if */
		  if (c.elm._enterCb) {
		    c.elm._enterCb();
		  }
		}

		function recordPosition (c) {
		  c.data.newPos = c.elm.getBoundingClientRect();
		}

		function applyTranslation (c) {
		  var oldPos = c.data.pos;
		  var newPos = c.data.newPos;
		  var dx = oldPos.left - newPos.left;
		  var dy = oldPos.top - newPos.top;
		  if (dx || dy) {
		    c.data.moved = true;
		    var s = c.elm.style;
		    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
		    s.transitionDuration = '0s';
		  }
		}

		var platformComponents = {
		  Transition: Transition,
		  TransitionGroup: TransitionGroup
		};

		/*  */

		// install platform specific utils
		Vue$2.config.isUnknownElement = isUnknownElement;
		Vue$2.config.isReservedTag = isReservedTag;
		Vue$2.config.getTagNamespace = getTagNamespace;
		Vue$2.config.mustUseProp = mustUseProp;

		// install platform runtime directives & components
		extend(Vue$2.options.directives, platformDirectives);
		extend(Vue$2.options.components, platformComponents);

		// install platform patch function
		Vue$2.prototype.__patch__ = config._isServer ? noop : patch$1;

		// wrap mount
		Vue$2.prototype.$mount = function (
		  el,
		  hydrating
		) {
		  el = el && !config._isServer ? query(el) : undefined;
		  return this._mount(el, hydrating)
		};

		// devtools global hook
		/* istanbul ignore next */
		setTimeout(function () {
		  if (config.devtools) {
		    if (devtools) {
		      devtools.emit('init', Vue$2);
		    } else if (
		      "development" !== 'production' &&
		      inBrowser && /Chrome\/\d+/.test(window.navigator.userAgent)
		    ) {
		      console.log(
		        'Download the Vue Devtools for a better development experience:\n' +
		        'https://github.com/vuejs/vue-devtools'
		      );
		    }
		  }
		}, 0);

		/*  */

		// check whether current browser encodes a char inside attribute values
		function shouldDecode (content, encoded) {
		  var div = document.createElement('div');
		  div.innerHTML = "<div a=\"" + content + "\">";
		  return div.innerHTML.indexOf(encoded) > 0
		}

		// #3663
		// IE encodes newlines inside attribute values while other browsers don't
		var shouldDecodeNewlines = inBrowser ? shouldDecode('\n', '&#10;') : false;

		/*  */

		var decoder = document.createElement('div');

		function decode (html) {
		  decoder.innerHTML = html;
		  return decoder.textContent
		}

		/**
		 * Not type-checking this file because it's mostly vendor code.
		 */

		/*!
		 * HTML Parser By John Resig (ejohn.org)
		 * Modified by Juriy "kangax" Zaytsev
		 * Original code by Erik Arvidsson, Mozilla Public License
		 * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
		 */

		// Regular Expressions for parsing tags and attributes
		var singleAttrIdentifier = /([^\s"'<>/=]+)/;
		var singleAttrAssign = /(?:=)/;
		var singleAttrValues = [
		  // attr value double quotes
		  /"([^"]*)"+/.source,
		  // attr value, single quotes
		  /'([^']*)'+/.source,
		  // attr value, no quotes
		  /([^\s"'=<>`]+)/.source
		];
		var attribute = new RegExp(
		  '^\\s*' + singleAttrIdentifier.source +
		  '(?:\\s*(' + singleAttrAssign.source + ')' +
		  '\\s*(?:' + singleAttrValues.join('|') + '))?'
		);

		// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName
		// but for Vue templates we can enforce a simple charset
		var ncname = '[a-zA-Z_][\\w\\-\\.]*';
		var qnameCapture = '((?:' + ncname + '\\:)?' + ncname + ')';
		var startTagOpen = new RegExp('^<' + qnameCapture);
		var startTagClose = /^\s*(\/?)>/;
		var endTag = new RegExp('^<\\/' + qnameCapture + '[^>]*>');
		var doctype = /^<!DOCTYPE [^>]+>/i;
		var comment = /^<!--/;
		var conditionalComment = /^<!\[/;

		var IS_REGEX_CAPTURING_BROKEN = false;
		'x'.replace(/x(.)?/g, function (m, g) {
		  IS_REGEX_CAPTURING_BROKEN = g === '';
		});

		// Special Elements (can contain anything)
		var isScriptOrStyle = makeMap('script,style', true);
		var hasLang = function (attr) { return attr.name === 'lang' && attr.value !== 'html'; };
		var isSpecialTag = function (tag, isSFC, stack) {
		  if (isScriptOrStyle(tag)) {
		    return true
		  }
		  // top-level template that has a pre-processor
		  if (
		    isSFC &&
		    tag === 'template' &&
		    stack.length === 1 &&
		    stack[0].attrs.some(hasLang)
		  ) {
		    return true
		  }
		  return false
		};

		var reCache = {};

		var ltRE = /&lt;/g;
		var gtRE = /&gt;/g;
		var nlRE = /&#10;/g;
		var ampRE = /&amp;/g;
		var quoteRE = /&quot;/g;

		function decodeAttr (value, shouldDecodeNewlines) {
		  if (shouldDecodeNewlines) {
		    value = value.replace(nlRE, '\n');
		  }
		  return value
		    .replace(ltRE, '<')
		    .replace(gtRE, '>')
		    .replace(ampRE, '&')
		    .replace(quoteRE, '"')
		}

		function parseHTML (html, options) {
		  var stack = [];
		  var expectHTML = options.expectHTML;
		  var isUnaryTag$$1 = options.isUnaryTag || no;
		  var index = 0;
		  var last, lastTag;
		  while (html) {
		    last = html;
		    // Make sure we're not in a script or style element
		    if (!lastTag || !isSpecialTag(lastTag, options.sfc, stack)) {
		      var textEnd = html.indexOf('<');
		      if (textEnd === 0) {
		        // Comment:
		        if (comment.test(html)) {
		          var commentEnd = html.indexOf('-->');

		          if (commentEnd >= 0) {
		            advance(commentEnd + 3);
		            continue
		          }
		        }

		        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
		        if (conditionalComment.test(html)) {
		          var conditionalEnd = html.indexOf(']>');

		          if (conditionalEnd >= 0) {
		            advance(conditionalEnd + 2);
		            continue
		          }
		        }

		        // Doctype:
		        var doctypeMatch = html.match(doctype);
		        if (doctypeMatch) {
		          advance(doctypeMatch[0].length);
		          continue
		        }

		        // End tag:
		        var endTagMatch = html.match(endTag);
		        if (endTagMatch) {
		          var curIndex = index;
		          advance(endTagMatch[0].length);
		          parseEndTag(endTagMatch[0], endTagMatch[1], curIndex, index);
		          continue
		        }

		        // Start tag:
		        var startTagMatch = parseStartTag();
		        if (startTagMatch) {
		          handleStartTag(startTagMatch);
		          continue
		        }
		      }

		      var text = void 0, rest$1 = void 0, next = void 0;
		      if (textEnd > 0) {
		        rest$1 = html.slice(textEnd);
		        while (
		          !endTag.test(rest$1) &&
		          !startTagOpen.test(rest$1) &&
		          !comment.test(rest$1) &&
		          !conditionalComment.test(rest$1)
		        ) {
		          // < in plain text, be forgiving and treat it as text
		          next = rest$1.indexOf('<', 1);
		          if (next < 0) { break }
		          textEnd += next;
		          rest$1 = html.slice(textEnd);
		        }
		        text = html.substring(0, textEnd);
		        advance(textEnd);
		      }

		      if (textEnd < 0) {
		        text = html;
		        html = '';
		      }

		      if (options.chars && text) {
		        options.chars(text);
		      }
		    } else {
		      var stackedTag = lastTag.toLowerCase();
		      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));
		      var endTagLength = 0;
		      var rest = html.replace(reStackedTag, function (all, text, endTag) {
		        endTagLength = endTag.length;
		        if (stackedTag !== 'script' && stackedTag !== 'style' && stackedTag !== 'noscript') {
		          text = text
		            .replace(/<!--([\s\S]*?)-->/g, '$1')
		            .replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
		        }
		        if (options.chars) {
		          options.chars(text);
		        }
		        return ''
		      });
		      index += html.length - rest.length;
		      html = rest;
		      parseEndTag('</' + stackedTag + '>', stackedTag, index - endTagLength, index);
		    }

		    if (html === last && options.chars) {
		      options.chars(html);
		      break
		    }
		  }

		  // Clean up any remaining tags
		  parseEndTag();

		  function advance (n) {
		    index += n;
		    html = html.substring(n);
		  }

		  function parseStartTag () {
		    var start = html.match(startTagOpen);
		    if (start) {
		      var match = {
		        tagName: start[1],
		        attrs: [],
		        start: index
		      };
		      advance(start[0].length);
		      var end, attr;
		      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {
		        advance(attr[0].length);
		        match.attrs.push(attr);
		      }
		      if (end) {
		        match.unarySlash = end[1];
		        advance(end[0].length);
		        match.end = index;
		        return match
		      }
		    }
		  }

		  function handleStartTag (match) {
		    var tagName = match.tagName;
		    var unarySlash = match.unarySlash;

		    if (expectHTML) {
		      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
		        parseEndTag('', lastTag);
		      }
		      if (canBeLeftOpenTag(tagName) && lastTag === tagName) {
		        parseEndTag('', tagName);
		      }
		    }

		    var unary = isUnaryTag$$1(tagName) || tagName === 'html' && lastTag === 'head' || !!unarySlash;

		    var l = match.attrs.length;
		    var attrs = new Array(l);
		    for (var i = 0; i < l; i++) {
		      var args = match.attrs[i];
		      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778
		      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('""') === -1) {
		        if (args[3] === '') { delete args[3]; }
		        if (args[4] === '') { delete args[4]; }
		        if (args[5] === '') { delete args[5]; }
		      }
		      var value = args[3] || args[4] || args[5] || '';
		      attrs[i] = {
		        name: args[1],
		        value: decodeAttr(
		          value,
		          options.shouldDecodeNewlines
		        )
		      };
		    }

		    if (!unary) {
		      stack.push({ tag: tagName, attrs: attrs });
		      lastTag = tagName;
		      unarySlash = '';
		    }

		    if (options.start) {
		      options.start(tagName, attrs, unary, match.start, match.end);
		    }
		  }

		  function parseEndTag (tag, tagName, start, end) {
		    var pos;
		    if (start == null) { start = index; }
		    if (end == null) { end = index; }

		    // Find the closest opened tag of the same type
		    if (tagName) {
		      var needle = tagName.toLowerCase();
		      for (pos = stack.length - 1; pos >= 0; pos--) {
		        if (stack[pos].tag.toLowerCase() === needle) {
		          break
		        }
		      }
		    } else {
		      // If no tag name is provided, clean shop
		      pos = 0;
		    }

		    if (pos >= 0) {
		      // Close all the open elements, up the stack
		      for (var i = stack.length - 1; i >= pos; i--) {
		        if (options.end) {
		          options.end(stack[i].tag, start, end);
		        }
		      }

		      // Remove the open elements from the stack
		      stack.length = pos;
		      lastTag = pos && stack[pos - 1].tag;
		    } else if (tagName.toLowerCase() === 'br') {
		      if (options.start) {
		        options.start(tagName, [], true, start, end);
		      }
		    } else if (tagName.toLowerCase() === 'p') {
		      if (options.start) {
		        options.start(tagName, [], false, start, end);
		      }
		      if (options.end) {
		        options.end(tagName, start, end);
		      }
		    }
		  }
		}

		/*  */

		function parseFilters (exp) {
		  var inSingle = false;
		  var inDouble = false;
		  var curly = 0;
		  var square = 0;
		  var paren = 0;
		  var lastFilterIndex = 0;
		  var c, prev, i, expression, filters;

		  for (i = 0; i < exp.length; i++) {
		    prev = c;
		    c = exp.charCodeAt(i);
		    if (inSingle) {
		      // check single quote
		      if (c === 0x27 && prev !== 0x5C) { inSingle = !inSingle; }
		    } else if (inDouble) {
		      // check double quote
		      if (c === 0x22 && prev !== 0x5C) { inDouble = !inDouble; }
		    } else if (
		      c === 0x7C && // pipe
		      exp.charCodeAt(i + 1) !== 0x7C &&
		      exp.charCodeAt(i - 1) !== 0x7C &&
		      !curly && !square && !paren
		    ) {
		      if (expression === undefined) {
		        // first filter, end of expression
		        lastFilterIndex = i + 1;
		        expression = exp.slice(0, i).trim();
		      } else {
		        pushFilter();
		      }
		    } else {
		      switch (c) {
		        case 0x22: inDouble = true; break // "
		        case 0x27: inSingle = true; break // '
		        case 0x28: paren++; break         // (
		        case 0x29: paren--; break         // )
		        case 0x5B: square++; break        // [
		        case 0x5D: square--; break        // ]
		        case 0x7B: curly++; break         // {
		        case 0x7D: curly--; break         // }
		      }
		    }
		  }

		  if (expression === undefined) {
		    expression = exp.slice(0, i).trim();
		  } else if (lastFilterIndex !== 0) {
		    pushFilter();
		  }

		  function pushFilter () {
		    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
		    lastFilterIndex = i + 1;
		  }

		  if (filters) {
		    for (i = 0; i < filters.length; i++) {
		      expression = wrapFilter(expression, filters[i]);
		    }
		  }

		  return expression
		}

		function wrapFilter (exp, filter) {
		  var i = filter.indexOf('(');
		  if (i < 0) {
		    // _f: resolveFilter
		    return ("_f(\"" + filter + "\")(" + exp + ")")
		  } else {
		    var name = filter.slice(0, i);
		    var args = filter.slice(i + 1);
		    return ("_f(\"" + name + "\")(" + exp + "," + args)
		  }
		}

		/*  */

		var defaultTagRE = /\{\{((?:.|\n)+?)\}\}/g;
		var regexEscapeRE = /[-.*+?^${}()|[\]/\\]/g;

		var buildRegex = cached(function (delimiters) {
		  var open = delimiters[0].replace(regexEscapeRE, '\\$&');
		  var close = delimiters[1].replace(regexEscapeRE, '\\$&');
		  return new RegExp(open + '((?:.|\\n)+?)' + close, 'g')
		});

		function parseText (
		  text,
		  delimiters
		) {
		  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;
		  if (!tagRE.test(text)) {
		    return
		  }
		  var tokens = [];
		  var lastIndex = tagRE.lastIndex = 0;
		  var match, index;
		  while ((match = tagRE.exec(text))) {
		    index = match.index;
		    // push text token
		    if (index > lastIndex) {
		      tokens.push(JSON.stringify(text.slice(lastIndex, index)));
		    }
		    // tag token
		    var exp = parseFilters(match[1].trim());
		    tokens.push(("_s(" + exp + ")"));
		    lastIndex = index + match[0].length;
		  }
		  if (lastIndex < text.length) {
		    tokens.push(JSON.stringify(text.slice(lastIndex)));
		  }
		  return tokens.join('+')
		}

		/*  */

		function baseWarn (msg) {
		  console.error(("[Vue parser]: " + msg));
		}

		function pluckModuleFunction (
		  modules,
		  key
		) {
		  return modules
		    ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })
		    : []
		}

		function addProp (el, name, value) {
		  (el.props || (el.props = [])).push({ name: name, value: value });
		}

		function addAttr (el, name, value) {
		  (el.attrs || (el.attrs = [])).push({ name: name, value: value });
		}

		function addDirective (
		  el,
		  name,
		  rawName,
		  value,
		  arg,
		  modifiers
		) {
		  (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });
		}

		function addHandler (
		  el,
		  name,
		  value,
		  modifiers,
		  important
		) {
		  // check capture modifier
		  if (modifiers && modifiers.capture) {
		    delete modifiers.capture;
		    name = '!' + name; // mark the event as captured
		  }
		  var events;
		  if (modifiers && modifiers.native) {
		    delete modifiers.native;
		    events = el.nativeEvents || (el.nativeEvents = {});
		  } else {
		    events = el.events || (el.events = {});
		  }
		  var newHandler = { value: value, modifiers: modifiers };
		  var handlers = events[name];
		  /* istanbul ignore if */
		  if (Array.isArray(handlers)) {
		    important ? handlers.unshift(newHandler) : handlers.push(newHandler);
		  } else if (handlers) {
		    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
		  } else {
		    events[name] = newHandler;
		  }
		}

		function getBindingAttr (
		  el,
		  name,
		  getStatic
		) {
		  var dynamicValue =
		    getAndRemoveAttr(el, ':' + name) ||
		    getAndRemoveAttr(el, 'v-bind:' + name);
		  if (dynamicValue != null) {
		    return dynamicValue
		  } else if (getStatic !== false) {
		    var staticValue = getAndRemoveAttr(el, name);
		    if (staticValue != null) {
		      return JSON.stringify(staticValue)
		    }
		  }
		}

		function getAndRemoveAttr (el, name) {
		  var val;
		  if ((val = el.attrsMap[name]) != null) {
		    var list = el.attrsList;
		    for (var i = 0, l = list.length; i < l; i++) {
		      if (list[i].name === name) {
		        list.splice(i, 1);
		        break
		      }
		    }
		  }
		  return val
		}

		/*  */

		var dirRE = /^v-|^@|^:/;
		var forAliasRE = /(.*?)\s+(?:in|of)\s+(.*)/;
		var forIteratorRE = /\(([^,]*),([^,]*)(?:,([^,]*))?\)/;
		var bindRE = /^:|^v-bind:/;
		var onRE = /^@|^v-on:/;
		var argRE = /:(.*)$/;
		var modifierRE = /\.[^.]+/g;
		var specialNewlineRE = /\u2028|\u2029/g;

		var decodeHTMLCached = cached(decode);

		// configurable state
		var warn$1;
		var platformGetTagNamespace;
		var platformMustUseProp;
		var platformIsPreTag;
		var preTransforms;
		var transforms;
		var postTransforms;
		var delimiters;

		/**
		 * Convert HTML string to AST.
		 */
		function parse (
		  template,
		  options
		) {
		  warn$1 = options.warn || baseWarn;
		  platformGetTagNamespace = options.getTagNamespace || no;
		  platformMustUseProp = options.mustUseProp || no;
		  platformIsPreTag = options.isPreTag || no;
		  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');
		  transforms = pluckModuleFunction(options.modules, 'transformNode');
		  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');
		  delimiters = options.delimiters;
		  var stack = [];
		  var preserveWhitespace = options.preserveWhitespace !== false;
		  var root;
		  var currentParent;
		  var inVPre = false;
		  var inPre = false;
		  var warned = false;
		  parseHTML(template, {
		    expectHTML: options.expectHTML,
		    isUnaryTag: options.isUnaryTag,
		    shouldDecodeNewlines: options.shouldDecodeNewlines,
		    start: function start (tag, attrs, unary) {
		      // check namespace.
		      // inherit parent ns if there is one
		      var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);

		      // handle IE svg bug
		      /* istanbul ignore if */
		      if (options.isIE && ns === 'svg') {
		        attrs = guardIESVGBug(attrs);
		      }

		      var element = {
		        type: 1,
		        tag: tag,
		        attrsList: attrs,
		        attrsMap: makeAttrsMap(attrs, options.isIE),
		        parent: currentParent,
		        children: []
		      };
		      if (ns) {
		        element.ns = ns;
		      }

		      if ("client" !== 'server' && isForbiddenTag(element)) {
		        element.forbidden = true;
		        "development" !== 'production' && warn$1(
		          'Templates should only be responsible for mapping the state to the ' +
		          'UI. Avoid placing tags with side-effects in your templates, such as ' +
		          "<" + tag + ">."
		        );
		      }

		      // apply pre-transforms
		      for (var i = 0; i < preTransforms.length; i++) {
		        preTransforms[i](element, options);
		      }

		      if (!inVPre) {
		        processPre(element);
		        if (element.pre) {
		          inVPre = true;
		        }
		      }
		      if (platformIsPreTag(element.tag)) {
		        inPre = true;
		      }
		      if (inVPre) {
		        processRawAttrs(element);
		      } else {
		        processFor(element);
		        processIf(element);
		        processOnce(element);
		        processKey(element);

		        // determine whether this is a plain element after
		        // removing structural attributes
		        element.plain = !element.key && !attrs.length;

		        processRef(element);
		        processSlot(element);
		        processComponent(element);
		        for (var i$1 = 0; i$1 < transforms.length; i$1++) {
		          transforms[i$1](element, options);
		        }
		        processAttrs(element);
		      }

		      function checkRootConstraints (el) {
		        if ("development" !== 'production' && !warned) {
		          if (el.tag === 'slot' || el.tag === 'template') {
		            warned = true;
		            warn$1(
		              "Cannot use <" + (el.tag) + "> as component root element because it may " +
		              'contain multiple nodes:\n' + template
		            );
		          }
		          if (el.attrsMap.hasOwnProperty('v-for')) {
		            warned = true;
		            warn$1(
		              'Cannot use v-for on stateful component root element because ' +
		              'it renders multiple elements:\n' + template
		            );
		          }
		        }
		      }

		      // tree management
		      if (!root) {
		        root = element;
		        checkRootConstraints(root);
		      } else if (!stack.length) {
		        // allow 2 root elements with v-if and v-else
		        if (root.if && element.else) {
		          checkRootConstraints(element);
		          root.elseBlock = element;
		        } else if ("development" !== 'production' && !warned) {
		          warned = true;
		          warn$1(
		            ("Component template should contain exactly one root element:\n\n" + template)
		          );
		        }
		      }
		      if (currentParent && !element.forbidden) {
		        if (element.else) {
		          processElse(element, currentParent);
		        } else {
		          currentParent.children.push(element);
		          element.parent = currentParent;
		        }
		      }
		      if (!unary) {
		        currentParent = element;
		        stack.push(element);
		      }
		      // apply post-transforms
		      for (var i$2 = 0; i$2 < postTransforms.length; i$2++) {
		        postTransforms[i$2](element, options);
		      }
		    },

		    end: function end () {
		      // remove trailing whitespace
		      var element = stack[stack.length - 1];
		      var lastNode = element.children[element.children.length - 1];
		      if (lastNode && lastNode.type === 3 && lastNode.text === ' ') {
		        element.children.pop();
		      }
		      // pop stack
		      stack.length -= 1;
		      currentParent = stack[stack.length - 1];
		      // check pre state
		      if (element.pre) {
		        inVPre = false;
		      }
		      if (platformIsPreTag(element.tag)) {
		        inPre = false;
		      }
		    },

		    chars: function chars (text) {
		      if (!currentParent) {
		        if ("development" !== 'production' && !warned && text === template) {
		          warned = true;
		          warn$1(
		            'Component template requires a root element, rather than just text:\n\n' + template
		          );
		        }
		        return
		      }
		      text = inPre || text.trim()
		        ? decodeHTMLCached(text)
		        // only preserve whitespace if its not right after a starting tag
		        : preserveWhitespace && currentParent.children.length ? ' ' : '';
		      if (text) {
		        var expression;
		        if (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {
		          currentParent.children.push({
		            type: 2,
		            expression: expression,
		            text: text
		          });
		        } else {
		          // #3895 special character
		          text = text.replace(specialNewlineRE, '');
		          currentParent.children.push({
		            type: 3,
		            text: text
		          });
		        }
		      }
		    }
		  });
		  return root
		}

		function processPre (el) {
		  if (getAndRemoveAttr(el, 'v-pre') != null) {
		    el.pre = true;
		  }
		}

		function processRawAttrs (el) {
		  var l = el.attrsList.length;
		  if (l) {
		    var attrs = el.attrs = new Array(l);
		    for (var i = 0; i < l; i++) {
		      attrs[i] = {
		        name: el.attrsList[i].name,
		        value: JSON.stringify(el.attrsList[i].value)
		      };
		    }
		  } else if (!el.pre) {
		    // non root node in pre blocks with no attributes
		    el.plain = true;
		  }
		}

		function processKey (el) {
		  var exp = getBindingAttr(el, 'key');
		  if (exp) {
		    if ("development" !== 'production' && el.tag === 'template') {
		      warn$1("<template> cannot be keyed. Place the key on real elements instead.");
		    }
		    el.key = exp;
		  }
		}

		function processRef (el) {
		  var ref = getBindingAttr(el, 'ref');
		  if (ref) {
		    el.ref = ref;
		    el.refInFor = checkInFor(el);
		  }
		}

		function processFor (el) {
		  var exp;
		  if ((exp = getAndRemoveAttr(el, 'v-for'))) {
		    var inMatch = exp.match(forAliasRE);
		    if (!inMatch) {
		      "development" !== 'production' && warn$1(
		        ("Invalid v-for expression: " + exp)
		      );
		      return
		    }
		    el.for = inMatch[2].trim();
		    var alias = inMatch[1].trim();
		    var iteratorMatch = alias.match(forIteratorRE);
		    if (iteratorMatch) {
		      el.alias = iteratorMatch[1].trim();
		      el.iterator1 = iteratorMatch[2].trim();
		      if (iteratorMatch[3]) {
		        el.iterator2 = iteratorMatch[3].trim();
		      }
		    } else {
		      el.alias = alias;
		    }
		  }
		}

		function processIf (el) {
		  var exp = getAndRemoveAttr(el, 'v-if');
		  if (exp) {
		    el.if = exp;
		  }
		  if (getAndRemoveAttr(el, 'v-else') != null) {
		    el.else = true;
		  }
		}

		function processElse (el, parent) {
		  var prev = findPrevElement(parent.children);
		  if (prev && prev.if) {
		    prev.elseBlock = el;
		  } else {
		    warn$1(
		      ("v-else used on element <" + (el.tag) + "> without corresponding v-if.")
		    );
		  }
		}

		function processOnce (el) {
		  var once = getAndRemoveAttr(el, 'v-once');
		  if (once != null) {
		    el.once = true;
		  }
		}

		function processSlot (el) {
		  if (el.tag === 'slot') {
		    el.slotName = getBindingAttr(el, 'name');
		  } else {
		    var slotTarget = getBindingAttr(el, 'slot');
		    if (slotTarget) {
		      el.slotTarget = slotTarget;
		    }
		  }
		}

		function processComponent (el) {
		  var binding;
		  if ((binding = getBindingAttr(el, 'is'))) {
		    el.component = binding;
		  }
		  if (getAndRemoveAttr(el, 'inline-template') != null) {
		    el.inlineTemplate = true;
		  }
		}

		function processAttrs (el) {
		  var list = el.attrsList;
		  var i, l, name, rawName, value, arg, modifiers, isProp;
		  for (i = 0, l = list.length; i < l; i++) {
		    name = rawName = list[i].name;
		    value = list[i].value;
		    if (dirRE.test(name)) {
		      // mark element as dynamic
		      el.hasBindings = true;
		      // modifiers
		      modifiers = parseModifiers(name);
		      if (modifiers) {
		        name = name.replace(modifierRE, '');
		      }
		      if (bindRE.test(name)) { // v-bind
		        name = name.replace(bindRE, '');
		        if (modifiers && modifiers.prop) {
		          isProp = true;
		          name = camelize(name);
		          if (name === 'innerHtml') { name = 'innerHTML'; }
		        }
		        if (isProp || platformMustUseProp(name)) {
		          addProp(el, name, value);
		        } else {
		          addAttr(el, name, value);
		        }
		      } else if (onRE.test(name)) { // v-on
		        name = name.replace(onRE, '');
		        addHandler(el, name, value, modifiers);
		      } else { // normal directives
		        name = name.replace(dirRE, '');
		        // parse arg
		        var argMatch = name.match(argRE);
		        if (argMatch && (arg = argMatch[1])) {
		          name = name.slice(0, -(arg.length + 1));
		        }
		        addDirective(el, name, rawName, value, arg, modifiers);
		        if ("development" !== 'production' && name === 'model') {
		          checkForAliasModel(el, value);
		        }
		      }
		    } else {
		      // literal attribute
		      {
		        var expression = parseText(value, delimiters);
		        if (expression) {
		          warn$1(
		            name + "=\"" + value + "\": " +
		            'Interpolation inside attributes has been removed. ' +
		            'Use v-bind or the colon shorthand instead. For example, ' +
		            'instead of <div id="{{ val }}">, use <div :id="val">.'
		          );
		        }
		      }
		      addAttr(el, name, JSON.stringify(value));
		    }
		  }
		}

		function checkInFor (el) {
		  var parent = el;
		  while (parent) {
		    if (parent.for !== undefined) {
		      return true
		    }
		    parent = parent.parent;
		  }
		  return false
		}

		function parseModifiers (name) {
		  var match = name.match(modifierRE);
		  if (match) {
		    var ret = {};
		    match.forEach(function (m) { ret[m.slice(1)] = true; });
		    return ret
		  }
		}

		function makeAttrsMap (attrs, isIE) {
		  var map = {};
		  for (var i = 0, l = attrs.length; i < l; i++) {
		    if ("development" !== 'production' && map[attrs[i].name] && !isIE) {
		      warn$1('duplicate attribute: ' + attrs[i].name);
		    }
		    map[attrs[i].name] = attrs[i].value;
		  }
		  return map
		}

		function findPrevElement (children) {
		  var i = children.length;
		  while (i--) {
		    if (children[i].tag) { return children[i] }
		  }
		}

		function isForbiddenTag (el) {
		  return (
		    el.tag === 'style' ||
		    (el.tag === 'script' && (
		      !el.attrsMap.type ||
		      el.attrsMap.type === 'text/javascript'
		    ))
		  )
		}

		var ieNSBug = /^xmlns:NS\d+/;
		var ieNSPrefix = /^NS\d+:/;

		/* istanbul ignore next */
		function guardIESVGBug (attrs) {
		  var res = [];
		  for (var i = 0; i < attrs.length; i++) {
		    var attr = attrs[i];
		    if (!ieNSBug.test(attr.name)) {
		      attr.name = attr.name.replace(ieNSPrefix, '');
		      res.push(attr);
		    }
		  }
		  return res
		}

		function checkForAliasModel (el, value) {
		  var _el = el;
		  while (_el) {
		    if (_el.for && _el.alias === value) {
		      warn$1(
		        "<" + (el.tag) + " v-model=\"" + value + "\">: " +
		        "You are binding v-model directly to a v-for iteration alias. " +
		        "This will not be able to modify the v-for source array because " +
		        "writing to the alias is like modifying a function local variable. " +
		        "Consider using an array of objects and use v-model on an object property instead."
		      );
		    }
		    _el = _el.parent;
		  }
		}

		/*  */

		var isStaticKey;
		var isPlatformReservedTag;

		var genStaticKeysCached = cached(genStaticKeys$1);

		/**
		 * Goal of the optimizer: walk the generated template AST tree
		 * and detect sub-trees that are purely static, i.e. parts of
		 * the DOM that never needs to change.
		 *
		 * Once we detect these sub-trees, we can:
		 *
		 * 1. Hoist them into constants, so that we no longer need to
		 *    create fresh nodes for them on each re-render;
		 * 2. Completely skip them in the patching process.
		 */
		function optimize (root, options) {
		  if (!root) { return }
		  isStaticKey = genStaticKeysCached(options.staticKeys || '');
		  isPlatformReservedTag = options.isReservedTag || (function () { return false; });
		  // first pass: mark all non-static nodes.
		  markStatic(root);
		  // second pass: mark static roots.
		  markStaticRoots(root, false);
		}

		function genStaticKeys$1 (keys) {
		  return makeMap(
		    'type,tag,attrsList,attrsMap,plain,parent,children,attrs' +
		    (keys ? ',' + keys : '')
		  )
		}

		function markStatic (node) {
		  node.static = isStatic(node);
		  if (node.type === 1) {
		    for (var i = 0, l = node.children.length; i < l; i++) {
		      var child = node.children[i];
		      markStatic(child);
		      if (!child.static) {
		        node.static = false;
		      }
		    }
		  }
		}

		function markStaticRoots (node, isInFor) {
		  if (node.type === 1) {
		    if (node.static || node.once) {
		      node.staticInFor = isInFor;
		    }
		    if (node.static) {
		      node.staticRoot = true;
		      return
		    }
		    if (node.children) {
		      for (var i = 0, l = node.children.length; i < l; i++) {
		        markStaticRoots(node.children[i], isInFor || !!node.for);
		      }
		    }
		  }
		}

		function isStatic (node) {
		  if (node.type === 2) { // expression
		    return false
		  }
		  if (node.type === 3) { // text
		    return true
		  }
		  return !!(node.pre || (
		    !node.hasBindings && // no dynamic bindings
		    !node.if && !node.for && // not v-if or v-for or v-else
		    !isBuiltInTag(node.tag) && // not a built-in
		    isPlatformReservedTag(node.tag) && // not a component
		    !isDirectChildOfTemplateFor(node) &&
		    Object.keys(node).every(isStaticKey)
		  ))
		}

		function isDirectChildOfTemplateFor (node) {
		  while (node.parent) {
		    node = node.parent;
		    if (node.tag !== 'template') {
		      return false
		    }
		    if (node.for) {
		      return true
		    }
		  }
		  return false
		}

		/*  */

		var simplePathRE = /^\s*[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['.*?']|\[".*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*\s*$/;

		// keyCode aliases
		var keyCodes = {
		  esc: 27,
		  tab: 9,
		  enter: 13,
		  space: 32,
		  up: 38,
		  left: 37,
		  right: 39,
		  down: 40,
		  'delete': [8, 46]
		};

		var modifierCode = {
		  stop: '$event.stopPropagation();',
		  prevent: '$event.preventDefault();',
		  self: 'if($event.target !== $event.currentTarget)return;'
		};

		function genHandlers (events, native) {
		  var res = native ? 'nativeOn:{' : 'on:{';
		  for (var name in events) {
		    res += "\"" + name + "\":" + (genHandler(events[name])) + ",";
		  }
		  return res.slice(0, -1) + '}'
		}

		function genHandler (
		  handler
		) {
		  if (!handler) {
		    return 'function(){}'
		  } else if (Array.isArray(handler)) {
		    return ("[" + (handler.map(genHandler).join(',')) + "]")
		  } else if (!handler.modifiers) {
		    return simplePathRE.test(handler.value)
		      ? handler.value
		      : ("function($event){" + (handler.value) + "}")
		  } else {
		    var code = '';
		    var keys = [];
		    for (var key in handler.modifiers) {
		      if (modifierCode[key]) {
		        code += modifierCode[key];
		      } else {
		        keys.push(key);
		      }
		    }
		    if (keys.length) {
		      code = genKeyFilter(keys) + code;
		    }
		    var handlerCode = simplePathRE.test(handler.value)
		      ? handler.value + '($event)'
		      : handler.value;
		    return 'function($event){' + code + handlerCode + '}'
		  }
		}

		function genKeyFilter (keys) {
		  var code = keys.length === 1
		    ? normalizeKeyCode(keys[0])
		    : Array.prototype.concat.apply([], keys.map(normalizeKeyCode));
		  if (Array.isArray(code)) {
		    return ("if(" + (code.map(function (c) { return ("$event.keyCode!==" + c); }).join('&&')) + ")return;")
		  } else {
		    return ("if($event.keyCode!==" + code + ")return;")
		  }
		}

		function normalizeKeyCode (key) {
		  return (
		    parseInt(key, 10) || // number keyCode
		    keyCodes[key] || // built-in alias
		    ("_k(" + (JSON.stringify(key)) + ")") // custom alias
		  )
		}

		/*  */

		function bind$2 (el, dir) {
		  el.wrapData = function (code) {
		    return ("_b(" + code + "," + (dir.value) + (dir.modifiers && dir.modifiers.prop ? ',true' : '') + ")")
		  };
		}

		var baseDirectives = {
		  bind: bind$2,
		  cloak: noop
		};

		/*  */

		// configurable state
		var warn$2;
		var transforms$1;
		var dataGenFns;
		var platformDirectives$1;
		var staticRenderFns;
		var onceCount;
		var currentOptions;

		function generate (
		  ast,
		  options
		) {
		  // save previous staticRenderFns so generate calls can be nested
		  var prevStaticRenderFns = staticRenderFns;
		  var currentStaticRenderFns = staticRenderFns = [];
		  var prevOnceCount = onceCount;
		  onceCount = 0;
		  currentOptions = options;
		  warn$2 = options.warn || baseWarn;
		  transforms$1 = pluckModuleFunction(options.modules, 'transformCode');
		  dataGenFns = pluckModuleFunction(options.modules, 'genData');
		  platformDirectives$1 = options.directives || {};
		  var code = ast ? genElement(ast) : '_h("div")';
		  staticRenderFns = prevStaticRenderFns;
		  onceCount = prevOnceCount;
		  return {
		    render: ("with(this){return " + code + "}"),
		    staticRenderFns: currentStaticRenderFns
		  }
		}

		function genElement (el) {
		  if (el.staticRoot && !el.staticProcessed) {
		    return genStatic(el)
		  } else if (el.once && !el.onceProcessed) {
		    return genOnce(el)
		  } else if (el.for && !el.forProcessed) {
		    return genFor(el)
		  } else if (el.if && !el.ifProcessed) {
		    return genIf(el)
		  } else if (el.tag === 'template' && !el.slotTarget) {
		    return genChildren(el) || 'void 0'
		  } else if (el.tag === 'slot') {
		    return genSlot(el)
		  } else {
		    // component or element
		    var code;
		    if (el.component) {
		      code = genComponent(el.component, el);
		    } else {
		      var data = el.plain ? undefined : genData(el);

		      var children = el.inlineTemplate ? null : genChildren(el);
		      code = "_h('" + (el.tag) + "'" + (data ? ("," + data) : '') + (children ? ("," + children) : '') + ")";
		    }
		    // module transforms
		    for (var i = 0; i < transforms$1.length; i++) {
		      code = transforms$1[i](el, code);
		    }
		    return code
		  }
		}

		// hoist static sub-trees out
		function genStatic (el) {
		  el.staticProcessed = true;
		  staticRenderFns.push(("with(this){return " + (genElement(el)) + "}"));
		  return ("_m(" + (staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + ")")
		}

		// v-once
		function genOnce (el) {
		  el.onceProcessed = true;
		  if (el.staticInFor) {
		    var key = '';
		    var parent = el.parent;
		    while (parent) {
		      if (parent.for) {
		        key = parent.key;
		        break
		      }
		      parent = parent.parent;
		    }
		    if (!key) {
		      "development" !== 'production' && warn$2(
		        "v-once can only be used inside v-for that is keyed. "
		      );
		      return genElement(el)
		    }
		    return ("_o(" + (genElement(el)) + "," + (onceCount++) + (key ? ("," + key) : "") + ")")
		  } else {
		    return genStatic(el)
		  }
		}

		function genIf (el) {
		  var exp = el.if;
		  el.ifProcessed = true; // avoid recursion
		  return ("(" + exp + ")?" + (genElement(el)) + ":" + (genElse(el)))
		}

		function genElse (el) {
		  return el.elseBlock
		    ? genElement(el.elseBlock)
		    : '_e()'
		}

		function genFor (el) {
		  var exp = el.for;
		  var alias = el.alias;
		  var iterator1 = el.iterator1 ? ("," + (el.iterator1)) : '';
		  var iterator2 = el.iterator2 ? ("," + (el.iterator2)) : '';
		  el.forProcessed = true; // avoid recursion
		  return "_l((" + exp + ")," +
		    "function(" + alias + iterator1 + iterator2 + "){" +
		      "return " + (genElement(el)) +
		    '})'
		}

		function genData (el) {
		  var data = '{';

		  // directives first.
		  // directives may mutate the el's other properties before they are generated.
		  var dirs = genDirectives(el);
		  if (dirs) { data += dirs + ','; }

		  // key
		  if (el.key) {
		    data += "key:" + (el.key) + ",";
		  }
		  // ref
		  if (el.ref) {
		    data += "ref:" + (el.ref) + ",";
		  }
		  if (el.refInFor) {
		    data += "refInFor:true,";
		  }
		  // record original tag name for components using "is" attribute
		  if (el.component) {
		    data += "tag:\"" + (el.tag) + "\",";
		  }
		  // slot target
		  if (el.slotTarget) {
		    data += "slot:" + (el.slotTarget) + ",";
		  }
		  // module data generation functions
		  for (var i = 0; i < dataGenFns.length; i++) {
		    data += dataGenFns[i](el);
		  }
		  // attributes
		  if (el.attrs) {
		    data += "attrs:{" + (genProps(el.attrs)) + "},";
		  }
		  // DOM props
		  if (el.props) {
		    data += "domProps:{" + (genProps(el.props)) + "},";
		  }
		  // event handlers
		  if (el.events) {
		    data += (genHandlers(el.events)) + ",";
		  }
		  if (el.nativeEvents) {
		    data += (genHandlers(el.nativeEvents, true)) + ",";
		  }
		  // inline-template
		  if (el.inlineTemplate) {
		    var ast = el.children[0];
		    if ("development" !== 'production' && (
		      el.children.length > 1 || ast.type !== 1
		    )) {
		      warn$2('Inline-template components must have exactly one child element.');
		    }
		    if (ast.type === 1) {
		      var inlineRenderFns = generate(ast, currentOptions);
		      data += "inlineTemplate:{render:function(){" + (inlineRenderFns.render) + "},staticRenderFns:[" + (inlineRenderFns.staticRenderFns.map(function (code) { return ("function(){" + code + "}"); }).join(',')) + "]}";
		    }
		  }
		  data = data.replace(/,$/, '') + '}';
		  // v-bind data wrap
		  if (el.wrapData) {
		    data = el.wrapData(data);
		  }
		  return data
		}

		function genDirectives (el) {
		  var dirs = el.directives;
		  if (!dirs) { return }
		  var res = 'directives:[';
		  var hasRuntime = false;
		  var i, l, dir, needRuntime;
		  for (i = 0, l = dirs.length; i < l; i++) {
		    dir = dirs[i];
		    needRuntime = true;
		    var gen = platformDirectives$1[dir.name] || baseDirectives[dir.name];
		    if (gen) {
		      // compile-time directive that manipulates AST.
		      // returns true if it also needs a runtime counterpart.
		      needRuntime = !!gen(el, dir, warn$2);
		    }
		    if (needRuntime) {
		      hasRuntime = true;
		      res += "{name:\"" + (dir.name) + "\",rawName:\"" + (dir.rawName) + "\"" + (dir.value ? (",value:(" + (dir.value) + "),expression:" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (",arg:\"" + (dir.arg) + "\"") : '') + (dir.modifiers ? (",modifiers:" + (JSON.stringify(dir.modifiers))) : '') + "},";
		    }
		  }
		  if (hasRuntime) {
		    return res.slice(0, -1) + ']'
		  }
		}

		function genChildren (el) {
		  if (el.children.length) {
		    return '[' + el.children.map(genNode).join(',') + ']'
		  }
		}

		function genNode (node) {
		  if (node.type === 1) {
		    return genElement(node)
		  } else {
		    return genText(node)
		  }
		}

		function genText (text) {
		  return text.type === 2
		    ? text.expression // no need for () because already wrapped in _s()
		    : JSON.stringify(text.text)
		}

		function genSlot (el) {
		  var slotName = el.slotName || '"default"';
		  var children = genChildren(el);
		  return ("_t(" + slotName + (children ? ("," + children) : '') + ")")
		}

		// componentName is el.component, take it as argument to shun flow's pessimistic refinement
		function genComponent (componentName, el) {
		  var children = el.inlineTemplate ? null : genChildren(el);
		  return ("_h(" + componentName + "," + (genData(el)) + (children ? ("," + children) : '') + ")")
		}

		function genProps (props) {
		  var res = '';
		  for (var i = 0; i < props.length; i++) {
		    var prop = props[i];
		    res += "\"" + (prop.name) + "\":" + (prop.value) + ",";
		  }
		  return res.slice(0, -1)
		}

		/*  */

		/**
		 * Compile a template.
		 */
		function compile$1 (
		  template,
		  options
		) {
		  var ast = parse(template.trim(), options);
		  optimize(ast, options);
		  var code = generate(ast, options);
		  return {
		    ast: ast,
		    render: code.render,
		    staticRenderFns: code.staticRenderFns
		  }
		}

		/*  */

		// operators like typeof, instanceof and in are allowed
		var prohibitedKeywordRE = new RegExp('\\b' + (
		  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +
		  'super,throw,while,yield,delete,export,import,return,switch,default,' +
		  'extends,finally,continue,debugger,function,arguments'
		).split(',').join('\\b|\\b') + '\\b');
		// check valid identifier for v-for
		var identRE = /[A-Za-z_$][\w$]*/;
		// strip strings in expressions
		var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;

		// detect problematic expressions in a template
		function detectErrors (ast) {
		  var errors = [];
		  if (ast) {
		    checkNode(ast, errors);
		  }
		  return errors
		}

		function checkNode (node, errors) {
		  if (node.type === 1) {
		    for (var name in node.attrsMap) {
		      if (dirRE.test(name)) {
		        var value = node.attrsMap[name];
		        if (value) {
		          if (name === 'v-for') {
		            checkFor(node, ("v-for=\"" + value + "\""), errors);
		          } else {
		            checkExpression(value, (name + "=\"" + value + "\""), errors);
		          }
		        }
		      }
		    }
		    if (node.children) {
		      for (var i = 0; i < node.children.length; i++) {
		        checkNode(node.children[i], errors);
		      }
		    }
		  } else if (node.type === 2) {
		    checkExpression(node.expression, node.text, errors);
		  }
		}

		function checkFor (node, text, errors) {
		  checkExpression(node.for || '', text, errors);
		  checkIdentifier(node.alias, 'v-for alias', text, errors);
		  checkIdentifier(node.iterator1, 'v-for iterator', text, errors);
		  checkIdentifier(node.iterator2, 'v-for iterator', text, errors);
		}

		function checkIdentifier (ident, type, text, errors) {
		  if (typeof ident === 'string' && !identRE.test(ident)) {
		    errors.push(("- invalid " + type + " \"" + ident + "\" in expression: " + text));
		  }
		}

		function checkExpression (exp, text, errors) {
		  try {
		    new Function(("return " + exp));
		  } catch (e) {
		    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);
		    if (keywordMatch) {
		      errors.push(
		        "- avoid using JavaScript keyword as property name: " +
		        "\"" + (keywordMatch[0]) + "\" in expression " + text
		      );
		    } else {
		      errors.push(("- invalid expression: " + text));
		    }
		  }
		}

		/*  */

		function transformNode (el, options) {
		  var warn = options.warn || baseWarn;
		  var staticClass = getAndRemoveAttr(el, 'class');
		  if ("development" !== 'production' && staticClass) {
		    var expression = parseText(staticClass, options.delimiters);
		    if (expression) {
		      warn(
		        "class=\"" + staticClass + "\": " +
		        'Interpolation inside attributes has been removed. ' +
		        'Use v-bind or the colon shorthand instead. For example, ' +
		        'instead of <div class="{{ val }}">, use <div :class="val">.'
		      );
		    }
		  }
		  if (staticClass) {
		    el.staticClass = JSON.stringify(staticClass);
		  }
		  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);
		  if (classBinding) {
		    el.classBinding = classBinding;
		  }
		}

		function genData$1 (el) {
		  var data = '';
		  if (el.staticClass) {
		    data += "staticClass:" + (el.staticClass) + ",";
		  }
		  if (el.classBinding) {
		    data += "class:" + (el.classBinding) + ",";
		  }
		  return data
		}

		var klass$1 = {
		  staticKeys: ['staticClass'],
		  transformNode: transformNode,
		  genData: genData$1
		};

		/*  */

		function transformNode$1 (el) {
		  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);
		  if (styleBinding) {
		    el.styleBinding = styleBinding;
		  }
		}

		function genData$2 (el) {
		  return el.styleBinding
		    ? ("style:(" + (el.styleBinding) + "),")
		    : ''
		}

		var style$1 = {
		  transformNode: transformNode$1,
		  genData: genData$2
		};

		var modules$1 = [
		  klass$1,
		  style$1
		];

		/*  */

		var len;
		var str;
		var chr;
		var index$1;
		var expressionPos;
		var expressionEndPos;

		/**
		 * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)
		 *
		 * for loop possible cases:
		 *
		 * - test
		 * - test[idx]
		 * - test[test1[idx]]
		 * - test["a"][idx]
		 * - xxx.test[a[a].test1[idx]]
		 * - test.xxx.a["asa"][test1[idx]]
		 *
		 */

		function parseModel (val) {
		  str = val;
		  len = str.length;
		  index$1 = expressionPos = expressionEndPos = 0;

		  if (val.indexOf('[') < 0) {
		    return {
		      exp: val,
		      idx: null
		    }
		  }

		  while (!eof()) {
		    chr = next();
		    /* istanbul ignore if */
		    if (isStringStart(chr)) {
		      parseString(chr);
		    } else if (chr === 0x5B) {
		      parseBracket(chr);
		    }
		  }

		  return {
		    exp: val.substring(0, expressionPos),
		    idx: val.substring(expressionPos + 1, expressionEndPos)
		  }
		}

		function next () {
		  return str.charCodeAt(++index$1)
		}

		function eof () {
		  return index$1 >= len
		}

		function isStringStart (chr) {
		  return chr === 0x22 || chr === 0x27
		}

		function parseBracket (chr) {
		  var inBracket = 1;
		  expressionPos = index$1;
		  while (!eof()) {
		    chr = next();
		    if (isStringStart(chr)) {
		      parseString(chr);
		      continue
		    }
		    if (chr === 0x5B) { inBracket++; }
		    if (chr === 0x5D) { inBracket--; }
		    if (inBracket === 0) {
		      expressionEndPos = index$1;
		      break
		    }
		  }
		}

		function parseString (chr) {
		  var stringQuote = chr;
		  while (!eof()) {
		    chr = next();
		    if (chr === stringQuote) {
		      break
		    }
		  }
		}

		/*  */

		var warn$3;

		function model$1 (
		  el,
		  dir,
		  _warn
		) {
		  warn$3 = _warn;
		  var value = dir.value;
		  var modifiers = dir.modifiers;
		  var tag = el.tag;
		  var type = el.attrsMap.type;
		  {
		    var dynamicType = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];
		    if (tag === 'input' && dynamicType) {
		      warn$3(
		        "<input :type=\"" + dynamicType + "\" v-model=\"" + value + "\">:\n" +
		        "v-model does not support dynamic input types. Use v-if branches instead."
		      );
		    }
		  }
		  if (tag === 'select') {
		    genSelect(el, value, modifiers);
		  } else if (tag === 'input' && type === 'checkbox') {
		    genCheckboxModel(el, value, modifiers);
		  } else if (tag === 'input' && type === 'radio') {
		    genRadioModel(el, value, modifiers);
		  } else {
		    genDefaultModel(el, value, modifiers);
		  }
		  // ensure runtime directive metadata
		  return true
		}

		function genCheckboxModel (
		  el,
		  value,
		  modifiers
		) {
		  if ("development" !== 'production' &&
		    el.attrsMap.checked != null) {
		    warn$3(
		      "<" + (el.tag) + " v-model=\"" + value + "\" checked>:\n" +
		      "inline checked attributes will be ignored when using v-model. " +
		      'Declare initial values in the component\'s data option instead.'
		    );
		  }
		  var number = modifiers && modifiers.number;
		  var valueBinding = getBindingAttr(el, 'value') || 'null';
		  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';
		  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';
		  addProp(el, 'checked',
		    "Array.isArray(" + value + ")" +
		      "?_i(" + value + "," + valueBinding + ")>-1" +
		      ":_q(" + value + "," + trueValueBinding + ")"
		  );
		  addHandler(el, 'change',
		    "var $$a=" + value + "," +
		        '$$el=$event.target,' +
		        "$$c=$$el.checked?(" + trueValueBinding + "):(" + falseValueBinding + ");" +
		    'if(Array.isArray($$a)){' +
		      "var $$v=" + (number ? '_n(' + valueBinding + ')' : valueBinding) + "," +
		          '$$i=_i($$a,$$v);' +
		      "if($$c){$$i<0&&(" + value + "=$$a.concat($$v))}" +
		      "else{$$i>-1&&(" + value + "=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}" +
		    "}else{" + value + "=$$c}",
		    null, true
		  );
		}

		function genRadioModel (
		    el,
		    value,
		    modifiers
		) {
		  if ("development" !== 'production' &&
		    el.attrsMap.checked != null) {
		    warn$3(
		      "<" + (el.tag) + " v-model=\"" + value + "\" checked>:\n" +
		      "inline checked attributes will be ignored when using v-model. " +
		      'Declare initial values in the component\'s data option instead.'
		    );
		  }
		  var number = modifiers && modifiers.number;
		  var valueBinding = getBindingAttr(el, 'value') || 'null';
		  valueBinding = number ? ("_n(" + valueBinding + ")") : valueBinding;
		  addProp(el, 'checked', ("_q(" + value + "," + valueBinding + ")"));
		  addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);
		}

		function genDefaultModel (
		  el,
		  value,
		  modifiers
		) {
		  {
		    if (el.tag === 'input' && el.attrsMap.value) {
		      warn$3(
		        "<" + (el.tag) + " v-model=\"" + value + "\" value=\"" + (el.attrsMap.value) + "\">:\n" +
		        'inline value attributes will be ignored when using v-model. ' +
		        'Declare initial values in the component\'s data option instead.'
		      );
		    }
		    if (el.tag === 'textarea' && el.children.length) {
		      warn$3(
		        "<textarea v-model=\"" + value + "\">:\n" +
		        'inline content inside <textarea> will be ignored when using v-model. ' +
		        'Declare initial values in the component\'s data option instead.'
		      );
		    }
		  }

		  var type = el.attrsMap.type;
		  var ref = modifiers || {};
		  var lazy = ref.lazy;
		  var number = ref.number;
		  var trim = ref.trim;
		  var event = lazy || (isIE && type === 'range') ? 'change' : 'input';
		  var needCompositionGuard = !lazy && type !== 'range';
		  var isNative = el.tag === 'input' || el.tag === 'textarea';

		  var valueExpression = isNative
		    ? ("$event.target.value" + (trim ? '.trim()' : ''))
		    : "$event";
		  valueExpression = number || type === 'number'
		    ? ("_n(" + valueExpression + ")")
		    : valueExpression;
		  var code = genAssignmentCode(value, valueExpression);
		  if (isNative && needCompositionGuard) {
		    code = "if($event.target.composing)return;" + code;
		  }
		  // inputs with type="file" are read only and setting the input's
		  // value will throw an error.
		  if ("development" !== 'production' &&
		      type === 'file') {
		    warn$3(
		      "<" + (el.tag) + " v-model=\"" + value + "\" type=\"file\">:\n" +
		      "File inputs are read only. Use a v-on:change listener instead."
		    );
		  }
		  addProp(el, 'value', isNative ? ("_s(" + value + ")") : ("(" + value + ")"));
		  addHandler(el, event, code, null, true);
		}

		function genSelect (
		    el,
		    value,
		    modifiers
		) {
		  {
		    el.children.some(checkOptionWarning);
		  }

		  var number = modifiers && modifiers.number;
		  var assignment = "Array.prototype.filter" +
		    ".call($event.target.options,function(o){return o.selected})" +
		    ".map(function(o){var val = \"_value\" in o ? o._value : o.value;" +
		    "return " + (number ? '_n(val)' : 'val') + "})" +
		    (el.attrsMap.multiple == null ? '[0]' : '');

		  var code = genAssignmentCode(value, assignment);
		  addHandler(el, 'change', code, null, true);
		}

		function checkOptionWarning (option) {
		  if (option.type === 1 &&
		    option.tag === 'option' &&
		    option.attrsMap.selected != null) {
		    warn$3(
		      "<select v-model=\"" + (option.parent.attrsMap['v-model']) + "\">:\n" +
		      'inline selected attributes on <option> will be ignored when using v-model. ' +
		      'Declare initial values in the component\'s data option instead.'
		    );
		    return true
		  }
		  return false
		}

		function genAssignmentCode (value, assignment) {
		  var modelRs = parseModel(value);
		  if (modelRs.idx === null) {
		    return (value + "=" + assignment)
		  } else {
		    return "var $$exp = " + (modelRs.exp) + ", $$idx = " + (modelRs.idx) + ";" +
		      "if (!Array.isArray($$exp)){" +
		        value + "=" + assignment + "}" +
		      "else{$$exp.splice($$idx, 1, " + assignment + ")}"
		  }
		}

		/*  */

		function text (el, dir) {
		  if (dir.value) {
		    addProp(el, 'textContent', ("_s(" + (dir.value) + ")"));
		  }
		}

		/*  */

		function html (el, dir) {
		  if (dir.value) {
		    addProp(el, 'innerHTML', ("_s(" + (dir.value) + ")"));
		  }
		}

		var directives$1 = {
		  model: model$1,
		  text: text,
		  html: html
		};

		/*  */

		var cache = Object.create(null);

		var baseOptions = {
		  isIE: isIE,
		  expectHTML: true,
		  modules: modules$1,
		  staticKeys: genStaticKeys(modules$1),
		  directives: directives$1,
		  isReservedTag: isReservedTag,
		  isUnaryTag: isUnaryTag,
		  mustUseProp: mustUseProp,
		  getTagNamespace: getTagNamespace,
		  isPreTag: isPreTag
		};

		function compile$$1 (
		  template,
		  options
		) {
		  options = options
		    ? extend(extend({}, baseOptions), options)
		    : baseOptions;
		  return compile$1(template, options)
		}

		function compileToFunctions (
		  template,
		  options,
		  vm
		) {
		  var _warn = (options && options.warn) || warn;
		  // detect possible CSP restriction
		  /* istanbul ignore if */
		  {
		    try {
		      new Function('return 1');
		    } catch (e) {
		      if (e.toString().match(/unsafe-eval|CSP/)) {
		        _warn(
		          'It seems you are using the standalone build of Vue.js in an ' +
		          'environment with Content Security Policy that prohibits unsafe-eval. ' +
		          'The template compiler cannot work in this environment. Consider ' +
		          'relaxing the policy to allow unsafe-eval or pre-compiling your ' +
		          'templates into render functions.'
		        );
		      }
		    }
		  }
		  var key = options && options.delimiters
		    ? String(options.delimiters) + template
		    : template;
		  if (cache[key]) {
		    return cache[key]
		  }
		  var res = {};
		  var compiled = compile$$1(template, options);
		  res.render = makeFunction(compiled.render);
		  var l = compiled.staticRenderFns.length;
		  res.staticRenderFns = new Array(l);
		  for (var i = 0; i < l; i++) {
		    res.staticRenderFns[i] = makeFunction(compiled.staticRenderFns[i]);
		  }
		  {
		    if (res.render === noop || res.staticRenderFns.some(function (fn) { return fn === noop; })) {
		      _warn(
		        "failed to compile template:\n\n" + template + "\n\n" +
		        detectErrors(compiled.ast).join('\n') +
		        '\n\n',
		        vm
		      );
		    }
		  }
		  return (cache[key] = res)
		}

		function makeFunction (code) {
		  try {
		    return new Function(code)
		  } catch (e) {
		    return noop
		  }
		}

		/*  */

		var idToTemplate = cached(function (id) {
		  var el = query(id);
		  return el && el.innerHTML
		});

		var mount = Vue$2.prototype.$mount;
		Vue$2.prototype.$mount = function (
		  el,
		  hydrating
		) {
		  el = el && query(el);

		  /* istanbul ignore if */
		  if (el === document.body || el === document.documentElement) {
		    "development" !== 'production' && warn(
		      "Do not mount Vue to <html> or <body> - mount to normal elements instead."
		    );
		    return this
		  }

		  var options = this.$options;
		  // resolve template/el and convert to render function
		  if (!options.render) {
		    var template = options.template;
		    if (template) {
		      if (typeof template === 'string') {
		        if (template.charAt(0) === '#') {
		          template = idToTemplate(template);
		        }
		      } else if (template.nodeType) {
		        template = template.innerHTML;
		      } else {
		        {
		          warn('invalid template option:' + template, this);
		        }
		        return this
		      }
		    } else if (el) {
		      template = getOuterHTML(el);
		    }
		    if (template) {
		      var ref = compileToFunctions(template, {
		        warn: warn,
		        shouldDecodeNewlines: shouldDecodeNewlines,
		        delimiters: options.delimiters
		      }, this);
		      var render = ref.render;
		      var staticRenderFns = ref.staticRenderFns;
		      options.render = render;
		      options.staticRenderFns = staticRenderFns;
		    }
		  }
		  return mount.call(this, el, hydrating)
		};

		/**
		 * Get outerHTML of elements, taking care
		 * of SVG elements in IE as well.
		 */
		function getOuterHTML (el) {
		  if (el.outerHTML) {
		    return el.outerHTML
		  } else {
		    var container = document.createElement('div');
		    container.appendChild(el.cloneNode(true));
		    return container.innerHTML
		  }
		}

		Vue$2.compile = compileToFunctions;

		return Vue$2;

		})));


	/***/ },
	/* 3 */
	/***/ function(module, exports, __webpack_require__) {

		var Vue = __webpack_require__(2);
		new Vue({
		    el: '#gamearea',
		    data: {
		        length: 6,
		        message: 'Hello Vue!',
		    }
		})

	/***/ },
	/* 4 */
	/***/ function(module, exports, __webpack_require__) {

		__webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"edge.js\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
		var $ = __webpack_require__(5);
		// Global variables
		var boardSize = 6;
		var tunnelLength = 12;
		var maxTunnelLength;
		var numProbes = 0;
		var probesList = [];
		var tunnel = new Tunnel();
		var finalTunnelGuess = [];
		var gameMode = -1;
		// 0 = Regular
		// 1 = Easy Mode
		var player1Name = "";
		var player2Name = "";
		var player1Score = 0;
		var player2Score = 0;
		var round = 1;
		var winningScore = 0;
		var winningPlayer = "";
		var computer = -1;
		// 0 = Humans
		// 1 = AI
		var gameState = -1;
		// 0 = badGuy placing tunnels
		// 1 = detector placing 1st hour probes
		// 2 = detector placing 2nd hour probes
		// 3 = detector placing 3rd hour probes
		// 4 = detector detecting


		// Clear the board before a new game
		var clearBoard = function () {
		    $(".animate").filter(function() {
		        $(this).removeClass("animate");
		    });
		    $(".final").filter(function() {
		        $(this).removeClass("final");
		    });
		    $(".detectedEdge").filter(function() {
		        $(this).removeClass("detectedEdge");
		    });
		    $(".reveal").filter(function() {
		        $(this).removeClass("reveal");
		    });
		}

		function Node(id) {
		    this.edges = [];
		    this.id = id;

		    this.addEdge = function(e0) {
		        this.edges.push(e0);
		    };

		    this.removeEdge = function(e0) {
		        var index = this.edges.indexOf(e0);
		        this.edges.splice(index, 1);
		    }
		}

		Node.prototype.toString = function nodeToString() {
		    var ret = this.id + ": ";
		    for (var i = 0; i < this.edges.length; i++) {
		        ret += (this.edges[i].id + " ");
		    }
		    return ret;
		}

		function Edge(n1, n2, id) {
		    this.n1 = n1;
		    this.n2 = n2;
		    this.id = id;
		    this.allNodes = [];
		}

		Edge.prototype.toString = function edgeToString() {
		    var ret = this.id + ": ";
		    console.log(ret)
		    for (var i = 0; i < this.allNodes.length; i++) {
		        ret += (this.allNodes[i].id + " ");
		    }
		    return ret;
		}

		function Tunnel() {
		    this.edges = {};
		    this.nodes = {};

		    this.addNode = function(node) {
		        var nodeId = node.id;
		        this.nodes[nodeId] = node;
		    };

		    this.removeNode = function(node) {
		        var nodeId = node.id;
		        delete this.nodes[nodeId];
		    };

		    this.addEdge = function(edge) {
		        var edgeId = edge.id;
		        this.edges[edgeId] = edge;
		    };

		    this.removeEdge = function(edge1) {
		        var edgeId = edge1.id;
		        delete this.edges[edgeId];
		    };

		    this.getStartNode = function() {
		        // Get all nodes that are touching the top row
		        var starts = [];
		        for (var nodeId in this.nodes) {
		            if (!this.nodes.hasOwnProperty(nodeId)) {
		                //not direct property of nodes
		                continue;
		            }

		            node = this.nodes[nodeId];
		            if (Number(node.id) < (boardSize + 1)) {
		                starts.push(node);
		            }
		        }

		        // Out of all nodes on top row, get all that have just one edge
		        var validStarts = [];
		        for (var i = 0; i < starts.length; i++) {
		            if (starts[i].edges.length == 1) {
		                validStarts.push(starts[i]);
		                console.log("valid starts: ", validStarts);
		            }
		        }

		        // If there is just one such node, it's our start
		        // Else there isn't a valid start node and tunnel is invalid
		        console.log("length of validStarts: ", validStarts.length);
		        if (validStarts.length == 1) {
		            console.log("validStarts[0] is ", validStarts[0]);
		            return validStarts[0];
		        }
		        else {
		            return null;
		        }
		    };

		    this.getEndNode = function() {
		        // Get all nodes that are touching the bottom row
		        var ends = [];
		        for (var nodeId in this.nodes) {
		            if (!this.nodes.hasOwnProperty(nodeId)) {
		                // Not direct property of nodes
		                continue;
		            }

		            node = this.nodes[nodeId];
		            if (Number(node.id) >= (boardSize * (boardSize + 1))) {
		                ends.push(node);
		            }
		        }

		        // Out of all nodes on top row, get all that have just one edge
		        var validEnds = [];
		        for (var i = 0; i < ends.length; i++) {
		            if (ends[i].edges.length == 1) {
		                validEnds.push(ends[i]);
		            }
		        }

		        // If there is just one such node, it's our start
		        // Else there isn't a valid start node and tunnel is invalid
		        if (validEnds.length == 1) {
		            return validEnds[0];
		        }
		        else {
		            return null;
		        }
		    };

		    this.validTunnel = function() {
		        console.log("EDGE INFO ", this.edges);
		        console.log("NODES ", this.nodes);
		        //duplicate nodes and edges
		        var allEdgeIds = [];
		        for (var item in this.edges) {
		            allEdgeIds.push(item);
		        }
		        console.log("All edge ids: ", allEdgeIds);
		        var allNodeIds = [];
		        for (var item in this.nodes) {
		            allNodeIds.push(item);
		        }
		        console.log("All nodes: ", allNodeIds);

		        var currNode = this.getStartNode();
		        console.log("Start node: ", currNode);

		        //if there is no start node, tunnel is invalid
		        if (currNode == null) {
		            return false;
		        }

		        //if there is no end node, tunnel is invalid
		        if (this.getEndNode() == null) {
		            return false;
		        }
		        console.log("end node: ", this.getEndNode());

		        //remove start node and it's only edge from total
		        allEdgeIds.splice(allEdgeIds.indexOf(currNode.edges[0].id), 1);

		        //get 2nd node
		        if(currNode.edges[0].n1 != currNode) {
		            currNode = currNode.edges[0].n1;
		        }
		        else {
		            currNode = currNode.edges[0].n2;
		        }

		        while (true) {
		            console.log("beg of loop", currNode.id);

		            //end conditions
		            if (currNode == this.getEndNode()) {
		                console.log("Reached end node");
		                //if we've removed all the edges we're good
		                if (allEdgeIds.length == 0) {
		                    return true;
		                }
		                else {
		                    console.log("AllEdgeIds does NOT == 0");
		                    return false;
		                }
		            }

		            //check that each node we reach only has 2 edges
		            if(currNode.edges.length != 2) {
		                console.log(currNode, "doesn't have 2 edges");
		                return false;
		            }

		            //check that one of the two edges is still alive
		            var nextEdge = null;
		            console.log("curr node edges:", currNode.edges);
		            console.log("All edge Ids: ", allEdgeIds);
		            for (var i = 0; i < currNode.edges.length; i++) {
		                console.log("currNode.edges[i].id ", currNode.edges[i].id);
		                if (allEdgeIds.indexOf(currNode.edges[i].id) > -1) {
		                    nextEdge = this.edges[currNode.edges[i].id];
		                }
		            }

		            //neither edge still in total list, tunnel invalid
		            if (nextEdge == null) {
		                console.log(nextEdge, "neither edge still in total list");
		                return false;
		            }

		            //clean up - remove curr node and curr edge
		            allEdgeIds.splice(allEdgeIds.indexOf(nextEdge.id), 1);

		            //get the next node
		            if(nextEdge.n1 != currNode) {
		                currNode = nextEdge.n1;
		            }
		            else {
		                currNode = nextEdge.n2;
		            }
		        }

		    };

		    this.clearTunnel = function() {
		        this.edges = {};
		        this.nodes = {};
		    }
		}

		Tunnel.prototype.toString = function tunnelToString() {
		    var ret = "tunnel: \n";
		    ret += "nodes: ";
		    for (var n in this.nodes) {
		        ret += (this.nodes[n].id + " ");
		    }
		    ret += "\nedges: ";
		    for (var e in this.edges) {
		        ret += (this.edges[e].id + " ");
		    }
		    ret += "\n";
		    return ret;
		}

		// Determine if was clicked before or not and add/remove edge from tunnel class
		var edges = document.getElementsByClassName("edge");

		var edgeClicked = function() {
		    var edgeId = this.getAttribute('x');
		    console.log(edgeId)
		    if (gameState == 0) {
		        $(this).toggleClass("animate");
		        if (edgeId in tunnel.edges) {
		            // Get nodes
		            tunnelLength++;
		            var n1 = tunnel.edges[edgeId].n1;
		            var n2 = tunnel.edges[edgeId].n2;
		            // Remove this edge from each node's edge list
		            n1.removeEdge(tunnel.edges[edgeId]);
		            n2.removeEdge(tunnel.edges[edgeId]);
		            if (n1.edges.length == 0) {
		                tunnel.removeNode(n1);
		            }
		            if (n2.edges.length == 0) {
		                tunnel.removeNode(n2);
		            }
		            tunnel.removeEdge(tunnel.edges[edgeId]);
		        } else {
		            // Check if there are no pieces
		            if (tunnelLength <= 0) {
		                remainingPieces.innerHTML = "There are no remaining edges! Please remove an edge to continue building.";
		                return;
		            }
		            tunnelLength--;
		            if (edgeId[0] == "h") {
		                console.log("slice: ", edgeId.slice(1));
		                var rNum = Math.floor(edgeId.slice(1) / boardSize);
		                console.log("rNum: ", rNum);
		                var n1Id = Number(edgeId.slice(1)) + rNum;
		                var n2Id = (n1Id + 1).toString();
		                console.log("n1Id: ", n1Id);
		                console.log("n2Id: ", n2Id);
		                var n1;
		                var n2;

		                if (n1Id in tunnel.nodes) {
		                    n1 = tunnel.nodes[n1Id];
		                } else {
		                    n1 = new Node(n1Id);
		                    tunnel.addNode(n1);
		                }

		                if (n2Id in tunnel.nodes) {
		                    n2 = tunnel.nodes[n2Id];
		                } else {
		                    n2 = new Node(n2Id);
		                    tunnel.addNode(n2);
		                }

		                var newEdge = new Edge(n1, n2, edgeId);
		                tunnel.addEdge(newEdge);
		                n1.addEdge(newEdge);
		                n2.addEdge(newEdge);
		            } else {
		                var n1Id = edgeId.slice(1);
		                var n2Id = (Number(edgeId.slice(1)) + boardSize + 1).toString();
		                console.log("n1Id: ", n1Id);
		                console.log("n2Id: ", n2Id);
		                var n1;
		                var n2;

		                if (n1Id in tunnel.nodes) {
		                    n1 = tunnel.nodes[n1Id];
		                } else {
		                    n1 = new Node(n1Id);
		                    tunnel.addNode(n1);
		                }

		                if (n2Id in tunnel.nodes) {
		                    n2 = tunnel.nodes[n2Id];
		                } else {
		                    n2 = new Node(n2Id);
		                    tunnel.addNode(n2);
		                }

		                var newEdge = new Edge(n1, n2, edgeId);
		                tunnel.addEdge(newEdge);
		                n1.addEdge(newEdge);
		                n2.addEdge(newEdge);
		            }
		        }

		        // this.style.background = this.style.background=='yellow'? '#63f9ff':'yellow';
		        remainingPieces.innerHTML = "Edges left: " + tunnelLength;
		        console.log(tunnel.edges);
		        console.log("Tunnel nodes: ", tunnel.nodes);
		    } else if (gameState == 4) {
		        if (finalTunnelGuess.indexOf(edgeId) > -1) {
		            finalTunnelGuess.splice(finalTunnelGuess.indexOf(edgeId), 1);
		        } else {
		            finalTunnelGuess.push(edgeId);
		        }
		        $(this).toggleClass("final");
		    }
		};



		// Get probes and add event listener to each one
		var probes = document.getElementsByClassName("probe");

		var probeClicked = function() {
		    if (gameState == 1 || gameState == 2 || gameState == 3) {
		        $(this).toggleClass("animate");
		        probeId = this.id;
		        console.log("Probe id: ", probeId);
		        index = probesList.indexOf(probeId);
		        console.log("Numprobes: " + numProbes);
		        console.log("Index: " + index);
		        if (index < 0) {
		            probesList.push(probeId.slice(1));
		            numProbes++;
		        } else {
		            probesList.splice(index, 1);
		            numProbes--;
		        }
		        // this.style.background = this.style.background == 'red' ? 'blue' : 'red';
		    }
		};

		for(var i=0;i<probes.length;i++){
		    probes[i].addEventListener('click', probeClicked, false);
		}

		var startGameInRegularMode = function () {
		    clearBoard();
		    gameMode = 0;
		    alert("Detector, please look away while Badguy builds a tunnel.");
		    startGame();
		}

		var startGameInEasyMode = function () {
		    clearBoard();
		    gameMode = 1;
		    alert("Detector, please look away while Badguy builds a tunnel.");
		    startGame();
		}

		var startGameAI = function () {
		    computer = 1;
		    gameMode = 0;
		    gameState = 0;
		    console.log("GAME STATE IN START AI ", gameState);
		    tunnel = createAITunnel();
		    startGame();
		}

		var startGameEasyAI = function () {
		    computer = 1;
		    gameMode = 1;
		    gameState = 0;
		    tunnel = createAITunnel();
		    startGame();
		}

		var startGame = function () {
		    clearBoard();
		    if (round == 1) {
		        tunnelLength = Math.floor(Math.random() * 13) + 8;
		        maxTunnelLength = tunnelLength;
		        alert("Maximum tunnel length is " + tunnelLength + ".");
		    } else {
		        tunnelLength = maxTunnelLength;
		    }
		    gameState++;
		    console.log("GAME STATE IS ", gameState);
		    document.getElementById('start').style.display = 'none';
		    document.getElementById('startEasy').style.display = 'none';
		    document.getElementById('startAI').style.display = 'none';
		    document.getElementById('startEasyAI').style.display = 'none';
		    document.getElementById('submitGuess').style.display = 'none';
		    if (gameState == 0) {
		        tunnelInfo.innerHTML = "Tunnel can be up to " + tunnelLength + " edges long.";
		        remainingPieces.innerHTML = "Edges left: " + tunnelLength;
		        document.getElementById('tunnelDone').style.display = 'block';
		    } else if (gameState == 1) {
		        message.innerHTML = "Computer opponent has constructed a tunnel. Detector, begin placing probes.";
		        document.getElementById('probesPlaced1').style.display = 'block';
		    }
		};

		var doneAddingTunnels = function () {
		    var valid = tunnel.validTunnel();
		    console.log(valid);

		    // If the tunnel isn't valid, don't let the game keep going
		    if(!valid) {
		        alert("Your tunnel is invalid. It must start on the top edge, end on the bottom edge, and be a single simple path.");
		        return;
		    }

		    document.getElementById('tunnelDone').style.display = 'none';
		    document.getElementById('probesPlaced1').style.display = 'block';
		    tunnelInfo.innerHTML = "";
		    remainingPieces.innerHTML = "";
		    currentTunnel.innerHTML = "";
		    message.innerHTML = "Done adding tunnels. Time for Detector to place first round of probes.";
		    for (var e in tunnel.edges) {
		        console.log("TRYING TO UNHIGHLIGHT");
		        console.log("tunnel.edges[e].id is ", tunnel.edges[e].id);
		        $("#" + tunnel.edges[e].id).toggleClass("animate");
		    }

		    // tunnelLength = 12;
		    // tunnel = createAITunnel();

		    console.log("final final tunnel:");
		    console.log("nodes");
		    for (var n in tunnel.nodes) {
		        console.log(tunnel.nodes[n] + "");
		    }
		    console.log("edges: ");
		    for (var e in tunnel.edges) {
		        console.log(tunnel.edges[e] + "");
		    }

		    gameState++;
		};

		var doneAddingProbes = function () {
		    message.innerHTML = "Done adding probes. Let's see how you did.";
		    for (var i = 0; i < probesList.length; i++) {
		        console.log("probesList[i] is ", probesList[i]);
		        if (probesList[i] in tunnel.nodes) {
		            console.log("we got in the if statement");
		            for (var j = 0; j < tunnel.nodes[probesList[i]].edges.length; j++) {
		                console.log("Found edge ", tunnel.nodes[probesList[i]].edges[j].id);
		                if (gameMode == 1) {
		                    $("#" + tunnel.nodes[probesList[i]].edges[j].id).addClass("animate");
		                }
		            }
		            $("#p" + probesList[i]).removeClass("animate");
		            $("#p" + probesList[i]).addClass("detectedEdge");
		        }
		    }

		    if (gameState == 1 || gameState == 2) {
		        //update score
		        if (computer == 1) {
		            //only need to update player1 score
		            player1Score += probesList.length;
		        } else {
		            if (round == 1) {
		                player1Score += probesList.length;
		            } else {
		                player2Score += probesList.length;
		            }
		        }

		        console.log("done with probe placement in round " + round);
		        console.log("player 1 score: " + player1Score);
		        console.log("player 2 score: " + player2Score);

		        probesList = [];
		        message.innerHTML = "Detector, please place another round of probes.";
		        document.getElementById('probesPlaced1').style.display = 'none';
		        document.getElementById('probesPlaced2').style.display = 'block';

		        gameState++;

		    } else if (gameState == 3) {
		        // Update score
		        if (computer == 1) {
		            // Only need to update player1 score
		            player1Score += probesList.length;
		        } else {
		            if (round == 1) {
		                player1Score += probesList.length;
		            } else {
		                player2Score += probesList.length;
		            }
		        }

		        console.log("done with probe placement in round " + round);
		        console.log("player 1 score: " + player1Score);
		        console.log("player 2 score: " + player2Score);

		        document.getElementById('probesPlaced2').style.display = 'none';
		        document.getElementById('submitGuess').style.display = 'block';
		        message.innerHTML = "Now, select all edges in the tunnel to submit your final guess.";
		        gameState++;
		    }

		    console.log("probes list after done ", probesList);
		};

		function restartGame() {
		    message.innerHTML = "";
		    round++;
		    if (computer == 1) {
		        if (gameMode == 0) { //regular ai
		            numProbes = 0;
		            probesList = [];
		            tunnel = new Tunnel();
		            finalTunnelGuess = [];
		            gameMode = -1;
		            computer = -1;
		            gameState = -1;
		            startGameAI();
		        } else {
		            numProbes = 0;
		            probesList = [];
		            tunnel = new Tunnel();
		            finalTunnelGuess = [];
		            gameMode = -1;
		            computer = -1;
		            gameState = -1;
		            startGameEasyAI();
		        }
		    } else {
		        if (gameMode == 0) {
		            numProbes = 0;
		            probesList = [];
		            tunnel = new Tunnel();
		            finalTunnelGuess = [];
		            gameMode = -1;
		            computer = -1;
		            gameState = -1;
		            startGameInRegularMode();
		        } else {
		            numProbes = 0;
		            probesList = [];
		            tunnel = new Tunnel();
		            finalTunnelGuess = [];
		            gameMode = -1;
		            computer = -1;
		            gameState = -1;
		            startGameInEasyMode();
		        }
		    }
		}

		var revealTunnel = function () {
		    for (var e in tunnel.edges) {
		        console.log("REVEALING TUNNEL");
		        console.log("tunnel.edges[e].id is ", tunnel.edges[e].id);
		        $("#" + tunnel.edges[e].id).removeClass("final");
		        $("#" + tunnel.edges[e].id).removeClass("animate");
		        $("#" + tunnel.edges[e].id).addClass("reveal");
		    }
		}

		var submitGuess = function () {
		    console.log("Final tunnel guess: ", finalTunnelGuess);
		    console.log("The actual tunnel: ", tunnel.edges);
		    console.log("Final tunnel guess LENGTH: ", finalTunnelGuess.length);
		    console.log("Tunnel length: ", Object.keys(tunnel.edges).length);
		    var clone = finalTunnelGuess.slice(0);
		    if (finalTunnelGuess.length != Object.keys(tunnel.edges).length) {
		        console.log("Tunnel length not the same");
		        if (round == 1) {
		            player1Score = 10000;
		            revealTunnel();
		            alert("You are a horrible Detector. Keep your day job. Your score is infinity.");
		        } else {
		            player2Score = 10000;
		            revealTunnel();
		            alert("You are a horrible Detector. Keep your day job. Your score is infinity.");
		        }
		    } else {
		        console.log("Tunnel length is good");
		        for (var i = 0; i < finalTunnelGuess.length; i++) {
		            console.log("Final tunnel guess: iteration ",i, finalTunnelGuess);
		            if (finalTunnelGuess[i] in tunnel.edges) {
		                console.log("Found match: " + finalTunnelGuess[i]);
		                clone.splice(clone.indexOf(finalTunnelGuess[i]), 1);
		                console.log("Clone: " + clone)
		            }
		        }
		        console.log("clone length ", clone.length);
		        if (!clone.length) {
		            if (round == 1) {
		                alert("Good job. Your score is " + player1Score + ".");
		            } else {
		                alert("Good job. Your score is " + player2Score + ".");
		            }
		        } else {
		            if (round == 1) {
		                player1Score = 10000;
		                revealTunnel();
		                alert("You are a horrible Detector. Keep your day job. Your score is infinity.");
		            } else {
		                player2Score = 10000;
		                revealTunnel();
		                alert("You are a horrible Detector. Keep your day job. Your score is infinity.");
		            }
		        }
		    }

		    if (round == 1 && computer != 1) {
		        // Popup that they need to switch roles
		        alert("Round 1 over. Now switch roles. The game will restart when you click OK.");
		        restartGame();
		    } else if (computer == 1) {
		        alert("Game over. You may submit your score.");
		        document.getElementById('submitGuess').style.display = 'none';
		        message.innerHTML = "";
		        document.getElementById("score").style.display="inline-block";
		    } else {
		        if (player1Score < player2Score ) {
		            winningScore = player1Score;
		            winningPlayer = player1Name;
		        } else {
		            winningScore = player2Score;
		            winningPlayer = player2Name;
		        }
		        if(computer != 1) {
		            if (player1Score < player2Score) {
		                alert("The game is over. Player 1 won with a score of " + player1Score + ". Player 1 can save their score.");
		            } else {
		                alert("The game is over. Player 2 won with a score of " + player2Score + ". Player 2 can save their score.");
		            }
		        } else {
		            alert("The game is over. Your score is " + player1Score + ". You can save your score.");
		            document.getElementById('submitGuess').style.display = 'none';
		            message.innerHTML = "";
		        }
		        document.getElementById('submitGuess').style.display = 'none';
		        message.innerHTML = "";
		        document.getElementById("score").style.display="inline-block";
		    }
		};


		// AI tunnel stuff
		function createAITunnel() {
		    var aiTunnel = new Tunnel();
		    var graph = new Graph();
		    graph.createGraph();
		    var currentTunnelLength = 0;

		    var start = Math.floor(Math.random() * (boardSize+1));
		    var currNodeFromGraph = graph.nodes[start];
		    var currNode = new Node(start);

		    var counter = 0;

		    while(true) {
		        console.log("curr node: " + currNode);

		        // Check if on end and if yes break
		        if (Math.floor(currNode.id / (boardSize+1)) == boardSize) {
		            console.log("on end!")
		            console.log("final tunnel: " + aiTunnel);
		            aiTunnel.addNode(currNode);
		            break;
		        }

		        // Pick an edge from the current nodes edges that's not the incoming edge
		        var potentialEdge = getRandomEdge(currNodeFromGraph, aiTunnel);
		        console.log("first potential edge: " + potentialEdge);

		        // See if adding that edge leaves enough pipes to get to the end
		        while (!potentialEdgeValid(potentialEdge, currNode, aiTunnel)) {
		            //while(false) {
		            potentialEdge = getRandomEdge(currNodeFromGraph, aiTunnel);
		            console.log("edge was invalid, got new one: " + potentialEdge);
		            //sleepFor(1000);
		        }

		        // Now we have a good edge, update it's n1
		        potentialEdge.n1 = currNode;

		        // Add the edge to currNode
		        currNode.addEdge(potentialEdge);

		        // Add them both to the tunnel
		        aiTunnel.addNode(currNode);
		        aiTunnel.addEdge(potentialEdge);

		        // Get the next node
		        var currNodeId = currNode.id;
		        var newNodeId = null;
		        // console.log("curr node id: " + currNodeId);
		        for (var i = 0; i < potentialEdge.allNodes.length; i++) {
		            // console.log("potentialEdge.allNodes[i].id: " + potentialEdge.allNodes[i].id );
		            if (potentialEdge.allNodes[i].id != currNodeId) {
		                newNodeId = potentialEdge.allNodes[i].id;
		            }
		        }
		        // console.log("new node id: " + newNodeId);

		        currNodeFromGraph = graph.nodes[newNodeId];
		        currNode = new Node(newNodeId);
		        currNode.addEdge(potentialEdge);
		        potentialEdge.n2 = currNode;
		        counter++;

		        console.log("tunnel: " + aiTunnel);

		    }

		    return aiTunnel;
		}

		function potentialEdgeValid(potentialEdge, currNode, tunnel) {

		    if(potentialEdge.id in tunnel.edges) {
		        console.log("edge exists, not valid");
		        return false;
		    }

		    tunnel.addEdge(potentialEdge);
		    tunnel.addNode(currNode);

		    var tunnelLengthSoFar = Object.keys(tunnel.edges).length;
		    var edgesLeft = tunnelLength - tunnelLengthSoFar;
		    var rowNum = getRowNum(potentialEdge);


		    console.log();
		    console.log("======= starting validation ========")
		    console.log("checking if edge " + potentialEdge.id + " is valid to add to tunnel: ");
		    console.log(tunnel + "");
		    console.log("tunnel len so far: " + tunnelLengthSoFar);
		    console.log("edges left so far: " + edgesLeft);
		    console.log("row num of edge: " + rowNum);

		    // Check that the other end of the new edge isn't already in the tunnel
		    // (This means we created a loop)
		    var currNodeId = currNode.id;
		    var newNodeId = null;
		    console.log("curr node id: " + currNodeId);
		    for (var i = 0; i < potentialEdge.allNodes.length; i++) {
		        //console.log("potentialEdge.allNodes[i].id: " + potentialEdge.allNodes[i].id );
		        if (potentialEdge.allNodes[i].id != currNodeId) {
		            newNodeId = potentialEdge.allNodes[i].id;
		        }
		    }
		    console.log("new node id: " + newNodeId);

		    if (newNodeId in tunnel.nodes) {
		        console.log("we created a loop, not valid");
		        tunnel.removeEdge(potentialEdge);
		        tunnel.removeNode(currNode);
		        return false;
		    }


		    // If the edge is horizontal then need (remaining pieces - (boardSize - rowNum)) >= 0
		    // Check if have enough nodes to end
		    var neededToEnd = -1;
		    if (potentialEdge.id[0] == "h") {
		        console.log("edge is horiz");
		        // Check if h edge below is already in tunnel
		        var edgeBelowId = Number(potentialEdge.id.slice(1)) + boardSize;
		        var edgeBelow = "h" + edgeBelowId;
		        if (edgeBelow in tunnel.edges) {
		            console.log("can't add this horiz edge because will cause box");
		            tunnel.removeEdge(potentialEdge);
		            tunnel.removeNode(currNode);
		            return false;
		        }
		        neededToEnd = boardSize - rowNum;
		    } else {
		        if (newNodeId > currNodeId) { //edge is going down
		            console.log("edge is v going down")
		            neededToEnd = (boardSize - rowNum) - 1;
		        } else {
		            console.log("edge is v going up");
		            // console.log("so for now returning false");
		            // return false;
		            // can't go up on the edges
		            var potEdgeIdNum = Number(potentialEdge.id.slice(1));
		            if(potEdgeIdNum % (boardSize + 1) == 0 || potEdgeIdNum % (boardSize + 1) == boardSize) {
		                console.log("can't go up on an outside edge");
		                tunnel.removeEdge(potentialEdge);
		                tunnel.removeNode(currNode);
		                return false;
		            }

		            neededToEnd = (boardSize - rowNum) + 1;
		        }
		    }
		    console.log("needed to end: " + neededToEnd);
		    console.log("======== done with check =========");
		    console.log();
		    tunnel.removeEdge(potentialEdge);
		    tunnel.removeNode(currNode);
		    return ((edgesLeft - neededToEnd) >= 0);

		    //if edge is vertical
		    //if edge is downward need (remaining pieces - (boardSize - rownum) - 1) >= 0
		    //else if upward need (remaining pieces - (boardSize - rownum) + 1) >= 0
		}

		function getRowNum(edge) {
		    var edgeId = Number(edge.id.slice(1));
		    if(edge.id[0] == "h") {
		        return Math.floor(edgeId / (boardSize));
		    } else {
		        return Math.floor(edgeId / (boardSize + 1));
		    }
		}

		function getRandomEdge(node, tunnel) {
		    // Given the tunnel and the current node
		    var nodeId = node.id;

		    var existingEdgeId;
		    if (nodeId in tunnel.nodes) {
		        var nodeFromTunnel = tunnel.nodes[nodeId];
		        existingEdgeId = nodeFromTunnel.edges[0];
		    } else {
		        existingEdgeId = "bad"
		    }

		    var potentialEdges = [];

		    for (var i = 0; i < node.edges.length; i++) {
		        if (node.edges[i].id != existingEdgeId) {
		            potentialEdges.push(node.edges[i]);
		        }
		    }

		    console.log("list of potential edge candidates for node " + nodeId);
		    for(var i = 0; i < potentialEdges.length; i++) {
		        console.log(potentialEdges[i].id);
		    }

		    var rand = potentialEdges[Math.floor(Math.random() * potentialEdges.length)];
		    return rand;
		}

		function Graph() {
		    this.nodes = {};
		    this.edges = {};
		    this.nodeIds = [];
		    this.edgeIds = [];

		    this.createGraph = function() {
		        console.log("!23")
		        for(var i = 0; i < ((boardSize+1)*(boardSize+1)); i++) {
		            var node = new Node(i);
		            this.nodes[i] = node;
		            this.nodeIds.push(i);
		            var horizontalEdgeIds = getHorizontalEdgesIds(i);
		            var verticalEdgeIds = getVerticalEdgesIds(i);

		            for(var j = 0; j < horizontalEdgeIds.length; j++) {
		                var edgeId = horizontalEdgeIds[j];
		                if (edgeId in this.edges) {
		                    // Add the node to the edge
		                    this.edges[edgeId].allNodes.push(node);
		                    node.addEdge(this.edges[edgeId]);
		                } else {
		                    // Create new edge and add it to edge object
		                    var edge = new Edge(null, null, edgeId);
		                    edge.allNodes.push(node);
		                    this.edges[edgeId] = edge;
		                    this.edgeIds.push(edgeId);
		                    node.addEdge(edge);
		                }
		            }

		            for (var j = 0; j < verticalEdgeIds.length; j++) {
		                var edgeId = verticalEdgeIds[j];
		                if (edgeId in this.edges) {
		                    // Add the node to it
		                    this.edges[edgeId].allNodes.push(node);
		                    node.addEdge(this.edges[edgeId]);
		                } else {
		                    // Create new edge
		                    var edge = new Edge(null, null, edgeId);
		                    edge.allNodes.push(node);
		                    this.edges[edgeId] = edge;
		                    this.edgeIds.push(edgeId);
		                    node.addEdge(this.edges[edgeId]);
		                }
		            }
		        }
		        console.log("nodes");
		        for (var n in this.nodes) {
		            console.log("" + this.nodes[n]);
		        }
		        console.log("edges");
		        for (var e in this.edges) {
		            console.log("" + this.edges[e]);
		        }
		    }
		}

		function getHorizontalEdgesIds(i) {
		    var horizontalEdgeIds = [];

		    // console.log("getting horizontal edges for node " + i);

		    // Create left and right edges
		    var rowNum = Math.floor(i / (boardSize + 1));
		    var leftEdge = i - (rowNum + 1);
		    var rightEdge = i - rowNum;
		    var leftEdgeId = "h" + leftEdge;
		    var rightEdgeId = "h" + rightEdge;

		    // console.log("row num: " + rowNum);
		    // console.log("left edge: " + leftEdge);
		    // console.log("right edge: " + rightEdge);

		    // If on left border, only has right edge
		    if (i % (boardSize + 1) == 0) {
		        // console.log("on left border");
		        leftEdgeId = null;
		    }

		    // If on right border only has left edge
		    if (i % (boardSize + 1) == 6) {
		        // console.log("on right border");
		        rightEdgeId = null;
		    }

		    // Add non null edges
		    if (leftEdgeId != null) {
		        horizontalEdgeIds.push(leftEdgeId);
		    }

		    if (rightEdgeId != null) {
		        horizontalEdgeIds.push(rightEdgeId);
		    }

		    // console.log("final result: " , horizontalEdgeIds);
		    return horizontalEdgeIds;
		}

		function getVerticalEdgesIds(i) {
		    var verticalEdgeIds = [];
		    // console.log("getting vertical edges for node " + i);

		    // If on the first row only has a down edge
		    if (i <= boardSize) {
		        // console.log("on first row");
		        var edgeId = "v" + i;
		        verticalEdgeIds.push(edgeId);
		        return verticalEdgeIds;
		    }

		    // If on the bottom row only has an up edge
		    if (i >= (boardSize * (boardSize + 1))) {
		        // console.log("on bottom row");
		        var upEdgeIdNum = i - (boardSize + 1);
		        var upEdgeId = "v" + upEdgeIdNum;
		        verticalEdgeIds.push(upEdgeId);
		        return verticalEdgeIds;
		    }

		    // Else has both edges
		    var downEdgeId = "v" + i;
		    var upEdgeIdNum = i - (boardSize + 1);
		    var upEdgeId = "v" + upEdgeIdNum;
		    verticalEdgeIds.push(downEdgeId);
		    verticalEdgeIds.push(upEdgeId);
		    // console.log("final result: ", verticalEdgeIds);
		    return verticalEdgeIds;
		}

		function edgeIsHorizontal(edge) {
		    var edgeId = edge.id;
		    var dir = edgeId.slice(0,1);
		    if (dir == "h") {
		        return true;
		    } else {
		        return false;
		    }
		}


		// Add button event listeners

		// Start game in normal mode
		document.getElementById('start').addEventListener('click', startGameInRegularMode, false);

		// Start game in easy mode
		document.getElementById('startEasy').addEventListener('click', startGameInEasyMode, false);

		// Start game with AI
		document.getElementById('startAI').addEventListener('click', startGameAI, false);

		// Start game with AI in easy mode
		document.getElementById('startEasyAI').addEventListener('click', startGameEasyAI, false);

		document.getElementById('tunnelDone').addEventListener('click', doneAddingTunnels, false);

		document.getElementById('probesPlaced1').addEventListener('click', doneAddingProbes, false);

		document.getElementById('probesPlaced2').addEventListener('click', doneAddingProbes, false);

		document.getElementById('submitGuess').addEventListener('click', submitGuess, false);



	/***/ },
	/* 5 */
	/***/ function(module, exports, __webpack_require__) {

		var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
		 * jQuery JavaScript Library v3.1.1
		 * https://jquery.com/
		 *
		 * Includes Sizzle.js
		 * https://sizzlejs.com/
		 *
		 * Copyright jQuery Foundation and other contributors
		 * Released under the MIT license
		 * https://jquery.org/license
		 *
		 * Date: 2016-09-22T22:30Z
		 */
		( function( global, factory ) {

			"use strict";

			if ( typeof module === "object" && typeof module.exports === "object" ) {

				// For CommonJS and CommonJS-like environments where a proper `window`
				// is present, execute the factory and get jQuery.
				// For environments that do not have a `window` with a `document`
				// (such as Node.js), expose a factory as module.exports.
				// This accentuates the need for the creation of a real `window`.
				// e.g. var jQuery = require("jquery")(window);
				// See ticket #14549 for more info.
				module.exports = global.document ?
					factory( global, true ) :
					function( w ) {
						if ( !w.document ) {
							throw new Error( "jQuery requires a window with a document" );
						}
						return factory( w );
					};
			} else {
				factory( global );
			}

		// Pass this if window is not defined yet
		} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

		// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
		// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
		// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
		// enough that all such attempts are guarded in a try block.
		"use strict";

		var arr = [];

		var document = window.document;

		var getProto = Object.getPrototypeOf;

		var slice = arr.slice;

		var concat = arr.concat;

		var push = arr.push;

		var indexOf = arr.indexOf;

		var class2type = {};

		var toString = class2type.toString;

		var hasOwn = class2type.hasOwnProperty;

		var fnToString = hasOwn.toString;

		var ObjectFunctionString = fnToString.call( Object );

		var support = {};



			function DOMEval( code, doc ) {
				doc = doc || document;

				var script = doc.createElement( "script" );

				script.text = code;
				doc.head.appendChild( script ).parentNode.removeChild( script );
			}
		/* global Symbol */
		// Defining this global in .eslintrc.json would create a danger of using the global
		// unguarded in another place, it seems safer to define global only for this module



		var
			version = "3.1.1",

			// Define a local copy of jQuery
			jQuery = function( selector, context ) {

				// The jQuery object is actually just the init constructor 'enhanced'
				// Need init if jQuery is called (just allow error to be thrown if not included)
				return new jQuery.fn.init( selector, context );
			},

			// Support: Android <=4.0 only
			// Make sure we trim BOM and NBSP
			rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

			// Matches dashed string for camelizing
			rmsPrefix = /^-ms-/,
			rdashAlpha = /-([a-z])/g,

			// Used by jQuery.camelCase as callback to replace()
			fcamelCase = function( all, letter ) {
				return letter.toUpperCase();
			};

		jQuery.fn = jQuery.prototype = {

			// The current version of jQuery being used
			jquery: version,

			constructor: jQuery,

			// The default length of a jQuery object is 0
			length: 0,

			toArray: function() {
				return slice.call( this );
			},

			// Get the Nth element in the matched element set OR
			// Get the whole matched element set as a clean array
			get: function( num ) {

				// Return all the elements in a clean array
				if ( num == null ) {
					return slice.call( this );
				}

				// Return just the one element from the set
				return num < 0 ? this[ num + this.length ] : this[ num ];
			},

			// Take an array of elements and push it onto the stack
			// (returning the new matched element set)
			pushStack: function( elems ) {

				// Build a new jQuery matched element set
				var ret = jQuery.merge( this.constructor(), elems );

				// Add the old object onto the stack (as a reference)
				ret.prevObject = this;

				// Return the newly-formed element set
				return ret;
			},

			// Execute a callback for every element in the matched set.
			each: function( callback ) {
				return jQuery.each( this, callback );
			},

			map: function( callback ) {
				return this.pushStack( jQuery.map( this, function( elem, i ) {
					return callback.call( elem, i, elem );
				} ) );
			},

			slice: function() {
				return this.pushStack( slice.apply( this, arguments ) );
			},

			first: function() {
				return this.eq( 0 );
			},

			last: function() {
				return this.eq( -1 );
			},

			eq: function( i ) {
				var len = this.length,
					j = +i + ( i < 0 ? len : 0 );
				return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
			},

			end: function() {
				return this.prevObject || this.constructor();
			},

			// For internal use only.
			// Behaves like an Array's method, not like a jQuery method.
			push: push,
			sort: arr.sort,
			splice: arr.splice
		};

		jQuery.extend = jQuery.fn.extend = function() {
			var options, name, src, copy, copyIsArray, clone,
				target = arguments[ 0 ] || {},
				i = 1,
				length = arguments.length,
				deep = false;

			// Handle a deep copy situation
			if ( typeof target === "boolean" ) {
				deep = target;

				// Skip the boolean and the target
				target = arguments[ i ] || {};
				i++;
			}

			// Handle case when target is a string or something (possible in deep copy)
			if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {
				target = {};
			}

			// Extend jQuery itself if only one argument is passed
			if ( i === length ) {
				target = this;
				i--;
			}

			for ( ; i < length; i++ ) {

				// Only deal with non-null/undefined values
				if ( ( options = arguments[ i ] ) != null ) {

					// Extend the base object
					for ( name in options ) {
						src = target[ name ];
						copy = options[ name ];

						// Prevent never-ending loop
						if ( target === copy ) {
							continue;
						}

						// Recurse if we're merging plain objects or arrays
						if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
							( copyIsArray = jQuery.isArray( copy ) ) ) ) {

							if ( copyIsArray ) {
								copyIsArray = false;
								clone = src && jQuery.isArray( src ) ? src : [];

							} else {
								clone = src && jQuery.isPlainObject( src ) ? src : {};
							}

							// Never move original objects, clone them
							target[ name ] = jQuery.extend( deep, clone, copy );

						// Don't bring in undefined values
						} else if ( copy !== undefined ) {
							target[ name ] = copy;
						}
					}
				}
			}

			// Return the modified object
			return target;
		};

		jQuery.extend( {

			// Unique for each copy of jQuery on the page
			expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

			// Assume jQuery is ready without the ready module
			isReady: true,

			error: function( msg ) {
				throw new Error( msg );
			},

			noop: function() {},

			isFunction: function( obj ) {
				return jQuery.type( obj ) === "function";
			},

			isArray: Array.isArray,

			isWindow: function( obj ) {
				return obj != null && obj === obj.window;
			},

			isNumeric: function( obj ) {

				// As of jQuery 3.0, isNumeric is limited to
				// strings and numbers (primitives or objects)
				// that can be coerced to finite numbers (gh-2662)
				var type = jQuery.type( obj );
				return ( type === "number" || type === "string" ) &&

					// parseFloat NaNs numeric-cast false positives ("")
					// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
					// subtraction forces infinities to NaN
					!isNaN( obj - parseFloat( obj ) );
			},

			isPlainObject: function( obj ) {
				var proto, Ctor;

				// Detect obvious negatives
				// Use toString instead of jQuery.type to catch host objects
				if ( !obj || toString.call( obj ) !== "[object Object]" ) {
					return false;
				}

				proto = getProto( obj );

				// Objects with no prototype (e.g., `Object.create( null )`) are plain
				if ( !proto ) {
					return true;
				}

				// Objects with prototype are plain iff they were constructed by a global Object function
				Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
				return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
			},

			isEmptyObject: function( obj ) {

				/* eslint-disable no-unused-vars */
				// See https://github.com/eslint/eslint/issues/6125
				var name;

				for ( name in obj ) {
					return false;
				}
				return true;
			},

			type: function( obj ) {
				if ( obj == null ) {
					return obj + "";
				}

				// Support: Android <=2.3 only (functionish RegExp)
				return typeof obj === "object" || typeof obj === "function" ?
					class2type[ toString.call( obj ) ] || "object" :
					typeof obj;
			},

			// Evaluates a script in a global context
			globalEval: function( code ) {
				DOMEval( code );
			},

			// Convert dashed to camelCase; used by the css and data modules
			// Support: IE <=9 - 11, Edge 12 - 13
			// Microsoft forgot to hump their vendor prefix (#9572)
			camelCase: function( string ) {
				return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
			},

			nodeName: function( elem, name ) {
				return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
			},

			each: function( obj, callback ) {
				var length, i = 0;

				if ( isArrayLike( obj ) ) {
					length = obj.length;
					for ( ; i < length; i++ ) {
						if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
							break;
						}
					}
				} else {
					for ( i in obj ) {
						if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
							break;
						}
					}
				}

				return obj;
			},

			// Support: Android <=4.0 only
			trim: function( text ) {
				return text == null ?
					"" :
					( text + "" ).replace( rtrim, "" );
			},

			// results is for internal usage only
			makeArray: function( arr, results ) {
				var ret = results || [];

				if ( arr != null ) {
					if ( isArrayLike( Object( arr ) ) ) {
						jQuery.merge( ret,
							typeof arr === "string" ?
							[ arr ] : arr
						);
					} else {
						push.call( ret, arr );
					}
				}

				return ret;
			},

			inArray: function( elem, arr, i ) {
				return arr == null ? -1 : indexOf.call( arr, elem, i );
			},

			// Support: Android <=4.0 only, PhantomJS 1 only
			// push.apply(_, arraylike) throws on ancient WebKit
			merge: function( first, second ) {
				var len = +second.length,
					j = 0,
					i = first.length;

				for ( ; j < len; j++ ) {
					first[ i++ ] = second[ j ];
				}

				first.length = i;

				return first;
			},

			grep: function( elems, callback, invert ) {
				var callbackInverse,
					matches = [],
					i = 0,
					length = elems.length,
					callbackExpect = !invert;

				// Go through the array, only saving the items
				// that pass the validator function
				for ( ; i < length; i++ ) {
					callbackInverse = !callback( elems[ i ], i );
					if ( callbackInverse !== callbackExpect ) {
						matches.push( elems[ i ] );
					}
				}

				return matches;
			},

			// arg is for internal usage only
			map: function( elems, callback, arg ) {
				var length, value,
					i = 0,
					ret = [];

				// Go through the array, translating each of the items to their new values
				if ( isArrayLike( elems ) ) {
					length = elems.length;
					for ( ; i < length; i++ ) {
						value = callback( elems[ i ], i, arg );

						if ( value != null ) {
							ret.push( value );
						}
					}

				// Go through every key on the object,
				} else {
					for ( i in elems ) {
						value = callback( elems[ i ], i, arg );

						if ( value != null ) {
							ret.push( value );
						}
					}
				}

				// Flatten any nested arrays
				return concat.apply( [], ret );
			},

			// A global GUID counter for objects
			guid: 1,

			// Bind a function to a context, optionally partially applying any
			// arguments.
			proxy: function( fn, context ) {
				var tmp, args, proxy;

				if ( typeof context === "string" ) {
					tmp = fn[ context ];
					context = fn;
					fn = tmp;
				}

				// Quick check to determine if target is callable, in the spec
				// this throws a TypeError, but we will just return undefined.
				if ( !jQuery.isFunction( fn ) ) {
					return undefined;
				}

				// Simulated bind
				args = slice.call( arguments, 2 );
				proxy = function() {
					return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
				};

				// Set the guid of unique handler to the same of original handler, so it can be removed
				proxy.guid = fn.guid = fn.guid || jQuery.guid++;

				return proxy;
			},

			now: Date.now,

			// jQuery.support is not used in Core but other projects attach their
			// properties to it so it needs to exist.
			support: support
		} );

		if ( typeof Symbol === "function" ) {
			jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
		}

		// Populate the class2type map
		jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
		function( i, name ) {
			class2type[ "[object " + name + "]" ] = name.toLowerCase();
		} );

		function isArrayLike( obj ) {

			// Support: real iOS 8.2 only (not reproducible in simulator)
			// `in` check used to prevent JIT error (gh-2145)
			// hasOwn isn't used here due to false negatives
			// regarding Nodelist length in IE
			var length = !!obj && "length" in obj && obj.length,
				type = jQuery.type( obj );

			if ( type === "function" || jQuery.isWindow( obj ) ) {
				return false;
			}

			return type === "array" || length === 0 ||
				typeof length === "number" && length > 0 && ( length - 1 ) in obj;
		}
		var Sizzle =
		/*!
		 * Sizzle CSS Selector Engine v2.3.3
		 * https://sizzlejs.com/
		 *
		 * Copyright jQuery Foundation and other contributors
		 * Released under the MIT license
		 * http://jquery.org/license
		 *
		 * Date: 2016-08-08
		 */
		(function( window ) {

		var i,
			support,
			Expr,
			getText,
			isXML,
			tokenize,
			compile,
			select,
			outermostContext,
			sortInput,
			hasDuplicate,

			// Local document vars
			setDocument,
			document,
			docElem,
			documentIsHTML,
			rbuggyQSA,
			rbuggyMatches,
			matches,
			contains,

			// Instance-specific data
			expando = "sizzle" + 1 * new Date(),
			preferredDoc = window.document,
			dirruns = 0,
			done = 0,
			classCache = createCache(),
			tokenCache = createCache(),
			compilerCache = createCache(),
			sortOrder = function( a, b ) {
				if ( a === b ) {
					hasDuplicate = true;
				}
				return 0;
			},

			// Instance methods
			hasOwn = ({}).hasOwnProperty,
			arr = [],
			pop = arr.pop,
			push_native = arr.push,
			push = arr.push,
			slice = arr.slice,
			// Use a stripped-down indexOf as it's faster than native
			// https://jsperf.com/thor-indexof-vs-for/5
			indexOf = function( list, elem ) {
				var i = 0,
					len = list.length;
				for ( ; i < len; i++ ) {
					if ( list[i] === elem ) {
						return i;
					}
				}
				return -1;
			},

			booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

			// Regular expressions

			// http://www.w3.org/TR/css3-selectors/#whitespace
			whitespace = "[\\x20\\t\\r\\n\\f]",

			// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
			identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

			// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
			attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
				// Operator (capture 2)
				"*([*^$|!~]?=)" + whitespace +
				// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
				"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
				"*\\]",

			pseudos = ":(" + identifier + ")(?:\\((" +
				// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
				// 1. quoted (capture 3; capture 4 or capture 5)
				"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
				// 2. simple (capture 6)
				"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
				// 3. anything else (capture 2)
				".*" +
				")\\)|)",

			// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
			rwhitespace = new RegExp( whitespace + "+", "g" ),
			rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

			rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
			rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

			rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

			rpseudo = new RegExp( pseudos ),
			ridentifier = new RegExp( "^" + identifier + "$" ),

			matchExpr = {
				"ID": new RegExp( "^#(" + identifier + ")" ),
				"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
				"TAG": new RegExp( "^(" + identifier + "|[*])" ),
				"ATTR": new RegExp( "^" + attributes ),
				"PSEUDO": new RegExp( "^" + pseudos ),
				"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
					"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
					"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
				"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
				// For use in libraries implementing .is()
				// We use this for POS matching in `select`
				"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
					whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
			},

			rinputs = /^(?:input|select|textarea|button)$/i,
			rheader = /^h\d$/i,

			rnative = /^[^{]+\{\s*\[native \w/,

			// Easily-parseable/retrievable ID or TAG or CLASS selectors
			rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

			rsibling = /[+~]/,

			// CSS escapes
			// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
			runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
			funescape = function( _, escaped, escapedWhitespace ) {
				var high = "0x" + escaped - 0x10000;
				// NaN means non-codepoint
				// Support: Firefox<24
				// Workaround erroneous numeric interpretation of +"0x"
				return high !== high || escapedWhitespace ?
					escaped :
					high < 0 ?
						// BMP codepoint
						String.fromCharCode( high + 0x10000 ) :
						// Supplemental Plane codepoint (surrogate pair)
						String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
			},

			// CSS string/identifier serialization
			// https://drafts.csswg.org/cssom/#common-serializing-idioms
			rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
			fcssescape = function( ch, asCodePoint ) {
				if ( asCodePoint ) {

					// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
					if ( ch === "\0" ) {
						return "\uFFFD";
					}

					// Control characters and (dependent upon position) numbers get escaped as code points
					return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
				}

				// Other potentially-special ASCII characters get backslash-escaped
				return "\\" + ch;
			},

			// Used for iframes
			// See setDocument()
			// Removing the function wrapper causes a "Permission Denied"
			// error in IE
			unloadHandler = function() {
				setDocument();
			},

			disabledAncestor = addCombinator(
				function( elem ) {
					return elem.disabled === true && ("form" in elem || "label" in elem);
				},
				{ dir: "parentNode", next: "legend" }
			);

		// Optimize for push.apply( _, NodeList )
		try {
			push.apply(
				(arr = slice.call( preferredDoc.childNodes )),
				preferredDoc.childNodes
			);
			// Support: Android<4.0
			// Detect silently failing push.apply
			arr[ preferredDoc.childNodes.length ].nodeType;
		} catch ( e ) {
			push = { apply: arr.length ?

				// Leverage slice if possible
				function( target, els ) {
					push_native.apply( target, slice.call(els) );
				} :

				// Support: IE<9
				// Otherwise append directly
				function( target, els ) {
					var j = target.length,
						i = 0;
					// Can't trust NodeList.length
					while ( (target[j++] = els[i++]) ) {}
					target.length = j - 1;
				}
			};
		}

		function Sizzle( selector, context, results, seed ) {
			var m, i, elem, nid, match, groups, newSelector,
				newContext = context && context.ownerDocument,

				// nodeType defaults to 9, since context defaults to document
				nodeType = context ? context.nodeType : 9;

			results = results || [];

			// Return early from calls with invalid selector or context
			if ( typeof selector !== "string" || !selector ||
				nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

				return results;
			}

			// Try to shortcut find operations (as opposed to filters) in HTML documents
			if ( !seed ) {

				if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
					setDocument( context );
				}
				context = context || document;

				if ( documentIsHTML ) {

					// If the selector is sufficiently simple, try using a "get*By*" DOM method
					// (excepting DocumentFragment context, where the methods don't exist)
					if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

						// ID selector
						if ( (m = match[1]) ) {

							// Document context
							if ( nodeType === 9 ) {
								if ( (elem = context.getElementById( m )) ) {

									// Support: IE, Opera, Webkit
									// TODO: identify versions
									// getElementById can match elements by name instead of ID
									if ( elem.id === m ) {
										results.push( elem );
										return results;
									}
								} else {
									return results;
								}

							// Element context
							} else {

								// Support: IE, Opera, Webkit
								// TODO: identify versions
								// getElementById can match elements by name instead of ID
								if ( newContext && (elem = newContext.getElementById( m )) &&
									contains( context, elem ) &&
									elem.id === m ) {

									results.push( elem );
									return results;
								}
							}

						// Type selector
						} else if ( match[2] ) {
							push.apply( results, context.getElementsByTagName( selector ) );
							return results;

						// Class selector
						} else if ( (m = match[3]) && support.getElementsByClassName &&
							context.getElementsByClassName ) {

							push.apply( results, context.getElementsByClassName( m ) );
							return results;
						}
					}

					// Take advantage of querySelectorAll
					if ( support.qsa &&
						!compilerCache[ selector + " " ] &&
						(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

						if ( nodeType !== 1 ) {
							newContext = context;
							newSelector = selector;

						// qSA looks outside Element context, which is not what we want
						// Thanks to Andrew Dupont for this workaround technique
						// Support: IE <=8
						// Exclude object elements
						} else if ( context.nodeName.toLowerCase() !== "object" ) {

							// Capture the context ID, setting it first if necessary
							if ( (nid = context.getAttribute( "id" )) ) {
								nid = nid.replace( rcssescape, fcssescape );
							} else {
								context.setAttribute( "id", (nid = expando) );
							}

							// Prefix every selector in the list
							groups = tokenize( selector );
							i = groups.length;
							while ( i-- ) {
								groups[i] = "#" + nid + " " + toSelector( groups[i] );
							}
							newSelector = groups.join( "," );

							// Expand context for sibling selectors
							newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
								context;
						}

						if ( newSelector ) {
							try {
								push.apply( results,
									newContext.querySelectorAll( newSelector )
								);
								return results;
							} catch ( qsaError ) {
							} finally {
								if ( nid === expando ) {
									context.removeAttribute( "id" );
								}
							}
						}
					}
				}
			}

			// All others
			return select( selector.replace( rtrim, "$1" ), context, results, seed );
		}

		/**
		 * Create key-value caches of limited size
		 * @returns {function(string, object)} Returns the Object data after storing it on itself with
		 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
		 *	deleting the oldest entry
		 */
		function createCache() {
			var keys = [];

			function cache( key, value ) {
				// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
				if ( keys.push( key + " " ) > Expr.cacheLength ) {
					// Only keep the most recent entries
					delete cache[ keys.shift() ];
				}
				return (cache[ key + " " ] = value);
			}
			return cache;
		}

		/**
		 * Mark a function for special use by Sizzle
		 * @param {Function} fn The function to mark
		 */
		function markFunction( fn ) {
			fn[ expando ] = true;
			return fn;
		}

		/**
		 * Support testing using an element
		 * @param {Function} fn Passed the created element and returns a boolean result
		 */
		function assert( fn ) {
			var el = document.createElement("fieldset");

			try {
				return !!fn( el );
			} catch (e) {
				return false;
			} finally {
				// Remove from its parent by default
				if ( el.parentNode ) {
					el.parentNode.removeChild( el );
				}
				// release memory in IE
				el = null;
			}
		}

		/**
		 * Adds the same handler for all of the specified attrs
		 * @param {String} attrs Pipe-separated list of attributes
		 * @param {Function} handler The method that will be applied
		 */
		function addHandle( attrs, handler ) {
			var arr = attrs.split("|"),
				i = arr.length;

			while ( i-- ) {
				Expr.attrHandle[ arr[i] ] = handler;
			}
		}

		/**
		 * Checks document order of two siblings
		 * @param {Element} a
		 * @param {Element} b
		 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
		 */
		function siblingCheck( a, b ) {
			var cur = b && a,
				diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
					a.sourceIndex - b.sourceIndex;

			// Use IE sourceIndex if available on both nodes
			if ( diff ) {
				return diff;
			}

			// Check if b follows a
			if ( cur ) {
				while ( (cur = cur.nextSibling) ) {
					if ( cur === b ) {
						return -1;
					}
				}
			}

			return a ? 1 : -1;
		}

		/**
		 * Returns a function to use in pseudos for input types
		 * @param {String} type
		 */
		function createInputPseudo( type ) {
			return function( elem ) {
				var name = elem.nodeName.toLowerCase();
				return name === "input" && elem.type === type;
			};
		}

		/**
		 * Returns a function to use in pseudos for buttons
		 * @param {String} type
		 */
		function createButtonPseudo( type ) {
			return function( elem ) {
				var name = elem.nodeName.toLowerCase();
				return (name === "input" || name === "button") && elem.type === type;
			};
		}

		/**
		 * Returns a function to use in pseudos for :enabled/:disabled
		 * @param {Boolean} disabled true for :disabled; false for :enabled
		 */
		function createDisabledPseudo( disabled ) {

			// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
			return function( elem ) {

				// Only certain elements can match :enabled or :disabled
				// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
				// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
				if ( "form" in elem ) {

					// Check for inherited disabledness on relevant non-disabled elements:
					// * listed form-associated elements in a disabled fieldset
					//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
					//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
					// * option elements in a disabled optgroup
					//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
					// All such elements have a "form" property.
					if ( elem.parentNode && elem.disabled === false ) {

						// Option elements defer to a parent optgroup if present
						if ( "label" in elem ) {
							if ( "label" in elem.parentNode ) {
								return elem.parentNode.disabled === disabled;
							} else {
								return elem.disabled === disabled;
							}
						}

						// Support: IE 6 - 11
						// Use the isDisabled shortcut property to check for disabled fieldset ancestors
						return elem.isDisabled === disabled ||

							// Where there is no isDisabled, check manually
							/* jshint -W018 */
							elem.isDisabled !== !disabled &&
								disabledAncestor( elem ) === disabled;
					}

					return elem.disabled === disabled;

				// Try to winnow out elements that can't be disabled before trusting the disabled property.
				// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
				// even exist on them, let alone have a boolean value.
				} else if ( "label" in elem ) {
					return elem.disabled === disabled;
				}

				// Remaining elements are neither :enabled nor :disabled
				return false;
			};
		}

		/**
		 * Returns a function to use in pseudos for positionals
		 * @param {Function} fn
		 */
		function createPositionalPseudo( fn ) {
			return markFunction(function( argument ) {
				argument = +argument;
				return markFunction(function( seed, matches ) {
					var j,
						matchIndexes = fn( [], seed.length, argument ),
						i = matchIndexes.length;

					// Match elements found at the specified indexes
					while ( i-- ) {
						if ( seed[ (j = matchIndexes[i]) ] ) {
							seed[j] = !(matches[j] = seed[j]);
						}
					}
				});
			});
		}

		/**
		 * Checks a node for validity as a Sizzle context
		 * @param {Element|Object=} context
		 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
		 */
		function testContext( context ) {
			return context && typeof context.getElementsByTagName !== "undefined" && context;
		}

		// Expose support vars for convenience
		support = Sizzle.support = {};

		/**
		 * Detects XML nodes
		 * @param {Element|Object} elem An element or a document
		 * @returns {Boolean} True iff elem is a non-HTML XML node
		 */
		isXML = Sizzle.isXML = function( elem ) {
			// documentElement is verified for cases where it doesn't yet exist
			// (such as loading iframes in IE - #4833)
			var documentElement = elem && (elem.ownerDocument || elem).documentElement;
			return documentElement ? documentElement.nodeName !== "HTML" : false;
		};

		/**
		 * Sets document-related variables once based on the current document
		 * @param {Element|Object} [doc] An element or document object to use to set the document
		 * @returns {Object} Returns the current document
		 */
		setDocument = Sizzle.setDocument = function( node ) {
			var hasCompare, subWindow,
				doc = node ? node.ownerDocument || node : preferredDoc;

			// Return early if doc is invalid or already selected
			if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
				return document;
			}

			// Update global variables
			document = doc;
			docElem = document.documentElement;
			documentIsHTML = !isXML( document );

			// Support: IE 9-11, Edge
			// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
			if ( preferredDoc !== document &&
				(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

				// Support: IE 11, Edge
				if ( subWindow.addEventListener ) {
					subWindow.addEventListener( "unload", unloadHandler, false );

				// Support: IE 9 - 10 only
				} else if ( subWindow.attachEvent ) {
					subWindow.attachEvent( "onunload", unloadHandler );
				}
			}

			/* Attributes
			---------------------------------------------------------------------- */

			// Support: IE<8
			// Verify that getAttribute really returns attributes and not properties
			// (excepting IE8 booleans)
			support.attributes = assert(function( el ) {
				el.className = "i";
				return !el.getAttribute("className");
			});

			/* getElement(s)By*
			---------------------------------------------------------------------- */

			// Check if getElementsByTagName("*") returns only elements
			support.getElementsByTagName = assert(function( el ) {
				el.appendChild( document.createComment("") );
				return !el.getElementsByTagName("*").length;
			});

			// Support: IE<9
			support.getElementsByClassName = rnative.test( document.getElementsByClassName );

			// Support: IE<10
			// Check if getElementById returns elements by name
			// The broken getElementById methods don't pick up programmatically-set names,
			// so use a roundabout getElementsByName test
			support.getById = assert(function( el ) {
				docElem.appendChild( el ).id = expando;
				return !document.getElementsByName || !document.getElementsByName( expando ).length;
			});

			// ID filter and find
			if ( support.getById ) {
				Expr.filter["ID"] = function( id ) {
					var attrId = id.replace( runescape, funescape );
					return function( elem ) {
						return elem.getAttribute("id") === attrId;
					};
				};
				Expr.find["ID"] = function( id, context ) {
					if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
						var elem = context.getElementById( id );
						return elem ? [ elem ] : [];
					}
				};
			} else {
				Expr.filter["ID"] =  function( id ) {
					var attrId = id.replace( runescape, funescape );
					return function( elem ) {
						var node = typeof elem.getAttributeNode !== "undefined" &&
							elem.getAttributeNode("id");
						return node && node.value === attrId;
					};
				};

				// Support: IE 6 - 7 only
				// getElementById is not reliable as a find shortcut
				Expr.find["ID"] = function( id, context ) {
					if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
						var node, i, elems,
							elem = context.getElementById( id );

						if ( elem ) {

							// Verify the id attribute
							node = elem.getAttributeNode("id");
							if ( node && node.value === id ) {
								return [ elem ];
							}

							// Fall back on getElementsByName
							elems = context.getElementsByName( id );
							i = 0;
							while ( (elem = elems[i++]) ) {
								node = elem.getAttributeNode("id");
								if ( node && node.value === id ) {
									return [ elem ];
								}
							}
						}

						return [];
					}
				};
			}

			// Tag
			Expr.find["TAG"] = support.getElementsByTagName ?
				function( tag, context ) {
					if ( typeof context.getElementsByTagName !== "undefined" ) {
						return context.getElementsByTagName( tag );

					// DocumentFragment nodes don't have gEBTN
					} else if ( support.qsa ) {
						return context.querySelectorAll( tag );
					}
				} :

				function( tag, context ) {
					var elem,
						tmp = [],
						i = 0,
						// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
						results = context.getElementsByTagName( tag );

					// Filter out possible comments
					if ( tag === "*" ) {
						while ( (elem = results[i++]) ) {
							if ( elem.nodeType === 1 ) {
								tmp.push( elem );
							}
						}

						return tmp;
					}
					return results;
				};

			// Class
			Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
				if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
					return context.getElementsByClassName( className );
				}
			};

			/* QSA/matchesSelector
			---------------------------------------------------------------------- */

			// QSA and matchesSelector support

			// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
			rbuggyMatches = [];

			// qSa(:focus) reports false when true (Chrome 21)
			// We allow this because of a bug in IE8/9 that throws an error
			// whenever `document.activeElement` is accessed on an iframe
			// So, we allow :focus to pass through QSA all the time to avoid the IE error
			// See https://bugs.jquery.com/ticket/13378
			rbuggyQSA = [];

			if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
				// Build QSA regex
				// Regex strategy adopted from Diego Perini
				assert(function( el ) {
					// Select is set to empty string on purpose
					// This is to test IE's treatment of not explicitly
					// setting a boolean content attribute,
					// since its presence should be enough
					// https://bugs.jquery.com/ticket/12359
					docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
						"<select id='" + expando + "-\r\\' msallowcapture=''>" +
						"<option selected=''></option></select>";

					// Support: IE8, Opera 11-12.16
					// Nothing should be selected when empty strings follow ^= or $= or *=
					// The test attribute must be unknown in Opera but "safe" for WinRT
					// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
					if ( el.querySelectorAll("[msallowcapture^='']").length ) {
						rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
					}

					// Support: IE8
					// Boolean attributes and "value" are not treated correctly
					if ( !el.querySelectorAll("[selected]").length ) {
						rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
					}

					// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
					if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
						rbuggyQSA.push("~=");
					}

					// Webkit/Opera - :checked should return selected option elements
					// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
					// IE8 throws error here and will not see later tests
					if ( !el.querySelectorAll(":checked").length ) {
						rbuggyQSA.push(":checked");
					}

					// Support: Safari 8+, iOS 8+
					// https://bugs.webkit.org/show_bug.cgi?id=136851
					// In-page `selector#id sibling-combinator selector` fails
					if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
						rbuggyQSA.push(".#.+[+~]");
					}
				});

				assert(function( el ) {
					el.innerHTML = "<a href='' disabled='disabled'></a>" +
						"<select disabled='disabled'><option/></select>";

					// Support: Windows 8 Native Apps
					// The type and name attributes are restricted during .innerHTML assignment
					var input = document.createElement("input");
					input.setAttribute( "type", "hidden" );
					el.appendChild( input ).setAttribute( "name", "D" );

					// Support: IE8
					// Enforce case-sensitivity of name attribute
					if ( el.querySelectorAll("[name=d]").length ) {
						rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
					}

					// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
					// IE8 throws error here and will not see later tests
					if ( el.querySelectorAll(":enabled").length !== 2 ) {
						rbuggyQSA.push( ":enabled", ":disabled" );
					}

					// Support: IE9-11+
					// IE's :disabled selector does not pick up the children of disabled fieldsets
					docElem.appendChild( el ).disabled = true;
					if ( el.querySelectorAll(":disabled").length !== 2 ) {
						rbuggyQSA.push( ":enabled", ":disabled" );
					}

					// Opera 10-11 does not throw on post-comma invalid pseudos
					el.querySelectorAll("*,:x");
					rbuggyQSA.push(",.*:");
				});
			}

			if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
				docElem.webkitMatchesSelector ||
				docElem.mozMatchesSelector ||
				docElem.oMatchesSelector ||
				docElem.msMatchesSelector) )) ) {

				assert(function( el ) {
					// Check to see if it's possible to do matchesSelector
					// on a disconnected node (IE 9)
					support.disconnectedMatch = matches.call( el, "*" );

					// This should fail with an exception
					// Gecko does not error, returns false instead
					matches.call( el, "[s!='']:x" );
					rbuggyMatches.push( "!=", pseudos );
				});
			}

			rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
			rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

			/* Contains
			---------------------------------------------------------------------- */
			hasCompare = rnative.test( docElem.compareDocumentPosition );

			// Element contains another
			// Purposefully self-exclusive
			// As in, an element does not contain itself
			contains = hasCompare || rnative.test( docElem.contains ) ?
				function( a, b ) {
					var adown = a.nodeType === 9 ? a.documentElement : a,
						bup = b && b.parentNode;
					return a === bup || !!( bup && bup.nodeType === 1 && (
						adown.contains ?
							adown.contains( bup ) :
							a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
					));
				} :
				function( a, b ) {
					if ( b ) {
						while ( (b = b.parentNode) ) {
							if ( b === a ) {
								return true;
							}
						}
					}
					return false;
				};

			/* Sorting
			---------------------------------------------------------------------- */

			// Document order sorting
			sortOrder = hasCompare ?
			function( a, b ) {

				// Flag for duplicate removal
				if ( a === b ) {
					hasDuplicate = true;
					return 0;
				}

				// Sort on method existence if only one input has compareDocumentPosition
				var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
				if ( compare ) {
					return compare;
				}

				// Calculate position if both inputs belong to the same document
				compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
					a.compareDocumentPosition( b ) :

					// Otherwise we know they are disconnected
					1;

				// Disconnected nodes
				if ( compare & 1 ||
					(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

					// Choose the first element that is related to our preferred document
					if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
						return -1;
					}
					if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
						return 1;
					}

					// Maintain original order
					return sortInput ?
						( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
						0;
				}

				return compare & 4 ? -1 : 1;
			} :
			function( a, b ) {
				// Exit early if the nodes are identical
				if ( a === b ) {
					hasDuplicate = true;
					return 0;
				}

				var cur,
					i = 0,
					aup = a.parentNode,
					bup = b.parentNode,
					ap = [ a ],
					bp = [ b ];

				// Parentless nodes are either documents or disconnected
				if ( !aup || !bup ) {
					return a === document ? -1 :
						b === document ? 1 :
						aup ? -1 :
						bup ? 1 :
						sortInput ?
						( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
						0;

				// If the nodes are siblings, we can do a quick check
				} else if ( aup === bup ) {
					return siblingCheck( a, b );
				}

				// Otherwise we need full lists of their ancestors for comparison
				cur = a;
				while ( (cur = cur.parentNode) ) {
					ap.unshift( cur );
				}
				cur = b;
				while ( (cur = cur.parentNode) ) {
					bp.unshift( cur );
				}

				// Walk down the tree looking for a discrepancy
				while ( ap[i] === bp[i] ) {
					i++;
				}

				return i ?
					// Do a sibling check if the nodes have a common ancestor
					siblingCheck( ap[i], bp[i] ) :

					// Otherwise nodes in our document sort first
					ap[i] === preferredDoc ? -1 :
					bp[i] === preferredDoc ? 1 :
					0;
			};

			return document;
		};

		Sizzle.matches = function( expr, elements ) {
			return Sizzle( expr, null, null, elements );
		};

		Sizzle.matchesSelector = function( elem, expr ) {
			// Set document vars if needed
			if ( ( elem.ownerDocument || elem ) !== document ) {
				setDocument( elem );
			}

			// Make sure that attribute selectors are quoted
			expr = expr.replace( rattributeQuotes, "='$1']" );

			if ( support.matchesSelector && documentIsHTML &&
				!compilerCache[ expr + " " ] &&
				( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
				( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

				try {
					var ret = matches.call( elem, expr );

					// IE 9's matchesSelector returns false on disconnected nodes
					if ( ret || support.disconnectedMatch ||
							// As well, disconnected nodes are said to be in a document
							// fragment in IE 9
							elem.document && elem.document.nodeType !== 11 ) {
						return ret;
					}
				} catch (e) {}
			}

			return Sizzle( expr, document, null, [ elem ] ).length > 0;
		};

		Sizzle.contains = function( context, elem ) {
			// Set document vars if needed
			if ( ( context.ownerDocument || context ) !== document ) {
				setDocument( context );
			}
			return contains( context, elem );
		};

		Sizzle.attr = function( elem, name ) {
			// Set document vars if needed
			if ( ( elem.ownerDocument || elem ) !== document ) {
				setDocument( elem );
			}

			var fn = Expr.attrHandle[ name.toLowerCase() ],
				// Don't get fooled by Object.prototype properties (jQuery #13807)
				val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
					fn( elem, name, !documentIsHTML ) :
					undefined;

			return val !== undefined ?
				val :
				support.attributes || !documentIsHTML ?
					elem.getAttribute( name ) :
					(val = elem.getAttributeNode(name)) && val.specified ?
						val.value :
						null;
		};

		Sizzle.escape = function( sel ) {
			return (sel + "").replace( rcssescape, fcssescape );
		};

		Sizzle.error = function( msg ) {
			throw new Error( "Syntax error, unrecognized expression: " + msg );
		};

		/**
		 * Document sorting and removing duplicates
		 * @param {ArrayLike} results
		 */
		Sizzle.uniqueSort = function( results ) {
			var elem,
				duplicates = [],
				j = 0,
				i = 0;

			// Unless we *know* we can detect duplicates, assume their presence
			hasDuplicate = !support.detectDuplicates;
			sortInput = !support.sortStable && results.slice( 0 );
			results.sort( sortOrder );

			if ( hasDuplicate ) {
				while ( (elem = results[i++]) ) {
					if ( elem === results[ i ] ) {
						j = duplicates.push( i );
					}
				}
				while ( j-- ) {
					results.splice( duplicates[ j ], 1 );
				}
			}

			// Clear input after sorting to release objects
			// See https://github.com/jquery/sizzle/pull/225
			sortInput = null;

			return results;
		};

		/**
		 * Utility function for retrieving the text value of an array of DOM nodes
		 * @param {Array|Element} elem
		 */
		getText = Sizzle.getText = function( elem ) {
			var node,
				ret = "",
				i = 0,
				nodeType = elem.nodeType;

			if ( !nodeType ) {
				// If no nodeType, this is expected to be an array
				while ( (node = elem[i++]) ) {
					// Do not traverse comment nodes
					ret += getText( node );
				}
			} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
				// Use textContent for elements
				// innerText usage removed for consistency of new lines (jQuery #11153)
				if ( typeof elem.textContent === "string" ) {
					return elem.textContent;
				} else {
					// Traverse its children
					for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
						ret += getText( elem );
					}
				}
			} else if ( nodeType === 3 || nodeType === 4 ) {
				return elem.nodeValue;
			}
			// Do not include comment or processing instruction nodes

			return ret;
		};

		Expr = Sizzle.selectors = {

			// Can be adjusted by the user
			cacheLength: 50,

			createPseudo: markFunction,

			match: matchExpr,

			attrHandle: {},

			find: {},

			relative: {
				">": { dir: "parentNode", first: true },
				" ": { dir: "parentNode" },
				"+": { dir: "previousSibling", first: true },
				"~": { dir: "previousSibling" }
			},

			preFilter: {
				"ATTR": function( match ) {
					match[1] = match[1].replace( runescape, funescape );

					// Move the given value to match[3] whether quoted or unquoted
					match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

					if ( match[2] === "~=" ) {
						match[3] = " " + match[3] + " ";
					}

					return match.slice( 0, 4 );
				},

				"CHILD": function( match ) {
					/* matches from matchExpr["CHILD"]
						1 type (only|nth|...)
						2 what (child|of-type)
						3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
						4 xn-component of xn+y argument ([+-]?\d*n|)
						5 sign of xn-component
						6 x of xn-component
						7 sign of y-component
						8 y of y-component
					*/
					match[1] = match[1].toLowerCase();

					if ( match[1].slice( 0, 3 ) === "nth" ) {
						// nth-* requires argument
						if ( !match[3] ) {
							Sizzle.error( match[0] );
						}

						// numeric x and y parameters for Expr.filter.CHILD
						// remember that false/true cast respectively to 0/1
						match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
						match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

					// other types prohibit arguments
					} else if ( match[3] ) {
						Sizzle.error( match[0] );
					}

					return match;
				},

				"PSEUDO": function( match ) {
					var excess,
						unquoted = !match[6] && match[2];

					if ( matchExpr["CHILD"].test( match[0] ) ) {
						return null;
					}

					// Accept quoted arguments as-is
					if ( match[3] ) {
						match[2] = match[4] || match[5] || "";

					// Strip excess characters from unquoted arguments
					} else if ( unquoted && rpseudo.test( unquoted ) &&
						// Get excess from tokenize (recursively)
						(excess = tokenize( unquoted, true )) &&
						// advance to the next closing parenthesis
						(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

						// excess is a negative index
						match[0] = match[0].slice( 0, excess );
						match[2] = unquoted.slice( 0, excess );
					}

					// Return only captures needed by the pseudo filter method (type and argument)
					return match.slice( 0, 3 );
				}
			},

			filter: {

				"TAG": function( nodeNameSelector ) {
					var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
					return nodeNameSelector === "*" ?
						function() { return true; } :
						function( elem ) {
							return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
						};
				},

				"CLASS": function( className ) {
					var pattern = classCache[ className + " " ];

					return pattern ||
						(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
						classCache( className, function( elem ) {
							return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
						});
				},

				"ATTR": function( name, operator, check ) {
					return function( elem ) {
						var result = Sizzle.attr( elem, name );

						if ( result == null ) {
							return operator === "!=";
						}
						if ( !operator ) {
							return true;
						}

						result += "";

						return operator === "=" ? result === check :
							operator === "!=" ? result !== check :
							operator === "^=" ? check && result.indexOf( check ) === 0 :
							operator === "*=" ? check && result.indexOf( check ) > -1 :
							operator === "$=" ? check && result.slice( -check.length ) === check :
							operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
							operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
							false;
					};
				},

				"CHILD": function( type, what, argument, first, last ) {
					var simple = type.slice( 0, 3 ) !== "nth",
						forward = type.slice( -4 ) !== "last",
						ofType = what === "of-type";

					return first === 1 && last === 0 ?

						// Shortcut for :nth-*(n)
						function( elem ) {
							return !!elem.parentNode;
						} :

						function( elem, context, xml ) {
							var cache, uniqueCache, outerCache, node, nodeIndex, start,
								dir = simple !== forward ? "nextSibling" : "previousSibling",
								parent = elem.parentNode,
								name = ofType && elem.nodeName.toLowerCase(),
								useCache = !xml && !ofType,
								diff = false;

							if ( parent ) {

								// :(first|last|only)-(child|of-type)
								if ( simple ) {
									while ( dir ) {
										node = elem;
										while ( (node = node[ dir ]) ) {
											if ( ofType ?
												node.nodeName.toLowerCase() === name :
												node.nodeType === 1 ) {

												return false;
											}
										}
										// Reverse direction for :only-* (if we haven't yet done so)
										start = dir = type === "only" && !start && "nextSibling";
									}
									return true;
								}

								start = [ forward ? parent.firstChild : parent.lastChild ];

								// non-xml :nth-child(...) stores cache data on `parent`
								if ( forward && useCache ) {

									// Seek `elem` from a previously-cached index

									// ...in a gzip-friendly way
									node = parent;
									outerCache = node[ expando ] || (node[ expando ] = {});

									// Support: IE <9 only
									// Defend against cloned attroperties (jQuery gh-1709)
									uniqueCache = outerCache[ node.uniqueID ] ||
										(outerCache[ node.uniqueID ] = {});

									cache = uniqueCache[ type ] || [];
									nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
									diff = nodeIndex && cache[ 2 ];
									node = nodeIndex && parent.childNodes[ nodeIndex ];

									while ( (node = ++nodeIndex && node && node[ dir ] ||

										// Fallback to seeking `elem` from the start
										(diff = nodeIndex = 0) || start.pop()) ) {

										// When found, cache indexes on `parent` and break
										if ( node.nodeType === 1 && ++diff && node === elem ) {
											uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
											break;
										}
									}

								} else {
									// Use previously-cached element index if available
									if ( useCache ) {
										// ...in a gzip-friendly way
										node = elem;
										outerCache = node[ expando ] || (node[ expando ] = {});

										// Support: IE <9 only
										// Defend against cloned attroperties (jQuery gh-1709)
										uniqueCache = outerCache[ node.uniqueID ] ||
											(outerCache[ node.uniqueID ] = {});

										cache = uniqueCache[ type ] || [];
										nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
										diff = nodeIndex;
									}

									// xml :nth-child(...)
									// or :nth-last-child(...) or :nth(-last)?-of-type(...)
									if ( diff === false ) {
										// Use the same loop as above to seek `elem` from the start
										while ( (node = ++nodeIndex && node && node[ dir ] ||
											(diff = nodeIndex = 0) || start.pop()) ) {

											if ( ( ofType ?
												node.nodeName.toLowerCase() === name :
												node.nodeType === 1 ) &&
												++diff ) {

												// Cache the index of each encountered element
												if ( useCache ) {
													outerCache = node[ expando ] || (node[ expando ] = {});

													// Support: IE <9 only
													// Defend against cloned attroperties (jQuery gh-1709)
													uniqueCache = outerCache[ node.uniqueID ] ||
														(outerCache[ node.uniqueID ] = {});

													uniqueCache[ type ] = [ dirruns, diff ];
												}

												if ( node === elem ) {
													break;
												}
											}
										}
									}
								}

								// Incorporate the offset, then check against cycle size
								diff -= last;
								return diff === first || ( diff % first === 0 && diff / first >= 0 );
							}
						};
				},

				"PSEUDO": function( pseudo, argument ) {
					// pseudo-class names are case-insensitive
					// http://www.w3.org/TR/selectors/#pseudo-classes
					// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
					// Remember that setFilters inherits from pseudos
					var args,
						fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
							Sizzle.error( "unsupported pseudo: " + pseudo );

					// The user may use createPseudo to indicate that
					// arguments are needed to create the filter function
					// just as Sizzle does
					if ( fn[ expando ] ) {
						return fn( argument );
					}

					// But maintain support for old signatures
					if ( fn.length > 1 ) {
						args = [ pseudo, pseudo, "", argument ];
						return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
							markFunction(function( seed, matches ) {
								var idx,
									matched = fn( seed, argument ),
									i = matched.length;
								while ( i-- ) {
									idx = indexOf( seed, matched[i] );
									seed[ idx ] = !( matches[ idx ] = matched[i] );
								}
							}) :
							function( elem ) {
								return fn( elem, 0, args );
							};
					}

					return fn;
				}
			},

			pseudos: {
				// Potentially complex pseudos
				"not": markFunction(function( selector ) {
					// Trim the selector passed to compile
					// to avoid treating leading and trailing
					// spaces as combinators
					var input = [],
						results = [],
						matcher = compile( selector.replace( rtrim, "$1" ) );

					return matcher[ expando ] ?
						markFunction(function( seed, matches, context, xml ) {
							var elem,
								unmatched = matcher( seed, null, xml, [] ),
								i = seed.length;

							// Match elements unmatched by `matcher`
							while ( i-- ) {
								if ( (elem = unmatched[i]) ) {
									seed[i] = !(matches[i] = elem);
								}
							}
						}) :
						function( elem, context, xml ) {
							input[0] = elem;
							matcher( input, null, xml, results );
							// Don't keep the element (issue #299)
							input[0] = null;
							return !results.pop();
						};
				}),

				"has": markFunction(function( selector ) {
					return function( elem ) {
						return Sizzle( selector, elem ).length > 0;
					};
				}),

				"contains": markFunction(function( text ) {
					text = text.replace( runescape, funescape );
					return function( elem ) {
						return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
					};
				}),

				// "Whether an element is represented by a :lang() selector
				// is based solely on the element's language value
				// being equal to the identifier C,
				// or beginning with the identifier C immediately followed by "-".
				// The matching of C against the element's language value is performed case-insensitively.
				// The identifier C does not have to be a valid language name."
				// http://www.w3.org/TR/selectors/#lang-pseudo
				"lang": markFunction( function( lang ) {
					// lang value must be a valid identifier
					if ( !ridentifier.test(lang || "") ) {
						Sizzle.error( "unsupported lang: " + lang );
					}
					lang = lang.replace( runescape, funescape ).toLowerCase();
					return function( elem ) {
						var elemLang;
						do {
							if ( (elemLang = documentIsHTML ?
								elem.lang :
								elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

								elemLang = elemLang.toLowerCase();
								return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
							}
						} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
						return false;
					};
				}),

				// Miscellaneous
				"target": function( elem ) {
					var hash = window.location && window.location.hash;
					return hash && hash.slice( 1 ) === elem.id;
				},

				"root": function( elem ) {
					return elem === docElem;
				},

				"focus": function( elem ) {
					return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
				},

				// Boolean properties
				"enabled": createDisabledPseudo( false ),
				"disabled": createDisabledPseudo( true ),

				"checked": function( elem ) {
					// In CSS3, :checked should return both checked and selected elements
					// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
					var nodeName = elem.nodeName.toLowerCase();
					return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
				},

				"selected": function( elem ) {
					// Accessing this property makes selected-by-default
					// options in Safari work properly
					if ( elem.parentNode ) {
						elem.parentNode.selectedIndex;
					}

					return elem.selected === true;
				},

				// Contents
				"empty": function( elem ) {
					// http://www.w3.org/TR/selectors/#empty-pseudo
					// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
					//   but not by others (comment: 8; processing instruction: 7; etc.)
					// nodeType < 6 works because attributes (2) do not appear as children
					for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
						if ( elem.nodeType < 6 ) {
							return false;
						}
					}
					return true;
				},

				"parent": function( elem ) {
					return !Expr.pseudos["empty"]( elem );
				},

				// Element/input types
				"header": function( elem ) {
					return rheader.test( elem.nodeName );
				},

				"input": function( elem ) {
					return rinputs.test( elem.nodeName );
				},

				"button": function( elem ) {
					var name = elem.nodeName.toLowerCase();
					return name === "input" && elem.type === "button" || name === "button";
				},

				"text": function( elem ) {
					var attr;
					return elem.nodeName.toLowerCase() === "input" &&
						elem.type === "text" &&

						// Support: IE<8
						// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
						( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
				},

				// Position-in-collection
				"first": createPositionalPseudo(function() {
					return [ 0 ];
				}),

				"last": createPositionalPseudo(function( matchIndexes, length ) {
					return [ length - 1 ];
				}),

				"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
					return [ argument < 0 ? argument + length : argument ];
				}),

				"even": createPositionalPseudo(function( matchIndexes, length ) {
					var i = 0;
					for ( ; i < length; i += 2 ) {
						matchIndexes.push( i );
					}
					return matchIndexes;
				}),

				"odd": createPositionalPseudo(function( matchIndexes, length ) {
					var i = 1;
					for ( ; i < length; i += 2 ) {
						matchIndexes.push( i );
					}
					return matchIndexes;
				}),

				"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
					var i = argument < 0 ? argument + length : argument;
					for ( ; --i >= 0; ) {
						matchIndexes.push( i );
					}
					return matchIndexes;
				}),

				"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
					var i = argument < 0 ? argument + length : argument;
					for ( ; ++i < length; ) {
						matchIndexes.push( i );
					}
					return matchIndexes;
				})
			}
		};

		Expr.pseudos["nth"] = Expr.pseudos["eq"];

		// Add button/input type pseudos
		for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
			Expr.pseudos[ i ] = createInputPseudo( i );
		}
		for ( i in { submit: true, reset: true } ) {
			Expr.pseudos[ i ] = createButtonPseudo( i );
		}

		// Easy API for creating new setFilters
		function setFilters() {}
		setFilters.prototype = Expr.filters = Expr.pseudos;
		Expr.setFilters = new setFilters();

		tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
			var matched, match, tokens, type,
				soFar, groups, preFilters,
				cached = tokenCache[ selector + " " ];

			if ( cached ) {
				return parseOnly ? 0 : cached.slice( 0 );
			}

			soFar = selector;
			groups = [];
			preFilters = Expr.preFilter;

			while ( soFar ) {

				// Comma and first run
				if ( !matched || (match = rcomma.exec( soFar )) ) {
					if ( match ) {
						// Don't consume trailing commas as valid
						soFar = soFar.slice( match[0].length ) || soFar;
					}
					groups.push( (tokens = []) );
				}

				matched = false;

				// Combinators
				if ( (match = rcombinators.exec( soFar )) ) {
					matched = match.shift();
					tokens.push({
						value: matched,
						// Cast descendant combinators to space
						type: match[0].replace( rtrim, " " )
					});
					soFar = soFar.slice( matched.length );
				}

				// Filters
				for ( type in Expr.filter ) {
					if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
						(match = preFilters[ type ]( match ))) ) {
						matched = match.shift();
						tokens.push({
							value: matched,
							type: type,
							matches: match
						});
						soFar = soFar.slice( matched.length );
					}
				}

				if ( !matched ) {
					break;
				}
			}

			// Return the length of the invalid excess
			// if we're just parsing
			// Otherwise, throw an error or return tokens
			return parseOnly ?
				soFar.length :
				soFar ?
					Sizzle.error( selector ) :
					// Cache the tokens
					tokenCache( selector, groups ).slice( 0 );
		};

		function toSelector( tokens ) {
			var i = 0,
				len = tokens.length,
				selector = "";
			for ( ; i < len; i++ ) {
				selector += tokens[i].value;
			}
			return selector;
		}

		function addCombinator( matcher, combinator, base ) {
			var dir = combinator.dir,
				skip = combinator.next,
				key = skip || dir,
				checkNonElements = base && key === "parentNode",
				doneName = done++;

			return combinator.first ?
				// Check against closest ancestor/preceding element
				function( elem, context, xml ) {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							return matcher( elem, context, xml );
						}
					}
					return false;
				} :

				// Check against all ancestor/preceding elements
				function( elem, context, xml ) {
					var oldCache, uniqueCache, outerCache,
						newCache = [ dirruns, doneName ];

					// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
					if ( xml ) {
						while ( (elem = elem[ dir ]) ) {
							if ( elem.nodeType === 1 || checkNonElements ) {
								if ( matcher( elem, context, xml ) ) {
									return true;
								}
							}
						}
					} else {
						while ( (elem = elem[ dir ]) ) {
							if ( elem.nodeType === 1 || checkNonElements ) {
								outerCache = elem[ expando ] || (elem[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

								if ( skip && skip === elem.nodeName.toLowerCase() ) {
									elem = elem[ dir ] || elem;
								} else if ( (oldCache = uniqueCache[ key ]) &&
									oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

									// Assign to newCache so results back-propagate to previous elements
									return (newCache[ 2 ] = oldCache[ 2 ]);
								} else {
									// Reuse newcache so results back-propagate to previous elements
									uniqueCache[ key ] = newCache;

									// A match means we're done; a fail means we have to keep checking
									if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
										return true;
									}
								}
							}
						}
					}
					return false;
				};
		}

		function elementMatcher( matchers ) {
			return matchers.length > 1 ?
				function( elem, context, xml ) {
					var i = matchers.length;
					while ( i-- ) {
						if ( !matchers[i]( elem, context, xml ) ) {
							return false;
						}
					}
					return true;
				} :
				matchers[0];
		}

		function multipleContexts( selector, contexts, results ) {
			var i = 0,
				len = contexts.length;
			for ( ; i < len; i++ ) {
				Sizzle( selector, contexts[i], results );
			}
			return results;
		}

		function condense( unmatched, map, filter, context, xml ) {
			var elem,
				newUnmatched = [],
				i = 0,
				len = unmatched.length,
				mapped = map != null;

			for ( ; i < len; i++ ) {
				if ( (elem = unmatched[i]) ) {
					if ( !filter || filter( elem, context, xml ) ) {
						newUnmatched.push( elem );
						if ( mapped ) {
							map.push( i );
						}
					}
				}
			}

			return newUnmatched;
		}

		function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
			if ( postFilter && !postFilter[ expando ] ) {
				postFilter = setMatcher( postFilter );
			}
			if ( postFinder && !postFinder[ expando ] ) {
				postFinder = setMatcher( postFinder, postSelector );
			}
			return markFunction(function( seed, results, context, xml ) {
				var temp, i, elem,
					preMap = [],
					postMap = [],
					preexisting = results.length,

					// Get initial elements from seed or context
					elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

					// Prefilter to get matcher input, preserving a map for seed-results synchronization
					matcherIn = preFilter && ( seed || !selector ) ?
						condense( elems, preMap, preFilter, context, xml ) :
						elems,

					matcherOut = matcher ?
						// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
						postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

							// ...intermediate processing is necessary
							[] :

							// ...otherwise use results directly
							results :
						matcherIn;

				// Find primary matches
				if ( matcher ) {
					matcher( matcherIn, matcherOut, context, xml );
				}

				// Apply postFilter
				if ( postFilter ) {
					temp = condense( matcherOut, postMap );
					postFilter( temp, [], context, xml );

					// Un-match failing elements by moving them back to matcherIn
					i = temp.length;
					while ( i-- ) {
						if ( (elem = temp[i]) ) {
							matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
						}
					}
				}

				if ( seed ) {
					if ( postFinder || preFilter ) {
						if ( postFinder ) {
							// Get the final matcherOut by condensing this intermediate into postFinder contexts
							temp = [];
							i = matcherOut.length;
							while ( i-- ) {
								if ( (elem = matcherOut[i]) ) {
									// Restore matcherIn since elem is not yet a final match
									temp.push( (matcherIn[i] = elem) );
								}
							}
							postFinder( null, (matcherOut = []), temp, xml );
						}

						// Move matched elements from seed to results to keep them synchronized
						i = matcherOut.length;
						while ( i-- ) {
							if ( (elem = matcherOut[i]) &&
								(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

								seed[temp] = !(results[temp] = elem);
							}
						}
					}

				// Add elements to results, through postFinder if defined
				} else {
					matcherOut = condense(
						matcherOut === results ?
							matcherOut.splice( preexisting, matcherOut.length ) :
							matcherOut
					);
					if ( postFinder ) {
						postFinder( null, results, matcherOut, xml );
					} else {
						push.apply( results, matcherOut );
					}
				}
			});
		}

		function matcherFromTokens( tokens ) {
			var checkContext, matcher, j,
				len = tokens.length,
				leadingRelative = Expr.relative[ tokens[0].type ],
				implicitRelative = leadingRelative || Expr.relative[" "],
				i = leadingRelative ? 1 : 0,

				// The foundational matcher ensures that elements are reachable from top-level context(s)
				matchContext = addCombinator( function( elem ) {
					return elem === checkContext;
				}, implicitRelative, true ),
				matchAnyContext = addCombinator( function( elem ) {
					return indexOf( checkContext, elem ) > -1;
				}, implicitRelative, true ),
				matchers = [ function( elem, context, xml ) {
					var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
						(checkContext = context).nodeType ?
							matchContext( elem, context, xml ) :
							matchAnyContext( elem, context, xml ) );
					// Avoid hanging onto element (issue #299)
					checkContext = null;
					return ret;
				} ];

			for ( ; i < len; i++ ) {
				if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
					matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
				} else {
					matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

					// Return special upon seeing a positional matcher
					if ( matcher[ expando ] ) {
						// Find the next relative operator (if any) for proper handling
						j = ++i;
						for ( ; j < len; j++ ) {
							if ( Expr.relative[ tokens[j].type ] ) {
								break;
							}
						}
						return setMatcher(
							i > 1 && elementMatcher( matchers ),
							i > 1 && toSelector(
								// If the preceding token was a descendant combinator, insert an implicit any-element `*`
								tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
							).replace( rtrim, "$1" ),
							matcher,
							i < j && matcherFromTokens( tokens.slice( i, j ) ),
							j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
							j < len && toSelector( tokens )
						);
					}
					matchers.push( matcher );
				}
			}

			return elementMatcher( matchers );
		}

		function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
			var bySet = setMatchers.length > 0,
				byElement = elementMatchers.length > 0,
				superMatcher = function( seed, context, xml, results, outermost ) {
					var elem, j, matcher,
						matchedCount = 0,
						i = "0",
						unmatched = seed && [],
						setMatched = [],
						contextBackup = outermostContext,
						// We must always have either seed elements or outermost context
						elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
						// Use integer dirruns iff this is the outermost matcher
						dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
						len = elems.length;

					if ( outermost ) {
						outermostContext = context === document || context || outermost;
					}

					// Add elements passing elementMatchers directly to results
					// Support: IE<9, Safari
					// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
					for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
						if ( byElement && elem ) {
							j = 0;
							if ( !context && elem.ownerDocument !== document ) {
								setDocument( elem );
								xml = !documentIsHTML;
							}
							while ( (matcher = elementMatchers[j++]) ) {
								if ( matcher( elem, context || document, xml) ) {
									results.push( elem );
									break;
								}
							}
							if ( outermost ) {
								dirruns = dirrunsUnique;
							}
						}

						// Track unmatched elements for set filters
						if ( bySet ) {
							// They will have gone through all possible matchers
							if ( (elem = !matcher && elem) ) {
								matchedCount--;
							}

							// Lengthen the array for every element, matched or not
							if ( seed ) {
								unmatched.push( elem );
							}
						}
					}

					// `i` is now the count of elements visited above, and adding it to `matchedCount`
					// makes the latter nonnegative.
					matchedCount += i;

					// Apply set filters to unmatched elements
					// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
					// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
					// no element matchers and no seed.
					// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
					// case, which will result in a "00" `matchedCount` that differs from `i` but is also
					// numerically zero.
					if ( bySet && i !== matchedCount ) {
						j = 0;
						while ( (matcher = setMatchers[j++]) ) {
							matcher( unmatched, setMatched, context, xml );
						}

						if ( seed ) {
							// Reintegrate element matches to eliminate the need for sorting
							if ( matchedCount > 0 ) {
								while ( i-- ) {
									if ( !(unmatched[i] || setMatched[i]) ) {
										setMatched[i] = pop.call( results );
									}
								}
							}

							// Discard index placeholder values to get only actual matches
							setMatched = condense( setMatched );
						}

						// Add matches to results
						push.apply( results, setMatched );

						// Seedless set matches succeeding multiple successful matchers stipulate sorting
						if ( outermost && !seed && setMatched.length > 0 &&
							( matchedCount + setMatchers.length ) > 1 ) {

							Sizzle.uniqueSort( results );
						}
					}

					// Override manipulation of globals by nested matchers
					if ( outermost ) {
						dirruns = dirrunsUnique;
						outermostContext = contextBackup;
					}

					return unmatched;
				};

			return bySet ?
				markFunction( superMatcher ) :
				superMatcher;
		}

		compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
			var i,
				setMatchers = [],
				elementMatchers = [],
				cached = compilerCache[ selector + " " ];

			if ( !cached ) {
				// Generate a function of recursive functions that can be used to check each element
				if ( !match ) {
					match = tokenize( selector );
				}
				i = match.length;
				while ( i-- ) {
					cached = matcherFromTokens( match[i] );
					if ( cached[ expando ] ) {
						setMatchers.push( cached );
					} else {
						elementMatchers.push( cached );
					}
				}

				// Cache the compiled function
				cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

				// Save selector and tokenization
				cached.selector = selector;
			}
			return cached;
		};

		/**
		 * A low-level selection function that works with Sizzle's compiled
		 *  selector functions
		 * @param {String|Function} selector A selector or a pre-compiled
		 *  selector function built with Sizzle.compile
		 * @param {Element} context
		 * @param {Array} [results]
		 * @param {Array} [seed] A set of elements to match against
		 */
		select = Sizzle.select = function( selector, context, results, seed ) {
			var i, tokens, token, type, find,
				compiled = typeof selector === "function" && selector,
				match = !seed && tokenize( (selector = compiled.selector || selector) );

			results = results || [];

			// Try to minimize operations if there is only one selector in the list and no seed
			// (the latter of which guarantees us context)
			if ( match.length === 1 ) {

				// Reduce context if the leading compound selector is an ID
				tokens = match[0] = match[0].slice( 0 );
				if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
						context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {

					context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
					if ( !context ) {
						return results;

					// Precompiled matchers will still verify ancestry, so step up a level
					} else if ( compiled ) {
						context = context.parentNode;
					}

					selector = selector.slice( tokens.shift().value.length );
				}

				// Fetch a seed set for right-to-left matching
				i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
				while ( i-- ) {
					token = tokens[i];

					// Abort if we hit a combinator
					if ( Expr.relative[ (type = token.type) ] ) {
						break;
					}
					if ( (find = Expr.find[ type ]) ) {
						// Search, expanding context for leading sibling combinators
						if ( (seed = find(
							token.matches[0].replace( runescape, funescape ),
							rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
						)) ) {

							// If seed is empty or no tokens remain, we can return early
							tokens.splice( i, 1 );
							selector = seed.length && toSelector( tokens );
							if ( !selector ) {
								push.apply( results, seed );
								return results;
							}

							break;
						}
					}
				}
			}

			// Compile and execute a filtering function if one is not provided
			// Provide `match` to avoid retokenization if we modified the selector above
			( compiled || compile( selector, match ) )(
				seed,
				context,
				!documentIsHTML,
				results,
				!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
			);
			return results;
		};

		// One-time assignments

		// Sort stability
		support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

		// Support: Chrome 14-35+
		// Always assume duplicates if they aren't passed to the comparison function
		support.detectDuplicates = !!hasDuplicate;

		// Initialize against the default document
		setDocument();

		// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
		// Detached nodes confoundingly follow *each other*
		support.sortDetached = assert(function( el ) {
			// Should return 1, but returns 4 (following)
			return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
		});

		// Support: IE<8
		// Prevent attribute/property "interpolation"
		// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
		if ( !assert(function( el ) {
			el.innerHTML = "<a href='#'></a>";
			return el.firstChild.getAttribute("href") === "#" ;
		}) ) {
			addHandle( "type|href|height|width", function( elem, name, isXML ) {
				if ( !isXML ) {
					return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
				}
			});
		}

		// Support: IE<9
		// Use defaultValue in place of getAttribute("value")
		if ( !support.attributes || !assert(function( el ) {
			el.innerHTML = "<input/>";
			el.firstChild.setAttribute( "value", "" );
			return el.firstChild.getAttribute( "value" ) === "";
		}) ) {
			addHandle( "value", function( elem, name, isXML ) {
				if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
					return elem.defaultValue;
				}
			});
		}

		// Support: IE<9
		// Use getAttributeNode to fetch booleans when getAttribute lies
		if ( !assert(function( el ) {
			return el.getAttribute("disabled") == null;
		}) ) {
			addHandle( booleans, function( elem, name, isXML ) {
				var val;
				if ( !isXML ) {
					return elem[ name ] === true ? name.toLowerCase() :
							(val = elem.getAttributeNode( name )) && val.specified ?
							val.value :
						null;
				}
			});
		}

		return Sizzle;

		})( window );



		jQuery.find = Sizzle;
		jQuery.expr = Sizzle.selectors;

		// Deprecated
		jQuery.expr[ ":" ] = jQuery.expr.pseudos;
		jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
		jQuery.text = Sizzle.getText;
		jQuery.isXMLDoc = Sizzle.isXML;
		jQuery.contains = Sizzle.contains;
		jQuery.escapeSelector = Sizzle.escape;




		var dir = function( elem, dir, until ) {
			var matched = [],
				truncate = until !== undefined;

			while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
				if ( elem.nodeType === 1 ) {
					if ( truncate && jQuery( elem ).is( until ) ) {
						break;
					}
					matched.push( elem );
				}
			}
			return matched;
		};


		var siblings = function( n, elem ) {
			var matched = [];

			for ( ; n; n = n.nextSibling ) {
				if ( n.nodeType === 1 && n !== elem ) {
					matched.push( n );
				}
			}

			return matched;
		};


		var rneedsContext = jQuery.expr.match.needsContext;

		var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



		var risSimple = /^.[^:#\[\.,]*$/;

		// Implement the identical functionality for filter and not
		function winnow( elements, qualifier, not ) {
			if ( jQuery.isFunction( qualifier ) ) {
				return jQuery.grep( elements, function( elem, i ) {
					return !!qualifier.call( elem, i, elem ) !== not;
				} );
			}

			// Single element
			if ( qualifier.nodeType ) {
				return jQuery.grep( elements, function( elem ) {
					return ( elem === qualifier ) !== not;
				} );
			}

			// Arraylike of elements (jQuery, arguments, Array)
			if ( typeof qualifier !== "string" ) {
				return jQuery.grep( elements, function( elem ) {
					return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
				} );
			}

			// Simple selector that can be filtered directly, removing non-Elements
			if ( risSimple.test( qualifier ) ) {
				return jQuery.filter( qualifier, elements, not );
			}

			// Complex selector, compare the two sets, removing non-Elements
			qualifier = jQuery.filter( qualifier, elements );
			return jQuery.grep( elements, function( elem ) {
				return ( indexOf.call( qualifier, elem ) > -1 ) !== not && elem.nodeType === 1;
			} );
		}

		jQuery.filter = function( expr, elems, not ) {
			var elem = elems[ 0 ];

			if ( not ) {
				expr = ":not(" + expr + ")";
			}

			if ( elems.length === 1 && elem.nodeType === 1 ) {
				return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
			}

			return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
				return elem.nodeType === 1;
			} ) );
		};

		jQuery.fn.extend( {
			find: function( selector ) {
				var i, ret,
					len = this.length,
					self = this;

				if ( typeof selector !== "string" ) {
					return this.pushStack( jQuery( selector ).filter( function() {
						for ( i = 0; i < len; i++ ) {
							if ( jQuery.contains( self[ i ], this ) ) {
								return true;
							}
						}
					} ) );
				}

				ret = this.pushStack( [] );

				for ( i = 0; i < len; i++ ) {
					jQuery.find( selector, self[ i ], ret );
				}

				return len > 1 ? jQuery.uniqueSort( ret ) : ret;
			},
			filter: function( selector ) {
				return this.pushStack( winnow( this, selector || [], false ) );
			},
			not: function( selector ) {
				return this.pushStack( winnow( this, selector || [], true ) );
			},
			is: function( selector ) {
				return !!winnow(
					this,

					// If this is a positional/relative selector, check membership in the returned set
					// so $("p:first").is("p:last") won't return true for a doc with two "p".
					typeof selector === "string" && rneedsContext.test( selector ) ?
						jQuery( selector ) :
						selector || [],
					false
				).length;
			}
		} );


		// Initialize a jQuery object


		// A central reference to the root jQuery(document)
		var rootjQuery,

			// A simple way to check for HTML strings
			// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
			// Strict HTML recognition (#11290: must start with <)
			// Shortcut simple #id case for speed
			rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

			init = jQuery.fn.init = function( selector, context, root ) {
				var match, elem;

				// HANDLE: $(""), $(null), $(undefined), $(false)
				if ( !selector ) {
					return this;
				}

				// Method init() accepts an alternate rootjQuery
				// so migrate can support jQuery.sub (gh-2101)
				root = root || rootjQuery;

				// Handle HTML strings
				if ( typeof selector === "string" ) {
					if ( selector[ 0 ] === "<" &&
						selector[ selector.length - 1 ] === ">" &&
						selector.length >= 3 ) {

						// Assume that strings that start and end with <> are HTML and skip the regex check
						match = [ null, selector, null ];

					} else {
						match = rquickExpr.exec( selector );
					}

					// Match html or make sure no context is specified for #id
					if ( match && ( match[ 1 ] || !context ) ) {

						// HANDLE: $(html) -> $(array)
						if ( match[ 1 ] ) {
							context = context instanceof jQuery ? context[ 0 ] : context;

							// Option to run scripts is true for back-compat
							// Intentionally let the error be thrown if parseHTML is not present
							jQuery.merge( this, jQuery.parseHTML(
								match[ 1 ],
								context && context.nodeType ? context.ownerDocument || context : document,
								true
							) );

							// HANDLE: $(html, props)
							if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
								for ( match in context ) {

									// Properties of context are called as methods if possible
									if ( jQuery.isFunction( this[ match ] ) ) {
										this[ match ]( context[ match ] );

									// ...and otherwise set as attributes
									} else {
										this.attr( match, context[ match ] );
									}
								}
							}

							return this;

						// HANDLE: $(#id)
						} else {
							elem = document.getElementById( match[ 2 ] );

							if ( elem ) {

								// Inject the element directly into the jQuery object
								this[ 0 ] = elem;
								this.length = 1;
							}
							return this;
						}

					// HANDLE: $(expr, $(...))
					} else if ( !context || context.jquery ) {
						return ( context || root ).find( selector );

					// HANDLE: $(expr, context)
					// (which is just equivalent to: $(context).find(expr)
					} else {
						return this.constructor( context ).find( selector );
					}

				// HANDLE: $(DOMElement)
				} else if ( selector.nodeType ) {
					this[ 0 ] = selector;
					this.length = 1;
					return this;

				// HANDLE: $(function)
				// Shortcut for document ready
				} else if ( jQuery.isFunction( selector ) ) {
					return root.ready !== undefined ?
						root.ready( selector ) :

						// Execute immediately if ready is not present
						selector( jQuery );
				}

				return jQuery.makeArray( selector, this );
			};

		// Give the init function the jQuery prototype for later instantiation
		init.prototype = jQuery.fn;

		// Initialize central reference
		rootjQuery = jQuery( document );


		var rparentsprev = /^(?:parents|prev(?:Until|All))/,

			// Methods guaranteed to produce a unique set when starting from a unique set
			guaranteedUnique = {
				children: true,
				contents: true,
				next: true,
				prev: true
			};

		jQuery.fn.extend( {
			has: function( target ) {
				var targets = jQuery( target, this ),
					l = targets.length;

				return this.filter( function() {
					var i = 0;
					for ( ; i < l; i++ ) {
						if ( jQuery.contains( this, targets[ i ] ) ) {
							return true;
						}
					}
				} );
			},

			closest: function( selectors, context ) {
				var cur,
					i = 0,
					l = this.length,
					matched = [],
					targets = typeof selectors !== "string" && jQuery( selectors );

				// Positional selectors never match, since there's no _selection_ context
				if ( !rneedsContext.test( selectors ) ) {
					for ( ; i < l; i++ ) {
						for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

							// Always skip document fragments
							if ( cur.nodeType < 11 && ( targets ?
								targets.index( cur ) > -1 :

								// Don't pass non-elements to Sizzle
								cur.nodeType === 1 &&
									jQuery.find.matchesSelector( cur, selectors ) ) ) {

								matched.push( cur );
								break;
							}
						}
					}
				}

				return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
			},

			// Determine the position of an element within the set
			index: function( elem ) {

				// No argument, return index in parent
				if ( !elem ) {
					return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
				}

				// Index in selector
				if ( typeof elem === "string" ) {
					return indexOf.call( jQuery( elem ), this[ 0 ] );
				}

				// Locate the position of the desired element
				return indexOf.call( this,

					// If it receives a jQuery object, the first element is used
					elem.jquery ? elem[ 0 ] : elem
				);
			},

			add: function( selector, context ) {
				return this.pushStack(
					jQuery.uniqueSort(
						jQuery.merge( this.get(), jQuery( selector, context ) )
					)
				);
			},

			addBack: function( selector ) {
				return this.add( selector == null ?
					this.prevObject : this.prevObject.filter( selector )
				);
			}
		} );

		function sibling( cur, dir ) {
			while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
			return cur;
		}

		jQuery.each( {
			parent: function( elem ) {
				var parent = elem.parentNode;
				return parent && parent.nodeType !== 11 ? parent : null;
			},
			parents: function( elem ) {
				return dir( elem, "parentNode" );
			},
			parentsUntil: function( elem, i, until ) {
				return dir( elem, "parentNode", until );
			},
			next: function( elem ) {
				return sibling( elem, "nextSibling" );
			},
			prev: function( elem ) {
				return sibling( elem, "previousSibling" );
			},
			nextAll: function( elem ) {
				return dir( elem, "nextSibling" );
			},
			prevAll: function( elem ) {
				return dir( elem, "previousSibling" );
			},
			nextUntil: function( elem, i, until ) {
				return dir( elem, "nextSibling", until );
			},
			prevUntil: function( elem, i, until ) {
				return dir( elem, "previousSibling", until );
			},
			siblings: function( elem ) {
				return siblings( ( elem.parentNode || {} ).firstChild, elem );
			},
			children: function( elem ) {
				return siblings( elem.firstChild );
			},
			contents: function( elem ) {
				return elem.contentDocument || jQuery.merge( [], elem.childNodes );
			}
		}, function( name, fn ) {
			jQuery.fn[ name ] = function( until, selector ) {
				var matched = jQuery.map( this, fn, until );

				if ( name.slice( -5 ) !== "Until" ) {
					selector = until;
				}

				if ( selector && typeof selector === "string" ) {
					matched = jQuery.filter( selector, matched );
				}

				if ( this.length > 1 ) {

					// Remove duplicates
					if ( !guaranteedUnique[ name ] ) {
						jQuery.uniqueSort( matched );
					}

					// Reverse order for parents* and prev-derivatives
					if ( rparentsprev.test( name ) ) {
						matched.reverse();
					}
				}

				return this.pushStack( matched );
			};
		} );
		var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



		// Convert String-formatted options into Object-formatted ones
		function createOptions( options ) {
			var object = {};
			jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
				object[ flag ] = true;
			} );
			return object;
		}

		/*
		 * Create a callback list using the following parameters:
		 *
		 *	options: an optional list of space-separated options that will change how
		 *			the callback list behaves or a more traditional option object
		 *
		 * By default a callback list will act like an event callback list and can be
		 * "fired" multiple times.
		 *
		 * Possible options:
		 *
		 *	once:			will ensure the callback list can only be fired once (like a Deferred)
		 *
		 *	memory:			will keep track of previous values and will call any callback added
		 *					after the list has been fired right away with the latest "memorized"
		 *					values (like a Deferred)
		 *
		 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
		 *
		 *	stopOnFalse:	interrupt callings when a callback returns false
		 *
		 */
		jQuery.Callbacks = function( options ) {

			// Convert options from String-formatted to Object-formatted if needed
			// (we check in cache first)
			options = typeof options === "string" ?
				createOptions( options ) :
				jQuery.extend( {}, options );

			var // Flag to know if list is currently firing
				firing,

				// Last fire value for non-forgettable lists
				memory,

				// Flag to know if list was already fired
				fired,

				// Flag to prevent firing
				locked,

				// Actual callback list
				list = [],

				// Queue of execution data for repeatable lists
				queue = [],

				// Index of currently firing callback (modified by add/remove as needed)
				firingIndex = -1,

				// Fire callbacks
				fire = function() {

					// Enforce single-firing
					locked = options.once;

					// Execute callbacks for all pending executions,
					// respecting firingIndex overrides and runtime changes
					fired = firing = true;
					for ( ; queue.length; firingIndex = -1 ) {
						memory = queue.shift();
						while ( ++firingIndex < list.length ) {

							// Run callback and check for early termination
							if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
								options.stopOnFalse ) {

								// Jump to end and forget the data so .add doesn't re-fire
								firingIndex = list.length;
								memory = false;
							}
						}
					}

					// Forget the data if we're done with it
					if ( !options.memory ) {
						memory = false;
					}

					firing = false;

					// Clean up if we're done firing for good
					if ( locked ) {

						// Keep an empty list if we have data for future add calls
						if ( memory ) {
							list = [];

						// Otherwise, this object is spent
						} else {
							list = "";
						}
					}
				},

				// Actual Callbacks object
				self = {

					// Add a callback or a collection of callbacks to the list
					add: function() {
						if ( list ) {

							// If we have memory from a past run, we should fire after adding
							if ( memory && !firing ) {
								firingIndex = list.length - 1;
								queue.push( memory );
							}

							( function add( args ) {
								jQuery.each( args, function( _, arg ) {
									if ( jQuery.isFunction( arg ) ) {
										if ( !options.unique || !self.has( arg ) ) {
											list.push( arg );
										}
									} else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {

										// Inspect recursively
										add( arg );
									}
								} );
							} )( arguments );

							if ( memory && !firing ) {
								fire();
							}
						}
						return this;
					},

					// Remove a callback from the list
					remove: function() {
						jQuery.each( arguments, function( _, arg ) {
							var index;
							while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
								list.splice( index, 1 );

								// Handle firing indexes
								if ( index <= firingIndex ) {
									firingIndex--;
								}
							}
						} );
						return this;
					},

					// Check if a given callback is in the list.
					// If no argument is given, return whether or not list has callbacks attached.
					has: function( fn ) {
						return fn ?
							jQuery.inArray( fn, list ) > -1 :
							list.length > 0;
					},

					// Remove all callbacks from the list
					empty: function() {
						if ( list ) {
							list = [];
						}
						return this;
					},

					// Disable .fire and .add
					// Abort any current/pending executions
					// Clear all callbacks and values
					disable: function() {
						locked = queue = [];
						list = memory = "";
						return this;
					},
					disabled: function() {
						return !list;
					},

					// Disable .fire
					// Also disable .add unless we have memory (since it would have no effect)
					// Abort any pending executions
					lock: function() {
						locked = queue = [];
						if ( !memory && !firing ) {
							list = memory = "";
						}
						return this;
					},
					locked: function() {
						return !!locked;
					},

					// Call all callbacks with the given context and arguments
					fireWith: function( context, args ) {
						if ( !locked ) {
							args = args || [];
							args = [ context, args.slice ? args.slice() : args ];
							queue.push( args );
							if ( !firing ) {
								fire();
							}
						}
						return this;
					},

					// Call all the callbacks with the given arguments
					fire: function() {
						self.fireWith( this, arguments );
						return this;
					},

					// To know if the callbacks have already been called at least once
					fired: function() {
						return !!fired;
					}
				};

			return self;
		};


		function Identity( v ) {
			return v;
		}
		function Thrower( ex ) {
			throw ex;
		}

		function adoptValue( value, resolve, reject ) {
			var method;

			try {

				// Check for promise aspect first to privilege synchronous behavior
				if ( value && jQuery.isFunction( ( method = value.promise ) ) ) {
					method.call( value ).done( resolve ).fail( reject );

				// Other thenables
				} else if ( value && jQuery.isFunction( ( method = value.then ) ) ) {
					method.call( value, resolve, reject );

				// Other non-thenables
				} else {

					// Support: Android 4.0 only
					// Strict mode functions invoked without .call/.apply get global-object context
					resolve.call( undefined, value );
				}

			// For Promises/A+, convert exceptions into rejections
			// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
			// Deferred#then to conditionally suppress rejection.
			} catch ( value ) {

				// Support: Android 4.0 only
				// Strict mode functions invoked without .call/.apply get global-object context
				reject.call( undefined, value );
			}
		}

		jQuery.extend( {

			Deferred: function( func ) {
				var tuples = [

						// action, add listener, callbacks,
						// ... .then handlers, argument index, [final state]
						[ "notify", "progress", jQuery.Callbacks( "memory" ),
							jQuery.Callbacks( "memory" ), 2 ],
						[ "resolve", "done", jQuery.Callbacks( "once memory" ),
							jQuery.Callbacks( "once memory" ), 0, "resolved" ],
						[ "reject", "fail", jQuery.Callbacks( "once memory" ),
							jQuery.Callbacks( "once memory" ), 1, "rejected" ]
					],
					state = "pending",
					promise = {
						state: function() {
							return state;
						},
						always: function() {
							deferred.done( arguments ).fail( arguments );
							return this;
						},
						"catch": function( fn ) {
							return promise.then( null, fn );
						},

						// Keep pipe for back-compat
						pipe: function( /* fnDone, fnFail, fnProgress */ ) {
							var fns = arguments;

							return jQuery.Deferred( function( newDefer ) {
								jQuery.each( tuples, function( i, tuple ) {

									// Map tuples (progress, done, fail) to arguments (done, fail, progress)
									var fn = jQuery.isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

									// deferred.progress(function() { bind to newDefer or newDefer.notify })
									// deferred.done(function() { bind to newDefer or newDefer.resolve })
									// deferred.fail(function() { bind to newDefer or newDefer.reject })
									deferred[ tuple[ 1 ] ]( function() {
										var returned = fn && fn.apply( this, arguments );
										if ( returned && jQuery.isFunction( returned.promise ) ) {
											returned.promise()
												.progress( newDefer.notify )
												.done( newDefer.resolve )
												.fail( newDefer.reject );
										} else {
											newDefer[ tuple[ 0 ] + "With" ](
												this,
												fn ? [ returned ] : arguments
											);
										}
									} );
								} );
								fns = null;
							} ).promise();
						},
						then: function( onFulfilled, onRejected, onProgress ) {
							var maxDepth = 0;
							function resolve( depth, deferred, handler, special ) {
								return function() {
									var that = this,
										args = arguments,
										mightThrow = function() {
											var returned, then;

											// Support: Promises/A+ section 2.3.3.3.3
											// https://promisesaplus.com/#point-59
											// Ignore double-resolution attempts
											if ( depth < maxDepth ) {
												return;
											}

											returned = handler.apply( that, args );

											// Support: Promises/A+ section 2.3.1
											// https://promisesaplus.com/#point-48
											if ( returned === deferred.promise() ) {
												throw new TypeError( "Thenable self-resolution" );
											}

											// Support: Promises/A+ sections 2.3.3.1, 3.5
											// https://promisesaplus.com/#point-54
											// https://promisesaplus.com/#point-75
											// Retrieve `then` only once
											then = returned &&

												// Support: Promises/A+ section 2.3.4
												// https://promisesaplus.com/#point-64
												// Only check objects and functions for thenability
												( typeof returned === "object" ||
													typeof returned === "function" ) &&
												returned.then;

											// Handle a returned thenable
											if ( jQuery.isFunction( then ) ) {

												// Special processors (notify) just wait for resolution
												if ( special ) {
													then.call(
														returned,
														resolve( maxDepth, deferred, Identity, special ),
														resolve( maxDepth, deferred, Thrower, special )
													);

												// Normal processors (resolve) also hook into progress
												} else {

													// ...and disregard older resolution values
													maxDepth++;

													then.call(
														returned,
														resolve( maxDepth, deferred, Identity, special ),
														resolve( maxDepth, deferred, Thrower, special ),
														resolve( maxDepth, deferred, Identity,
															deferred.notifyWith )
													);
												}

											// Handle all other returned values
											} else {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Identity ) {
													that = undefined;
													args = [ returned ];
												}

												// Process the value(s)
												// Default process is resolve
												( special || deferred.resolveWith )( that, args );
											}
										},

										// Only normal processors (resolve) catch and reject exceptions
										process = special ?
											mightThrow :
											function() {
												try {
													mightThrow();
												} catch ( e ) {

													if ( jQuery.Deferred.exceptionHook ) {
														jQuery.Deferred.exceptionHook( e,
															process.stackTrace );
													}

													// Support: Promises/A+ section 2.3.3.3.4.1
													// https://promisesaplus.com/#point-61
													// Ignore post-resolution exceptions
													if ( depth + 1 >= maxDepth ) {

														// Only substitute handlers pass on context
														// and multiple values (non-spec behavior)
														if ( handler !== Thrower ) {
															that = undefined;
															args = [ e ];
														}

														deferred.rejectWith( that, args );
													}
												}
											};

									// Support: Promises/A+ section 2.3.3.3.1
									// https://promisesaplus.com/#point-57
									// Re-resolve promises immediately to dodge false rejection from
									// subsequent errors
									if ( depth ) {
										process();
									} else {

										// Call an optional hook to record the stack, in case of exception
										// since it's otherwise lost when execution goes async
										if ( jQuery.Deferred.getStackHook ) {
											process.stackTrace = jQuery.Deferred.getStackHook();
										}
										window.setTimeout( process );
									}
								};
							}

							return jQuery.Deferred( function( newDefer ) {

								// progress_handlers.add( ... )
								tuples[ 0 ][ 3 ].add(
									resolve(
										0,
										newDefer,
										jQuery.isFunction( onProgress ) ?
											onProgress :
											Identity,
										newDefer.notifyWith
									)
								);

								// fulfilled_handlers.add( ... )
								tuples[ 1 ][ 3 ].add(
									resolve(
										0,
										newDefer,
										jQuery.isFunction( onFulfilled ) ?
											onFulfilled :
											Identity
									)
								);

								// rejected_handlers.add( ... )
								tuples[ 2 ][ 3 ].add(
									resolve(
										0,
										newDefer,
										jQuery.isFunction( onRejected ) ?
											onRejected :
											Thrower
									)
								);
							} ).promise();
						},

						// Get a promise for this deferred
						// If obj is provided, the promise aspect is added to the object
						promise: function( obj ) {
							return obj != null ? jQuery.extend( obj, promise ) : promise;
						}
					},
					deferred = {};

				// Add list-specific methods
				jQuery.each( tuples, function( i, tuple ) {
					var list = tuple[ 2 ],
						stateString = tuple[ 5 ];

					// promise.progress = list.add
					// promise.done = list.add
					// promise.fail = list.add
					promise[ tuple[ 1 ] ] = list.add;

					// Handle state
					if ( stateString ) {
						list.add(
							function() {

								// state = "resolved" (i.e., fulfilled)
								// state = "rejected"
								state = stateString;
							},

							// rejected_callbacks.disable
							// fulfilled_callbacks.disable
							tuples[ 3 - i ][ 2 ].disable,

							// progress_callbacks.lock
							tuples[ 0 ][ 2 ].lock
						);
					}

					// progress_handlers.fire
					// fulfilled_handlers.fire
					// rejected_handlers.fire
					list.add( tuple[ 3 ].fire );

					// deferred.notify = function() { deferred.notifyWith(...) }
					// deferred.resolve = function() { deferred.resolveWith(...) }
					// deferred.reject = function() { deferred.rejectWith(...) }
					deferred[ tuple[ 0 ] ] = function() {
						deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
						return this;
					};

					// deferred.notifyWith = list.fireWith
					// deferred.resolveWith = list.fireWith
					// deferred.rejectWith = list.fireWith
					deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
				} );

				// Make the deferred a promise
				promise.promise( deferred );

				// Call given func if any
				if ( func ) {
					func.call( deferred, deferred );
				}

				// All done!
				return deferred;
			},

			// Deferred helper
			when: function( singleValue ) {
				var

					// count of uncompleted subordinates
					remaining = arguments.length,

					// count of unprocessed arguments
					i = remaining,

					// subordinate fulfillment data
					resolveContexts = Array( i ),
					resolveValues = slice.call( arguments ),

					// the master Deferred
					master = jQuery.Deferred(),

					// subordinate callback factory
					updateFunc = function( i ) {
						return function( value ) {
							resolveContexts[ i ] = this;
							resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
							if ( !( --remaining ) ) {
								master.resolveWith( resolveContexts, resolveValues );
							}
						};
					};

				// Single- and empty arguments are adopted like Promise.resolve
				if ( remaining <= 1 ) {
					adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject );

					// Use .then() to unwrap secondary thenables (cf. gh-3000)
					if ( master.state() === "pending" ||
						jQuery.isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

						return master.then();
					}
				}

				// Multiple arguments are aggregated like Promise.all array elements
				while ( i-- ) {
					adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
				}

				return master.promise();
			}
		} );


		// These usually indicate a programmer mistake during development,
		// warn about them ASAP rather than swallowing them by default.
		var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

		jQuery.Deferred.exceptionHook = function( error, stack ) {

			// Support: IE 8 - 9 only
			// Console exists when dev tools are open, which can happen at any time
			if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
				window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
			}
		};




		jQuery.readyException = function( error ) {
			window.setTimeout( function() {
				throw error;
			} );
		};




		// The deferred used on DOM ready
		var readyList = jQuery.Deferred();

		jQuery.fn.ready = function( fn ) {

			readyList
				.then( fn )

				// Wrap jQuery.readyException in a function so that the lookup
				// happens at the time of error handling instead of callback
				// registration.
				.catch( function( error ) {
					jQuery.readyException( error );
				} );

			return this;
		};

		jQuery.extend( {

			// Is the DOM ready to be used? Set to true once it occurs.
			isReady: false,

			// A counter to track how many items to wait for before
			// the ready event fires. See #6781
			readyWait: 1,

			// Hold (or release) the ready event
			holdReady: function( hold ) {
				if ( hold ) {
					jQuery.readyWait++;
				} else {
					jQuery.ready( true );
				}
			},

			// Handle when the DOM is ready
			ready: function( wait ) {

				// Abort if there are pending holds or we're already ready
				if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
					return;
				}

				// Remember that the DOM is ready
				jQuery.isReady = true;

				// If a normal DOM Ready event fired, decrement, and wait if need be
				if ( wait !== true && --jQuery.readyWait > 0 ) {
					return;
				}

				// If there are functions bound, to execute
				readyList.resolveWith( document, [ jQuery ] );
			}
		} );

		jQuery.ready.then = readyList.then;

		// The ready event handler and self cleanup method
		function completed() {
			document.removeEventListener( "DOMContentLoaded", completed );
			window.removeEventListener( "load", completed );
			jQuery.ready();
		}

		// Catch cases where $(document).ready() is called
		// after the browser event has already occurred.
		// Support: IE <=9 - 10 only
		// Older IE sometimes signals "interactive" too soon
		if ( document.readyState === "complete" ||
			( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

			// Handle it asynchronously to allow scripts the opportunity to delay ready
			window.setTimeout( jQuery.ready );

		} else {

			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", completed );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", completed );
		}




		// Multifunctional method to get and set values of a collection
		// The value/s can optionally be executed if it's a function
		var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
			var i = 0,
				len = elems.length,
				bulk = key == null;

			// Sets many values
			if ( jQuery.type( key ) === "object" ) {
				chainable = true;
				for ( i in key ) {
					access( elems, fn, i, key[ i ], true, emptyGet, raw );
				}

			// Sets one value
			} else if ( value !== undefined ) {
				chainable = true;

				if ( !jQuery.isFunction( value ) ) {
					raw = true;
				}

				if ( bulk ) {

					// Bulk operations run against the entire set
					if ( raw ) {
						fn.call( elems, value );
						fn = null;

					// ...except when executing function values
					} else {
						bulk = fn;
						fn = function( elem, key, value ) {
							return bulk.call( jQuery( elem ), value );
						};
					}
				}

				if ( fn ) {
					for ( ; i < len; i++ ) {
						fn(
							elems[ i ], key, raw ?
							value :
							value.call( elems[ i ], i, fn( elems[ i ], key ) )
						);
					}
				}
			}

			if ( chainable ) {
				return elems;
			}

			// Gets
			if ( bulk ) {
				return fn.call( elems );
			}

			return len ? fn( elems[ 0 ], key ) : emptyGet;
		};
		var acceptData = function( owner ) {

			// Accepts only:
			//  - Node
			//    - Node.ELEMENT_NODE
			//    - Node.DOCUMENT_NODE
			//  - Object
			//    - Any
			return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
		};




		function Data() {
			this.expando = jQuery.expando + Data.uid++;
		}

		Data.uid = 1;

		Data.prototype = {

			cache: function( owner ) {

				// Check if the owner object already has a cache
				var value = owner[ this.expando ];

				// If not, create one
				if ( !value ) {
					value = {};

					// We can accept data for non-element nodes in modern browsers,
					// but we should not, see #8335.
					// Always return an empty object.
					if ( acceptData( owner ) ) {

						// If it is a node unlikely to be stringify-ed or looped over
						// use plain assignment
						if ( owner.nodeType ) {
							owner[ this.expando ] = value;

						// Otherwise secure it in a non-enumerable property
						// configurable must be true to allow the property to be
						// deleted when data is removed
						} else {
							Object.defineProperty( owner, this.expando, {
								value: value,
								configurable: true
							} );
						}
					}
				}

				return value;
			},
			set: function( owner, data, value ) {
				var prop,
					cache = this.cache( owner );

				// Handle: [ owner, key, value ] args
				// Always use camelCase key (gh-2257)
				if ( typeof data === "string" ) {
					cache[ jQuery.camelCase( data ) ] = value;

				// Handle: [ owner, { properties } ] args
				} else {

					// Copy the properties one-by-one to the cache object
					for ( prop in data ) {
						cache[ jQuery.camelCase( prop ) ] = data[ prop ];
					}
				}
				return cache;
			},
			get: function( owner, key ) {
				return key === undefined ?
					this.cache( owner ) :

					// Always use camelCase key (gh-2257)
					owner[ this.expando ] && owner[ this.expando ][ jQuery.camelCase( key ) ];
			},
			access: function( owner, key, value ) {

				// In cases where either:
				//
				//   1. No key was specified
				//   2. A string key was specified, but no value provided
				//
				// Take the "read" path and allow the get method to determine
				// which value to return, respectively either:
				//
				//   1. The entire cache object
				//   2. The data stored at the key
				//
				if ( key === undefined ||
						( ( key && typeof key === "string" ) && value === undefined ) ) {

					return this.get( owner, key );
				}

				// When the key is not a string, or both a key and value
				// are specified, set or extend (existing objects) with either:
				//
				//   1. An object of properties
				//   2. A key and value
				//
				this.set( owner, key, value );

				// Since the "set" path can have two possible entry points
				// return the expected data based on which path was taken[*]
				return value !== undefined ? value : key;
			},
			remove: function( owner, key ) {
				var i,
					cache = owner[ this.expando ];

				if ( cache === undefined ) {
					return;
				}

				if ( key !== undefined ) {

					// Support array or space separated string of keys
					if ( jQuery.isArray( key ) ) {

						// If key is an array of keys...
						// We always set camelCase keys, so remove that.
						key = key.map( jQuery.camelCase );
					} else {
						key = jQuery.camelCase( key );

						// If a key with the spaces exists, use it.
						// Otherwise, create an array by matching non-whitespace
						key = key in cache ?
							[ key ] :
							( key.match( rnothtmlwhite ) || [] );
					}

					i = key.length;

					while ( i-- ) {
						delete cache[ key[ i ] ];
					}
				}

				// Remove the expando if there's no more data
				if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

					// Support: Chrome <=35 - 45
					// Webkit & Blink performance suffers when deleting properties
					// from DOM nodes, so set to undefined instead
					// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
					if ( owner.nodeType ) {
						owner[ this.expando ] = undefined;
					} else {
						delete owner[ this.expando ];
					}
				}
			},
			hasData: function( owner ) {
				var cache = owner[ this.expando ];
				return cache !== undefined && !jQuery.isEmptyObject( cache );
			}
		};
		var dataPriv = new Data();

		var dataUser = new Data();



		//	Implementation Summary
		//
		//	1. Enforce API surface and semantic compatibility with 1.9.x branch
		//	2. Improve the module's maintainability by reducing the storage
		//		paths to a single mechanism.
		//	3. Use the same single mechanism to support "private" and "user" data.
		//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
		//	5. Avoid exposing implementation details on user objects (eg. expando properties)
		//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

		var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
			rmultiDash = /[A-Z]/g;

		function getData( data ) {
			if ( data === "true" ) {
				return true;
			}

			if ( data === "false" ) {
				return false;
			}

			if ( data === "null" ) {
				return null;
			}

			// Only convert to a number if it doesn't change the string
			if ( data === +data + "" ) {
				return +data;
			}

			if ( rbrace.test( data ) ) {
				return JSON.parse( data );
			}

			return data;
		}

		function dataAttr( elem, key, data ) {
			var name;

			// If nothing was found internally, try to fetch any
			// data from the HTML5 data-* attribute
			if ( data === undefined && elem.nodeType === 1 ) {
				name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
				data = elem.getAttribute( name );

				if ( typeof data === "string" ) {
					try {
						data = getData( data );
					} catch ( e ) {}

					// Make sure we set the data so it isn't changed later
					dataUser.set( elem, key, data );
				} else {
					data = undefined;
				}
			}
			return data;
		}

		jQuery.extend( {
			hasData: function( elem ) {
				return dataUser.hasData( elem ) || dataPriv.hasData( elem );
			},

			data: function( elem, name, data ) {
				return dataUser.access( elem, name, data );
			},

			removeData: function( elem, name ) {
				dataUser.remove( elem, name );
			},

			// TODO: Now that all calls to _data and _removeData have been replaced
			// with direct calls to dataPriv methods, these can be deprecated.
			_data: function( elem, name, data ) {
				return dataPriv.access( elem, name, data );
			},

			_removeData: function( elem, name ) {
				dataPriv.remove( elem, name );
			}
		} );

		jQuery.fn.extend( {
			data: function( key, value ) {
				var i, name, data,
					elem = this[ 0 ],
					attrs = elem && elem.attributes;

				// Gets all values
				if ( key === undefined ) {
					if ( this.length ) {
						data = dataUser.get( elem );

						if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
							i = attrs.length;
							while ( i-- ) {

								// Support: IE 11 only
								// The attrs elements can be null (#14894)
								if ( attrs[ i ] ) {
									name = attrs[ i ].name;
									if ( name.indexOf( "data-" ) === 0 ) {
										name = jQuery.camelCase( name.slice( 5 ) );
										dataAttr( elem, name, data[ name ] );
									}
								}
							}
							dataPriv.set( elem, "hasDataAttrs", true );
						}
					}

					return data;
				}

				// Sets multiple values
				if ( typeof key === "object" ) {
					return this.each( function() {
						dataUser.set( this, key );
					} );
				}

				return access( this, function( value ) {
					var data;

					// The calling jQuery object (element matches) is not empty
					// (and therefore has an element appears at this[ 0 ]) and the
					// `value` parameter was not undefined. An empty jQuery object
					// will result in `undefined` for elem = this[ 0 ] which will
					// throw an exception if an attempt to read a data cache is made.
					if ( elem && value === undefined ) {

						// Attempt to get data from the cache
						// The key will always be camelCased in Data
						data = dataUser.get( elem, key );
						if ( data !== undefined ) {
							return data;
						}

						// Attempt to "discover" the data in
						// HTML5 custom data-* attrs
						data = dataAttr( elem, key );
						if ( data !== undefined ) {
							return data;
						}

						// We tried really hard, but the data doesn't exist.
						return;
					}

					// Set the data...
					this.each( function() {

						// We always store the camelCased key
						dataUser.set( this, key, value );
					} );
				}, null, value, arguments.length > 1, null, true );
			},

			removeData: function( key ) {
				return this.each( function() {
					dataUser.remove( this, key );
				} );
			}
		} );


		jQuery.extend( {
			queue: function( elem, type, data ) {
				var queue;

				if ( elem ) {
					type = ( type || "fx" ) + "queue";
					queue = dataPriv.get( elem, type );

					// Speed up dequeue by getting out quickly if this is just a lookup
					if ( data ) {
						if ( !queue || jQuery.isArray( data ) ) {
							queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
						} else {
							queue.push( data );
						}
					}
					return queue || [];
				}
			},

			dequeue: function( elem, type ) {
				type = type || "fx";

				var queue = jQuery.queue( elem, type ),
					startLength = queue.length,
					fn = queue.shift(),
					hooks = jQuery._queueHooks( elem, type ),
					next = function() {
						jQuery.dequeue( elem, type );
					};

				// If the fx queue is dequeued, always remove the progress sentinel
				if ( fn === "inprogress" ) {
					fn = queue.shift();
					startLength--;
				}

				if ( fn ) {

					// Add a progress sentinel to prevent the fx queue from being
					// automatically dequeued
					if ( type === "fx" ) {
						queue.unshift( "inprogress" );
					}

					// Clear up the last queue stop function
					delete hooks.stop;
					fn.call( elem, next, hooks );
				}

				if ( !startLength && hooks ) {
					hooks.empty.fire();
				}
			},

			// Not public - generate a queueHooks object, or return the current one
			_queueHooks: function( elem, type ) {
				var key = type + "queueHooks";
				return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
					empty: jQuery.Callbacks( "once memory" ).add( function() {
						dataPriv.remove( elem, [ type + "queue", key ] );
					} )
				} );
			}
		} );

		jQuery.fn.extend( {
			queue: function( type, data ) {
				var setter = 2;

				if ( typeof type !== "string" ) {
					data = type;
					type = "fx";
					setter--;
				}

				if ( arguments.length < setter ) {
					return jQuery.queue( this[ 0 ], type );
				}

				return data === undefined ?
					this :
					this.each( function() {
						var queue = jQuery.queue( this, type, data );

						// Ensure a hooks for this queue
						jQuery._queueHooks( this, type );

						if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
							jQuery.dequeue( this, type );
						}
					} );
			},
			dequeue: function( type ) {
				return this.each( function() {
					jQuery.dequeue( this, type );
				} );
			},
			clearQueue: function( type ) {
				return this.queue( type || "fx", [] );
			},

			// Get a promise resolved when queues of a certain type
			// are emptied (fx is the type by default)
			promise: function( type, obj ) {
				var tmp,
					count = 1,
					defer = jQuery.Deferred(),
					elements = this,
					i = this.length,
					resolve = function() {
						if ( !( --count ) ) {
							defer.resolveWith( elements, [ elements ] );
						}
					};

				if ( typeof type !== "string" ) {
					obj = type;
					type = undefined;
				}
				type = type || "fx";

				while ( i-- ) {
					tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
					if ( tmp && tmp.empty ) {
						count++;
						tmp.empty.add( resolve );
					}
				}
				resolve();
				return defer.promise( obj );
			}
		} );
		var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

		var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


		var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

		var isHiddenWithinTree = function( elem, el ) {

				// isHiddenWithinTree might be called from jQuery#filter function;
				// in that case, element will be second argument
				elem = el || elem;

				// Inline style trumps all
				return elem.style.display === "none" ||
					elem.style.display === "" &&

					// Otherwise, check computed style
					// Support: Firefox <=43 - 45
					// Disconnected elements can have computed display: none, so first confirm that elem is
					// in the document.
					jQuery.contains( elem.ownerDocument, elem ) &&

					jQuery.css( elem, "display" ) === "none";
			};

		var swap = function( elem, options, callback, args ) {
			var ret, name,
				old = {};

			// Remember the old values, and insert the new ones
			for ( name in options ) {
				old[ name ] = elem.style[ name ];
				elem.style[ name ] = options[ name ];
			}

			ret = callback.apply( elem, args || [] );

			// Revert the old values
			for ( name in options ) {
				elem.style[ name ] = old[ name ];
			}

			return ret;
		};




		function adjustCSS( elem, prop, valueParts, tween ) {
			var adjusted,
				scale = 1,
				maxIterations = 20,
				currentValue = tween ?
					function() {
						return tween.cur();
					} :
					function() {
						return jQuery.css( elem, prop, "" );
					},
				initial = currentValue(),
				unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

				// Starting value computation is required for potential unit mismatches
				initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
					rcssNum.exec( jQuery.css( elem, prop ) );

			if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

				// Trust units reported by jQuery.css
				unit = unit || initialInUnit[ 3 ];

				// Make sure we update the tween properties later on
				valueParts = valueParts || [];

				// Iteratively approximate from a nonzero starting point
				initialInUnit = +initial || 1;

				do {

					// If previous iteration zeroed out, double until we get *something*.
					// Use string for doubling so we don't accidentally see scale as unchanged below
					scale = scale || ".5";

					// Adjust and apply
					initialInUnit = initialInUnit / scale;
					jQuery.style( elem, prop, initialInUnit + unit );

				// Update scale, tolerating zero or NaN from tween.cur()
				// Break the loop if scale is unchanged or perfect, or if we've just had enough.
				} while (
					scale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations
				);
			}

			if ( valueParts ) {
				initialInUnit = +initialInUnit || +initial || 0;

				// Apply relative offset (+=/-=) if specified
				adjusted = valueParts[ 1 ] ?
					initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
					+valueParts[ 2 ];
				if ( tween ) {
					tween.unit = unit;
					tween.start = initialInUnit;
					tween.end = adjusted;
				}
			}
			return adjusted;
		}


		var defaultDisplayMap = {};

		function getDefaultDisplay( elem ) {
			var temp,
				doc = elem.ownerDocument,
				nodeName = elem.nodeName,
				display = defaultDisplayMap[ nodeName ];

			if ( display ) {
				return display;
			}

			temp = doc.body.appendChild( doc.createElement( nodeName ) );
			display = jQuery.css( temp, "display" );

			temp.parentNode.removeChild( temp );

			if ( display === "none" ) {
				display = "block";
			}
			defaultDisplayMap[ nodeName ] = display;

			return display;
		}

		function showHide( elements, show ) {
			var display, elem,
				values = [],
				index = 0,
				length = elements.length;

			// Determine new display value for elements that need to change
			for ( ; index < length; index++ ) {
				elem = elements[ index ];
				if ( !elem.style ) {
					continue;
				}

				display = elem.style.display;
				if ( show ) {

					// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
					// check is required in this first loop unless we have a nonempty display value (either
					// inline or about-to-be-restored)
					if ( display === "none" ) {
						values[ index ] = dataPriv.get( elem, "display" ) || null;
						if ( !values[ index ] ) {
							elem.style.display = "";
						}
					}
					if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
						values[ index ] = getDefaultDisplay( elem );
					}
				} else {
					if ( display !== "none" ) {
						values[ index ] = "none";

						// Remember what we're overwriting
						dataPriv.set( elem, "display", display );
					}
				}
			}

			// Set the display of the elements in a second loop to avoid constant reflow
			for ( index = 0; index < length; index++ ) {
				if ( values[ index ] != null ) {
					elements[ index ].style.display = values[ index ];
				}
			}

			return elements;
		}

		jQuery.fn.extend( {
			show: function() {
				return showHide( this, true );
			},
			hide: function() {
				return showHide( this );
			},
			toggle: function( state ) {
				if ( typeof state === "boolean" ) {
					return state ? this.show() : this.hide();
				}

				return this.each( function() {
					if ( isHiddenWithinTree( this ) ) {
						jQuery( this ).show();
					} else {
						jQuery( this ).hide();
					}
				} );
			}
		} );
		var rcheckableType = ( /^(?:checkbox|radio)$/i );

		var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]+)/i );

		var rscriptType = ( /^$|\/(?:java|ecma)script/i );



		// We have to close these tags to support XHTML (#13200)
		var wrapMap = {

			// Support: IE <=9 only
			option: [ 1, "<select multiple='multiple'>", "</select>" ],

			// XHTML parsers do not magically insert elements in the
			// same way that tag soup parsers do. So we cannot shorten
			// this by omitting <tbody> or other required elements.
			thead: [ 1, "<table>", "</table>" ],
			col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
			tr: [ 2, "<table><tbody>", "</tbody></table>" ],
			td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

			_default: [ 0, "", "" ]
		};

		// Support: IE <=9 only
		wrapMap.optgroup = wrapMap.option;

		wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
		wrapMap.th = wrapMap.td;


		function getAll( context, tag ) {

			// Support: IE <=9 - 11 only
			// Use typeof to avoid zero-argument method invocation on host objects (#15151)
			var ret;

			if ( typeof context.getElementsByTagName !== "undefined" ) {
				ret = context.getElementsByTagName( tag || "*" );

			} else if ( typeof context.querySelectorAll !== "undefined" ) {
				ret = context.querySelectorAll( tag || "*" );

			} else {
				ret = [];
			}

			if ( tag === undefined || tag && jQuery.nodeName( context, tag ) ) {
				return jQuery.merge( [ context ], ret );
			}

			return ret;
		}


		// Mark scripts as having already been evaluated
		function setGlobalEval( elems, refElements ) {
			var i = 0,
				l = elems.length;

			for ( ; i < l; i++ ) {
				dataPriv.set(
					elems[ i ],
					"globalEval",
					!refElements || dataPriv.get( refElements[ i ], "globalEval" )
				);
			}
		}


		var rhtml = /<|&#?\w+;/;

		function buildFragment( elems, context, scripts, selection, ignored ) {
			var elem, tmp, tag, wrap, contains, j,
				fragment = context.createDocumentFragment(),
				nodes = [],
				i = 0,
				l = elems.length;

			for ( ; i < l; i++ ) {
				elem = elems[ i ];

				if ( elem || elem === 0 ) {

					// Add nodes directly
					if ( jQuery.type( elem ) === "object" ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

					// Convert non-html into a text node
					} else if ( !rhtml.test( elem ) ) {
						nodes.push( context.createTextNode( elem ) );

					// Convert html into DOM nodes
					} else {
						tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

						// Deserialize a standard representation
						tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
						wrap = wrapMap[ tag ] || wrapMap._default;
						tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

						// Descend through wrappers to the right content
						j = wrap[ 0 ];
						while ( j-- ) {
							tmp = tmp.lastChild;
						}

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( nodes, tmp.childNodes );

						// Remember the top-level container
						tmp = fragment.firstChild;

						// Ensure the created nodes are orphaned (#12392)
						tmp.textContent = "";
					}
				}
			}

			// Remove wrapper from fragment
			fragment.textContent = "";

			i = 0;
			while ( ( elem = nodes[ i++ ] ) ) {

				// Skip elements already in the context collection (trac-4087)
				if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
					if ( ignored ) {
						ignored.push( elem );
					}
					continue;
				}

				contains = jQuery.contains( elem.ownerDocument, elem );

				// Append to fragment
				tmp = getAll( fragment.appendChild( elem ), "script" );

				// Preserve script evaluation history
				if ( contains ) {
					setGlobalEval( tmp );
				}

				// Capture executables
				if ( scripts ) {
					j = 0;
					while ( ( elem = tmp[ j++ ] ) ) {
						if ( rscriptType.test( elem.type || "" ) ) {
							scripts.push( elem );
						}
					}
				}
			}

			return fragment;
		}


		( function() {
			var fragment = document.createDocumentFragment(),
				div = fragment.appendChild( document.createElement( "div" ) ),
				input = document.createElement( "input" );

			// Support: Android 4.0 - 4.3 only
			// Check state lost if the name is set (#11217)
			// Support: Windows Web Apps (WWA)
			// `name` and `type` must use .setAttribute for WWA (#14901)
			input.setAttribute( "type", "radio" );
			input.setAttribute( "checked", "checked" );
			input.setAttribute( "name", "t" );

			div.appendChild( input );

			// Support: Android <=4.1 only
			// Older WebKit doesn't clone checked state correctly in fragments
			support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

			// Support: IE <=11 only
			// Make sure textarea (and checkbox) defaultValue is properly cloned
			div.innerHTML = "<textarea>x</textarea>";
			support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
		} )();
		var documentElement = document.documentElement;



		var
			rkeyEvent = /^key/,
			rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
			rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

		function returnTrue() {
			return true;
		}

		function returnFalse() {
			return false;
		}

		// Support: IE <=9 only
		// See #13393 for more info
		function safeActiveElement() {
			try {
				return document.activeElement;
			} catch ( err ) { }
		}

		function on( elem, types, selector, data, fn, one ) {
			var origFn, type;

			// Types can be a map of types/handlers
			if ( typeof types === "object" ) {

				// ( types-Object, selector, data )
				if ( typeof selector !== "string" ) {

					// ( types-Object, data )
					data = data || selector;
					selector = undefined;
				}
				for ( type in types ) {
					on( elem, type, selector, data, types[ type ], one );
				}
				return elem;
			}

			if ( data == null && fn == null ) {

				// ( types, fn )
				fn = selector;
				data = selector = undefined;
			} else if ( fn == null ) {
				if ( typeof selector === "string" ) {

					// ( types, selector, fn )
					fn = data;
					data = undefined;
				} else {

					// ( types, data, fn )
					fn = data;
					data = selector;
					selector = undefined;
				}
			}
			if ( fn === false ) {
				fn = returnFalse;
			} else if ( !fn ) {
				return elem;
			}

			if ( one === 1 ) {
				origFn = fn;
				fn = function( event ) {

					// Can use an empty set, since event contains the info
					jQuery().off( event );
					return origFn.apply( this, arguments );
				};

				// Use same guid so caller can remove using origFn
				fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
			}
			return elem.each( function() {
				jQuery.event.add( this, types, fn, data, selector );
			} );
		}

		/*
		 * Helper functions for managing events -- not part of the public interface.
		 * Props to Dean Edwards' addEvent library for many of the ideas.
		 */
		jQuery.event = {

			global: {},

			add: function( elem, types, handler, data, selector ) {

				var handleObjIn, eventHandle, tmp,
					events, t, handleObj,
					special, handlers, type, namespaces, origType,
					elemData = dataPriv.get( elem );

				// Don't attach events to noData or text/comment nodes (but allow plain objects)
				if ( !elemData ) {
					return;
				}

				// Caller can pass in an object of custom data in lieu of the handler
				if ( handler.handler ) {
					handleObjIn = handler;
					handler = handleObjIn.handler;
					selector = handleObjIn.selector;
				}

				// Ensure that invalid selectors throw exceptions at attach time
				// Evaluate against documentElement in case elem is a non-element node (e.g., document)
				if ( selector ) {
					jQuery.find.matchesSelector( documentElement, selector );
				}

				// Make sure that the handler has a unique ID, used to find/remove it later
				if ( !handler.guid ) {
					handler.guid = jQuery.guid++;
				}

				// Init the element's event structure and main handler, if this is the first
				if ( !( events = elemData.events ) ) {
					events = elemData.events = {};
				}
				if ( !( eventHandle = elemData.handle ) ) {
					eventHandle = elemData.handle = function( e ) {

						// Discard the second event of a jQuery.event.trigger() and
						// when an event is called after a page has unloaded
						return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
							jQuery.event.dispatch.apply( elem, arguments ) : undefined;
					};
				}

				// Handle multiple events separated by a space
				types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
				t = types.length;
				while ( t-- ) {
					tmp = rtypenamespace.exec( types[ t ] ) || [];
					type = origType = tmp[ 1 ];
					namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

					// There *must* be a type, no attaching namespace-only handlers
					if ( !type ) {
						continue;
					}

					// If event changes its type, use the special event handlers for the changed type
					special = jQuery.event.special[ type ] || {};

					// If selector defined, determine special event api type, otherwise given type
					type = ( selector ? special.delegateType : special.bindType ) || type;

					// Update special based on newly reset type
					special = jQuery.event.special[ type ] || {};

					// handleObj is passed to all event handlers
					handleObj = jQuery.extend( {
						type: type,
						origType: origType,
						data: data,
						handler: handler,
						guid: handler.guid,
						selector: selector,
						needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
						namespace: namespaces.join( "." )
					}, handleObjIn );

					// Init the event handler queue if we're the first
					if ( !( handlers = events[ type ] ) ) {
						handlers = events[ type ] = [];
						handlers.delegateCount = 0;

						// Only use addEventListener if the special events handler returns false
						if ( !special.setup ||
							special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

							if ( elem.addEventListener ) {
								elem.addEventListener( type, eventHandle );
							}
						}
					}

					if ( special.add ) {
						special.add.call( elem, handleObj );

						if ( !handleObj.handler.guid ) {
							handleObj.handler.guid = handler.guid;
						}
					}

					// Add to the element's handler list, delegates in front
					if ( selector ) {
						handlers.splice( handlers.delegateCount++, 0, handleObj );
					} else {
						handlers.push( handleObj );
					}

					// Keep track of which events have ever been used, for event optimization
					jQuery.event.global[ type ] = true;
				}

			},

			// Detach an event or set of events from an element
			remove: function( elem, types, handler, selector, mappedTypes ) {

				var j, origCount, tmp,
					events, t, handleObj,
					special, handlers, type, namespaces, origType,
					elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

				if ( !elemData || !( events = elemData.events ) ) {
					return;
				}

				// Once for each type.namespace in types; type may be omitted
				types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
				t = types.length;
				while ( t-- ) {
					tmp = rtypenamespace.exec( types[ t ] ) || [];
					type = origType = tmp[ 1 ];
					namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

					// Unbind all events (on this namespace, if provided) for the element
					if ( !type ) {
						for ( type in events ) {
							jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
						}
						continue;
					}

					special = jQuery.event.special[ type ] || {};
					type = ( selector ? special.delegateType : special.bindType ) || type;
					handlers = events[ type ] || [];
					tmp = tmp[ 2 ] &&
						new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

					// Remove matching events
					origCount = j = handlers.length;
					while ( j-- ) {
						handleObj = handlers[ j ];

						if ( ( mappedTypes || origType === handleObj.origType ) &&
							( !handler || handler.guid === handleObj.guid ) &&
							( !tmp || tmp.test( handleObj.namespace ) ) &&
							( !selector || selector === handleObj.selector ||
								selector === "**" && handleObj.selector ) ) {
							handlers.splice( j, 1 );

							if ( handleObj.selector ) {
								handlers.delegateCount--;
							}
							if ( special.remove ) {
								special.remove.call( elem, handleObj );
							}
						}
					}

					// Remove generic event handler if we removed something and no more handlers exist
					// (avoids potential for endless recursion during removal of special event handlers)
					if ( origCount && !handlers.length ) {
						if ( !special.teardown ||
							special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

							jQuery.removeEvent( elem, type, elemData.handle );
						}

						delete events[ type ];
					}
				}

				// Remove data and the expando if it's no longer used
				if ( jQuery.isEmptyObject( events ) ) {
					dataPriv.remove( elem, "handle events" );
				}
			},

			dispatch: function( nativeEvent ) {

				// Make a writable jQuery.Event from the native event object
				var event = jQuery.event.fix( nativeEvent );

				var i, j, ret, matched, handleObj, handlerQueue,
					args = new Array( arguments.length ),
					handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
					special = jQuery.event.special[ event.type ] || {};

				// Use the fix-ed jQuery.Event rather than the (read-only) native event
				args[ 0 ] = event;

				for ( i = 1; i < arguments.length; i++ ) {
					args[ i ] = arguments[ i ];
				}

				event.delegateTarget = this;

				// Call the preDispatch hook for the mapped type, and let it bail if desired
				if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
					return;
				}

				// Determine handlers
				handlerQueue = jQuery.event.handlers.call( this, event, handlers );

				// Run delegates first; they may want to stop propagation beneath us
				i = 0;
				while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
					event.currentTarget = matched.elem;

					j = 0;
					while ( ( handleObj = matched.handlers[ j++ ] ) &&
						!event.isImmediatePropagationStopped() ) {

						// Triggered event must either 1) have no namespace, or 2) have namespace(s)
						// a subset or equal to those in the bound event (both can have no namespace).
						if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

							event.handleObj = handleObj;
							event.data = handleObj.data;

							ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
								handleObj.handler ).apply( matched.elem, args );

							if ( ret !== undefined ) {
								if ( ( event.result = ret ) === false ) {
									event.preventDefault();
									event.stopPropagation();
								}
							}
						}
					}
				}

				// Call the postDispatch hook for the mapped type
				if ( special.postDispatch ) {
					special.postDispatch.call( this, event );
				}

				return event.result;
			},

			handlers: function( event, handlers ) {
				var i, handleObj, sel, matchedHandlers, matchedSelectors,
					handlerQueue = [],
					delegateCount = handlers.delegateCount,
					cur = event.target;

				// Find delegate handlers
				if ( delegateCount &&

					// Support: IE <=9
					// Black-hole SVG <use> instance trees (trac-13180)
					cur.nodeType &&

					// Support: Firefox <=42
					// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
					// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
					// Support: IE 11 only
					// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
					!( event.type === "click" && event.button >= 1 ) ) {

					for ( ; cur !== this; cur = cur.parentNode || this ) {

						// Don't check non-elements (#13208)
						// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
						if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
							matchedHandlers = [];
							matchedSelectors = {};
							for ( i = 0; i < delegateCount; i++ ) {
								handleObj = handlers[ i ];

								// Don't conflict with Object.prototype properties (#13203)
								sel = handleObj.selector + " ";

								if ( matchedSelectors[ sel ] === undefined ) {
									matchedSelectors[ sel ] = handleObj.needsContext ?
										jQuery( sel, this ).index( cur ) > -1 :
										jQuery.find( sel, this, null, [ cur ] ).length;
								}
								if ( matchedSelectors[ sel ] ) {
									matchedHandlers.push( handleObj );
								}
							}
							if ( matchedHandlers.length ) {
								handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
							}
						}
					}
				}

				// Add the remaining (directly-bound) handlers
				cur = this;
				if ( delegateCount < handlers.length ) {
					handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
				}

				return handlerQueue;
			},

			addProp: function( name, hook ) {
				Object.defineProperty( jQuery.Event.prototype, name, {
					enumerable: true,
					configurable: true,

					get: jQuery.isFunction( hook ) ?
						function() {
							if ( this.originalEvent ) {
									return hook( this.originalEvent );
							}
						} :
						function() {
							if ( this.originalEvent ) {
									return this.originalEvent[ name ];
							}
						},

					set: function( value ) {
						Object.defineProperty( this, name, {
							enumerable: true,
							configurable: true,
							writable: true,
							value: value
						} );
					}
				} );
			},

			fix: function( originalEvent ) {
				return originalEvent[ jQuery.expando ] ?
					originalEvent :
					new jQuery.Event( originalEvent );
			},

			special: {
				load: {

					// Prevent triggered image.load events from bubbling to window.load
					noBubble: true
				},
				focus: {

					// Fire native event if possible so blur/focus sequence is correct
					trigger: function() {
						if ( this !== safeActiveElement() && this.focus ) {
							this.focus();
							return false;
						}
					},
					delegateType: "focusin"
				},
				blur: {
					trigger: function() {
						if ( this === safeActiveElement() && this.blur ) {
							this.blur();
							return false;
						}
					},
					delegateType: "focusout"
				},
				click: {

					// For checkbox, fire native event so checked state will be right
					trigger: function() {
						if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
							this.click();
							return false;
						}
					},

					// For cross-browser consistency, don't fire native .click() on links
					_default: function( event ) {
						return jQuery.nodeName( event.target, "a" );
					}
				},

				beforeunload: {
					postDispatch: function( event ) {

						// Support: Firefox 20+
						// Firefox doesn't alert if the returnValue field is not set.
						if ( event.result !== undefined && event.originalEvent ) {
							event.originalEvent.returnValue = event.result;
						}
					}
				}
			}
		};

		jQuery.removeEvent = function( elem, type, handle ) {

			// This "if" is needed for plain objects
			if ( elem.removeEventListener ) {
				elem.removeEventListener( type, handle );
			}
		};

		jQuery.Event = function( src, props ) {

			// Allow instantiation without the 'new' keyword
			if ( !( this instanceof jQuery.Event ) ) {
				return new jQuery.Event( src, props );
			}

			// Event object
			if ( src && src.type ) {
				this.originalEvent = src;
				this.type = src.type;

				// Events bubbling up the document may have been marked as prevented
				// by a handler lower down the tree; reflect the correct value.
				this.isDefaultPrevented = src.defaultPrevented ||
						src.defaultPrevented === undefined &&

						// Support: Android <=2.3 only
						src.returnValue === false ?
					returnTrue :
					returnFalse;

				// Create target properties
				// Support: Safari <=6 - 7 only
				// Target should not be a text node (#504, #13143)
				this.target = ( src.target && src.target.nodeType === 3 ) ?
					src.target.parentNode :
					src.target;

				this.currentTarget = src.currentTarget;
				this.relatedTarget = src.relatedTarget;

			// Event type
			} else {
				this.type = src;
			}

			// Put explicitly provided properties onto the event object
			if ( props ) {
				jQuery.extend( this, props );
			}

			// Create a timestamp if incoming event doesn't have one
			this.timeStamp = src && src.timeStamp || jQuery.now();

			// Mark it as fixed
			this[ jQuery.expando ] = true;
		};

		// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
		// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
		jQuery.Event.prototype = {
			constructor: jQuery.Event,
			isDefaultPrevented: returnFalse,
			isPropagationStopped: returnFalse,
			isImmediatePropagationStopped: returnFalse,
			isSimulated: false,

			preventDefault: function() {
				var e = this.originalEvent;

				this.isDefaultPrevented = returnTrue;

				if ( e && !this.isSimulated ) {
					e.preventDefault();
				}
			},
			stopPropagation: function() {
				var e = this.originalEvent;

				this.isPropagationStopped = returnTrue;

				if ( e && !this.isSimulated ) {
					e.stopPropagation();
				}
			},
			stopImmediatePropagation: function() {
				var e = this.originalEvent;

				this.isImmediatePropagationStopped = returnTrue;

				if ( e && !this.isSimulated ) {
					e.stopImmediatePropagation();
				}

				this.stopPropagation();
			}
		};

		// Includes all common event props including KeyEvent and MouseEvent specific props
		jQuery.each( {
			altKey: true,
			bubbles: true,
			cancelable: true,
			changedTouches: true,
			ctrlKey: true,
			detail: true,
			eventPhase: true,
			metaKey: true,
			pageX: true,
			pageY: true,
			shiftKey: true,
			view: true,
			"char": true,
			charCode: true,
			key: true,
			keyCode: true,
			button: true,
			buttons: true,
			clientX: true,
			clientY: true,
			offsetX: true,
			offsetY: true,
			pointerId: true,
			pointerType: true,
			screenX: true,
			screenY: true,
			targetTouches: true,
			toElement: true,
			touches: true,

			which: function( event ) {
				var button = event.button;

				// Add which for key events
				if ( event.which == null && rkeyEvent.test( event.type ) ) {
					return event.charCode != null ? event.charCode : event.keyCode;
				}

				// Add which for click: 1 === left; 2 === middle; 3 === right
				if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
					if ( button & 1 ) {
						return 1;
					}

					if ( button & 2 ) {
						return 3;
					}

					if ( button & 4 ) {
						return 2;
					}

					return 0;
				}

				return event.which;
			}
		}, jQuery.event.addProp );

		// Create mouseenter/leave events using mouseover/out and event-time checks
		// so that event delegation works in jQuery.
		// Do the same for pointerenter/pointerleave and pointerover/pointerout
		//
		// Support: Safari 7 only
		// Safari sends mouseenter too often; see:
		// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
		// for the description of the bug (it existed in older Chrome versions as well).
		jQuery.each( {
			mouseenter: "mouseover",
			mouseleave: "mouseout",
			pointerenter: "pointerover",
			pointerleave: "pointerout"
		}, function( orig, fix ) {
			jQuery.event.special[ orig ] = {
				delegateType: fix,
				bindType: fix,

				handle: function( event ) {
					var ret,
						target = this,
						related = event.relatedTarget,
						handleObj = event.handleObj;

					// For mouseenter/leave call the handler if related is outside the target.
					// NB: No relatedTarget if the mouse left/entered the browser window
					if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
						event.type = handleObj.origType;
						ret = handleObj.handler.apply( this, arguments );
						event.type = fix;
					}
					return ret;
				}
			};
		} );

		jQuery.fn.extend( {

			on: function( types, selector, data, fn ) {
				return on( this, types, selector, data, fn );
			},
			one: function( types, selector, data, fn ) {
				return on( this, types, selector, data, fn, 1 );
			},
			off: function( types, selector, fn ) {
				var handleObj, type;
				if ( types && types.preventDefault && types.handleObj ) {

					// ( event )  dispatched jQuery.Event
					handleObj = types.handleObj;
					jQuery( types.delegateTarget ).off(
						handleObj.namespace ?
							handleObj.origType + "." + handleObj.namespace :
							handleObj.origType,
						handleObj.selector,
						handleObj.handler
					);
					return this;
				}
				if ( typeof types === "object" ) {

					// ( types-object [, selector] )
					for ( type in types ) {
						this.off( type, selector, types[ type ] );
					}
					return this;
				}
				if ( selector === false || typeof selector === "function" ) {

					// ( types [, fn] )
					fn = selector;
					selector = undefined;
				}
				if ( fn === false ) {
					fn = returnFalse;
				}
				return this.each( function() {
					jQuery.event.remove( this, types, fn, selector );
				} );
			}
		} );


		var

			/* eslint-disable max-len */

			// See https://github.com/eslint/eslint/issues/3229
			rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

			/* eslint-enable */

			// Support: IE <=10 - 11, Edge 12 - 13
			// In IE/Edge using regex groups here causes severe slowdowns.
			// See https://connect.microsoft.com/IE/feedback/details/1736512/
			rnoInnerhtml = /<script|<style|<link/i,

			// checked="checked" or checked
			rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
			rscriptTypeMasked = /^true\/(.*)/,
			rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

		function manipulationTarget( elem, content ) {
			if ( jQuery.nodeName( elem, "table" ) &&
				jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

				return elem.getElementsByTagName( "tbody" )[ 0 ] || elem;
			}

			return elem;
		}

		// Replace/restore the type attribute of script elements for safe DOM manipulation
		function disableScript( elem ) {
			elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
			return elem;
		}
		function restoreScript( elem ) {
			var match = rscriptTypeMasked.exec( elem.type );

			if ( match ) {
				elem.type = match[ 1 ];
			} else {
				elem.removeAttribute( "type" );
			}

			return elem;
		}

		function cloneCopyEvent( src, dest ) {
			var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

			if ( dest.nodeType !== 1 ) {
				return;
			}

			// 1. Copy private data: events, handlers, etc.
			if ( dataPriv.hasData( src ) ) {
				pdataOld = dataPriv.access( src );
				pdataCur = dataPriv.set( dest, pdataOld );
				events = pdataOld.events;

				if ( events ) {
					delete pdataCur.handle;
					pdataCur.events = {};

					for ( type in events ) {
						for ( i = 0, l = events[ type ].length; i < l; i++ ) {
							jQuery.event.add( dest, type, events[ type ][ i ] );
						}
					}
				}
			}

			// 2. Copy user data
			if ( dataUser.hasData( src ) ) {
				udataOld = dataUser.access( src );
				udataCur = jQuery.extend( {}, udataOld );

				dataUser.set( dest, udataCur );
			}
		}

		// Fix IE bugs, see support tests
		function fixInput( src, dest ) {
			var nodeName = dest.nodeName.toLowerCase();

			// Fails to persist the checked state of a cloned checkbox or radio button.
			if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
				dest.checked = src.checked;

			// Fails to return the selected option to the default selected state when cloning options
			} else if ( nodeName === "input" || nodeName === "textarea" ) {
				dest.defaultValue = src.defaultValue;
			}
		}

		function domManip( collection, args, callback, ignored ) {

			// Flatten any nested arrays
			args = concat.apply( [], args );

			var fragment, first, scripts, hasScripts, node, doc,
				i = 0,
				l = collection.length,
				iNoClone = l - 1,
				value = args[ 0 ],
				isFunction = jQuery.isFunction( value );

			// We can't cloneNode fragments that contain checked, in WebKit
			if ( isFunction ||
					( l > 1 && typeof value === "string" &&
						!support.checkClone && rchecked.test( value ) ) ) {
				return collection.each( function( index ) {
					var self = collection.eq( index );
					if ( isFunction ) {
						args[ 0 ] = value.call( this, index, self.html() );
					}
					domManip( self, args, callback, ignored );
				} );
			}

			if ( l ) {
				fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
				first = fragment.firstChild;

				if ( fragment.childNodes.length === 1 ) {
					fragment = first;
				}

				// Require either new content or an interest in ignored elements to invoke the callback
				if ( first || ignored ) {
					scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
					hasScripts = scripts.length;

					// Use the original fragment for the last item
					// instead of the first because it can end up
					// being emptied incorrectly in certain situations (#8070).
					for ( ; i < l; i++ ) {
						node = fragment;

						if ( i !== iNoClone ) {
							node = jQuery.clone( node, true, true );

							// Keep references to cloned scripts for later restoration
							if ( hasScripts ) {

								// Support: Android <=4.0 only, PhantomJS 1 only
								// push.apply(_, arraylike) throws on ancient WebKit
								jQuery.merge( scripts, getAll( node, "script" ) );
							}
						}

						callback.call( collection[ i ], node, i );
					}

					if ( hasScripts ) {
						doc = scripts[ scripts.length - 1 ].ownerDocument;

						// Reenable scripts
						jQuery.map( scripts, restoreScript );

						// Evaluate executable scripts on first document insertion
						for ( i = 0; i < hasScripts; i++ ) {
							node = scripts[ i ];
							if ( rscriptType.test( node.type || "" ) &&
								!dataPriv.access( node, "globalEval" ) &&
								jQuery.contains( doc, node ) ) {

								if ( node.src ) {

									// Optional AJAX dependency, but won't run scripts if not present
									if ( jQuery._evalUrl ) {
										jQuery._evalUrl( node.src );
									}
								} else {
									DOMEval( node.textContent.replace( rcleanScript, "" ), doc );
								}
							}
						}
					}
				}
			}

			return collection;
		}

		function remove( elem, selector, keepData ) {
			var node,
				nodes = selector ? jQuery.filter( selector, elem ) : elem,
				i = 0;

			for ( ; ( node = nodes[ i ] ) != null; i++ ) {
				if ( !keepData && node.nodeType === 1 ) {
					jQuery.cleanData( getAll( node ) );
				}

				if ( node.parentNode ) {
					if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
						setGlobalEval( getAll( node, "script" ) );
					}
					node.parentNode.removeChild( node );
				}
			}

			return elem;
		}

		jQuery.extend( {
			htmlPrefilter: function( html ) {
				return html.replace( rxhtmlTag, "<$1></$2>" );
			},

			clone: function( elem, dataAndEvents, deepDataAndEvents ) {
				var i, l, srcElements, destElements,
					clone = elem.cloneNode( true ),
					inPage = jQuery.contains( elem.ownerDocument, elem );

				// Fix IE cloning issues
				if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
						!jQuery.isXMLDoc( elem ) ) {

					// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
					destElements = getAll( clone );
					srcElements = getAll( elem );

					for ( i = 0, l = srcElements.length; i < l; i++ ) {
						fixInput( srcElements[ i ], destElements[ i ] );
					}
				}

				// Copy the events from the original to the clone
				if ( dataAndEvents ) {
					if ( deepDataAndEvents ) {
						srcElements = srcElements || getAll( elem );
						destElements = destElements || getAll( clone );

						for ( i = 0, l = srcElements.length; i < l; i++ ) {
							cloneCopyEvent( srcElements[ i ], destElements[ i ] );
						}
					} else {
						cloneCopyEvent( elem, clone );
					}
				}

				// Preserve script evaluation history
				destElements = getAll( clone, "script" );
				if ( destElements.length > 0 ) {
					setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
				}

				// Return the cloned set
				return clone;
			},

			cleanData: function( elems ) {
				var data, elem, type,
					special = jQuery.event.special,
					i = 0;

				for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
					if ( acceptData( elem ) ) {
						if ( ( data = elem[ dataPriv.expando ] ) ) {
							if ( data.events ) {
								for ( type in data.events ) {
									if ( special[ type ] ) {
										jQuery.event.remove( elem, type );

									// This is a shortcut to avoid jQuery.event.remove's overhead
									} else {
										jQuery.removeEvent( elem, type, data.handle );
									}
								}
							}

							// Support: Chrome <=35 - 45+
							// Assign undefined instead of using delete, see Data#remove
							elem[ dataPriv.expando ] = undefined;
						}
						if ( elem[ dataUser.expando ] ) {

							// Support: Chrome <=35 - 45+
							// Assign undefined instead of using delete, see Data#remove
							elem[ dataUser.expando ] = undefined;
						}
					}
				}
			}
		} );

		jQuery.fn.extend( {
			detach: function( selector ) {
				return remove( this, selector, true );
			},

			remove: function( selector ) {
				return remove( this, selector );
			},

			text: function( value ) {
				return access( this, function( value ) {
					return value === undefined ?
						jQuery.text( this ) :
						this.empty().each( function() {
							if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
								this.textContent = value;
							}
						} );
				}, null, value, arguments.length );
			},

			append: function() {
				return domManip( this, arguments, function( elem ) {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						var target = manipulationTarget( this, elem );
						target.appendChild( elem );
					}
				} );
			},

			prepend: function() {
				return domManip( this, arguments, function( elem ) {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						var target = manipulationTarget( this, elem );
						target.insertBefore( elem, target.firstChild );
					}
				} );
			},

			before: function() {
				return domManip( this, arguments, function( elem ) {
					if ( this.parentNode ) {
						this.parentNode.insertBefore( elem, this );
					}
				} );
			},

			after: function() {
				return domManip( this, arguments, function( elem ) {
					if ( this.parentNode ) {
						this.parentNode.insertBefore( elem, this.nextSibling );
					}
				} );
			},

			empty: function() {
				var elem,
					i = 0;

				for ( ; ( elem = this[ i ] ) != null; i++ ) {
					if ( elem.nodeType === 1 ) {

						// Prevent memory leaks
						jQuery.cleanData( getAll( elem, false ) );

						// Remove any remaining nodes
						elem.textContent = "";
					}
				}

				return this;
			},

			clone: function( dataAndEvents, deepDataAndEvents ) {
				dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
				deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

				return this.map( function() {
					return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
				} );
			},

			html: function( value ) {
				return access( this, function( value ) {
					var elem = this[ 0 ] || {},
						i = 0,
						l = this.length;

					if ( value === undefined && elem.nodeType === 1 ) {
						return elem.innerHTML;
					}

					// See if we can take a shortcut and just use innerHTML
					if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
						!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

						value = jQuery.htmlPrefilter( value );

						try {
							for ( ; i < l; i++ ) {
								elem = this[ i ] || {};

								// Remove element nodes and prevent memory leaks
								if ( elem.nodeType === 1 ) {
									jQuery.cleanData( getAll( elem, false ) );
									elem.innerHTML = value;
								}
							}

							elem = 0;

						// If using innerHTML throws an exception, use the fallback method
						} catch ( e ) {}
					}

					if ( elem ) {
						this.empty().append( value );
					}
				}, null, value, arguments.length );
			},

			replaceWith: function() {
				var ignored = [];

				// Make the changes, replacing each non-ignored context element with the new content
				return domManip( this, arguments, function( elem ) {
					var parent = this.parentNode;

					if ( jQuery.inArray( this, ignored ) < 0 ) {
						jQuery.cleanData( getAll( this ) );
						if ( parent ) {
							parent.replaceChild( elem, this );
						}
					}

				// Force callback invocation
				}, ignored );
			}
		} );

		jQuery.each( {
			appendTo: "append",
			prependTo: "prepend",
			insertBefore: "before",
			insertAfter: "after",
			replaceAll: "replaceWith"
		}, function( name, original ) {
			jQuery.fn[ name ] = function( selector ) {
				var elems,
					ret = [],
					insert = jQuery( selector ),
					last = insert.length - 1,
					i = 0;

				for ( ; i <= last; i++ ) {
					elems = i === last ? this : this.clone( true );
					jQuery( insert[ i ] )[ original ]( elems );

					// Support: Android <=4.0 only, PhantomJS 1 only
					// .get() because push.apply(_, arraylike) throws on ancient WebKit
					push.apply( ret, elems.get() );
				}

				return this.pushStack( ret );
			};
		} );
		var rmargin = ( /^margin/ );

		var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

		var getStyles = function( elem ) {

				// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
				// IE throws on elements created in popups
				// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
				var view = elem.ownerDocument.defaultView;

				if ( !view || !view.opener ) {
					view = window;
				}

				return view.getComputedStyle( elem );
			};



		( function() {

			// Executing both pixelPosition & boxSizingReliable tests require only one layout
			// so they're executed at the same time to save the second computation.
			function computeStyleTests() {

				// This is a singleton, we need to execute it only once
				if ( !div ) {
					return;
				}

				div.style.cssText =
					"box-sizing:border-box;" +
					"position:relative;display:block;" +
					"margin:auto;border:1px;padding:1px;" +
					"top:1%;width:50%";
				div.innerHTML = "";
				documentElement.appendChild( container );

				var divStyle = window.getComputedStyle( div );
				pixelPositionVal = divStyle.top !== "1%";

				// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
				reliableMarginLeftVal = divStyle.marginLeft === "2px";
				boxSizingReliableVal = divStyle.width === "4px";

				// Support: Android 4.0 - 4.3 only
				// Some styles come back with percentage values, even though they shouldn't
				div.style.marginRight = "50%";
				pixelMarginRightVal = divStyle.marginRight === "4px";

				documentElement.removeChild( container );

				// Nullify the div so it wouldn't be stored in the memory and
				// it will also be a sign that checks already performed
				div = null;
			}

			var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,
				container = document.createElement( "div" ),
				div = document.createElement( "div" );

			// Finish early in limited (non-browser) environments
			if ( !div.style ) {
				return;
			}

			// Support: IE <=9 - 11 only
			// Style of cloned element affects source element cloned (#8908)
			div.style.backgroundClip = "content-box";
			div.cloneNode( true ).style.backgroundClip = "";
			support.clearCloneStyle = div.style.backgroundClip === "content-box";

			container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
				"padding:0;margin-top:1px;position:absolute";
			container.appendChild( div );

			jQuery.extend( support, {
				pixelPosition: function() {
					computeStyleTests();
					return pixelPositionVal;
				},
				boxSizingReliable: function() {
					computeStyleTests();
					return boxSizingReliableVal;
				},
				pixelMarginRight: function() {
					computeStyleTests();
					return pixelMarginRightVal;
				},
				reliableMarginLeft: function() {
					computeStyleTests();
					return reliableMarginLeftVal;
				}
			} );
		} )();


		function curCSS( elem, name, computed ) {
			var width, minWidth, maxWidth, ret,
				style = elem.style;

			computed = computed || getStyles( elem );

			// Support: IE <=9 only
			// getPropertyValue is only needed for .css('filter') (#12537)
			if ( computed ) {
				ret = computed.getPropertyValue( name ) || computed[ name ];

				if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
					ret = jQuery.style( elem, name );
				}

				// A tribute to the "awesome hack by Dean Edwards"
				// Android Browser returns percentage for some values,
				// but width seems to be reliably pixels.
				// This is against the CSSOM draft spec:
				// https://drafts.csswg.org/cssom/#resolved-values
				if ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {

					// Remember the original values
					width = style.width;
					minWidth = style.minWidth;
					maxWidth = style.maxWidth;

					// Put in the new values to get a computed value out
					style.minWidth = style.maxWidth = style.width = ret;
					ret = computed.width;

					// Revert the changed values
					style.width = width;
					style.minWidth = minWidth;
					style.maxWidth = maxWidth;
				}
			}

			return ret !== undefined ?

				// Support: IE <=9 - 11 only
				// IE returns zIndex value as an integer.
				ret + "" :
				ret;
		}


		function addGetHookIf( conditionFn, hookFn ) {

			// Define the hook, we'll check on the first run if it's really needed.
			return {
				get: function() {
					if ( conditionFn() ) {

						// Hook not needed (or it's not possible to use it due
						// to missing dependency), remove it.
						delete this.get;
						return;
					}

					// Hook needed; redefine it so that the support test is not executed again.
					return ( this.get = hookFn ).apply( this, arguments );
				}
			};
		}


		var

			// Swappable if display is none or starts with table
			// except "table", "table-cell", or "table-caption"
			// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
			rdisplayswap = /^(none|table(?!-c[ea]).+)/,
			cssShow = { position: "absolute", visibility: "hidden", display: "block" },
			cssNormalTransform = {
				letterSpacing: "0",
				fontWeight: "400"
			},

			cssPrefixes = [ "Webkit", "Moz", "ms" ],
			emptyStyle = document.createElement( "div" ).style;

		// Return a css property mapped to a potentially vendor prefixed property
		function vendorPropName( name ) {

			// Shortcut for names that are not vendor prefixed
			if ( name in emptyStyle ) {
				return name;
			}

			// Check for vendor prefixed names
			var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
				i = cssPrefixes.length;

			while ( i-- ) {
				name = cssPrefixes[ i ] + capName;
				if ( name in emptyStyle ) {
					return name;
				}
			}
		}

		function setPositiveNumber( elem, value, subtract ) {

			// Any relative (+/-) values have already been
			// normalized at this point
			var matches = rcssNum.exec( value );
			return matches ?

				// Guard against undefined "subtract", e.g., when used as in cssHooks
				Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
				value;
		}

		function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
			var i,
				val = 0;

			// If we already have the right measurement, avoid augmentation
			if ( extra === ( isBorderBox ? "border" : "content" ) ) {
				i = 4;

			// Otherwise initialize for horizontal or vertical properties
			} else {
				i = name === "width" ? 1 : 0;
			}

			for ( ; i < 4; i += 2 ) {

				// Both box models exclude margin, so add it if we want it
				if ( extra === "margin" ) {
					val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
				}

				if ( isBorderBox ) {

					// border-box includes padding, so remove it if we want content
					if ( extra === "content" ) {
						val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
					}

					// At this point, extra isn't border nor margin, so remove border
					if ( extra !== "margin" ) {
						val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
					}
				} else {

					// At this point, extra isn't content, so add padding
					val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

					// At this point, extra isn't content nor padding, so add border
					if ( extra !== "padding" ) {
						val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
					}
				}
			}

			return val;
		}

		function getWidthOrHeight( elem, name, extra ) {

			// Start with offset property, which is equivalent to the border-box value
			var val,
				valueIsBorderBox = true,
				styles = getStyles( elem ),
				isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

			// Support: IE <=11 only
			// Running getBoundingClientRect on a disconnected node
			// in IE throws an error.
			if ( elem.getClientRects().length ) {
				val = elem.getBoundingClientRect()[ name ];
			}

			// Some non-html elements return undefined for offsetWidth, so check for null/undefined
			// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
			// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
			if ( val <= 0 || val == null ) {

				// Fall back to computed then uncomputed css if necessary
				val = curCSS( elem, name, styles );
				if ( val < 0 || val == null ) {
					val = elem.style[ name ];
				}

				// Computed unit is not pixels. Stop here and return.
				if ( rnumnonpx.test( val ) ) {
					return val;
				}

				// Check for style in case a browser which returns unreliable values
				// for getComputedStyle silently falls back to the reliable elem.style
				valueIsBorderBox = isBorderBox &&
					( support.boxSizingReliable() || val === elem.style[ name ] );

				// Normalize "", auto, and prepare for extra
				val = parseFloat( val ) || 0;
			}

			// Use the active box-sizing model to add/subtract irrelevant styles
			return ( val +
				augmentWidthOrHeight(
					elem,
					name,
					extra || ( isBorderBox ? "border" : "content" ),
					valueIsBorderBox,
					styles
				)
			) + "px";
		}

		jQuery.extend( {

			// Add in style property hooks for overriding the default
			// behavior of getting and setting a style property
			cssHooks: {
				opacity: {
					get: function( elem, computed ) {
						if ( computed ) {

							// We should always get a number back from opacity
							var ret = curCSS( elem, "opacity" );
							return ret === "" ? "1" : ret;
						}
					}
				}
			},

			// Don't automatically add "px" to these possibly-unitless properties
			cssNumber: {
				"animationIterationCount": true,
				"columnCount": true,
				"fillOpacity": true,
				"flexGrow": true,
				"flexShrink": true,
				"fontWeight": true,
				"lineHeight": true,
				"opacity": true,
				"order": true,
				"orphans": true,
				"widows": true,
				"zIndex": true,
				"zoom": true
			},

			// Add in properties whose names you wish to fix before
			// setting or getting the value
			cssProps: {
				"float": "cssFloat"
			},

			// Get and set the style property on a DOM Node
			style: function( elem, name, value, extra ) {

				// Don't set styles on text and comment nodes
				if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
					return;
				}

				// Make sure that we're working with the right name
				var ret, type, hooks,
					origName = jQuery.camelCase( name ),
					style = elem.style;

				name = jQuery.cssProps[ origName ] ||
					( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

				// Gets hook for the prefixed version, then unprefixed version
				hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

				// Check if we're setting a value
				if ( value !== undefined ) {
					type = typeof value;

					// Convert "+=" or "-=" to relative numbers (#7345)
					if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
						value = adjustCSS( elem, name, ret );

						// Fixes bug #9237
						type = "number";
					}

					// Make sure that null and NaN values aren't set (#7116)
					if ( value == null || value !== value ) {
						return;
					}

					// If a number was passed in, add the unit (except for certain CSS properties)
					if ( type === "number" ) {
						value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
					}

					// background-* props affect original clone's values
					if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
						style[ name ] = "inherit";
					}

					// If a hook was provided, use that value, otherwise just set the specified value
					if ( !hooks || !( "set" in hooks ) ||
						( value = hooks.set( elem, value, extra ) ) !== undefined ) {

						style[ name ] = value;
					}

				} else {

					// If a hook was provided get the non-computed value from there
					if ( hooks && "get" in hooks &&
						( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

						return ret;
					}

					// Otherwise just get the value from the style object
					return style[ name ];
				}
			},

			css: function( elem, name, extra, styles ) {
				var val, num, hooks,
					origName = jQuery.camelCase( name );

				// Make sure that we're working with the right name
				name = jQuery.cssProps[ origName ] ||
					( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

				// Try prefixed name followed by the unprefixed name
				hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

				// If a hook was provided get the computed value from there
				if ( hooks && "get" in hooks ) {
					val = hooks.get( elem, true, extra );
				}

				// Otherwise, if a way to get the computed value exists, use that
				if ( val === undefined ) {
					val = curCSS( elem, name, styles );
				}

				// Convert "normal" to computed value
				if ( val === "normal" && name in cssNormalTransform ) {
					val = cssNormalTransform[ name ];
				}

				// Make numeric if forced or a qualifier was provided and val looks numeric
				if ( extra === "" || extra ) {
					num = parseFloat( val );
					return extra === true || isFinite( num ) ? num || 0 : val;
				}
				return val;
			}
		} );

		jQuery.each( [ "height", "width" ], function( i, name ) {
			jQuery.cssHooks[ name ] = {
				get: function( elem, computed, extra ) {
					if ( computed ) {

						// Certain elements can have dimension info if we invisibly show them
						// but it must have a current display style that would benefit
						return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

							// Support: Safari 8+
							// Table columns in Safari have non-zero offsetWidth & zero
							// getBoundingClientRect().width unless display is changed.
							// Support: IE <=11 only
							// Running getBoundingClientRect on a disconnected node
							// in IE throws an error.
							( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
								swap( elem, cssShow, function() {
									return getWidthOrHeight( elem, name, extra );
								} ) :
								getWidthOrHeight( elem, name, extra );
					}
				},

				set: function( elem, value, extra ) {
					var matches,
						styles = extra && getStyles( elem ),
						subtract = extra && augmentWidthOrHeight(
							elem,
							name,
							extra,
							jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
							styles
						);

					// Convert to pixels if value adjustment is needed
					if ( subtract && ( matches = rcssNum.exec( value ) ) &&
						( matches[ 3 ] || "px" ) !== "px" ) {

						elem.style[ name ] = value;
						value = jQuery.css( elem, name );
					}

					return setPositiveNumber( elem, value, subtract );
				}
			};
		} );

		jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
			function( elem, computed ) {
				if ( computed ) {
					return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
						elem.getBoundingClientRect().left -
							swap( elem, { marginLeft: 0 }, function() {
								return elem.getBoundingClientRect().left;
							} )
						) + "px";
				}
			}
		);

		// These hooks are used by animate to expand properties
		jQuery.each( {
			margin: "",
			padding: "",
			border: "Width"
		}, function( prefix, suffix ) {
			jQuery.cssHooks[ prefix + suffix ] = {
				expand: function( value ) {
					var i = 0,
						expanded = {},

						// Assumes a single number if not a string
						parts = typeof value === "string" ? value.split( " " ) : [ value ];

					for ( ; i < 4; i++ ) {
						expanded[ prefix + cssExpand[ i ] + suffix ] =
							parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
					}

					return expanded;
				}
			};

			if ( !rmargin.test( prefix ) ) {
				jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
			}
		} );

		jQuery.fn.extend( {
			css: function( name, value ) {
				return access( this, function( elem, name, value ) {
					var styles, len,
						map = {},
						i = 0;

					if ( jQuery.isArray( name ) ) {
						styles = getStyles( elem );
						len = name.length;

						for ( ; i < len; i++ ) {
							map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
						}

						return map;
					}

					return value !== undefined ?
						jQuery.style( elem, name, value ) :
						jQuery.css( elem, name );
				}, name, value, arguments.length > 1 );
			}
		} );


		function Tween( elem, options, prop, end, easing ) {
			return new Tween.prototype.init( elem, options, prop, end, easing );
		}
		jQuery.Tween = Tween;

		Tween.prototype = {
			constructor: Tween,
			init: function( elem, options, prop, end, easing, unit ) {
				this.elem = elem;
				this.prop = prop;
				this.easing = easing || jQuery.easing._default;
				this.options = options;
				this.start = this.now = this.cur();
				this.end = end;
				this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
			},
			cur: function() {
				var hooks = Tween.propHooks[ this.prop ];

				return hooks && hooks.get ?
					hooks.get( this ) :
					Tween.propHooks._default.get( this );
			},
			run: function( percent ) {
				var eased,
					hooks = Tween.propHooks[ this.prop ];

				if ( this.options.duration ) {
					this.pos = eased = jQuery.easing[ this.easing ](
						percent, this.options.duration * percent, 0, 1, this.options.duration
					);
				} else {
					this.pos = eased = percent;
				}
				this.now = ( this.end - this.start ) * eased + this.start;

				if ( this.options.step ) {
					this.options.step.call( this.elem, this.now, this );
				}

				if ( hooks && hooks.set ) {
					hooks.set( this );
				} else {
					Tween.propHooks._default.set( this );
				}
				return this;
			}
		};

		Tween.prototype.init.prototype = Tween.prototype;

		Tween.propHooks = {
			_default: {
				get: function( tween ) {
					var result;

					// Use a property on the element directly when it is not a DOM element,
					// or when there is no matching style property that exists.
					if ( tween.elem.nodeType !== 1 ||
						tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
						return tween.elem[ tween.prop ];
					}

					// Passing an empty string as a 3rd parameter to .css will automatically
					// attempt a parseFloat and fallback to a string if the parse fails.
					// Simple values such as "10px" are parsed to Float;
					// complex values such as "rotate(1rad)" are returned as-is.
					result = jQuery.css( tween.elem, tween.prop, "" );

					// Empty strings, null, undefined and "auto" are converted to 0.
					return !result || result === "auto" ? 0 : result;
				},
				set: function( tween ) {

					// Use step hook for back compat.
					// Use cssHook if its there.
					// Use .style if available and use plain properties where available.
					if ( jQuery.fx.step[ tween.prop ] ) {
						jQuery.fx.step[ tween.prop ]( tween );
					} else if ( tween.elem.nodeType === 1 &&
						( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
							jQuery.cssHooks[ tween.prop ] ) ) {
						jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
					} else {
						tween.elem[ tween.prop ] = tween.now;
					}
				}
			}
		};

		// Support: IE <=9 only
		// Panic based approach to setting things on disconnected nodes
		Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
			set: function( tween ) {
				if ( tween.elem.nodeType && tween.elem.parentNode ) {
					tween.elem[ tween.prop ] = tween.now;
				}
			}
		};

		jQuery.easing = {
			linear: function( p ) {
				return p;
			},
			swing: function( p ) {
				return 0.5 - Math.cos( p * Math.PI ) / 2;
			},
			_default: "swing"
		};

		jQuery.fx = Tween.prototype.init;

		// Back compat <1.8 extension point
		jQuery.fx.step = {};




		var
			fxNow, timerId,
			rfxtypes = /^(?:toggle|show|hide)$/,
			rrun = /queueHooks$/;

		function raf() {
			if ( timerId ) {
				window.requestAnimationFrame( raf );
				jQuery.fx.tick();
			}
		}

		// Animations created synchronously will run synchronously
		function createFxNow() {
			window.setTimeout( function() {
				fxNow = undefined;
			} );
			return ( fxNow = jQuery.now() );
		}

		// Generate parameters to create a standard animation
		function genFx( type, includeWidth ) {
			var which,
				i = 0,
				attrs = { height: type };

			// If we include width, step value is 1 to do all cssExpand values,
			// otherwise step value is 2 to skip over Left and Right
			includeWidth = includeWidth ? 1 : 0;
			for ( ; i < 4; i += 2 - includeWidth ) {
				which = cssExpand[ i ];
				attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
			}

			if ( includeWidth ) {
				attrs.opacity = attrs.width = type;
			}

			return attrs;
		}

		function createTween( value, prop, animation ) {
			var tween,
				collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
				index = 0,
				length = collection.length;
			for ( ; index < length; index++ ) {
				if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

					// We're done with this property
					return tween;
				}
			}
		}

		function defaultPrefilter( elem, props, opts ) {
			var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
				isBox = "width" in props || "height" in props,
				anim = this,
				orig = {},
				style = elem.style,
				hidden = elem.nodeType && isHiddenWithinTree( elem ),
				dataShow = dataPriv.get( elem, "fxshow" );

			// Queue-skipping animations hijack the fx hooks
			if ( !opts.queue ) {
				hooks = jQuery._queueHooks( elem, "fx" );
				if ( hooks.unqueued == null ) {
					hooks.unqueued = 0;
					oldfire = hooks.empty.fire;
					hooks.empty.fire = function() {
						if ( !hooks.unqueued ) {
							oldfire();
						}
					};
				}
				hooks.unqueued++;

				anim.always( function() {

					// Ensure the complete handler is called before this completes
					anim.always( function() {
						hooks.unqueued--;
						if ( !jQuery.queue( elem, "fx" ).length ) {
							hooks.empty.fire();
						}
					} );
				} );
			}

			// Detect show/hide animations
			for ( prop in props ) {
				value = props[ prop ];
				if ( rfxtypes.test( value ) ) {
					delete props[ prop ];
					toggle = toggle || value === "toggle";
					if ( value === ( hidden ? "hide" : "show" ) ) {

						// Pretend to be hidden if this is a "show" and
						// there is still data from a stopped show/hide
						if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
							hidden = true;

						// Ignore all other no-op show/hide data
						} else {
							continue;
						}
					}
					orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
				}
			}

			// Bail out if this is a no-op like .hide().hide()
			propTween = !jQuery.isEmptyObject( props );
			if ( !propTween && jQuery.isEmptyObject( orig ) ) {
				return;
			}

			// Restrict "overflow" and "display" styles during box animations
			if ( isBox && elem.nodeType === 1 ) {

				// Support: IE <=9 - 11, Edge 12 - 13
				// Record all 3 overflow attributes because IE does not infer the shorthand
				// from identically-valued overflowX and overflowY
				opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

				// Identify a display type, preferring old show/hide data over the CSS cascade
				restoreDisplay = dataShow && dataShow.display;
				if ( restoreDisplay == null ) {
					restoreDisplay = dataPriv.get( elem, "display" );
				}
				display = jQuery.css( elem, "display" );
				if ( display === "none" ) {
					if ( restoreDisplay ) {
						display = restoreDisplay;
					} else {

						// Get nonempty value(s) by temporarily forcing visibility
						showHide( [ elem ], true );
						restoreDisplay = elem.style.display || restoreDisplay;
						display = jQuery.css( elem, "display" );
						showHide( [ elem ] );
					}
				}

				// Animate inline elements as inline-block
				if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
					if ( jQuery.css( elem, "float" ) === "none" ) {

						// Restore the original display value at the end of pure show/hide animations
						if ( !propTween ) {
							anim.done( function() {
								style.display = restoreDisplay;
							} );
							if ( restoreDisplay == null ) {
								display = style.display;
								restoreDisplay = display === "none" ? "" : display;
							}
						}
						style.display = "inline-block";
					}
				}
			}

			if ( opts.overflow ) {
				style.overflow = "hidden";
				anim.always( function() {
					style.overflow = opts.overflow[ 0 ];
					style.overflowX = opts.overflow[ 1 ];
					style.overflowY = opts.overflow[ 2 ];
				} );
			}

			// Implement show/hide animations
			propTween = false;
			for ( prop in orig ) {

				// General show/hide setup for this element animation
				if ( !propTween ) {
					if ( dataShow ) {
						if ( "hidden" in dataShow ) {
							hidden = dataShow.hidden;
						}
					} else {
						dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
					}

					// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
					if ( toggle ) {
						dataShow.hidden = !hidden;
					}

					// Show elements before animating them
					if ( hidden ) {
						showHide( [ elem ], true );
					}

					/* eslint-disable no-loop-func */

					anim.done( function() {

					/* eslint-enable no-loop-func */

						// The final step of a "hide" animation is actually hiding the element
						if ( !hidden ) {
							showHide( [ elem ] );
						}
						dataPriv.remove( elem, "fxshow" );
						for ( prop in orig ) {
							jQuery.style( elem, prop, orig[ prop ] );
						}
					} );
				}

				// Per-property setup
				propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
				if ( !( prop in dataShow ) ) {
					dataShow[ prop ] = propTween.start;
					if ( hidden ) {
						propTween.end = propTween.start;
						propTween.start = 0;
					}
				}
			}
		}

		function propFilter( props, specialEasing ) {
			var index, name, easing, value, hooks;

			// camelCase, specialEasing and expand cssHook pass
			for ( index in props ) {
				name = jQuery.camelCase( index );
				easing = specialEasing[ name ];
				value = props[ index ];
				if ( jQuery.isArray( value ) ) {
					easing = value[ 1 ];
					value = props[ index ] = value[ 0 ];
				}

				if ( index !== name ) {
					props[ name ] = value;
					delete props[ index ];
				}

				hooks = jQuery.cssHooks[ name ];
				if ( hooks && "expand" in hooks ) {
					value = hooks.expand( value );
					delete props[ name ];

					// Not quite $.extend, this won't overwrite existing keys.
					// Reusing 'index' because we have the correct "name"
					for ( index in value ) {
						if ( !( index in props ) ) {
							props[ index ] = value[ index ];
							specialEasing[ index ] = easing;
						}
					}
				} else {
					specialEasing[ name ] = easing;
				}
			}
		}

		function Animation( elem, properties, options ) {
			var result,
				stopped,
				index = 0,
				length = Animation.prefilters.length,
				deferred = jQuery.Deferred().always( function() {

					// Don't match elem in the :animated selector
					delete tick.elem;
				} ),
				tick = function() {
					if ( stopped ) {
						return false;
					}
					var currentTime = fxNow || createFxNow(),
						remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

						// Support: Android 2.3 only
						// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
						temp = remaining / animation.duration || 0,
						percent = 1 - temp,
						index = 0,
						length = animation.tweens.length;

					for ( ; index < length; index++ ) {
						animation.tweens[ index ].run( percent );
					}

					deferred.notifyWith( elem, [ animation, percent, remaining ] );

					if ( percent < 1 && length ) {
						return remaining;
					} else {
						deferred.resolveWith( elem, [ animation ] );
						return false;
					}
				},
				animation = deferred.promise( {
					elem: elem,
					props: jQuery.extend( {}, properties ),
					opts: jQuery.extend( true, {
						specialEasing: {},
						easing: jQuery.easing._default
					}, options ),
					originalProperties: properties,
					originalOptions: options,
					startTime: fxNow || createFxNow(),
					duration: options.duration,
					tweens: [],
					createTween: function( prop, end ) {
						var tween = jQuery.Tween( elem, animation.opts, prop, end,
								animation.opts.specialEasing[ prop ] || animation.opts.easing );
						animation.tweens.push( tween );
						return tween;
					},
					stop: function( gotoEnd ) {
						var index = 0,

							// If we are going to the end, we want to run all the tweens
							// otherwise we skip this part
							length = gotoEnd ? animation.tweens.length : 0;
						if ( stopped ) {
							return this;
						}
						stopped = true;
						for ( ; index < length; index++ ) {
							animation.tweens[ index ].run( 1 );
						}

						// Resolve when we played the last frame; otherwise, reject
						if ( gotoEnd ) {
							deferred.notifyWith( elem, [ animation, 1, 0 ] );
							deferred.resolveWith( elem, [ animation, gotoEnd ] );
						} else {
							deferred.rejectWith( elem, [ animation, gotoEnd ] );
						}
						return this;
					}
				} ),
				props = animation.props;

			propFilter( props, animation.opts.specialEasing );

			for ( ; index < length; index++ ) {
				result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
				if ( result ) {
					if ( jQuery.isFunction( result.stop ) ) {
						jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
							jQuery.proxy( result.stop, result );
					}
					return result;
				}
			}

			jQuery.map( props, createTween, animation );

			if ( jQuery.isFunction( animation.opts.start ) ) {
				animation.opts.start.call( elem, animation );
			}

			jQuery.fx.timer(
				jQuery.extend( tick, {
					elem: elem,
					anim: animation,
					queue: animation.opts.queue
				} )
			);

			// attach callbacks from options
			return animation.progress( animation.opts.progress )
				.done( animation.opts.done, animation.opts.complete )
				.fail( animation.opts.fail )
				.always( animation.opts.always );
		}

		jQuery.Animation = jQuery.extend( Animation, {

			tweeners: {
				"*": [ function( prop, value ) {
					var tween = this.createTween( prop, value );
					adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
					return tween;
				} ]
			},

			tweener: function( props, callback ) {
				if ( jQuery.isFunction( props ) ) {
					callback = props;
					props = [ "*" ];
				} else {
					props = props.match( rnothtmlwhite );
				}

				var prop,
					index = 0,
					length = props.length;

				for ( ; index < length; index++ ) {
					prop = props[ index ];
					Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
					Animation.tweeners[ prop ].unshift( callback );
				}
			},

			prefilters: [ defaultPrefilter ],

			prefilter: function( callback, prepend ) {
				if ( prepend ) {
					Animation.prefilters.unshift( callback );
				} else {
					Animation.prefilters.push( callback );
				}
			}
		} );

		jQuery.speed = function( speed, easing, fn ) {
			var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
				complete: fn || !fn && easing ||
					jQuery.isFunction( speed ) && speed,
				duration: speed,
				easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
			};

			// Go to the end state if fx are off or if document is hidden
			if ( jQuery.fx.off || document.hidden ) {
				opt.duration = 0;

			} else {
				if ( typeof opt.duration !== "number" ) {
					if ( opt.duration in jQuery.fx.speeds ) {
						opt.duration = jQuery.fx.speeds[ opt.duration ];

					} else {
						opt.duration = jQuery.fx.speeds._default;
					}
				}
			}

			// Normalize opt.queue - true/undefined/null -> "fx"
			if ( opt.queue == null || opt.queue === true ) {
				opt.queue = "fx";
			}

			// Queueing
			opt.old = opt.complete;

			opt.complete = function() {
				if ( jQuery.isFunction( opt.old ) ) {
					opt.old.call( this );
				}

				if ( opt.queue ) {
					jQuery.dequeue( this, opt.queue );
				}
			};

			return opt;
		};

		jQuery.fn.extend( {
			fadeTo: function( speed, to, easing, callback ) {

				// Show any hidden elements after setting opacity to 0
				return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

					// Animate to the value specified
					.end().animate( { opacity: to }, speed, easing, callback );
			},
			animate: function( prop, speed, easing, callback ) {
				var empty = jQuery.isEmptyObject( prop ),
					optall = jQuery.speed( speed, easing, callback ),
					doAnimation = function() {

						// Operate on a copy of prop so per-property easing won't be lost
						var anim = Animation( this, jQuery.extend( {}, prop ), optall );

						// Empty animations, or finishing resolves immediately
						if ( empty || dataPriv.get( this, "finish" ) ) {
							anim.stop( true );
						}
					};
					doAnimation.finish = doAnimation;

				return empty || optall.queue === false ?
					this.each( doAnimation ) :
					this.queue( optall.queue, doAnimation );
			},
			stop: function( type, clearQueue, gotoEnd ) {
				var stopQueue = function( hooks ) {
					var stop = hooks.stop;
					delete hooks.stop;
					stop( gotoEnd );
				};

				if ( typeof type !== "string" ) {
					gotoEnd = clearQueue;
					clearQueue = type;
					type = undefined;
				}
				if ( clearQueue && type !== false ) {
					this.queue( type || "fx", [] );
				}

				return this.each( function() {
					var dequeue = true,
						index = type != null && type + "queueHooks",
						timers = jQuery.timers,
						data = dataPriv.get( this );

					if ( index ) {
						if ( data[ index ] && data[ index ].stop ) {
							stopQueue( data[ index ] );
						}
					} else {
						for ( index in data ) {
							if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
								stopQueue( data[ index ] );
							}
						}
					}

					for ( index = timers.length; index--; ) {
						if ( timers[ index ].elem === this &&
							( type == null || timers[ index ].queue === type ) ) {

							timers[ index ].anim.stop( gotoEnd );
							dequeue = false;
							timers.splice( index, 1 );
						}
					}

					// Start the next in the queue if the last step wasn't forced.
					// Timers currently will call their complete callbacks, which
					// will dequeue but only if they were gotoEnd.
					if ( dequeue || !gotoEnd ) {
						jQuery.dequeue( this, type );
					}
				} );
			},
			finish: function( type ) {
				if ( type !== false ) {
					type = type || "fx";
				}
				return this.each( function() {
					var index,
						data = dataPriv.get( this ),
						queue = data[ type + "queue" ],
						hooks = data[ type + "queueHooks" ],
						timers = jQuery.timers,
						length = queue ? queue.length : 0;

					// Enable finishing flag on private data
					data.finish = true;

					// Empty the queue first
					jQuery.queue( this, type, [] );

					if ( hooks && hooks.stop ) {
						hooks.stop.call( this, true );
					}

					// Look for any active animations, and finish them
					for ( index = timers.length; index--; ) {
						if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
							timers[ index ].anim.stop( true );
							timers.splice( index, 1 );
						}
					}

					// Look for any animations in the old queue and finish them
					for ( index = 0; index < length; index++ ) {
						if ( queue[ index ] && queue[ index ].finish ) {
							queue[ index ].finish.call( this );
						}
					}

					// Turn off finishing flag
					delete data.finish;
				} );
			}
		} );

		jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
			var cssFn = jQuery.fn[ name ];
			jQuery.fn[ name ] = function( speed, easing, callback ) {
				return speed == null || typeof speed === "boolean" ?
					cssFn.apply( this, arguments ) :
					this.animate( genFx( name, true ), speed, easing, callback );
			};
		} );

		// Generate shortcuts for custom animations
		jQuery.each( {
			slideDown: genFx( "show" ),
			slideUp: genFx( "hide" ),
			slideToggle: genFx( "toggle" ),
			fadeIn: { opacity: "show" },
			fadeOut: { opacity: "hide" },
			fadeToggle: { opacity: "toggle" }
		}, function( name, props ) {
			jQuery.fn[ name ] = function( speed, easing, callback ) {
				return this.animate( props, speed, easing, callback );
			};
		} );

		jQuery.timers = [];
		jQuery.fx.tick = function() {
			var timer,
				i = 0,
				timers = jQuery.timers;

			fxNow = jQuery.now();

			for ( ; i < timers.length; i++ ) {
				timer = timers[ i ];

				// Checks the timer has not already been removed
				if ( !timer() && timers[ i ] === timer ) {
					timers.splice( i--, 1 );
				}
			}

			if ( !timers.length ) {
				jQuery.fx.stop();
			}
			fxNow = undefined;
		};

		jQuery.fx.timer = function( timer ) {
			jQuery.timers.push( timer );
			if ( timer() ) {
				jQuery.fx.start();
			} else {
				jQuery.timers.pop();
			}
		};

		jQuery.fx.interval = 13;
		jQuery.fx.start = function() {
			if ( !timerId ) {
				timerId = window.requestAnimationFrame ?
					window.requestAnimationFrame( raf ) :
					window.setInterval( jQuery.fx.tick, jQuery.fx.interval );
			}
		};

		jQuery.fx.stop = function() {
			if ( window.cancelAnimationFrame ) {
				window.cancelAnimationFrame( timerId );
			} else {
				window.clearInterval( timerId );
			}

			timerId = null;
		};

		jQuery.fx.speeds = {
			slow: 600,
			fast: 200,

			// Default speed
			_default: 400
		};


		// Based off of the plugin by Clint Helfers, with permission.
		// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
		jQuery.fn.delay = function( time, type ) {
			time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
			type = type || "fx";

			return this.queue( type, function( next, hooks ) {
				var timeout = window.setTimeout( next, time );
				hooks.stop = function() {
					window.clearTimeout( timeout );
				};
			} );
		};


		( function() {
			var input = document.createElement( "input" ),
				select = document.createElement( "select" ),
				opt = select.appendChild( document.createElement( "option" ) );

			input.type = "checkbox";

			// Support: Android <=4.3 only
			// Default value for a checkbox should be "on"
			support.checkOn = input.value !== "";

			// Support: IE <=11 only
			// Must access selectedIndex to make default options select
			support.optSelected = opt.selected;

			// Support: IE <=11 only
			// An input loses its value after becoming a radio
			input = document.createElement( "input" );
			input.value = "t";
			input.type = "radio";
			support.radioValue = input.value === "t";
		} )();


		var boolHook,
			attrHandle = jQuery.expr.attrHandle;

		jQuery.fn.extend( {
			attr: function( name, value ) {
				return access( this, jQuery.attr, name, value, arguments.length > 1 );
			},

			removeAttr: function( name ) {
				return this.each( function() {
					jQuery.removeAttr( this, name );
				} );
			}
		} );

		jQuery.extend( {
			attr: function( elem, name, value ) {
				var ret, hooks,
					nType = elem.nodeType;

				// Don't get/set attributes on text, comment and attribute nodes
				if ( nType === 3 || nType === 8 || nType === 2 ) {
					return;
				}

				// Fallback to prop when attributes are not supported
				if ( typeof elem.getAttribute === "undefined" ) {
					return jQuery.prop( elem, name, value );
				}

				// Attribute hooks are determined by the lowercase version
				// Grab necessary hook if one is defined
				if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
					hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
						( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
				}

				if ( value !== undefined ) {
					if ( value === null ) {
						jQuery.removeAttr( elem, name );
						return;
					}

					if ( hooks && "set" in hooks &&
						( ret = hooks.set( elem, value, name ) ) !== undefined ) {
						return ret;
					}

					elem.setAttribute( name, value + "" );
					return value;
				}

				if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
					return ret;
				}

				ret = jQuery.find.attr( elem, name );

				// Non-existent attributes return null, we normalize to undefined
				return ret == null ? undefined : ret;
			},

			attrHooks: {
				type: {
					set: function( elem, value ) {
						if ( !support.radioValue && value === "radio" &&
							jQuery.nodeName( elem, "input" ) ) {
							var val = elem.value;
							elem.setAttribute( "type", value );
							if ( val ) {
								elem.value = val;
							}
							return value;
						}
					}
				}
			},

			removeAttr: function( elem, value ) {
				var name,
					i = 0,

					// Attribute names can contain non-HTML whitespace characters
					// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
					attrNames = value && value.match( rnothtmlwhite );

				if ( attrNames && elem.nodeType === 1 ) {
					while ( ( name = attrNames[ i++ ] ) ) {
						elem.removeAttribute( name );
					}
				}
			}
		} );

		// Hooks for boolean attributes
		boolHook = {
			set: function( elem, value, name ) {
				if ( value === false ) {

					// Remove boolean attributes when set to false
					jQuery.removeAttr( elem, name );
				} else {
					elem.setAttribute( name, name );
				}
				return name;
			}
		};

		jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
			var getter = attrHandle[ name ] || jQuery.find.attr;

			attrHandle[ name ] = function( elem, name, isXML ) {
				var ret, handle,
					lowercaseName = name.toLowerCase();

				if ( !isXML ) {

					// Avoid an infinite loop by temporarily removing this function from the getter
					handle = attrHandle[ lowercaseName ];
					attrHandle[ lowercaseName ] = ret;
					ret = getter( elem, name, isXML ) != null ?
						lowercaseName :
						null;
					attrHandle[ lowercaseName ] = handle;
				}
				return ret;
			};
		} );




		var rfocusable = /^(?:input|select|textarea|button)$/i,
			rclickable = /^(?:a|area)$/i;

		jQuery.fn.extend( {
			prop: function( name, value ) {
				return access( this, jQuery.prop, name, value, arguments.length > 1 );
			},

			removeProp: function( name ) {
				return this.each( function() {
					delete this[ jQuery.propFix[ name ] || name ];
				} );
			}
		} );

		jQuery.extend( {
			prop: function( elem, name, value ) {
				var ret, hooks,
					nType = elem.nodeType;

				// Don't get/set properties on text, comment and attribute nodes
				if ( nType === 3 || nType === 8 || nType === 2 ) {
					return;
				}

				if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

					// Fix name and attach hooks
					name = jQuery.propFix[ name ] || name;
					hooks = jQuery.propHooks[ name ];
				}

				if ( value !== undefined ) {
					if ( hooks && "set" in hooks &&
						( ret = hooks.set( elem, value, name ) ) !== undefined ) {
						return ret;
					}

					return ( elem[ name ] = value );
				}

				if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
					return ret;
				}

				return elem[ name ];
			},

			propHooks: {
				tabIndex: {
					get: function( elem ) {

						// Support: IE <=9 - 11 only
						// elem.tabIndex doesn't always return the
						// correct value when it hasn't been explicitly set
						// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
						// Use proper attribute retrieval(#12072)
						var tabindex = jQuery.find.attr( elem, "tabindex" );

						if ( tabindex ) {
							return parseInt( tabindex, 10 );
						}

						if (
							rfocusable.test( elem.nodeName ) ||
							rclickable.test( elem.nodeName ) &&
							elem.href
						) {
							return 0;
						}

						return -1;
					}
				}
			},

			propFix: {
				"for": "htmlFor",
				"class": "className"
			}
		} );

		// Support: IE <=11 only
		// Accessing the selectedIndex property
		// forces the browser to respect setting selected
		// on the option
		// The getter ensures a default option is selected
		// when in an optgroup
		// eslint rule "no-unused-expressions" is disabled for this code
		// since it considers such accessions noop
		if ( !support.optSelected ) {
			jQuery.propHooks.selected = {
				get: function( elem ) {

					/* eslint no-unused-expressions: "off" */

					var parent = elem.parentNode;
					if ( parent && parent.parentNode ) {
						parent.parentNode.selectedIndex;
					}
					return null;
				},
				set: function( elem ) {

					/* eslint no-unused-expressions: "off" */

					var parent = elem.parentNode;
					if ( parent ) {
						parent.selectedIndex;

						if ( parent.parentNode ) {
							parent.parentNode.selectedIndex;
						}
					}
				}
			};
		}

		jQuery.each( [
			"tabIndex",
			"readOnly",
			"maxLength",
			"cellSpacing",
			"cellPadding",
			"rowSpan",
			"colSpan",
			"useMap",
			"frameBorder",
			"contentEditable"
		], function() {
			jQuery.propFix[ this.toLowerCase() ] = this;
		} );




			// Strip and collapse whitespace according to HTML spec
			// https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace
			function stripAndCollapse( value ) {
				var tokens = value.match( rnothtmlwhite ) || [];
				return tokens.join( " " );
			}


		function getClass( elem ) {
			return elem.getAttribute && elem.getAttribute( "class" ) || "";
		}

		jQuery.fn.extend( {
			addClass: function( value ) {
				var classes, elem, cur, curValue, clazz, j, finalValue,
					i = 0;

				if ( jQuery.isFunction( value ) ) {
					return this.each( function( j ) {
						jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
					} );
				}

				if ( typeof value === "string" && value ) {
					classes = value.match( rnothtmlwhite ) || [];

					while ( ( elem = this[ i++ ] ) ) {
						curValue = getClass( elem );
						cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

						if ( cur ) {
							j = 0;
							while ( ( clazz = classes[ j++ ] ) ) {
								if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
									cur += clazz + " ";
								}
							}

							// Only assign if different to avoid unneeded rendering.
							finalValue = stripAndCollapse( cur );
							if ( curValue !== finalValue ) {
								elem.setAttribute( "class", finalValue );
							}
						}
					}
				}

				return this;
			},

			removeClass: function( value ) {
				var classes, elem, cur, curValue, clazz, j, finalValue,
					i = 0;

				if ( jQuery.isFunction( value ) ) {
					return this.each( function( j ) {
						jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
					} );
				}

				if ( !arguments.length ) {
					return this.attr( "class", "" );
				}

				if ( typeof value === "string" && value ) {
					classes = value.match( rnothtmlwhite ) || [];

					while ( ( elem = this[ i++ ] ) ) {
						curValue = getClass( elem );

						// This expression is here for better compressibility (see addClass)
						cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

						if ( cur ) {
							j = 0;
							while ( ( clazz = classes[ j++ ] ) ) {

								// Remove *all* instances
								while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
									cur = cur.replace( " " + clazz + " ", " " );
								}
							}

							// Only assign if different to avoid unneeded rendering.
							finalValue = stripAndCollapse( cur );
							if ( curValue !== finalValue ) {
								elem.setAttribute( "class", finalValue );
							}
						}
					}
				}

				return this;
			},

			toggleClass: function( value, stateVal ) {
				var type = typeof value;

				if ( typeof stateVal === "boolean" && type === "string" ) {
					return stateVal ? this.addClass( value ) : this.removeClass( value );
				}

				if ( jQuery.isFunction( value ) ) {
					return this.each( function( i ) {
						jQuery( this ).toggleClass(
							value.call( this, i, getClass( this ), stateVal ),
							stateVal
						);
					} );
				}

				return this.each( function() {
					var className, i, self, classNames;

					if ( type === "string" ) {

						// Toggle individual class names
						i = 0;
						self = jQuery( this );
						classNames = value.match( rnothtmlwhite ) || [];

						while ( ( className = classNames[ i++ ] ) ) {

							// Check each className given, space separated list
							if ( self.hasClass( className ) ) {
								self.removeClass( className );
							} else {
								self.addClass( className );
							}
						}

					// Toggle whole class name
					} else if ( value === undefined || type === "boolean" ) {
						className = getClass( this );
						if ( className ) {

							// Store className if set
							dataPriv.set( this, "__className__", className );
						}

						// If the element has a class name or if we're passed `false`,
						// then remove the whole classname (if there was one, the above saved it).
						// Otherwise bring back whatever was previously saved (if anything),
						// falling back to the empty string if nothing was stored.
						if ( this.setAttribute ) {
							this.setAttribute( "class",
								className || value === false ?
								"" :
								dataPriv.get( this, "__className__" ) || ""
							);
						}
					}
				} );
			},

			hasClass: function( selector ) {
				var className, elem,
					i = 0;

				className = " " + selector + " ";
				while ( ( elem = this[ i++ ] ) ) {
					if ( elem.nodeType === 1 &&
						( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
							return true;
					}
				}

				return false;
			}
		} );




		var rreturn = /\r/g;

		jQuery.fn.extend( {
			val: function( value ) {
				var hooks, ret, isFunction,
					elem = this[ 0 ];

				if ( !arguments.length ) {
					if ( elem ) {
						hooks = jQuery.valHooks[ elem.type ] ||
							jQuery.valHooks[ elem.nodeName.toLowerCase() ];

						if ( hooks &&
							"get" in hooks &&
							( ret = hooks.get( elem, "value" ) ) !== undefined
						) {
							return ret;
						}

						ret = elem.value;

						// Handle most common string cases
						if ( typeof ret === "string" ) {
							return ret.replace( rreturn, "" );
						}

						// Handle cases where value is null/undef or number
						return ret == null ? "" : ret;
					}

					return;
				}

				isFunction = jQuery.isFunction( value );

				return this.each( function( i ) {
					var val;

					if ( this.nodeType !== 1 ) {
						return;
					}

					if ( isFunction ) {
						val = value.call( this, i, jQuery( this ).val() );
					} else {
						val = value;
					}

					// Treat null/undefined as ""; convert numbers to string
					if ( val == null ) {
						val = "";

					} else if ( typeof val === "number" ) {
						val += "";

					} else if ( jQuery.isArray( val ) ) {
						val = jQuery.map( val, function( value ) {
							return value == null ? "" : value + "";
						} );
					}

					hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

					// If set returns undefined, fall back to normal setting
					if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
						this.value = val;
					}
				} );
			}
		} );

		jQuery.extend( {
			valHooks: {
				option: {
					get: function( elem ) {

						var val = jQuery.find.attr( elem, "value" );
						return val != null ?
							val :

							// Support: IE <=10 - 11 only
							// option.text throws exceptions (#14686, #14858)
							// Strip and collapse whitespace
							// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
							stripAndCollapse( jQuery.text( elem ) );
					}
				},
				select: {
					get: function( elem ) {
						var value, option, i,
							options = elem.options,
							index = elem.selectedIndex,
							one = elem.type === "select-one",
							values = one ? null : [],
							max = one ? index + 1 : options.length;

						if ( index < 0 ) {
							i = max;

						} else {
							i = one ? index : 0;
						}

						// Loop through all the selected options
						for ( ; i < max; i++ ) {
							option = options[ i ];

							// Support: IE <=9 only
							// IE8-9 doesn't update selected after form reset (#2551)
							if ( ( option.selected || i === index ) &&

									// Don't return options that are disabled or in a disabled optgroup
									!option.disabled &&
									( !option.parentNode.disabled ||
										!jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

								// Get the specific value for the option
								value = jQuery( option ).val();

								// We don't need an array for one selects
								if ( one ) {
									return value;
								}

								// Multi-Selects return an array
								values.push( value );
							}
						}

						return values;
					},

					set: function( elem, value ) {
						var optionSet, option,
							options = elem.options,
							values = jQuery.makeArray( value ),
							i = options.length;

						while ( i-- ) {
							option = options[ i ];

							/* eslint-disable no-cond-assign */

							if ( option.selected =
								jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
							) {
								optionSet = true;
							}

							/* eslint-enable no-cond-assign */
						}

						// Force browsers to behave consistently when non-matching value is set
						if ( !optionSet ) {
							elem.selectedIndex = -1;
						}
						return values;
					}
				}
			}
		} );

		// Radios and checkboxes getter/setter
		jQuery.each( [ "radio", "checkbox" ], function() {
			jQuery.valHooks[ this ] = {
				set: function( elem, value ) {
					if ( jQuery.isArray( value ) ) {
						return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
					}
				}
			};
			if ( !support.checkOn ) {
				jQuery.valHooks[ this ].get = function( elem ) {
					return elem.getAttribute( "value" ) === null ? "on" : elem.value;
				};
			}
		} );




		// Return jQuery for attributes-only inclusion


		var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;

		jQuery.extend( jQuery.event, {

			trigger: function( event, data, elem, onlyHandlers ) {

				var i, cur, tmp, bubbleType, ontype, handle, special,
					eventPath = [ elem || document ],
					type = hasOwn.call( event, "type" ) ? event.type : event,
					namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

				cur = tmp = elem = elem || document;

				// Don't do events on text and comment nodes
				if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
					return;
				}

				// focus/blur morphs to focusin/out; ensure we're not firing them right now
				if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
					return;
				}

				if ( type.indexOf( "." ) > -1 ) {

					// Namespaced trigger; create a regexp to match event type in handle()
					namespaces = type.split( "." );
					type = namespaces.shift();
					namespaces.sort();
				}
				ontype = type.indexOf( ":" ) < 0 && "on" + type;

				// Caller can pass in a jQuery.Event object, Object, or just an event type string
				event = event[ jQuery.expando ] ?
					event :
					new jQuery.Event( type, typeof event === "object" && event );

				// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
				event.isTrigger = onlyHandlers ? 2 : 3;
				event.namespace = namespaces.join( "." );
				event.rnamespace = event.namespace ?
					new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
					null;

				// Clean up the event in case it is being reused
				event.result = undefined;
				if ( !event.target ) {
					event.target = elem;
				}

				// Clone any incoming data and prepend the event, creating the handler arg list
				data = data == null ?
					[ event ] :
					jQuery.makeArray( data, [ event ] );

				// Allow special events to draw outside the lines
				special = jQuery.event.special[ type ] || {};
				if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
					return;
				}

				// Determine event propagation path in advance, per W3C events spec (#9951)
				// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
				if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

					bubbleType = special.delegateType || type;
					if ( !rfocusMorph.test( bubbleType + type ) ) {
						cur = cur.parentNode;
					}
					for ( ; cur; cur = cur.parentNode ) {
						eventPath.push( cur );
						tmp = cur;
					}

					// Only add window if we got to document (e.g., not plain obj or detached DOM)
					if ( tmp === ( elem.ownerDocument || document ) ) {
						eventPath.push( tmp.defaultView || tmp.parentWindow || window );
					}
				}

				// Fire handlers on the event path
				i = 0;
				while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {

					event.type = i > 1 ?
						bubbleType :
						special.bindType || type;

					// jQuery handler
					handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
						dataPriv.get( cur, "handle" );
					if ( handle ) {
						handle.apply( cur, data );
					}

					// Native handler
					handle = ontype && cur[ ontype ];
					if ( handle && handle.apply && acceptData( cur ) ) {
						event.result = handle.apply( cur, data );
						if ( event.result === false ) {
							event.preventDefault();
						}
					}
				}
				event.type = type;

				// If nobody prevented the default action, do it now
				if ( !onlyHandlers && !event.isDefaultPrevented() ) {

					if ( ( !special._default ||
						special._default.apply( eventPath.pop(), data ) === false ) &&
						acceptData( elem ) ) {

						// Call a native DOM method on the target with the same name as the event.
						// Don't do default actions on window, that's where global variables be (#6170)
						if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

							// Don't re-trigger an onFOO event when we call its FOO() method
							tmp = elem[ ontype ];

							if ( tmp ) {
								elem[ ontype ] = null;
							}

							// Prevent re-triggering of the same event, since we already bubbled it above
							jQuery.event.triggered = type;
							elem[ type ]();
							jQuery.event.triggered = undefined;

							if ( tmp ) {
								elem[ ontype ] = tmp;
							}
						}
					}
				}

				return event.result;
			},

			// Piggyback on a donor event to simulate a different one
			// Used only for `focus(in | out)` events
			simulate: function( type, elem, event ) {
				var e = jQuery.extend(
					new jQuery.Event(),
					event,
					{
						type: type,
						isSimulated: true
					}
				);

				jQuery.event.trigger( e, null, elem );
			}

		} );

		jQuery.fn.extend( {

			trigger: function( type, data ) {
				return this.each( function() {
					jQuery.event.trigger( type, data, this );
				} );
			},
			triggerHandler: function( type, data ) {
				var elem = this[ 0 ];
				if ( elem ) {
					return jQuery.event.trigger( type, data, elem, true );
				}
			}
		} );


		jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
			"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
			"change select submit keydown keypress keyup contextmenu" ).split( " " ),
			function( i, name ) {

			// Handle event binding
			jQuery.fn[ name ] = function( data, fn ) {
				return arguments.length > 0 ?
					this.on( name, null, data, fn ) :
					this.trigger( name );
			};
		} );

		jQuery.fn.extend( {
			hover: function( fnOver, fnOut ) {
				return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
			}
		} );




		support.focusin = "onfocusin" in window;


		// Support: Firefox <=44
		// Firefox doesn't have focus(in | out) events
		// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
		//
		// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
		// focus(in | out) events fire after focus & blur events,
		// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
		// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
		if ( !support.focusin ) {
			jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

				// Attach a single capturing handler on the document while someone wants focusin/focusout
				var handler = function( event ) {
					jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
				};

				jQuery.event.special[ fix ] = {
					setup: function() {
						var doc = this.ownerDocument || this,
							attaches = dataPriv.access( doc, fix );

						if ( !attaches ) {
							doc.addEventListener( orig, handler, true );
						}
						dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
					},
					teardown: function() {
						var doc = this.ownerDocument || this,
							attaches = dataPriv.access( doc, fix ) - 1;

						if ( !attaches ) {
							doc.removeEventListener( orig, handler, true );
							dataPriv.remove( doc, fix );

						} else {
							dataPriv.access( doc, fix, attaches );
						}
					}
				};
			} );
		}
		var location = window.location;

		var nonce = jQuery.now();

		var rquery = ( /\?/ );



		// Cross-browser xml parsing
		jQuery.parseXML = function( data ) {
			var xml;
			if ( !data || typeof data !== "string" ) {
				return null;
			}

			// Support: IE 9 - 11 only
			// IE throws on parseFromString with invalid input.
			try {
				xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
			} catch ( e ) {
				xml = undefined;
			}

			if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
				jQuery.error( "Invalid XML: " + data );
			}
			return xml;
		};


		var
			rbracket = /\[\]$/,
			rCRLF = /\r?\n/g,
			rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
			rsubmittable = /^(?:input|select|textarea|keygen)/i;

		function buildParams( prefix, obj, traditional, add ) {
			var name;

			if ( jQuery.isArray( obj ) ) {

				// Serialize array item.
				jQuery.each( obj, function( i, v ) {
					if ( traditional || rbracket.test( prefix ) ) {

						// Treat each array item as a scalar.
						add( prefix, v );

					} else {

						// Item is non-scalar (array or object), encode its numeric index.
						buildParams(
							prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
							v,
							traditional,
							add
						);
					}
				} );

			} else if ( !traditional && jQuery.type( obj ) === "object" ) {

				// Serialize object item.
				for ( name in obj ) {
					buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
				}

			} else {

				// Serialize scalar item.
				add( prefix, obj );
			}
		}

		// Serialize an array of form elements or a set of
		// key/values into a query string
		jQuery.param = function( a, traditional ) {
			var prefix,
				s = [],
				add = function( key, valueOrFunction ) {

					// If value is a function, invoke it and use its return value
					var value = jQuery.isFunction( valueOrFunction ) ?
						valueOrFunction() :
						valueOrFunction;

					s[ s.length ] = encodeURIComponent( key ) + "=" +
						encodeURIComponent( value == null ? "" : value );
				};

			// If an array was passed in, assume that it is an array of form elements.
			if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

				// Serialize the form elements
				jQuery.each( a, function() {
					add( this.name, this.value );
				} );

			} else {

				// If traditional, encode the "old" way (the way 1.3.2 or older
				// did it), otherwise encode params recursively.
				for ( prefix in a ) {
					buildParams( prefix, a[ prefix ], traditional, add );
				}
			}

			// Return the resulting serialization
			return s.join( "&" );
		};

		jQuery.fn.extend( {
			serialize: function() {
				return jQuery.param( this.serializeArray() );
			},
			serializeArray: function() {
				return this.map( function() {

					// Can add propHook for "elements" to filter or add form elements
					var elements = jQuery.prop( this, "elements" );
					return elements ? jQuery.makeArray( elements ) : this;
				} )
				.filter( function() {
					var type = this.type;

					// Use .is( ":disabled" ) so that fieldset[disabled] works
					return this.name && !jQuery( this ).is( ":disabled" ) &&
						rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
						( this.checked || !rcheckableType.test( type ) );
				} )
				.map( function( i, elem ) {
					var val = jQuery( this ).val();

					if ( val == null ) {
						return null;
					}

					if ( jQuery.isArray( val ) ) {
						return jQuery.map( val, function( val ) {
							return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
						} );
					}

					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} ).get();
			}
		} );


		var
			r20 = /%20/g,
			rhash = /#.*$/,
			rantiCache = /([?&])_=[^&]*/,
			rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

			// #7653, #8125, #8152: local protocol detection
			rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
			rnoContent = /^(?:GET|HEAD)$/,
			rprotocol = /^\/\//,

			/* Prefilters
			 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
			 * 2) These are called:
			 *    - BEFORE asking for a transport
			 *    - AFTER param serialization (s.data is a string if s.processData is true)
			 * 3) key is the dataType
			 * 4) the catchall symbol "*" can be used
			 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
			 */
			prefilters = {},

			/* Transports bindings
			 * 1) key is the dataType
			 * 2) the catchall symbol "*" can be used
			 * 3) selection will start with transport dataType and THEN go to "*" if needed
			 */
			transports = {},

			// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
			allTypes = "*/".concat( "*" ),

			// Anchor tag for parsing the document origin
			originAnchor = document.createElement( "a" );
			originAnchor.href = location.href;

		// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
		function addToPrefiltersOrTransports( structure ) {

			// dataTypeExpression is optional and defaults to "*"
			return function( dataTypeExpression, func ) {

				if ( typeof dataTypeExpression !== "string" ) {
					func = dataTypeExpression;
					dataTypeExpression = "*";
				}

				var dataType,
					i = 0,
					dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

				if ( jQuery.isFunction( func ) ) {

					// For each dataType in the dataTypeExpression
					while ( ( dataType = dataTypes[ i++ ] ) ) {

						// Prepend if requested
						if ( dataType[ 0 ] === "+" ) {
							dataType = dataType.slice( 1 ) || "*";
							( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

						// Otherwise append
						} else {
							( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
						}
					}
				}
			};
		}

		// Base inspection function for prefilters and transports
		function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

			var inspected = {},
				seekingTransport = ( structure === transports );

			function inspect( dataType ) {
				var selected;
				inspected[ dataType ] = true;
				jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
					var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
					if ( typeof dataTypeOrTransport === "string" &&
						!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

						options.dataTypes.unshift( dataTypeOrTransport );
						inspect( dataTypeOrTransport );
						return false;
					} else if ( seekingTransport ) {
						return !( selected = dataTypeOrTransport );
					}
				} );
				return selected;
			}

			return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
		}

		// A special extend for ajax options
		// that takes "flat" options (not to be deep extended)
		// Fixes #9887
		function ajaxExtend( target, src ) {
			var key, deep,
				flatOptions = jQuery.ajaxSettings.flatOptions || {};

			for ( key in src ) {
				if ( src[ key ] !== undefined ) {
					( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
				}
			}
			if ( deep ) {
				jQuery.extend( true, target, deep );
			}

			return target;
		}

		/* Handles responses to an ajax request:
		 * - finds the right dataType (mediates between content-type and expected dataType)
		 * - returns the corresponding response
		 */
		function ajaxHandleResponses( s, jqXHR, responses ) {

			var ct, type, finalDataType, firstDataType,
				contents = s.contents,
				dataTypes = s.dataTypes;

			// Remove auto dataType and get content-type in the process
			while ( dataTypes[ 0 ] === "*" ) {
				dataTypes.shift();
				if ( ct === undefined ) {
					ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
				}
			}

			// Check if we're dealing with a known content-type
			if ( ct ) {
				for ( type in contents ) {
					if ( contents[ type ] && contents[ type ].test( ct ) ) {
						dataTypes.unshift( type );
						break;
					}
				}
			}

			// Check to see if we have a response for the expected dataType
			if ( dataTypes[ 0 ] in responses ) {
				finalDataType = dataTypes[ 0 ];
			} else {

				// Try convertible dataTypes
				for ( type in responses ) {
					if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
						finalDataType = type;
						break;
					}
					if ( !firstDataType ) {
						firstDataType = type;
					}
				}

				// Or just use first one
				finalDataType = finalDataType || firstDataType;
			}

			// If we found a dataType
			// We add the dataType to the list if needed
			// and return the corresponding response
			if ( finalDataType ) {
				if ( finalDataType !== dataTypes[ 0 ] ) {
					dataTypes.unshift( finalDataType );
				}
				return responses[ finalDataType ];
			}
		}

		/* Chain conversions given the request and the original response
		 * Also sets the responseXXX fields on the jqXHR instance
		 */
		function ajaxConvert( s, response, jqXHR, isSuccess ) {
			var conv2, current, conv, tmp, prev,
				converters = {},

				// Work with a copy of dataTypes in case we need to modify it for conversion
				dataTypes = s.dataTypes.slice();

			// Create converters map with lowercased keys
			if ( dataTypes[ 1 ] ) {
				for ( conv in s.converters ) {
					converters[ conv.toLowerCase() ] = s.converters[ conv ];
				}
			}

			current = dataTypes.shift();

			// Convert to each sequential dataType
			while ( current ) {

				if ( s.responseFields[ current ] ) {
					jqXHR[ s.responseFields[ current ] ] = response;
				}

				// Apply the dataFilter if provided
				if ( !prev && isSuccess && s.dataFilter ) {
					response = s.dataFilter( response, s.dataType );
				}

				prev = current;
				current = dataTypes.shift();

				if ( current ) {

					// There's only work to do if current dataType is non-auto
					if ( current === "*" ) {

						current = prev;

					// Convert response if prev dataType is non-auto and differs from current
					} else if ( prev !== "*" && prev !== current ) {

						// Seek a direct converter
						conv = converters[ prev + " " + current ] || converters[ "* " + current ];

						// If none found, seek a pair
						if ( !conv ) {
							for ( conv2 in converters ) {

								// If conv2 outputs current
								tmp = conv2.split( " " );
								if ( tmp[ 1 ] === current ) {

									// If prev can be converted to accepted input
									conv = converters[ prev + " " + tmp[ 0 ] ] ||
										converters[ "* " + tmp[ 0 ] ];
									if ( conv ) {

										// Condense equivalence converters
										if ( conv === true ) {
											conv = converters[ conv2 ];

										// Otherwise, insert the intermediate dataType
										} else if ( converters[ conv2 ] !== true ) {
											current = tmp[ 0 ];
											dataTypes.unshift( tmp[ 1 ] );
										}
										break;
									}
								}
							}
						}

						// Apply converter (if not an equivalence)
						if ( conv !== true ) {

							// Unless errors are allowed to bubble, catch and return them
							if ( conv && s.throws ) {
								response = conv( response );
							} else {
								try {
									response = conv( response );
								} catch ( e ) {
									return {
										state: "parsererror",
										error: conv ? e : "No conversion from " + prev + " to " + current
									};
								}
							}
						}
					}
				}
			}

			return { state: "success", data: response };
		}

		jQuery.extend( {

			// Counter for holding the number of active queries
			active: 0,

			// Last-Modified header cache for next request
			lastModified: {},
			etag: {},

			ajaxSettings: {
				url: location.href,
				type: "GET",
				isLocal: rlocalProtocol.test( location.protocol ),
				global: true,
				processData: true,
				async: true,
				contentType: "application/x-www-form-urlencoded; charset=UTF-8",

				/*
				timeout: 0,
				data: null,
				dataType: null,
				username: null,
				password: null,
				cache: null,
				throws: false,
				traditional: false,
				headers: {},
				*/

				accepts: {
					"*": allTypes,
					text: "text/plain",
					html: "text/html",
					xml: "application/xml, text/xml",
					json: "application/json, text/javascript"
				},

				contents: {
					xml: /\bxml\b/,
					html: /\bhtml/,
					json: /\bjson\b/
				},

				responseFields: {
					xml: "responseXML",
					text: "responseText",
					json: "responseJSON"
				},

				// Data converters
				// Keys separate source (or catchall "*") and destination types with a single space
				converters: {

					// Convert anything to text
					"* text": String,

					// Text to html (true = no transformation)
					"text html": true,

					// Evaluate text as a json expression
					"text json": JSON.parse,

					// Parse text as xml
					"text xml": jQuery.parseXML
				},

				// For options that shouldn't be deep extended:
				// you can add your own custom options here if
				// and when you create one that shouldn't be
				// deep extended (see ajaxExtend)
				flatOptions: {
					url: true,
					context: true
				}
			},

			// Creates a full fledged settings object into target
			// with both ajaxSettings and settings fields.
			// If target is omitted, writes into ajaxSettings.
			ajaxSetup: function( target, settings ) {
				return settings ?

					// Building a settings object
					ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

					// Extending ajaxSettings
					ajaxExtend( jQuery.ajaxSettings, target );
			},

			ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
			ajaxTransport: addToPrefiltersOrTransports( transports ),

			// Main method
			ajax: function( url, options ) {

				// If url is an object, simulate pre-1.5 signature
				if ( typeof url === "object" ) {
					options = url;
					url = undefined;
				}

				// Force options to be an object
				options = options || {};

				var transport,

					// URL without anti-cache param
					cacheURL,

					// Response headers
					responseHeadersString,
					responseHeaders,

					// timeout handle
					timeoutTimer,

					// Url cleanup var
					urlAnchor,

					// Request state (becomes false upon send and true upon completion)
					completed,

					// To know if global events are to be dispatched
					fireGlobals,

					// Loop variable
					i,

					// uncached part of the url
					uncached,

					// Create the final options object
					s = jQuery.ajaxSetup( {}, options ),

					// Callbacks context
					callbackContext = s.context || s,

					// Context for global events is callbackContext if it is a DOM node or jQuery collection
					globalEventContext = s.context &&
						( callbackContext.nodeType || callbackContext.jquery ) ?
							jQuery( callbackContext ) :
							jQuery.event,

					// Deferreds
					deferred = jQuery.Deferred(),
					completeDeferred = jQuery.Callbacks( "once memory" ),

					// Status-dependent callbacks
					statusCode = s.statusCode || {},

					// Headers (they are sent all at once)
					requestHeaders = {},
					requestHeadersNames = {},

					// Default abort message
					strAbort = "canceled",

					// Fake xhr
					jqXHR = {
						readyState: 0,

						// Builds headers hashtable if needed
						getResponseHeader: function( key ) {
							var match;
							if ( completed ) {
								if ( !responseHeaders ) {
									responseHeaders = {};
									while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
										responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
									}
								}
								match = responseHeaders[ key.toLowerCase() ];
							}
							return match == null ? null : match;
						},

						// Raw string
						getAllResponseHeaders: function() {
							return completed ? responseHeadersString : null;
						},

						// Caches the header
						setRequestHeader: function( name, value ) {
							if ( completed == null ) {
								name = requestHeadersNames[ name.toLowerCase() ] =
									requestHeadersNames[ name.toLowerCase() ] || name;
								requestHeaders[ name ] = value;
							}
							return this;
						},

						// Overrides response content-type header
						overrideMimeType: function( type ) {
							if ( completed == null ) {
								s.mimeType = type;
							}
							return this;
						},

						// Status-dependent callbacks
						statusCode: function( map ) {
							var code;
							if ( map ) {
								if ( completed ) {

									// Execute the appropriate callbacks
									jqXHR.always( map[ jqXHR.status ] );
								} else {

									// Lazy-add the new callbacks in a way that preserves old ones
									for ( code in map ) {
										statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
									}
								}
							}
							return this;
						},

						// Cancel the request
						abort: function( statusText ) {
							var finalText = statusText || strAbort;
							if ( transport ) {
								transport.abort( finalText );
							}
							done( 0, finalText );
							return this;
						}
					};

				// Attach deferreds
				deferred.promise( jqXHR );

				// Add protocol if not provided (prefilters might expect it)
				// Handle falsy url in the settings object (#10093: consistency with old signature)
				// We also use the url parameter if available
				s.url = ( ( url || s.url || location.href ) + "" )
					.replace( rprotocol, location.protocol + "//" );

				// Alias method option to type as per ticket #12004
				s.type = options.method || options.type || s.method || s.type;

				// Extract dataTypes list
				s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

				// A cross-domain request is in order when the origin doesn't match the current origin.
				if ( s.crossDomain == null ) {
					urlAnchor = document.createElement( "a" );

					// Support: IE <=8 - 11, Edge 12 - 13
					// IE throws exception on accessing the href property if url is malformed,
					// e.g. http://example.com:80x/
					try {
						urlAnchor.href = s.url;

						// Support: IE <=8 - 11 only
						// Anchor's host property isn't correctly set when s.url is relative
						urlAnchor.href = urlAnchor.href;
						s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
							urlAnchor.protocol + "//" + urlAnchor.host;
					} catch ( e ) {

						// If there is an error parsing the URL, assume it is crossDomain,
						// it can be rejected by the transport if it is invalid
						s.crossDomain = true;
					}
				}

				// Convert data if not already a string
				if ( s.data && s.processData && typeof s.data !== "string" ) {
					s.data = jQuery.param( s.data, s.traditional );
				}

				// Apply prefilters
				inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

				// If request was aborted inside a prefilter, stop there
				if ( completed ) {
					return jqXHR;
				}

				// We can fire global events as of now if asked to
				// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
				fireGlobals = jQuery.event && s.global;

				// Watch for a new set of requests
				if ( fireGlobals && jQuery.active++ === 0 ) {
					jQuery.event.trigger( "ajaxStart" );
				}

				// Uppercase the type
				s.type = s.type.toUpperCase();

				// Determine if request has content
				s.hasContent = !rnoContent.test( s.type );

				// Save the URL in case we're toying with the If-Modified-Since
				// and/or If-None-Match header later on
				// Remove hash to simplify url manipulation
				cacheURL = s.url.replace( rhash, "" );

				// More options handling for requests with no content
				if ( !s.hasContent ) {

					// Remember the hash so we can put it back
					uncached = s.url.slice( cacheURL.length );

					// If data is available, append data to url
					if ( s.data ) {
						cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

						// #9682: remove data so that it's not used in an eventual retry
						delete s.data;
					}

					// Add or update anti-cache param if needed
					if ( s.cache === false ) {
						cacheURL = cacheURL.replace( rantiCache, "$1" );
						uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
					}

					// Put hash and anti-cache on the URL that will be requested (gh-1732)
					s.url = cacheURL + uncached;

				// Change '%20' to '+' if this is encoded form body content (gh-2658)
				} else if ( s.data && s.processData &&
					( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
					s.data = s.data.replace( r20, "+" );
				}

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					if ( jQuery.lastModified[ cacheURL ] ) {
						jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
					}
					if ( jQuery.etag[ cacheURL ] ) {
						jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
					}
				}

				// Set the correct header, if data is being sent
				if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
					jqXHR.setRequestHeader( "Content-Type", s.contentType );
				}

				// Set the Accepts header for the server, depending on the dataType
				jqXHR.setRequestHeader(
					"Accept",
					s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
						s.accepts[ s.dataTypes[ 0 ] ] +
							( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
						s.accepts[ "*" ]
				);

				// Check for headers option
				for ( i in s.headers ) {
					jqXHR.setRequestHeader( i, s.headers[ i ] );
				}

				// Allow custom headers/mimetypes and early abort
				if ( s.beforeSend &&
					( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

					// Abort if not done already and return
					return jqXHR.abort();
				}

				// Aborting is no longer a cancellation
				strAbort = "abort";

				// Install callbacks on deferreds
				completeDeferred.add( s.complete );
				jqXHR.done( s.success );
				jqXHR.fail( s.error );

				// Get transport
				transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

				// If no transport, we auto-abort
				if ( !transport ) {
					done( -1, "No Transport" );
				} else {
					jqXHR.readyState = 1;

					// Send global event
					if ( fireGlobals ) {
						globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
					}

					// If request was aborted inside ajaxSend, stop there
					if ( completed ) {
						return jqXHR;
					}

					// Timeout
					if ( s.async && s.timeout > 0 ) {
						timeoutTimer = window.setTimeout( function() {
							jqXHR.abort( "timeout" );
						}, s.timeout );
					}

					try {
						completed = false;
						transport.send( requestHeaders, done );
					} catch ( e ) {

						// Rethrow post-completion exceptions
						if ( completed ) {
							throw e;
						}

						// Propagate others as results
						done( -1, e );
					}
				}

				// Callback for when everything is done
				function done( status, nativeStatusText, responses, headers ) {
					var isSuccess, success, error, response, modified,
						statusText = nativeStatusText;

					// Ignore repeat invocations
					if ( completed ) {
						return;
					}

					completed = true;

					// Clear timeout if it exists
					if ( timeoutTimer ) {
						window.clearTimeout( timeoutTimer );
					}

					// Dereference transport for early garbage collection
					// (no matter how long the jqXHR object will be used)
					transport = undefined;

					// Cache response headers
					responseHeadersString = headers || "";

					// Set readyState
					jqXHR.readyState = status > 0 ? 4 : 0;

					// Determine if successful
					isSuccess = status >= 200 && status < 300 || status === 304;

					// Get response data
					if ( responses ) {
						response = ajaxHandleResponses( s, jqXHR, responses );
					}

					// Convert no matter what (that way responseXXX fields are always set)
					response = ajaxConvert( s, response, jqXHR, isSuccess );

					// If successful, handle type chaining
					if ( isSuccess ) {

						// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
						if ( s.ifModified ) {
							modified = jqXHR.getResponseHeader( "Last-Modified" );
							if ( modified ) {
								jQuery.lastModified[ cacheURL ] = modified;
							}
							modified = jqXHR.getResponseHeader( "etag" );
							if ( modified ) {
								jQuery.etag[ cacheURL ] = modified;
							}
						}

						// if no content
						if ( status === 204 || s.type === "HEAD" ) {
							statusText = "nocontent";

						// if not modified
						} else if ( status === 304 ) {
							statusText = "notmodified";

						// If we have data, let's convert it
						} else {
							statusText = response.state;
							success = response.data;
							error = response.error;
							isSuccess = !error;
						}
					} else {

						// Extract error from statusText and normalize for non-aborts
						error = statusText;
						if ( status || !statusText ) {
							statusText = "error";
							if ( status < 0 ) {
								status = 0;
							}
						}
					}

					// Set data for the fake xhr object
					jqXHR.status = status;
					jqXHR.statusText = ( nativeStatusText || statusText ) + "";

					// Success/Error
					if ( isSuccess ) {
						deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
					} else {
						deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
					}

					// Status-dependent callbacks
					jqXHR.statusCode( statusCode );
					statusCode = undefined;

					if ( fireGlobals ) {
						globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
							[ jqXHR, s, isSuccess ? success : error ] );
					}

					// Complete
					completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

					if ( fireGlobals ) {
						globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

						// Handle the global AJAX counter
						if ( !( --jQuery.active ) ) {
							jQuery.event.trigger( "ajaxStop" );
						}
					}
				}

				return jqXHR;
			},

			getJSON: function( url, data, callback ) {
				return jQuery.get( url, data, callback, "json" );
			},

			getScript: function( url, callback ) {
				return jQuery.get( url, undefined, callback, "script" );
			}
		} );

		jQuery.each( [ "get", "post" ], function( i, method ) {
			jQuery[ method ] = function( url, data, callback, type ) {

				// Shift arguments if data argument was omitted
				if ( jQuery.isFunction( data ) ) {
					type = type || callback;
					callback = data;
					data = undefined;
				}

				// The url can be an options object (which then must have .url)
				return jQuery.ajax( jQuery.extend( {
					url: url,
					type: method,
					dataType: type,
					data: data,
					success: callback
				}, jQuery.isPlainObject( url ) && url ) );
			};
		} );


		jQuery._evalUrl = function( url ) {
			return jQuery.ajax( {
				url: url,

				// Make this explicit, since user can override this through ajaxSetup (#11264)
				type: "GET",
				dataType: "script",
				cache: true,
				async: false,
				global: false,
				"throws": true
			} );
		};


		jQuery.fn.extend( {
			wrapAll: function( html ) {
				var wrap;

				if ( this[ 0 ] ) {
					if ( jQuery.isFunction( html ) ) {
						html = html.call( this[ 0 ] );
					}

					// The elements to wrap the target around
					wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

					if ( this[ 0 ].parentNode ) {
						wrap.insertBefore( this[ 0 ] );
					}

					wrap.map( function() {
						var elem = this;

						while ( elem.firstElementChild ) {
							elem = elem.firstElementChild;
						}

						return elem;
					} ).append( this );
				}

				return this;
			},

			wrapInner: function( html ) {
				if ( jQuery.isFunction( html ) ) {
					return this.each( function( i ) {
						jQuery( this ).wrapInner( html.call( this, i ) );
					} );
				}

				return this.each( function() {
					var self = jQuery( this ),
						contents = self.contents();

					if ( contents.length ) {
						contents.wrapAll( html );

					} else {
						self.append( html );
					}
				} );
			},

			wrap: function( html ) {
				var isFunction = jQuery.isFunction( html );

				return this.each( function( i ) {
					jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );
				} );
			},

			unwrap: function( selector ) {
				this.parent( selector ).not( "body" ).each( function() {
					jQuery( this ).replaceWith( this.childNodes );
				} );
				return this;
			}
		} );


		jQuery.expr.pseudos.hidden = function( elem ) {
			return !jQuery.expr.pseudos.visible( elem );
		};
		jQuery.expr.pseudos.visible = function( elem ) {
			return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
		};




		jQuery.ajaxSettings.xhr = function() {
			try {
				return new window.XMLHttpRequest();
			} catch ( e ) {}
		};

		var xhrSuccessStatus = {

				// File protocol always yields status code 0, assume 200
				0: 200,

				// Support: IE <=9 only
				// #1450: sometimes IE returns 1223 when it should be 204
				1223: 204
			},
			xhrSupported = jQuery.ajaxSettings.xhr();

		support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
		support.ajax = xhrSupported = !!xhrSupported;

		jQuery.ajaxTransport( function( options ) {
			var callback, errorCallback;

			// Cross domain only allowed if supported through XMLHttpRequest
			if ( support.cors || xhrSupported && !options.crossDomain ) {
				return {
					send: function( headers, complete ) {
						var i,
							xhr = options.xhr();

						xhr.open(
							options.type,
							options.url,
							options.async,
							options.username,
							options.password
						);

						// Apply custom fields if provided
						if ( options.xhrFields ) {
							for ( i in options.xhrFields ) {
								xhr[ i ] = options.xhrFields[ i ];
							}
						}

						// Override mime type if needed
						if ( options.mimeType && xhr.overrideMimeType ) {
							xhr.overrideMimeType( options.mimeType );
						}

						// X-Requested-With header
						// For cross-domain requests, seeing as conditions for a preflight are
						// akin to a jigsaw puzzle, we simply never set it to be sure.
						// (it can always be set on a per-request basis or even using ajaxSetup)
						// For same-domain requests, won't change header if already provided.
						if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
							headers[ "X-Requested-With" ] = "XMLHttpRequest";
						}

						// Set headers
						for ( i in headers ) {
							xhr.setRequestHeader( i, headers[ i ] );
						}

						// Callback
						callback = function( type ) {
							return function() {
								if ( callback ) {
									callback = errorCallback = xhr.onload =
										xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;

									if ( type === "abort" ) {
										xhr.abort();
									} else if ( type === "error" ) {

										// Support: IE <=9 only
										// On a manual native abort, IE9 throws
										// errors on any property access that is not readyState
										if ( typeof xhr.status !== "number" ) {
											complete( 0, "error" );
										} else {
											complete(

												// File: protocol always yields status 0; see #8605, #14207
												xhr.status,
												xhr.statusText
											);
										}
									} else {
										complete(
											xhrSuccessStatus[ xhr.status ] || xhr.status,
											xhr.statusText,

											// Support: IE <=9 only
											// IE9 has no XHR2 but throws on binary (trac-11426)
											// For XHR2 non-text, let the caller handle it (gh-2498)
											( xhr.responseType || "text" ) !== "text"  ||
											typeof xhr.responseText !== "string" ?
												{ binary: xhr.response } :
												{ text: xhr.responseText },
											xhr.getAllResponseHeaders()
										);
									}
								}
							};
						};

						// Listen to events
						xhr.onload = callback();
						errorCallback = xhr.onerror = callback( "error" );

						// Support: IE 9 only
						// Use onreadystatechange to replace onabort
						// to handle uncaught aborts
						if ( xhr.onabort !== undefined ) {
							xhr.onabort = errorCallback;
						} else {
							xhr.onreadystatechange = function() {

								// Check readyState before timeout as it changes
								if ( xhr.readyState === 4 ) {

									// Allow onerror to be called first,
									// but that will not handle a native abort
									// Also, save errorCallback to a variable
									// as xhr.onerror cannot be accessed
									window.setTimeout( function() {
										if ( callback ) {
											errorCallback();
										}
									} );
								}
							};
						}

						// Create the abort callback
						callback = callback( "abort" );

						try {

							// Do send the request (this may raise an exception)
							xhr.send( options.hasContent && options.data || null );
						} catch ( e ) {

							// #14683: Only rethrow if this hasn't been notified as an error yet
							if ( callback ) {
								throw e;
							}
						}
					},

					abort: function() {
						if ( callback ) {
							callback();
						}
					}
				};
			}
		} );




		// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
		jQuery.ajaxPrefilter( function( s ) {
			if ( s.crossDomain ) {
				s.contents.script = false;
			}
		} );

		// Install script dataType
		jQuery.ajaxSetup( {
			accepts: {
				script: "text/javascript, application/javascript, " +
					"application/ecmascript, application/x-ecmascript"
			},
			contents: {
				script: /\b(?:java|ecma)script\b/
			},
			converters: {
				"text script": function( text ) {
					jQuery.globalEval( text );
					return text;
				}
			}
		} );

		// Handle cache's special case and crossDomain
		jQuery.ajaxPrefilter( "script", function( s ) {
			if ( s.cache === undefined ) {
				s.cache = false;
			}
			if ( s.crossDomain ) {
				s.type = "GET";
			}
		} );

		// Bind script tag hack transport
		jQuery.ajaxTransport( "script", function( s ) {

			// This transport only deals with cross domain requests
			if ( s.crossDomain ) {
				var script, callback;
				return {
					send: function( _, complete ) {
						script = jQuery( "<script>" ).prop( {
							charset: s.scriptCharset,
							src: s.url
						} ).on(
							"load error",
							callback = function( evt ) {
								script.remove();
								callback = null;
								if ( evt ) {
									complete( evt.type === "error" ? 404 : 200, evt.type );
								}
							}
						);

						// Use native DOM manipulation to avoid our domManip AJAX trickery
						document.head.appendChild( script[ 0 ] );
					},
					abort: function() {
						if ( callback ) {
							callback();
						}
					}
				};
			}
		} );




		var oldCallbacks = [],
			rjsonp = /(=)\?(?=&|$)|\?\?/;

		// Default jsonp settings
		jQuery.ajaxSetup( {
			jsonp: "callback",
			jsonpCallback: function() {
				var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
				this[ callback ] = true;
				return callback;
			}
		} );

		// Detect, normalize options and install callbacks for jsonp requests
		jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

			var callbackName, overwritten, responseContainer,
				jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
					"url" :
					typeof s.data === "string" &&
						( s.contentType || "" )
							.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
						rjsonp.test( s.data ) && "data"
				);

			// Handle iff the expected data type is "jsonp" or we have a parameter to set
			if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

				// Get callback name, remembering preexisting value associated with it
				callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
					s.jsonpCallback() :
					s.jsonpCallback;

				// Insert callback into url or form data
				if ( jsonProp ) {
					s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
				} else if ( s.jsonp !== false ) {
					s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
				}

				// Use data converter to retrieve json after script execution
				s.converters[ "script json" ] = function() {
					if ( !responseContainer ) {
						jQuery.error( callbackName + " was not called" );
					}
					return responseContainer[ 0 ];
				};

				// Force json dataType
				s.dataTypes[ 0 ] = "json";

				// Install callback
				overwritten = window[ callbackName ];
				window[ callbackName ] = function() {
					responseContainer = arguments;
				};

				// Clean-up function (fires after converters)
				jqXHR.always( function() {

					// If previous value didn't exist - remove it
					if ( overwritten === undefined ) {
						jQuery( window ).removeProp( callbackName );

					// Otherwise restore preexisting value
					} else {
						window[ callbackName ] = overwritten;
					}

					// Save back as free
					if ( s[ callbackName ] ) {

						// Make sure that re-using the options doesn't screw things around
						s.jsonpCallback = originalSettings.jsonpCallback;

						// Save the callback name for future use
						oldCallbacks.push( callbackName );
					}

					// Call if it was a function and we have a response
					if ( responseContainer && jQuery.isFunction( overwritten ) ) {
						overwritten( responseContainer[ 0 ] );
					}

					responseContainer = overwritten = undefined;
				} );

				// Delegate to script
				return "script";
			}
		} );




		// Support: Safari 8 only
		// In Safari 8 documents created via document.implementation.createHTMLDocument
		// collapse sibling forms: the second one becomes a child of the first one.
		// Because of that, this security measure has to be disabled in Safari 8.
		// https://bugs.webkit.org/show_bug.cgi?id=137337
		support.createHTMLDocument = ( function() {
			var body = document.implementation.createHTMLDocument( "" ).body;
			body.innerHTML = "<form></form><form></form>";
			return body.childNodes.length === 2;
		} )();


		// Argument "data" should be string of html
		// context (optional): If specified, the fragment will be created in this context,
		// defaults to document
		// keepScripts (optional): If true, will include scripts passed in the html string
		jQuery.parseHTML = function( data, context, keepScripts ) {
			if ( typeof data !== "string" ) {
				return [];
			}
			if ( typeof context === "boolean" ) {
				keepScripts = context;
				context = false;
			}

			var base, parsed, scripts;

			if ( !context ) {

				// Stop scripts or inline event handlers from being executed immediately
				// by using document.implementation
				if ( support.createHTMLDocument ) {
					context = document.implementation.createHTMLDocument( "" );

					// Set the base href for the created document
					// so any parsed elements with URLs
					// are based on the document's URL (gh-2965)
					base = context.createElement( "base" );
					base.href = document.location.href;
					context.head.appendChild( base );
				} else {
					context = document;
				}
			}

			parsed = rsingleTag.exec( data );
			scripts = !keepScripts && [];

			// Single tag
			if ( parsed ) {
				return [ context.createElement( parsed[ 1 ] ) ];
			}

			parsed = buildFragment( [ data ], context, scripts );

			if ( scripts && scripts.length ) {
				jQuery( scripts ).remove();
			}

			return jQuery.merge( [], parsed.childNodes );
		};


		/**
		 * Load a url into a page
		 */
		jQuery.fn.load = function( url, params, callback ) {
			var selector, type, response,
				self = this,
				off = url.indexOf( " " );

			if ( off > -1 ) {
				selector = stripAndCollapse( url.slice( off ) );
				url = url.slice( 0, off );
			}

			// If it's a function
			if ( jQuery.isFunction( params ) ) {

				// We assume that it's the callback
				callback = params;
				params = undefined;

			// Otherwise, build a param string
			} else if ( params && typeof params === "object" ) {
				type = "POST";
			}

			// If we have elements to modify, make the request
			if ( self.length > 0 ) {
				jQuery.ajax( {
					url: url,

					// If "type" variable is undefined, then "GET" method will be used.
					// Make value of this field explicit since
					// user can override it through ajaxSetup method
					type: type || "GET",
					dataType: "html",
					data: params
				} ).done( function( responseText ) {

					// Save response for use in complete callback
					response = arguments;

					self.html( selector ?

						// If a selector was specified, locate the right elements in a dummy div
						// Exclude scripts to avoid IE 'Permission Denied' errors
						jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

						// Otherwise use the full result
						responseText );

				// If the request succeeds, this function gets "data", "status", "jqXHR"
				// but they are ignored because response was set above.
				// If it fails, this function gets "jqXHR", "status", "error"
				} ).always( callback && function( jqXHR, status ) {
					self.each( function() {
						callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
					} );
				} );
			}

			return this;
		};




		// Attach a bunch of functions for handling common AJAX events
		jQuery.each( [
			"ajaxStart",
			"ajaxStop",
			"ajaxComplete",
			"ajaxError",
			"ajaxSuccess",
			"ajaxSend"
		], function( i, type ) {
			jQuery.fn[ type ] = function( fn ) {
				return this.on( type, fn );
			};
		} );




		jQuery.expr.pseudos.animated = function( elem ) {
			return jQuery.grep( jQuery.timers, function( fn ) {
				return elem === fn.elem;
			} ).length;
		};




		/**
		 * Gets a window from an element
		 */
		function getWindow( elem ) {
			return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
		}

		jQuery.offset = {
			setOffset: function( elem, options, i ) {
				var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
					position = jQuery.css( elem, "position" ),
					curElem = jQuery( elem ),
					props = {};

				// Set position first, in-case top/left are set even on static elem
				if ( position === "static" ) {
					elem.style.position = "relative";
				}

				curOffset = curElem.offset();
				curCSSTop = jQuery.css( elem, "top" );
				curCSSLeft = jQuery.css( elem, "left" );
				calculatePosition = ( position === "absolute" || position === "fixed" ) &&
					( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

				// Need to be able to calculate position if either
				// top or left is auto and position is either absolute or fixed
				if ( calculatePosition ) {
					curPosition = curElem.position();
					curTop = curPosition.top;
					curLeft = curPosition.left;

				} else {
					curTop = parseFloat( curCSSTop ) || 0;
					curLeft = parseFloat( curCSSLeft ) || 0;
				}

				if ( jQuery.isFunction( options ) ) {

					// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
					options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
				}

				if ( options.top != null ) {
					props.top = ( options.top - curOffset.top ) + curTop;
				}
				if ( options.left != null ) {
					props.left = ( options.left - curOffset.left ) + curLeft;
				}

				if ( "using" in options ) {
					options.using.call( elem, props );

				} else {
					curElem.css( props );
				}
			}
		};

		jQuery.fn.extend( {
			offset: function( options ) {

				// Preserve chaining for setter
				if ( arguments.length ) {
					return options === undefined ?
						this :
						this.each( function( i ) {
							jQuery.offset.setOffset( this, options, i );
						} );
				}

				var docElem, win, rect, doc,
					elem = this[ 0 ];

				if ( !elem ) {
					return;
				}

				// Support: IE <=11 only
				// Running getBoundingClientRect on a
				// disconnected node in IE throws an error
				if ( !elem.getClientRects().length ) {
					return { top: 0, left: 0 };
				}

				rect = elem.getBoundingClientRect();

				// Make sure element is not hidden (display: none)
				if ( rect.width || rect.height ) {
					doc = elem.ownerDocument;
					win = getWindow( doc );
					docElem = doc.documentElement;

					return {
						top: rect.top + win.pageYOffset - docElem.clientTop,
						left: rect.left + win.pageXOffset - docElem.clientLeft
					};
				}

				// Return zeros for disconnected and hidden elements (gh-2310)
				return rect;
			},

			position: function() {
				if ( !this[ 0 ] ) {
					return;
				}

				var offsetParent, offset,
					elem = this[ 0 ],
					parentOffset = { top: 0, left: 0 };

				// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
				// because it is its only offset parent
				if ( jQuery.css( elem, "position" ) === "fixed" ) {

					// Assume getBoundingClientRect is there when computed position is fixed
					offset = elem.getBoundingClientRect();

				} else {

					// Get *real* offsetParent
					offsetParent = this.offsetParent();

					// Get correct offsets
					offset = this.offset();
					if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
						parentOffset = offsetParent.offset();
					}

					// Add offsetParent borders
					parentOffset = {
						top: parentOffset.top + jQuery.css( offsetParent[ 0 ], "borderTopWidth", true ),
						left: parentOffset.left + jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true )
					};
				}

				// Subtract parent offsets and element margins
				return {
					top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
					left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
				};
			},

			// This method will return documentElement in the following cases:
			// 1) For the element inside the iframe without offsetParent, this method will return
			//    documentElement of the parent window
			// 2) For the hidden or detached element
			// 3) For body or html element, i.e. in case of the html node - it will return itself
			//
			// but those exceptions were never presented as a real life use-cases
			// and might be considered as more preferable results.
			//
			// This logic, however, is not guaranteed and can change at any point in the future
			offsetParent: function() {
				return this.map( function() {
					var offsetParent = this.offsetParent;

					while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
						offsetParent = offsetParent.offsetParent;
					}

					return offsetParent || documentElement;
				} );
			}
		} );

		// Create scrollLeft and scrollTop methods
		jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
			var top = "pageYOffset" === prop;

			jQuery.fn[ method ] = function( val ) {
				return access( this, function( elem, method, val ) {
					var win = getWindow( elem );

					if ( val === undefined ) {
						return win ? win[ prop ] : elem[ method ];
					}

					if ( win ) {
						win.scrollTo(
							!top ? val : win.pageXOffset,
							top ? val : win.pageYOffset
						);

					} else {
						elem[ method ] = val;
					}
				}, method, val, arguments.length );
			};
		} );

		// Support: Safari <=7 - 9.1, Chrome <=37 - 49
		// Add the top/left cssHooks using jQuery.fn.position
		// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
		// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
		// getComputedStyle returns percent when specified for top/left/bottom/right;
		// rather than make the css module depend on the offset module, just check for it here
		jQuery.each( [ "top", "left" ], function( i, prop ) {
			jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
				function( elem, computed ) {
					if ( computed ) {
						computed = curCSS( elem, prop );

						// If curCSS returns percentage, fallback to offset
						return rnumnonpx.test( computed ) ?
							jQuery( elem ).position()[ prop ] + "px" :
							computed;
					}
				}
			);
		} );


		// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
		jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
			jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
				function( defaultExtra, funcName ) {

				// Margin is only for outerHeight, outerWidth
				jQuery.fn[ funcName ] = function( margin, value ) {
					var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
						extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

					return access( this, function( elem, type, value ) {
						var doc;

						if ( jQuery.isWindow( elem ) ) {

							// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
							return funcName.indexOf( "outer" ) === 0 ?
								elem[ "inner" + name ] :
								elem.document.documentElement[ "client" + name ];
						}

						// Get document width or height
						if ( elem.nodeType === 9 ) {
							doc = elem.documentElement;

							// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
							// whichever is greatest
							return Math.max(
								elem.body[ "scroll" + name ], doc[ "scroll" + name ],
								elem.body[ "offset" + name ], doc[ "offset" + name ],
								doc[ "client" + name ]
							);
						}

						return value === undefined ?

							// Get width or height on the element, requesting but not forcing parseFloat
							jQuery.css( elem, type, extra ) :

							// Set width or height on the element
							jQuery.style( elem, type, value, extra );
					}, type, chainable ? margin : undefined, chainable );
				};
			} );
		} );


		jQuery.fn.extend( {

			bind: function( types, data, fn ) {
				return this.on( types, null, data, fn );
			},
			unbind: function( types, fn ) {
				return this.off( types, null, fn );
			},

			delegate: function( selector, types, data, fn ) {
				return this.on( types, selector, data, fn );
			},
			undelegate: function( selector, types, fn ) {

				// ( namespace ) or ( selector, types [, fn] )
				return arguments.length === 1 ?
					this.off( selector, "**" ) :
					this.off( types, selector || "**", fn );
			}
		} );

		jQuery.parseJSON = JSON.parse;




		// Register as a named AMD module, since jQuery can be concatenated with other
		// files that may use define, but not via a proper concatenation script that
		// understands anonymous AMD modules. A named AMD is safest and most robust
		// way to register. Lowercase jquery is used because AMD module names are
		// derived from file names, and jQuery is normally delivered in a lowercase
		// file name. Do this after creating the global so that if an AMD module wants
		// to call noConflict to hide this version of jQuery, it will work.

		// Note that for maximum portability, libraries that are not jQuery should
		// declare themselves as anonymous modules, and avoid setting a global if an
		// AMD loader is present. jQuery is a special case. For more information, see
		// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

		if ( true ) {
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
				return jQuery;
			}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		}




		var

			// Map over jQuery in case of overwrite
			_jQuery = window.jQuery,

			// Map over the $ in case of overwrite
			_$ = window.$;

		jQuery.noConflict = function( deep ) {
			if ( window.$ === jQuery ) {
				window.$ = _$;
			}

			if ( deep && window.jQuery === jQuery ) {
				window.jQuery = _jQuery;
			}

			return jQuery;
		};

		// Expose jQuery and $ identifiers, even in AMD
		// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
		// and CommonJS for browser emulators (#13566)
		if ( !noGlobal ) {
			window.jQuery = window.$ = jQuery;
		}





		return jQuery;
		} );


	/***/ },
	/* 6 */
	/***/ function(module, exports) {

		/******/ (function(modules) { // webpackBootstrap
		/******/ 	// The module cache
		/******/ 	var installedModules = {};

		/******/ 	// The require function
		/******/ 	function __webpack_require__(moduleId) {

		/******/ 		// Check if module is in cache
		/******/ 		if(installedModules[moduleId])
		/******/ 			return installedModules[moduleId].exports;

		/******/ 		// Create a new module (and put it into the cache)
		/******/ 		var module = installedModules[moduleId] = {
		/******/ 			exports: {},
		/******/ 			id: moduleId,
		/******/ 			loaded: false
		/******/ 		};

		/******/ 		// Execute the module function
		/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

		/******/ 		// Flag the module as loaded
		/******/ 		module.loaded = true;

		/******/ 		// Return the exports of the module
		/******/ 		return module.exports;
		/******/ 	}


		/******/ 	// expose the modules object (__webpack_modules__)
		/******/ 	__webpack_require__.m = modules;

		/******/ 	// expose the module cache
		/******/ 	__webpack_require__.c = installedModules;

		/******/ 	// __webpack_public_path__
		/******/ 	__webpack_require__.p = "";

		/******/ 	// Load entry module and return exports
		/******/ 	return __webpack_require__(0);
		/******/ })
		/************************************************************************/
		/******/ ([
		/* 0 */
		/***/ function(module, exports, __webpack_require__) {

			__webpack_require__(1);
			__webpack_require__(1);
			module.exports = __webpack_require__(6);


		/***/ },
		/* 1 */
		/***/ function(module, exports, __webpack_require__) {

			var Vue = __webpack_require__(2);
			var app1 = __webpack_require__(3);
			var logic = __webpack_require__(4);

		/***/ },
		/* 2 */
		/***/ function(module, exports, __webpack_require__) {

			/*!
			 * Vue.js v2.0.5
			 * (c) 2014-2016 Evan You
			 * Released under the MIT License.
			 */
			(function (global, factory) {
			   true ? module.exports = factory() :
			  typeof define === 'function' && define.amd ? define(factory) :
			  (global.Vue = factory());
			}(this, (function () { 'use strict';

			/*  */

			/**
			 * Convert a value to a string that is actually rendered.
			 */
			function _toString (val) {
			  return val == null
			    ? ''
			    : typeof val === 'object'
			      ? JSON.stringify(val, null, 2)
			      : String(val)
			}

			/**
			 * Convert a input value to a number for persistence.
			 * If the conversion fails, return original string.
			 */
			function toNumber (val) {
			  var n = parseFloat(val, 10);
			  return (n || n === 0) ? n : val
			}

			/**
			 * Make a map and return a function for checking if a key
			 * is in that map.
			 */
			function makeMap (
			  str,
			  expectsLowerCase
			) {
			  var map = Object.create(null);
			  var list = str.split(',');
			  for (var i = 0; i < list.length; i++) {
			    map[list[i]] = true;
			  }
			  return expectsLowerCase
			    ? function (val) { return map[val.toLowerCase()]; }
			    : function (val) { return map[val]; }
			}

			/**
			 * Check if a tag is a built-in tag.
			 */
			var isBuiltInTag = makeMap('slot,component', true);

			/**
			 * Remove an item from an array
			 */
			function remove$1 (arr, item) {
			  if (arr.length) {
			    var index = arr.indexOf(item);
			    if (index > -1) {
			      return arr.splice(index, 1)
			    }
			  }
			}

			/**
			 * Check whether the object has the property.
			 */
			var hasOwnProperty = Object.prototype.hasOwnProperty;
			function hasOwn (obj, key) {
			  return hasOwnProperty.call(obj, key)
			}

			/**
			 * Check if value is primitive
			 */
			function isPrimitive (value) {
			  return typeof value === 'string' || typeof value === 'number'
			}

			/**
			 * Create a cached version of a pure function.
			 */
			function cached (fn) {
			  var cache = Object.create(null);
			  return function cachedFn (str) {
			    var hit = cache[str];
			    return hit || (cache[str] = fn(str))
			  }
			}

			/**
			 * Camelize a hyphen-delmited string.
			 */
			var camelizeRE = /-(\w)/g;
			var camelize = cached(function (str) {
			  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })
			});

			/**
			 * Capitalize a string.
			 */
			var capitalize = cached(function (str) {
			  return str.charAt(0).toUpperCase() + str.slice(1)
			});

			/**
			 * Hyphenate a camelCase string.
			 */
			var hyphenateRE = /([^-])([A-Z])/g;
			var hyphenate = cached(function (str) {
			  return str
			    .replace(hyphenateRE, '$1-$2')
			    .replace(hyphenateRE, '$1-$2')
			    .toLowerCase()
			});

			/**
			 * Simple bind, faster than native
			 */
			function bind$1 (fn, ctx) {
			  function boundFn (a) {
			    var l = arguments.length;
			    return l
			      ? l > 1
			        ? fn.apply(ctx, arguments)
			        : fn.call(ctx, a)
			      : fn.call(ctx)
			  }
			  // record original fn length
			  boundFn._length = fn.length;
			  return boundFn
			}

			/**
			 * Convert an Array-like object to a real Array.
			 */
			function toArray (list, start) {
			  start = start || 0;
			  var i = list.length - start;
			  var ret = new Array(i);
			  while (i--) {
			    ret[i] = list[i + start];
			  }
			  return ret
			}

			/**
			 * Mix properties into target object.
			 */
			function extend (to, _from) {
			  for (var key in _from) {
			    to[key] = _from[key];
			  }
			  return to
			}

			/**
			 * Quick object check - this is primarily used to tell
			 * Objects from primitive values when we know the value
			 * is a JSON-compliant type.
			 */
			function isObject (obj) {
			  return obj !== null && typeof obj === 'object'
			}

			/**
			 * Strict object type check. Only returns true
			 * for plain JavaScript objects.
			 */
			var toString = Object.prototype.toString;
			var OBJECT_STRING = '[object Object]';
			function isPlainObject (obj) {
			  return toString.call(obj) === OBJECT_STRING
			}

			/**
			 * Merge an Array of Objects into a single Object.
			 */
			function toObject (arr) {
			  var res = {};
			  for (var i = 0; i < arr.length; i++) {
			    if (arr[i]) {
			      extend(res, arr[i]);
			    }
			  }
			  return res
			}

			/**
			 * Perform no operation.
			 */
			function noop () {}

			/**
			 * Always return false.
			 */
			var no = function () { return false; };

			/**
			 * Generate a static keys string from compiler modules.
			 */
			function genStaticKeys (modules) {
			  return modules.reduce(function (keys, m) {
			    return keys.concat(m.staticKeys || [])
			  }, []).join(',')
			}

			/**
			 * Check if two values are loosely equal - that is,
			 * if they are plain objects, do they have the same shape?
			 */
			function looseEqual (a, b) {
			  /* eslint-disable eqeqeq */
			  return a == b || (
			    isObject(a) && isObject(b)
			      ? JSON.stringify(a) === JSON.stringify(b)
			      : false
			  )
			  /* eslint-enable eqeqeq */
			}

			function looseIndexOf (arr, val) {
			  for (var i = 0; i < arr.length; i++) {
			    if (looseEqual(arr[i], val)) { return i }
			  }
			  return -1
			}

			/*  */

			var config = {
			  /**
			   * Option merge strategies (used in core/util/options)
			   */
			  optionMergeStrategies: Object.create(null),

			  /**
			   * Whether to suppress warnings.
			   */
			  silent: false,

			  /**
			   * Whether to enable devtools
			   */
			  devtools: "development" !== 'production',

			  /**
			   * Error handler for watcher errors
			   */
			  errorHandler: null,

			  /**
			   * Ignore certain custom elements
			   */
			  ignoredElements: null,

			  /**
			   * Custom user key aliases for v-on
			   */
			  keyCodes: Object.create(null),

			  /**
			   * Check if a tag is reserved so that it cannot be registered as a
			   * component. This is platform-dependent and may be overwritten.
			   */
			  isReservedTag: no,

			  /**
			   * Check if a tag is an unknown element.
			   * Platform-dependent.
			   */
			  isUnknownElement: no,

			  /**
			   * Get the namespace of an element
			   */
			  getTagNamespace: noop,

			  /**
			   * Check if an attribute must be bound using property, e.g. value
			   * Platform-dependent.
			   */
			  mustUseProp: no,

			  /**
			   * List of asset types that a component can own.
			   */
			  _assetTypes: [
			    'component',
			    'directive',
			    'filter'
			  ],

			  /**
			   * List of lifecycle hooks.
			   */
			  _lifecycleHooks: [
			    'beforeCreate',
			    'created',
			    'beforeMount',
			    'mounted',
			    'beforeUpdate',
			    'updated',
			    'beforeDestroy',
			    'destroyed',
			    'activated',
			    'deactivated'
			  ],

			  /**
			   * Max circular updates allowed in a scheduler flush cycle.
			   */
			  _maxUpdateCount: 100,

			  /**
			   * Server rendering?
			   */
			  _isServer: "client" === 'server'
			};

			/*  */

			/**
			 * Check if a string starts with $ or _
			 */
			function isReserved (str) {
			  var c = (str + '').charCodeAt(0);
			  return c === 0x24 || c === 0x5F
			}

			/**
			 * Define a property.
			 */
			function def (obj, key, val, enumerable) {
			  Object.defineProperty(obj, key, {
			    value: val,
			    enumerable: !!enumerable,
			    writable: true,
			    configurable: true
			  });
			}

			/**
			 * Parse simple path.
			 */
			var bailRE = /[^\w.$]/;
			function parsePath (path) {
			  if (bailRE.test(path)) {
			    return
			  } else {
			    var segments = path.split('.');
			    return function (obj) {
			      for (var i = 0; i < segments.length; i++) {
			        if (!obj) { return }
			        obj = obj[segments[i]];
			      }
			      return obj
			    }
			  }
			}

			/*  */
			/* globals MutationObserver */

			// can we use __proto__?
			var hasProto = '__proto__' in {};

			// Browser environment sniffing
			var inBrowser =
			  typeof window !== 'undefined' &&
			  Object.prototype.toString.call(window) !== '[object Object]';

			var UA = inBrowser && window.navigator.userAgent.toLowerCase();
			var isIE = UA && /msie|trident/.test(UA);
			var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
			var isEdge = UA && UA.indexOf('edge/') > 0;
			var isAndroid = UA && UA.indexOf('android') > 0;
			var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);

			// detect devtools
			var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

			/* istanbul ignore next */
			function isNative (Ctor) {
			  return /native code/.test(Ctor.toString())
			}

			/**
			 * Defer a task to execute it asynchronously.
			 */
			var nextTick = (function () {
			  var callbacks = [];
			  var pending = false;
			  var timerFunc;

			  function nextTickHandler () {
			    pending = false;
			    var copies = callbacks.slice(0);
			    callbacks.length = 0;
			    for (var i = 0; i < copies.length; i++) {
			      copies[i]();
			    }
			  }

			  // the nextTick behavior leverages the microtask queue, which can be accessed
			  // via either native Promise.then or MutationObserver.
			  // MutationObserver has wider support, however it is seriously bugged in
			  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
			  // completely stops working after triggering a few times... so, if native
			  // Promise is available, we will use it:
			  /* istanbul ignore if */
			  if (typeof Promise !== 'undefined' && isNative(Promise)) {
			    var p = Promise.resolve();
			    timerFunc = function () {
			      p.then(nextTickHandler);
			      // in problematic UIWebViews, Promise.then doesn't completely break, but
			      // it can get stuck in a weird state where callbacks are pushed into the
			      // microtask queue but the queue isn't being flushed, until the browser
			      // needs to do some other work, e.g. handle a timer. Therefore we can
			      // "force" the microtask queue to be flushed by adding an empty timer.
			      if (isIOS) { setTimeout(noop); }
			    };
			  } else if (typeof MutationObserver !== 'undefined' && (
			    isNative(MutationObserver) ||
			    // PhantomJS and iOS 7.x
			    MutationObserver.toString() === '[object MutationObserverConstructor]'
			  )) {
			    // use MutationObserver where native Promise is not available,
			    // e.g. PhantomJS IE11, iOS7, Android 4.4
			    var counter = 1;
			    var observer = new MutationObserver(nextTickHandler);
			    var textNode = document.createTextNode(String(counter));
			    observer.observe(textNode, {
			      characterData: true
			    });
			    timerFunc = function () {
			      counter = (counter + 1) % 2;
			      textNode.data = String(counter);
			    };
			  } else {
			    // fallback to setTimeout
			    /* istanbul ignore next */
			    timerFunc = function () {
			      setTimeout(nextTickHandler, 0);
			    };
			  }

			  return function queueNextTick (cb, ctx) {
			    var func = ctx
			      ? function () { cb.call(ctx); }
			      : cb;
			    callbacks.push(func);
			    if (!pending) {
			      pending = true;
			      timerFunc();
			    }
			  }
			})();

			var _Set;
			/* istanbul ignore if */
			if (typeof Set !== 'undefined' && isNative(Set)) {
			  // use native Set when available.
			  _Set = Set;
			} else {
			  // a non-standard Set polyfill that only works with primitive keys.
			  _Set = (function () {
			    function Set () {
			      this.set = Object.create(null);
			    }
			    Set.prototype.has = function has (key) {
			      return this.set[key] !== undefined
			    };
			    Set.prototype.add = function add (key) {
			      this.set[key] = 1;
			    };
			    Set.prototype.clear = function clear () {
			      this.set = Object.create(null);
			    };

			    return Set;
			  }());
			}

			/* not type checking this file because flow doesn't play well with Proxy */

			var hasProxy;
			var proxyHandlers;
			var initProxy;

			{
			  var allowedGlobals = makeMap(
			    'Infinity,undefined,NaN,isFinite,isNaN,' +
			    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +
			    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +
			    'require' // for Webpack/Browserify
			  );

			  hasProxy =
			    typeof Proxy !== 'undefined' &&
			    Proxy.toString().match(/native code/);

			  proxyHandlers = {
			    has: function has (target, key) {
			      var has = key in target;
			      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';
			      if (!has && !isAllowed) {
			        warn(
			          "Property or method \"" + key + "\" is not defined on the instance but " +
			          "referenced during render. Make sure to declare reactive data " +
			          "properties in the data option.",
			          target
			        );
			      }
			      return has || !isAllowed
			    }
			  };

			  initProxy = function initProxy (vm) {
			    if (hasProxy) {
			      vm._renderProxy = new Proxy(vm, proxyHandlers);
			    } else {
			      vm._renderProxy = vm;
			    }
			  };
			}

			/*  */


			var uid$2 = 0;

			/**
			 * A dep is an observable that can have multiple
			 * directives subscribing to it.
			 */
			var Dep = function Dep () {
			  this.id = uid$2++;
			  this.subs = [];
			};

			Dep.prototype.addSub = function addSub (sub) {
			  this.subs.push(sub);
			};

			Dep.prototype.removeSub = function removeSub (sub) {
			  remove$1(this.subs, sub);
			};

			Dep.prototype.depend = function depend () {
			  if (Dep.target) {
			    Dep.target.addDep(this);
			  }
			};

			Dep.prototype.notify = function notify () {
			  // stablize the subscriber list first
			  var subs = this.subs.slice();
			  for (var i = 0, l = subs.length; i < l; i++) {
			    subs[i].update();
			  }
			};

			// the current target watcher being evaluated.
			// this is globally unique because there could be only one
			// watcher being evaluated at any time.
			Dep.target = null;
			var targetStack = [];

			function pushTarget (_target) {
			  if (Dep.target) { targetStack.push(Dep.target); }
			  Dep.target = _target;
			}

			function popTarget () {
			  Dep.target = targetStack.pop();
			}

			/*  */


			var queue = [];
			var has$1 = {};
			var circular = {};
			var waiting = false;
			var flushing = false;
			var index = 0;

			/**
			 * Reset the scheduler's state.
			 */
			function resetSchedulerState () {
			  queue.length = 0;
			  has$1 = {};
			  {
			    circular = {};
			  }
			  waiting = flushing = false;
			}

			/**
			 * Flush both queues and run the watchers.
			 */
			function flushSchedulerQueue () {
			  flushing = true;

			  // Sort queue before flush.
			  // This ensures that:
			  // 1. Components are updated from parent to child. (because parent is always
			  //    created before the child)
			  // 2. A component's user watchers are run before its render watcher (because
			  //    user watchers are created before the render watcher)
			  // 3. If a component is destroyed during a parent component's watcher run,
			  //    its watchers can be skipped.
			  queue.sort(function (a, b) { return a.id - b.id; });

			  // do not cache length because more watchers might be pushed
			  // as we run existing watchers
			  for (index = 0; index < queue.length; index++) {
			    var watcher = queue[index];
			    var id = watcher.id;
			    has$1[id] = null;
			    watcher.run();
			    // in dev build, check and stop circular updates.
			    if ("development" !== 'production' && has$1[id] != null) {
			      circular[id] = (circular[id] || 0) + 1;
			      if (circular[id] > config._maxUpdateCount) {
			        warn(
			          'You may have an infinite update loop ' + (
			            watcher.user
			              ? ("in watcher with expression \"" + (watcher.expression) + "\"")
			              : "in a component render function."
			          ),
			          watcher.vm
			        );
			        break
			      }
			    }
			  }

			  // devtool hook
			  /* istanbul ignore if */
			  if (devtools && config.devtools) {
			    devtools.emit('flush');
			  }

			  resetSchedulerState();
			}

			/**
			 * Push a watcher into the watcher queue.
			 * Jobs with duplicate IDs will be skipped unless it's
			 * pushed when the queue is being flushed.
			 */
			function queueWatcher (watcher) {
			  var id = watcher.id;
			  if (has$1[id] == null) {
			    has$1[id] = true;
			    if (!flushing) {
			      queue.push(watcher);
			    } else {
			      // if already flushing, splice the watcher based on its id
			      // if already past its id, it will be run next immediately.
			      var i = queue.length - 1;
			      while (i >= 0 && queue[i].id > watcher.id) {
			        i--;
			      }
			      queue.splice(Math.max(i, index) + 1, 0, watcher);
			    }
			    // queue the flush
			    if (!waiting) {
			      waiting = true;
			      nextTick(flushSchedulerQueue);
			    }
			  }
			}

			/*  */

			var uid$1 = 0;

			/**
			 * A watcher parses an expression, collects dependencies,
			 * and fires callback when the expression value changes.
			 * This is used for both the $watch() api and directives.
			 */
			var Watcher = function Watcher (
			  vm,
			  expOrFn,
			  cb,
			  options
			) {
			  if ( options === void 0 ) options = {};

			  this.vm = vm;
			  vm._watchers.push(this);
			  // options
			  this.deep = !!options.deep;
			  this.user = !!options.user;
			  this.lazy = !!options.lazy;
			  this.sync = !!options.sync;
			  this.expression = expOrFn.toString();
			  this.cb = cb;
			  this.id = ++uid$1; // uid for batching
			  this.active = true;
			  this.dirty = this.lazy; // for lazy watchers
			  this.deps = [];
			  this.newDeps = [];
			  this.depIds = new _Set();
			  this.newDepIds = new _Set();
			  // parse expression for getter
			  if (typeof expOrFn === 'function') {
			    this.getter = expOrFn;
			  } else {
			    this.getter = parsePath(expOrFn);
			    if (!this.getter) {
			      this.getter = function () {};
			      "development" !== 'production' && warn(
			        "Failed watching path: \"" + expOrFn + "\" " +
			        'Watcher only accepts simple dot-delimited paths. ' +
			        'For full control, use a function instead.',
			        vm
			      );
			    }
			  }
			  this.value = this.lazy
			    ? undefined
			    : this.get();
			};

			/**
			 * Evaluate the getter, and re-collect dependencies.
			 */
			Watcher.prototype.get = function get () {
			  pushTarget(this);
			  var value = this.getter.call(this.vm, this.vm);
			  // "touch" every property so they are all tracked as
			  // dependencies for deep watching
			  if (this.deep) {
			    traverse(value);
			  }
			  popTarget();
			  this.cleanupDeps();
			  return value
			};

			/**
			 * Add a dependency to this directive.
			 */
			Watcher.prototype.addDep = function addDep (dep) {
			  var id = dep.id;
			  if (!this.newDepIds.has(id)) {
			    this.newDepIds.add(id);
			    this.newDeps.push(dep);
			    if (!this.depIds.has(id)) {
			      dep.addSub(this);
			    }
			  }
			};

			/**
			 * Clean up for dependency collection.
			 */
			Watcher.prototype.cleanupDeps = function cleanupDeps () {
			    var this$1 = this;

			  var i = this.deps.length;
			  while (i--) {
			    var dep = this$1.deps[i];
			    if (!this$1.newDepIds.has(dep.id)) {
			      dep.removeSub(this$1);
			    }
			  }
			  var tmp = this.depIds;
			  this.depIds = this.newDepIds;
			  this.newDepIds = tmp;
			  this.newDepIds.clear();
			  tmp = this.deps;
			  this.deps = this.newDeps;
			  this.newDeps = tmp;
			  this.newDeps.length = 0;
			};

			/**
			 * Subscriber interface.
			 * Will be called when a dependency changes.
			 */
			Watcher.prototype.update = function update () {
			  /* istanbul ignore else */
			  if (this.lazy) {
			    this.dirty = true;
			  } else if (this.sync) {
			    this.run();
			  } else {
			    queueWatcher(this);
			  }
			};

			/**
			 * Scheduler job interface.
			 * Will be called by the scheduler.
			 */
			Watcher.prototype.run = function run () {
			  if (this.active) {
			    var value = this.get();
			      if (
			        value !== this.value ||
			      // Deep watchers and watchers on Object/Arrays should fire even
			      // when the value is the same, because the value may
			      // have mutated.
			      isObject(value) ||
			      this.deep
			    ) {
			      // set new value
			      var oldValue = this.value;
			      this.value = value;
			      if (this.user) {
			        try {
			          this.cb.call(this.vm, value, oldValue);
			        } catch (e) {
			          "development" !== 'production' && warn(
			            ("Error in watcher \"" + (this.expression) + "\""),
			            this.vm
			          );
			          /* istanbul ignore else */
			          if (config.errorHandler) {
			            config.errorHandler.call(null, e, this.vm);
			          } else {
			            throw e
			          }
			        }
			      } else {
			        this.cb.call(this.vm, value, oldValue);
			      }
			    }
			  }
			};

			/**
			 * Evaluate the value of the watcher.
			 * This only gets called for lazy watchers.
			 */
			Watcher.prototype.evaluate = function evaluate () {
			  this.value = this.get();
			  this.dirty = false;
			};

			/**
			 * Depend on all deps collected by this watcher.
			 */
			Watcher.prototype.depend = function depend () {
			    var this$1 = this;

			  var i = this.deps.length;
			  while (i--) {
			    this$1.deps[i].depend();
			  }
			};

			/**
			 * Remove self from all dependencies' subscriber list.
			 */
			Watcher.prototype.teardown = function teardown () {
			    var this$1 = this;

			  if (this.active) {
			    // remove self from vm's watcher list
			    // this is a somewhat expensive operation so we skip it
			    // if the vm is being destroyed or is performing a v-for
			    // re-render (the watcher list is then filtered by v-for).
			    if (!this.vm._isBeingDestroyed && !this.vm._vForRemoving) {
			      remove$1(this.vm._watchers, this);
			    }
			    var i = this.deps.length;
			    while (i--) {
			      this$1.deps[i].removeSub(this$1);
			    }
			    this.active = false;
			  }
			};

			/**
			 * Recursively traverse an object to evoke all converted
			 * getters, so that every nested property inside the object
			 * is collected as a "deep" dependency.
			 */
			var seenObjects = new _Set();
			function traverse (val) {
			  seenObjects.clear();
			  _traverse(val, seenObjects);
			}

			function _traverse (val, seen) {
			  var i, keys;
			  var isA = Array.isArray(val);
			  if ((!isA && !isObject(val)) || !Object.isExtensible(val)) {
			    return
			  }
			  if (val.__ob__) {
			    var depId = val.__ob__.dep.id;
			    if (seen.has(depId)) {
			      return
			    }
			    seen.add(depId);
			  }
			  if (isA) {
			    i = val.length;
			    while (i--) { _traverse(val[i], seen); }
			  } else {
			    keys = Object.keys(val);
			    i = keys.length;
			    while (i--) { _traverse(val[keys[i]], seen); }
			  }
			}

			/*
			 * not type checking this file because flow doesn't play well with
			 * dynamically accessing methods on Array prototype
			 */

			var arrayProto = Array.prototype;
			var arrayMethods = Object.create(arrayProto);[
			  'push',
			  'pop',
			  'shift',
			  'unshift',
			  'splice',
			  'sort',
			  'reverse'
			]
			.forEach(function (method) {
			  // cache original method
			  var original = arrayProto[method];
			  def(arrayMethods, method, function mutator () {
			    var arguments$1 = arguments;

			    // avoid leaking arguments:
			    // http://jsperf.com/closure-with-arguments
			    var i = arguments.length;
			    var args = new Array(i);
			    while (i--) {
			      args[i] = arguments$1[i];
			    }
			    var result = original.apply(this, args);
			    var ob = this.__ob__;
			    var inserted;
			    switch (method) {
			      case 'push':
			        inserted = args;
			        break
			      case 'unshift':
			        inserted = args;
			        break
			      case 'splice':
			        inserted = args.slice(2);
			        break
			    }
			    if (inserted) { ob.observeArray(inserted); }
			    // notify change
			    ob.dep.notify();
			    return result
			  });
			});

			/*  */

			var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

			/**
			 * By default, when a reactive property is set, the new value is
			 * also converted to become reactive. However when passing down props,
			 * we don't want to force conversion because the value may be a nested value
			 * under a frozen data structure. Converting it would defeat the optimization.
			 */
			var observerState = {
			  shouldConvert: true,
			  isSettingProps: false
			};

			/**
			 * Observer class that are attached to each observed
			 * object. Once attached, the observer converts target
			 * object's property keys into getter/setters that
			 * collect dependencies and dispatches updates.
			 */
			var Observer = function Observer (value) {
			  this.value = value;
			  this.dep = new Dep();
			  this.vmCount = 0;
			  def(value, '__ob__', this);
			  if (Array.isArray(value)) {
			    var augment = hasProto
			      ? protoAugment
			      : copyAugment;
			    augment(value, arrayMethods, arrayKeys);
			    this.observeArray(value);
			  } else {
			    this.walk(value);
			  }
			};

			/**
			 * Walk through each property and convert them into
			 * getter/setters. This method should only be called when
			 * value type is Object.
			 */
			Observer.prototype.walk = function walk (obj) {
			  var keys = Object.keys(obj);
			  for (var i = 0; i < keys.length; i++) {
			    defineReactive$$1(obj, keys[i], obj[keys[i]]);
			  }
			};

			/**
			 * Observe a list of Array items.
			 */
			Observer.prototype.observeArray = function observeArray (items) {
			  for (var i = 0, l = items.length; i < l; i++) {
			    observe(items[i]);
			  }
			};

			// helpers

			/**
			 * Augment an target Object or Array by intercepting
			 * the prototype chain using __proto__
			 */
			function protoAugment (target, src) {
			  /* eslint-disable no-proto */
			  target.__proto__ = src;
			  /* eslint-enable no-proto */
			}

			/**
			 * Augment an target Object or Array by defining
			 * hidden properties.
			 *
			 * istanbul ignore next
			 */
			function copyAugment (target, src, keys) {
			  for (var i = 0, l = keys.length; i < l; i++) {
			    var key = keys[i];
			    def(target, key, src[key]);
			  }
			}

			/**
			 * Attempt to create an observer instance for a value,
			 * returns the new observer if successfully observed,
			 * or the existing observer if the value already has one.
			 */
			function observe (value) {
			  if (!isObject(value)) {
			    return
			  }
			  var ob;
			  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
			    ob = value.__ob__;
			  } else if (
			    observerState.shouldConvert &&
			    !config._isServer &&
			    (Array.isArray(value) || isPlainObject(value)) &&
			    Object.isExtensible(value) &&
			    !value._isVue
			  ) {
			    ob = new Observer(value);
			  }
			  return ob
			}

			/**
			 * Define a reactive property on an Object.
			 */
			function defineReactive$$1 (
			  obj,
			  key,
			  val,
			  customSetter
			) {
			  var dep = new Dep();

			  var property = Object.getOwnPropertyDescriptor(obj, key);
			  if (property && property.configurable === false) {
			    return
			  }

			  // cater for pre-defined getter/setters
			  var getter = property && property.get;
			  var setter = property && property.set;

			  var childOb = observe(val);
			  Object.defineProperty(obj, key, {
			    enumerable: true,
			    configurable: true,
			    get: function reactiveGetter () {
			      var value = getter ? getter.call(obj) : val;
			      if (Dep.target) {
			        dep.depend();
			        if (childOb) {
			          childOb.dep.depend();
			        }
			        if (Array.isArray(value)) {
			          dependArray(value);
			        }
			      }
			      return value
			    },
			    set: function reactiveSetter (newVal) {
			      var value = getter ? getter.call(obj) : val;
			      if (newVal === value) {
			        return
			      }
			      if ("development" !== 'production' && customSetter) {
			        customSetter();
			      }
			      if (setter) {
			        setter.call(obj, newVal);
			      } else {
			        val = newVal;
			      }
			      childOb = observe(newVal);
			      dep.notify();
			    }
			  });
			}

			/**
			 * Set a property on an object. Adds the new property and
			 * triggers change notification if the property doesn't
			 * already exist.
			 */
			function set (obj, key, val) {
			  if (Array.isArray(obj)) {
			    obj.length = Math.max(obj.length, key);
			    obj.splice(key, 1, val);
			    return val
			  }
			  if (hasOwn(obj, key)) {
			    obj[key] = val;
			    return
			  }
			  var ob = obj.__ob__;
			  if (obj._isVue || (ob && ob.vmCount)) {
			    "development" !== 'production' && warn(
			      'Avoid adding reactive properties to a Vue instance or its root $data ' +
			      'at runtime - declare it upfront in the data option.'
			    );
			    return
			  }
			  if (!ob) {
			    obj[key] = val;
			    return
			  }
			  defineReactive$$1(ob.value, key, val);
			  ob.dep.notify();
			  return val
			}

			/**
			 * Delete a property and trigger change if necessary.
			 */
			function del (obj, key) {
			  var ob = obj.__ob__;
			  if (obj._isVue || (ob && ob.vmCount)) {
			    "development" !== 'production' && warn(
			      'Avoid deleting properties on a Vue instance or its root $data ' +
			      '- just set it to null.'
			    );
			    return
			  }
			  if (!hasOwn(obj, key)) {
			    return
			  }
			  delete obj[key];
			  if (!ob) {
			    return
			  }
			  ob.dep.notify();
			}

			/**
			 * Collect dependencies on array elements when the array is touched, since
			 * we cannot intercept array element access like property getters.
			 */
			function dependArray (value) {
			  for (var e = void 0, i = 0, l = value.length; i < l; i++) {
			    e = value[i];
			    e && e.__ob__ && e.__ob__.dep.depend();
			    if (Array.isArray(e)) {
			      dependArray(e);
			    }
			  }
			}

			/*  */

			function initState (vm) {
			  vm._watchers = [];
			  initProps(vm);
			  initData(vm);
			  initComputed(vm);
			  initMethods(vm);
			  initWatch(vm);
			}

			function initProps (vm) {
			  var props = vm.$options.props;
			  if (props) {
			    var propsData = vm.$options.propsData || {};
			    var keys = vm.$options._propKeys = Object.keys(props);
			    var isRoot = !vm.$parent;
			    // root instance props should be converted
			    observerState.shouldConvert = isRoot;
			    var loop = function ( i ) {
			      var key = keys[i];
			      /* istanbul ignore else */
			      {
			        defineReactive$$1(vm, key, validateProp(key, props, propsData, vm), function () {
			          if (vm.$parent && !observerState.isSettingProps) {
			            warn(
			              "Avoid mutating a prop directly since the value will be " +
			              "overwritten whenever the parent component re-renders. " +
			              "Instead, use a data or computed property based on the prop's " +
			              "value. Prop being mutated: \"" + key + "\"",
			              vm
			            );
			          }
			        });
			      }
			    };

			    for (var i = 0; i < keys.length; i++) loop( i );
			    observerState.shouldConvert = true;
			  }
			}

			function initData (vm) {
			  var data = vm.$options.data;
			  data = vm._data = typeof data === 'function'
			    ? data.call(vm)
			    : data || {};
			  if (!isPlainObject(data)) {
			    data = {};
			    "development" !== 'production' && warn(
			      'data functions should return an object.',
			      vm
			    );
			  }
			  // proxy data on instance
			  var keys = Object.keys(data);
			  var props = vm.$options.props;
			  var i = keys.length;
			  while (i--) {
			    if (props && hasOwn(props, keys[i])) {
			      "development" !== 'production' && warn(
			        "The data property \"" + (keys[i]) + "\" is already declared as a prop. " +
			        "Use prop default value instead.",
			        vm
			      );
			    } else {
			      proxy(vm, keys[i]);
			    }
			  }
			  // observe data
			  observe(data);
			  data.__ob__ && data.__ob__.vmCount++;
			}

			var computedSharedDefinition = {
			  enumerable: true,
			  configurable: true,
			  get: noop,
			  set: noop
			};

			function initComputed (vm) {
			  var computed = vm.$options.computed;
			  if (computed) {
			    for (var key in computed) {
			      var userDef = computed[key];
			      if (typeof userDef === 'function') {
			        computedSharedDefinition.get = makeComputedGetter(userDef, vm);
			        computedSharedDefinition.set = noop;
			      } else {
			        computedSharedDefinition.get = userDef.get
			          ? userDef.cache !== false
			            ? makeComputedGetter(userDef.get, vm)
			            : bind$1(userDef.get, vm)
			          : noop;
			        computedSharedDefinition.set = userDef.set
			          ? bind$1(userDef.set, vm)
			          : noop;
			      }
			      Object.defineProperty(vm, key, computedSharedDefinition);
			    }
			  }
			}

			function makeComputedGetter (getter, owner) {
			  var watcher = new Watcher(owner, getter, noop, {
			    lazy: true
			  });
			  return function computedGetter () {
			    if (watcher.dirty) {
			      watcher.evaluate();
			    }
			    if (Dep.target) {
			      watcher.depend();
			    }
			    return watcher.value
			  }
			}

			function initMethods (vm) {
			  var methods = vm.$options.methods;
			  if (methods) {
			    for (var key in methods) {
			      vm[key] = methods[key] == null ? noop : bind$1(methods[key], vm);
			      {
			        methods[key] == null && warn(
			          "method \"" + key + "\" has an undefined value in the component definition. " +
			          "Did you reference the function correctly?",
			          vm
			        );
			        hasOwn(Vue$2.prototype, key) && warn(
			          ("Avoid overriding Vue's internal method \"" + key + "\"."),
			          vm
			        );
			      }
			    }
			  }
			}

			function initWatch (vm) {
			  var watch = vm.$options.watch;
			  if (watch) {
			    for (var key in watch) {
			      var handler = watch[key];
			      if (Array.isArray(handler)) {
			        for (var i = 0; i < handler.length; i++) {
			          createWatcher(vm, key, handler[i]);
			        }
			      } else {
			        createWatcher(vm, key, handler);
			      }
			    }
			  }
			}

			function createWatcher (vm, key, handler) {
			  var options;
			  if (isPlainObject(handler)) {
			    options = handler;
			    handler = handler.handler;
			  }
			  if (typeof handler === 'string') {
			    handler = vm[handler];
			  }
			  vm.$watch(key, handler, options);
			}

			function stateMixin (Vue) {
			  // flow somehow has problems with directly declared definition object
			  // when using Object.defineProperty, so we have to procedurally build up
			  // the object here.
			  var dataDef = {};
			  dataDef.get = function () {
			    return this._data
			  };
			  {
			    dataDef.set = function (newData) {
			      warn(
			        'Avoid replacing instance root $data. ' +
			        'Use nested data properties instead.',
			        this
			      );
			    };
			  }
			  Object.defineProperty(Vue.prototype, '$data', dataDef);

			  Vue.prototype.$set = set;
			  Vue.prototype.$delete = del;

			  Vue.prototype.$watch = function (
			    expOrFn,
			    cb,
			    options
			  ) {
			    var vm = this;
			    options = options || {};
			    options.user = true;
			    var watcher = new Watcher(vm, expOrFn, cb, options);
			    if (options.immediate) {
			      cb.call(vm, watcher.value);
			    }
			    return function unwatchFn () {
			      watcher.teardown();
			    }
			  };
			}

			function proxy (vm, key) {
			  if (!isReserved(key)) {
			    Object.defineProperty(vm, key, {
			      configurable: true,
			      enumerable: true,
			      get: function proxyGetter () {
			        return vm._data[key]
			      },
			      set: function proxySetter (val) {
			        vm._data[key] = val;
			      }
			    });
			  }
			}

			/*  */

			var VNode = function VNode (
			  tag,
			  data,
			  children,
			  text,
			  elm,
			  ns,
			  context,
			  componentOptions
			) {
			  this.tag = tag;
			  this.data = data;
			  this.children = children;
			  this.text = text;
			  this.elm = elm;
			  this.ns = ns;
			  this.context = context;
			  this.functionalContext = undefined;
			  this.key = data && data.key;
			  this.componentOptions = componentOptions;
			  this.child = undefined;
			  this.parent = undefined;
			  this.raw = false;
			  this.isStatic = false;
			  this.isRootInsert = true;
			  this.isComment = false;
			  this.isCloned = false;
			  this.isOnce = false;
			};

			var emptyVNode = function () {
			  var node = new VNode();
			  node.text = '';
			  node.isComment = true;
			  return node
			};

			// optimized shallow clone
			// used for static nodes and slot nodes because they may be reused across
			// multiple renders, cloning them avoids errors when DOM manipulations rely
			// on their elm reference.
			function cloneVNode (vnode) {
			  var cloned = new VNode(
			    vnode.tag,
			    vnode.data,
			    vnode.children,
			    vnode.text,
			    vnode.elm,
			    vnode.ns,
			    vnode.context,
			    vnode.componentOptions
			  );
			  cloned.isStatic = vnode.isStatic;
			  cloned.key = vnode.key;
			  cloned.isCloned = true;
			  return cloned
			}

			function cloneVNodes (vnodes) {
			  var res = new Array(vnodes.length);
			  for (var i = 0; i < vnodes.length; i++) {
			    res[i] = cloneVNode(vnodes[i]);
			  }
			  return res
			}

			/*  */

			function mergeVNodeHook (def, hookKey, hook, key) {
			  key = key + hookKey;
			  var injectedHash = def.__injected || (def.__injected = {});
			  if (!injectedHash[key]) {
			    injectedHash[key] = true;
			    var oldHook = def[hookKey];
			    if (oldHook) {
			      def[hookKey] = function () {
			        oldHook.apply(this, arguments);
			        hook.apply(this, arguments);
			      };
			    } else {
			      def[hookKey] = hook;
			    }
			  }
			}

			/*  */

			function updateListeners (
			  on,
			  oldOn,
			  add,
			  remove$$1,
			  vm
			) {
			  var name, cur, old, fn, event, capture;
			  for (name in on) {
			    cur = on[name];
			    old = oldOn[name];
			    if (!cur) {
			      "development" !== 'production' && warn(
			        "Invalid handler for event \"" + name + "\": got " + String(cur),
			        vm
			      );
			    } else if (!old) {
			      capture = name.charAt(0) === '!';
			      event = capture ? name.slice(1) : name;
			      if (Array.isArray(cur)) {
			        add(event, (cur.invoker = arrInvoker(cur)), capture);
			      } else {
			        if (!cur.invoker) {
			          fn = cur;
			          cur = on[name] = {};
			          cur.fn = fn;
			          cur.invoker = fnInvoker(cur);
			        }
			        add(event, cur.invoker, capture);
			      }
			    } else if (cur !== old) {
			      if (Array.isArray(old)) {
			        old.length = cur.length;
			        for (var i = 0; i < old.length; i++) { old[i] = cur[i]; }
			        on[name] = old;
			      } else {
			        old.fn = cur;
			        on[name] = old;
			      }
			    }
			  }
			  for (name in oldOn) {
			    if (!on[name]) {
			      event = name.charAt(0) === '!' ? name.slice(1) : name;
			      remove$$1(event, oldOn[name].invoker);
			    }
			  }
			}

			function arrInvoker (arr) {
			  return function (ev) {
			    var arguments$1 = arguments;

			    var single = arguments.length === 1;
			    for (var i = 0; i < arr.length; i++) {
			      single ? arr[i](ev) : arr[i].apply(null, arguments$1);
			    }
			  }
			}

			function fnInvoker (o) {
			  return function (ev) {
			    var single = arguments.length === 1;
			    single ? o.fn(ev) : o.fn.apply(null, arguments);
			  }
			}

			/*  */

			function normalizeChildren (
			  children,
			  ns,
			  nestedIndex
			) {
			  if (isPrimitive(children)) {
			    return [createTextVNode(children)]
			  }
			  if (Array.isArray(children)) {
			    var res = [];
			    for (var i = 0, l = children.length; i < l; i++) {
			      var c = children[i];
			      var last = res[res.length - 1];
			      //  nested
			      if (Array.isArray(c)) {
			        res.push.apply(res, normalizeChildren(c, ns, ((nestedIndex || '') + "_" + i)));
			      } else if (isPrimitive(c)) {
			        if (last && last.text) {
			          last.text += String(c);
			        } else if (c !== '') {
			          // convert primitive to vnode
			          res.push(createTextVNode(c));
			        }
			      } else if (c instanceof VNode) {
			        if (c.text && last && last.text) {
			          last.text += c.text;
			        } else {
			          // inherit parent namespace
			          if (ns) {
			            applyNS(c, ns);
			          }
			          // default key for nested array children (likely generated by v-for)
			          if (c.tag && c.key == null && nestedIndex != null) {
			            c.key = "__vlist" + nestedIndex + "_" + i + "__";
			          }
			          res.push(c);
			        }
			      }
			    }
			    return res
			  }
			}

			function createTextVNode (val) {
			  return new VNode(undefined, undefined, undefined, String(val))
			}

			function applyNS (vnode, ns) {
			  if (vnode.tag && !vnode.ns) {
			    vnode.ns = ns;
			    if (vnode.children) {
			      for (var i = 0, l = vnode.children.length; i < l; i++) {
			        applyNS(vnode.children[i], ns);
			      }
			    }
			  }
			}

			/*  */

			function getFirstComponentChild (children) {
			  return children && children.filter(function (c) { return c && c.componentOptions; })[0]
			}

			/*  */

			var activeInstance = null;

			function initLifecycle (vm) {
			  var options = vm.$options;

			  // locate first non-abstract parent
			  var parent = options.parent;
			  if (parent && !options.abstract) {
			    while (parent.$options.abstract && parent.$parent) {
			      parent = parent.$parent;
			    }
			    parent.$children.push(vm);
			  }

			  vm.$parent = parent;
			  vm.$root = parent ? parent.$root : vm;

			  vm.$children = [];
			  vm.$refs = {};

			  vm._watcher = null;
			  vm._inactive = false;
			  vm._isMounted = false;
			  vm._isDestroyed = false;
			  vm._isBeingDestroyed = false;
			}

			function lifecycleMixin (Vue) {
			  Vue.prototype._mount = function (
			    el,
			    hydrating
			  ) {
			    var vm = this;
			    vm.$el = el;
			    if (!vm.$options.render) {
			      vm.$options.render = emptyVNode;
			      {
			        /* istanbul ignore if */
			        if (vm.$options.template) {
			          warn(
			            'You are using the runtime-only build of Vue where the template ' +
			            'option is not available. Either pre-compile the templates into ' +
			            'render functions, or use the compiler-included build.',
			            vm
			          );
			        } else {
			          warn(
			            'Failed to mount component: template or render function not defined.',
			            vm
			          );
			        }
			      }
			    }
			    callHook(vm, 'beforeMount');
			    vm._watcher = new Watcher(vm, function () {
			      vm._update(vm._render(), hydrating);
			    }, noop);
			    hydrating = false;
			    // manually mounted instance, call mounted on self
			    // mounted is called for render-created child components in its inserted hook
			    if (vm.$vnode == null) {
			      vm._isMounted = true;
			      callHook(vm, 'mounted');
			    }
			    return vm
			  };

			  Vue.prototype._update = function (vnode, hydrating) {
			    var vm = this;
			    if (vm._isMounted) {
			      callHook(vm, 'beforeUpdate');
			    }
			    var prevEl = vm.$el;
			    var prevActiveInstance = activeInstance;
			    activeInstance = vm;
			    var prevVnode = vm._vnode;
			    vm._vnode = vnode;
			    if (!prevVnode) {
			      // Vue.prototype.__patch__ is injected in entry points
			      // based on the rendering backend used.
			      vm.$el = vm.__patch__(vm.$el, vnode, hydrating);
			    } else {
			      vm.$el = vm.__patch__(prevVnode, vnode);
			    }
			    activeInstance = prevActiveInstance;
			    // update __vue__ reference
			    if (prevEl) {
			      prevEl.__vue__ = null;
			    }
			    if (vm.$el) {
			      vm.$el.__vue__ = vm;
			    }
			    // if parent is an HOC, update its $el as well
			    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
			      vm.$parent.$el = vm.$el;
			    }
			    if (vm._isMounted) {
			      callHook(vm, 'updated');
			    }
			  };

			  Vue.prototype._updateFromParent = function (
			    propsData,
			    listeners,
			    parentVnode,
			    renderChildren
			  ) {
			    var vm = this;
			    var hasChildren = !!(vm.$options._renderChildren || renderChildren);
			    vm.$options._parentVnode = parentVnode;
			    vm.$options._renderChildren = renderChildren;
			    // update props
			    if (propsData && vm.$options.props) {
			      observerState.shouldConvert = false;
			      {
			        observerState.isSettingProps = true;
			      }
			      var propKeys = vm.$options._propKeys || [];
			      for (var i = 0; i < propKeys.length; i++) {
			        var key = propKeys[i];
			        vm[key] = validateProp(key, vm.$options.props, propsData, vm);
			      }
			      observerState.shouldConvert = true;
			      {
			        observerState.isSettingProps = false;
			      }
			      vm.$options.propsData = propsData;
			    }
			    // update listeners
			    if (listeners) {
			      var oldListeners = vm.$options._parentListeners;
			      vm.$options._parentListeners = listeners;
			      vm._updateListeners(listeners, oldListeners);
			    }
			    // resolve slots + force update if has children
			    if (hasChildren) {
			      vm.$slots = resolveSlots(renderChildren, vm._renderContext);
			      vm.$forceUpdate();
			    }
			  };

			  Vue.prototype.$forceUpdate = function () {
			    var vm = this;
			    if (vm._watcher) {
			      vm._watcher.update();
			    }
			  };

			  Vue.prototype.$destroy = function () {
			    var vm = this;
			    if (vm._isBeingDestroyed) {
			      return
			    }
			    callHook(vm, 'beforeDestroy');
			    vm._isBeingDestroyed = true;
			    // remove self from parent
			    var parent = vm.$parent;
			    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
			      remove$1(parent.$children, vm);
			    }
			    // teardown watchers
			    if (vm._watcher) {
			      vm._watcher.teardown();
			    }
			    var i = vm._watchers.length;
			    while (i--) {
			      vm._watchers[i].teardown();
			    }
			    // remove reference from data ob
			    // frozen object may not have observer.
			    if (vm._data.__ob__) {
			      vm._data.__ob__.vmCount--;
			    }
			    // call the last hook...
			    vm._isDestroyed = true;
			    callHook(vm, 'destroyed');
			    // turn off all instance listeners.
			    vm.$off();
			    // remove __vue__ reference
			    if (vm.$el) {
			      vm.$el.__vue__ = null;
			    }
			    // invoke destroy hooks on current rendered tree
			    vm.__patch__(vm._vnode, null);
			  };
			}

			function callHook (vm, hook) {
			  var handlers = vm.$options[hook];
			  if (handlers) {
			    for (var i = 0, j = handlers.length; i < j; i++) {
			      handlers[i].call(vm);
			    }
			  }
			  vm.$emit('hook:' + hook);
			}

			/*  */

			var hooks = { init: init, prepatch: prepatch, insert: insert, destroy: destroy$1 };
			var hooksToMerge = Object.keys(hooks);

			function createComponent (
			  Ctor,
			  data,
			  context,
			  children,
			  tag
			) {
			  if (!Ctor) {
			    return
			  }

			  if (isObject(Ctor)) {
			    Ctor = Vue$2.extend(Ctor);
			  }

			  if (typeof Ctor !== 'function') {
			    {
			      warn(("Invalid Component definition: " + (String(Ctor))), context);
			    }
			    return
			  }

			  // resolve constructor options in case global mixins are applied after
			  // component constructor creation
			  resolveConstructorOptions(Ctor);

			  // async component
			  if (!Ctor.cid) {
			    if (Ctor.resolved) {
			      Ctor = Ctor.resolved;
			    } else {
			      Ctor = resolveAsyncComponent(Ctor, function () {
			        // it's ok to queue this on every render because
			        // $forceUpdate is buffered by the scheduler.
			        context.$forceUpdate();
			      });
			      if (!Ctor) {
			        // return nothing if this is indeed an async component
			        // wait for the callback to trigger parent update.
			        return
			      }
			    }
			  }

			  data = data || {};

			  // extract props
			  var propsData = extractProps(data, Ctor);

			  // functional component
			  if (Ctor.options.functional) {
			    return createFunctionalComponent(Ctor, propsData, data, context, children)
			  }

			  // extract listeners, since these needs to be treated as
			  // child component listeners instead of DOM listeners
			  var listeners = data.on;
			  // replace with listeners with .native modifier
			  data.on = data.nativeOn;

			  if (Ctor.options.abstract) {
			    // abstract components do not keep anything
			    // other than props & listeners
			    data = {};
			  }

			  // merge component management hooks onto the placeholder node
			  mergeHooks(data);

			  // return a placeholder vnode
			  var name = Ctor.options.name || tag;
			  var vnode = new VNode(
			    ("vue-component-" + (Ctor.cid) + (name ? ("-" + name) : '')),
			    data, undefined, undefined, undefined, undefined, context,
			    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }
			  );
			  return vnode
			}

			function createFunctionalComponent (
			  Ctor,
			  propsData,
			  data,
			  context,
			  children
			) {
			  var props = {};
			  var propOptions = Ctor.options.props;
			  if (propOptions) {
			    for (var key in propOptions) {
			      props[key] = validateProp(key, propOptions, propsData);
			    }
			  }
			  var vnode = Ctor.options.render.call(
			    null,
			    // ensure the createElement function in functional components
			    // gets a unique context - this is necessary for correct named slot check
			    bind$1(createElement, { _self: Object.create(context) }),
			    {
			      props: props,
			      data: data,
			      parent: context,
			      children: normalizeChildren(children),
			      slots: function () { return resolveSlots(children, context); }
			    }
			  );
			  if (vnode instanceof VNode) {
			    vnode.functionalContext = context;
			    if (data.slot) {
			      (vnode.data || (vnode.data = {})).slot = data.slot;
			    }
			  }
			  return vnode
			}

			function createComponentInstanceForVnode (
			  vnode, // we know it's MountedComponentVNode but flow doesn't
			  parent // activeInstance in lifecycle state
			) {
			  var vnodeComponentOptions = vnode.componentOptions;
			  var options = {
			    _isComponent: true,
			    parent: parent,
			    propsData: vnodeComponentOptions.propsData,
			    _componentTag: vnodeComponentOptions.tag,
			    _parentVnode: vnode,
			    _parentListeners: vnodeComponentOptions.listeners,
			    _renderChildren: vnodeComponentOptions.children
			  };
			  // check inline-template render functions
			  var inlineTemplate = vnode.data.inlineTemplate;
			  if (inlineTemplate) {
			    options.render = inlineTemplate.render;
			    options.staticRenderFns = inlineTemplate.staticRenderFns;
			  }
			  return new vnodeComponentOptions.Ctor(options)
			}

			function init (vnode, hydrating) {
			  if (!vnode.child || vnode.child._isDestroyed) {
			    var child = vnode.child = createComponentInstanceForVnode(vnode, activeInstance);
			    child.$mount(hydrating ? vnode.elm : undefined, hydrating);
			  }
			}

			function prepatch (
			  oldVnode,
			  vnode
			) {
			  var options = vnode.componentOptions;
			  var child = vnode.child = oldVnode.child;
			  child._updateFromParent(
			    options.propsData, // updated props
			    options.listeners, // updated listeners
			    vnode, // new parent vnode
			    options.children // new children
			  );
			}

			function insert (vnode) {
			  if (!vnode.child._isMounted) {
			    vnode.child._isMounted = true;
			    callHook(vnode.child, 'mounted');
			  }
			  if (vnode.data.keepAlive) {
			    vnode.child._inactive = false;
			    callHook(vnode.child, 'activated');
			  }
			}

			function destroy$1 (vnode) {
			  if (!vnode.child._isDestroyed) {
			    if (!vnode.data.keepAlive) {
			      vnode.child.$destroy();
			    } else {
			      vnode.child._inactive = true;
			      callHook(vnode.child, 'deactivated');
			    }
			  }
			}

			function resolveAsyncComponent (
			  factory,
			  cb
			) {
			  if (factory.requested) {
			    // pool callbacks
			    factory.pendingCallbacks.push(cb);
			  } else {
			    factory.requested = true;
			    var cbs = factory.pendingCallbacks = [cb];
			    var sync = true;

			    var resolve = function (res) {
			      if (isObject(res)) {
			        res = Vue$2.extend(res);
			      }
			      // cache resolved
			      factory.resolved = res;
			      // invoke callbacks only if this is not a synchronous resolve
			      // (async resolves are shimmed as synchronous during SSR)
			      if (!sync) {
			        for (var i = 0, l = cbs.length; i < l; i++) {
			          cbs[i](res);
			        }
			      }
			    };

			    var reject = function (reason) {
			      "development" !== 'production' && warn(
			        "Failed to resolve async component: " + (String(factory)) +
			        (reason ? ("\nReason: " + reason) : '')
			      );
			    };

			    var res = factory(resolve, reject);

			    // handle promise
			    if (res && typeof res.then === 'function' && !factory.resolved) {
			      res.then(resolve, reject);
			    }

			    sync = false;
			    // return in case resolved synchronously
			    return factory.resolved
			  }
			}

			function extractProps (data, Ctor) {
			  // we are only extracting raw values here.
			  // validation and default values are handled in the child
			  // component itself.
			  var propOptions = Ctor.options.props;
			  if (!propOptions) {
			    return
			  }
			  var res = {};
			  var attrs = data.attrs;
			  var props = data.props;
			  var domProps = data.domProps;
			  if (attrs || props || domProps) {
			    for (var key in propOptions) {
			      var altKey = hyphenate(key);
			      checkProp(res, props, key, altKey, true) ||
			      checkProp(res, attrs, key, altKey) ||
			      checkProp(res, domProps, key, altKey);
			    }
			  }
			  return res
			}

			function checkProp (
			  res,
			  hash,
			  key,
			  altKey,
			  preserve
			) {
			  if (hash) {
			    if (hasOwn(hash, key)) {
			      res[key] = hash[key];
			      if (!preserve) {
			        delete hash[key];
			      }
			      return true
			    } else if (hasOwn(hash, altKey)) {
			      res[key] = hash[altKey];
			      if (!preserve) {
			        delete hash[altKey];
			      }
			      return true
			    }
			  }
			  return false
			}

			function mergeHooks (data) {
			  if (!data.hook) {
			    data.hook = {};
			  }
			  for (var i = 0; i < hooksToMerge.length; i++) {
			    var key = hooksToMerge[i];
			    var fromParent = data.hook[key];
			    var ours = hooks[key];
			    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;
			  }
			}

			function mergeHook$1 (a, b) {
			  // since all hooks have at most two args, use fixed args
			  // to avoid having to use fn.apply().
			  return function (_, __) {
			    a(_, __);
			    b(_, __);
			  }
			}

			/*  */

			// wrapper function for providing a more flexible interface
			// without getting yelled at by flow
			function createElement (
			  tag,
			  data,
			  children
			) {
			  if (data && (Array.isArray(data) || typeof data !== 'object')) {
			    children = data;
			    data = undefined;
			  }
			  // make sure to use real instance instead of proxy as context
			  return _createElement(this._self, tag, data, children)
			}

			function _createElement (
			  context,
			  tag,
			  data,
			  children
			) {
			  if (data && data.__ob__) {
			    "development" !== 'production' && warn(
			      "Avoid using observed data object as vnode data: " + (JSON.stringify(data)) + "\n" +
			      'Always create fresh vnode data objects in each render!',
			      context
			    );
			    return
			  }
			  if (!tag) {
			    // in case of component :is set to falsy value
			    return emptyVNode()
			  }
			  if (typeof tag === 'string') {
			    var Ctor;
			    var ns = config.getTagNamespace(tag);
			    if (config.isReservedTag(tag)) {
			      // platform built-in elements
			      return new VNode(
			        tag, data, normalizeChildren(children, ns),
			        undefined, undefined, ns, context
			      )
			    } else if ((Ctor = resolveAsset(context.$options, 'components', tag))) {
			      // component
			      return createComponent(Ctor, data, context, children, tag)
			    } else {
			      // unknown or unlisted namespaced elements
			      // check at runtime because it may get assigned a namespace when its
			      // parent normalizes children
			      var childNs = tag === 'foreignObject' ? 'xhtml' : ns;
			      return new VNode(
			        tag, data, normalizeChildren(children, childNs),
			        undefined, undefined, ns, context
			      )
			    }
			  } else {
			    // direct component options / constructor
			    return createComponent(tag, data, context, children)
			  }
			}

			/*  */

			function initRender (vm) {
			  vm.$vnode = null; // the placeholder node in parent tree
			  vm._vnode = null; // the root of the child tree
			  vm._staticTrees = null;
			  vm._renderContext = vm.$options._parentVnode && vm.$options._parentVnode.context;
			  vm.$slots = resolveSlots(vm.$options._renderChildren, vm._renderContext);
			  // bind the public createElement fn to this instance
			  // so that we get proper render context inside it.
			  vm.$createElement = bind$1(createElement, vm);
			  if (vm.$options.el) {
			    vm.$mount(vm.$options.el);
			  }
			}

			function renderMixin (Vue) {
			  Vue.prototype.$nextTick = function (fn) {
			    nextTick(fn, this);
			  };

			  Vue.prototype._render = function () {
			    var vm = this;
			    var ref = vm.$options;
			    var render = ref.render;
			    var staticRenderFns = ref.staticRenderFns;
			    var _parentVnode = ref._parentVnode;

			    if (vm._isMounted) {
			      // clone slot nodes on re-renders
			      for (var key in vm.$slots) {
			        vm.$slots[key] = cloneVNodes(vm.$slots[key]);
			      }
			    }

			    if (staticRenderFns && !vm._staticTrees) {
			      vm._staticTrees = [];
			    }
			    // set parent vnode. this allows render functions to have access
			    // to the data on the placeholder node.
			    vm.$vnode = _parentVnode;
			    // render self
			    var vnode;
			    try {
			      vnode = render.call(vm._renderProxy, vm.$createElement);
			    } catch (e) {
			      {
			        warn(("Error when rendering " + (formatComponentName(vm)) + ":"));
			      }
			      /* istanbul ignore else */
			      if (config.errorHandler) {
			        config.errorHandler.call(null, e, vm);
			      } else {
			        if (config._isServer) {
			          throw e
			        } else {
			          console.error(e);
			        }
			      }
			      // return previous vnode to prevent render error causing blank component
			      vnode = vm._vnode;
			    }
			    // return empty vnode in case the render function errored out
			    if (!(vnode instanceof VNode)) {
			      if ("development" !== 'production' && Array.isArray(vnode)) {
			        warn(
			          'Multiple root nodes returned from render function. Render function ' +
			          'should return a single root node.',
			          vm
			        );
			      }
			      vnode = emptyVNode();
			    }
			    // set parent
			    vnode.parent = _parentVnode;
			    return vnode
			  };

			  // shorthands used in render functions
			  Vue.prototype._h = createElement;
			  // toString for mustaches
			  Vue.prototype._s = _toString;
			  // number conversion
			  Vue.prototype._n = toNumber;
			  // empty vnode
			  Vue.prototype._e = emptyVNode;
			  // loose equal
			  Vue.prototype._q = looseEqual;
			  // loose indexOf
			  Vue.prototype._i = looseIndexOf;

			  // render static tree by index
			  Vue.prototype._m = function renderStatic (
			    index,
			    isInFor
			  ) {
			    var tree = this._staticTrees[index];
			    // if has already-rendered static tree and not inside v-for,
			    // we can reuse the same tree by doing a shallow clone.
			    if (tree && !isInFor) {
			      return Array.isArray(tree)
			        ? cloneVNodes(tree)
			        : cloneVNode(tree)
			    }
			    // otherwise, render a fresh tree.
			    tree = this._staticTrees[index] = this.$options.staticRenderFns[index].call(this._renderProxy);
			    markStatic(tree, ("__static__" + index), false);
			    return tree
			  };

			  // mark node as static (v-once)
			  Vue.prototype._o = function markOnce (
			    tree,
			    index,
			    key
			  ) {
			    markStatic(tree, ("__once__" + index + (key ? ("_" + key) : "")), true);
			    return tree
			  };

			  function markStatic (tree, key, isOnce) {
			    if (Array.isArray(tree)) {
			      for (var i = 0; i < tree.length; i++) {
			        if (tree[i] && typeof tree[i] !== 'string') {
			          markStaticNode(tree[i], (key + "_" + i), isOnce);
			        }
			      }
			    } else {
			      markStaticNode(tree, key, isOnce);
			    }
			  }

			  function markStaticNode (node, key, isOnce) {
			    node.isStatic = true;
			    node.key = key;
			    node.isOnce = isOnce;
			  }

			  // filter resolution helper
			  var identity = function (_) { return _; };
			  Vue.prototype._f = function resolveFilter (id) {
			    return resolveAsset(this.$options, 'filters', id, true) || identity
			  };

			  // render v-for
			  Vue.prototype._l = function renderList (
			    val,
			    render
			  ) {
			    var ret, i, l, keys, key;
			    if (Array.isArray(val)) {
			      ret = new Array(val.length);
			      for (i = 0, l = val.length; i < l; i++) {
			        ret[i] = render(val[i], i);
			      }
			    } else if (typeof val === 'number') {
			      ret = new Array(val);
			      for (i = 0; i < val; i++) {
			        ret[i] = render(i + 1, i);
			      }
			    } else if (isObject(val)) {
			      keys = Object.keys(val);
			      ret = new Array(keys.length);
			      for (i = 0, l = keys.length; i < l; i++) {
			        key = keys[i];
			        ret[i] = render(val[key], key, i);
			      }
			    }
			    return ret
			  };

			  // renderSlot
			  Vue.prototype._t = function (
			    name,
			    fallback
			  ) {
			    var slotNodes = this.$slots[name];
			    // warn duplicate slot usage
			    if (slotNodes && "development" !== 'production') {
			      slotNodes._rendered && warn(
			        "Duplicate presence of slot \"" + name + "\" found in the same render tree " +
			        "- this will likely cause render errors.",
			        this
			      );
			      slotNodes._rendered = true;
			    }
			    return slotNodes || fallback
			  };

			  // apply v-bind object
			  Vue.prototype._b = function bindProps (
			    data,
			    value,
			    asProp
			  ) {
			    if (value) {
			      if (!isObject(value)) {
			        "development" !== 'production' && warn(
			          'v-bind without argument expects an Object or Array value',
			          this
			        );
			      } else {
			        if (Array.isArray(value)) {
			          value = toObject(value);
			        }
			        for (var key in value) {
			          if (key === 'class' || key === 'style') {
			            data[key] = value[key];
			          } else {
			            var hash = asProp || config.mustUseProp(key)
			              ? data.domProps || (data.domProps = {})
			              : data.attrs || (data.attrs = {});
			            hash[key] = value[key];
			          }
			        }
			      }
			    }
			    return data
			  };

			  // expose v-on keyCodes
			  Vue.prototype._k = function getKeyCodes (key) {
			    return config.keyCodes[key]
			  };
			}

			function resolveSlots (
			  renderChildren,
			  context
			) {
			  var slots = {};
			  if (!renderChildren) {
			    return slots
			  }
			  var children = normalizeChildren(renderChildren) || [];
			  var defaultSlot = [];
			  var name, child;
			  for (var i = 0, l = children.length; i < l; i++) {
			    child = children[i];
			    // named slots should only be respected if the vnode was rendered in the
			    // same context.
			    if ((child.context === context || child.functionalContext === context) &&
			        child.data && (name = child.data.slot)) {
			      var slot = (slots[name] || (slots[name] = []));
			      if (child.tag === 'template') {
			        slot.push.apply(slot, child.children);
			      } else {
			        slot.push(child);
			      }
			    } else {
			      defaultSlot.push(child);
			    }
			  }
			  // ignore single whitespace
			  if (defaultSlot.length && !(
			    defaultSlot.length === 1 &&
			    (defaultSlot[0].text === ' ' || defaultSlot[0].isComment)
			  )) {
			    slots.default = defaultSlot;
			  }
			  return slots
			}

			/*  */

			function initEvents (vm) {
			  vm._events = Object.create(null);
			  // init parent attached events
			  var listeners = vm.$options._parentListeners;
			  var on = bind$1(vm.$on, vm);
			  var off = bind$1(vm.$off, vm);
			  vm._updateListeners = function (listeners, oldListeners) {
			    updateListeners(listeners, oldListeners || {}, on, off, vm);
			  };
			  if (listeners) {
			    vm._updateListeners(listeners);
			  }
			}

			function eventsMixin (Vue) {
			  Vue.prototype.$on = function (event, fn) {
			    var vm = this;(vm._events[event] || (vm._events[event] = [])).push(fn);
			    return vm
			  };

			  Vue.prototype.$once = function (event, fn) {
			    var vm = this;
			    function on () {
			      vm.$off(event, on);
			      fn.apply(vm, arguments);
			    }
			    on.fn = fn;
			    vm.$on(event, on);
			    return vm
			  };

			  Vue.prototype.$off = function (event, fn) {
			    var vm = this;
			    // all
			    if (!arguments.length) {
			      vm._events = Object.create(null);
			      return vm
			    }
			    // specific event
			    var cbs = vm._events[event];
			    if (!cbs) {
			      return vm
			    }
			    if (arguments.length === 1) {
			      vm._events[event] = null;
			      return vm
			    }
			    // specific handler
			    var cb;
			    var i = cbs.length;
			    while (i--) {
			      cb = cbs[i];
			      if (cb === fn || cb.fn === fn) {
			        cbs.splice(i, 1);
			        break
			      }
			    }
			    return vm
			  };

			  Vue.prototype.$emit = function (event) {
			    var vm = this;
			    var cbs = vm._events[event];
			    if (cbs) {
			      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
			      var args = toArray(arguments, 1);
			      for (var i = 0, l = cbs.length; i < l; i++) {
			        cbs[i].apply(vm, args);
			      }
			    }
			    return vm
			  };
			}

			/*  */

			var uid = 0;

			function initMixin (Vue) {
			  Vue.prototype._init = function (options) {
			    var vm = this;
			    // a uid
			    vm._uid = uid++;
			    // a flag to avoid this being observed
			    vm._isVue = true;
			    // merge options
			    if (options && options._isComponent) {
			      // optimize internal component instantiation
			      // since dynamic options merging is pretty slow, and none of the
			      // internal component options needs special treatment.
			      initInternalComponent(vm, options);
			    } else {
			      vm.$options = mergeOptions(
			        resolveConstructorOptions(vm.constructor),
			        options || {},
			        vm
			      );
			    }
			    /* istanbul ignore else */
			    {
			      initProxy(vm);
			    }
			    // expose real self
			    vm._self = vm;
			    initLifecycle(vm);
			    initEvents(vm);
			    callHook(vm, 'beforeCreate');
			    initState(vm);
			    callHook(vm, 'created');
			    initRender(vm);
			  };
			}

			function initInternalComponent (vm, options) {
			  var opts = vm.$options = Object.create(vm.constructor.options);
			  // doing this because it's faster than dynamic enumeration.
			  opts.parent = options.parent;
			  opts.propsData = options.propsData;
			  opts._parentVnode = options._parentVnode;
			  opts._parentListeners = options._parentListeners;
			  opts._renderChildren = options._renderChildren;
			  opts._componentTag = options._componentTag;
			  if (options.render) {
			    opts.render = options.render;
			    opts.staticRenderFns = options.staticRenderFns;
			  }
			}

			function resolveConstructorOptions (Ctor) {
			  var options = Ctor.options;
			  if (Ctor.super) {
			    var superOptions = Ctor.super.options;
			    var cachedSuperOptions = Ctor.superOptions;
			    var extendOptions = Ctor.extendOptions;
			    if (superOptions !== cachedSuperOptions) {
			      // super option changed
			      Ctor.superOptions = superOptions;
			      extendOptions.render = options.render;
			      extendOptions.staticRenderFns = options.staticRenderFns;
			      options = Ctor.options = mergeOptions(superOptions, extendOptions);
			      if (options.name) {
			        options.components[options.name] = Ctor;
			      }
			    }
			  }
			  return options
			}

			function Vue$2 (options) {
			  if ("development" !== 'production' &&
			    !(this instanceof Vue$2)) {
			    warn('Vue is a constructor and should be called with the `new` keyword');
			  }
			  this._init(options);
			}

			initMixin(Vue$2);
			stateMixin(Vue$2);
			eventsMixin(Vue$2);
			lifecycleMixin(Vue$2);
			renderMixin(Vue$2);

			var warn = noop;
			var formatComponentName;

			{
			  var hasConsole = typeof console !== 'undefined';

			  warn = function (msg, vm) {
			    if (hasConsole && (!config.silent)) {
			      console.error("[Vue warn]: " + msg + " " + (
			        vm ? formatLocation(formatComponentName(vm)) : ''
			      ));
			    }
			  };

			  formatComponentName = function (vm) {
			    if (vm.$root === vm) {
			      return 'root instance'
			    }
			    var name = vm._isVue
			      ? vm.$options.name || vm.$options._componentTag
			      : vm.name;
			    return (
			      (name ? ("component <" + name + ">") : "anonymous component") +
			      (vm._isVue && vm.$options.__file ? (" at " + (vm.$options.__file)) : '')
			    )
			  };

			  var formatLocation = function (str) {
			    if (str === 'anonymous component') {
			      str += " - use the \"name\" option for better debugging messages.";
			    }
			    return ("\n(found in " + str + ")")
			  };
			}

			/*  */

			/**
			 * Option overwriting strategies are functions that handle
			 * how to merge a parent option value and a child option
			 * value into the final value.
			 */
			var strats = config.optionMergeStrategies;

			/**
			 * Options with restrictions
			 */
			{
			  strats.el = strats.propsData = function (parent, child, vm, key) {
			    if (!vm) {
			      warn(
			        "option \"" + key + "\" can only be used during instance " +
			        'creation with the `new` keyword.'
			      );
			    }
			    return defaultStrat(parent, child)
			  };
			}

			/**
			 * Helper that recursively merges two data objects together.
			 */
			function mergeData (to, from) {
			  var key, toVal, fromVal;
			  for (key in from) {
			    toVal = to[key];
			    fromVal = from[key];
			    if (!hasOwn(to, key)) {
			      set(to, key, fromVal);
			    } else if (isObject(toVal) && isObject(fromVal)) {
			      mergeData(toVal, fromVal);
			    }
			  }
			  return to
			}

			/**
			 * Data
			 */
			strats.data = function (
			  parentVal,
			  childVal,
			  vm
			) {
			  if (!vm) {
			    // in a Vue.extend merge, both should be functions
			    if (!childVal) {
			      return parentVal
			    }
			    if (typeof childVal !== 'function') {
			      "development" !== 'production' && warn(
			        'The "data" option should be a function ' +
			        'that returns a per-instance value in component ' +
			        'definitions.',
			        vm
			      );
			      return parentVal
			    }
			    if (!parentVal) {
			      return childVal
			    }
			    // when parentVal & childVal are both present,
			    // we need to return a function that returns the
			    // merged result of both functions... no need to
			    // check if parentVal is a function here because
			    // it has to be a function to pass previous merges.
			    return function mergedDataFn () {
			      return mergeData(
			        childVal.call(this),
			        parentVal.call(this)
			      )
			    }
			  } else if (parentVal || childVal) {
			    return function mergedInstanceDataFn () {
			      // instance merge
			      var instanceData = typeof childVal === 'function'
			        ? childVal.call(vm)
			        : childVal;
			      var defaultData = typeof parentVal === 'function'
			        ? parentVal.call(vm)
			        : undefined;
			      if (instanceData) {
			        return mergeData(instanceData, defaultData)
			      } else {
			        return defaultData
			      }
			    }
			  }
			};

			/**
			 * Hooks and param attributes are merged as arrays.
			 */
			function mergeHook (
			  parentVal,
			  childVal
			) {
			  return childVal
			    ? parentVal
			      ? parentVal.concat(childVal)
			      : Array.isArray(childVal)
			        ? childVal
			        : [childVal]
			    : parentVal
			}

			config._lifecycleHooks.forEach(function (hook) {
			  strats[hook] = mergeHook;
			});

			/**
			 * Assets
			 *
			 * When a vm is present (instance creation), we need to do
			 * a three-way merge between constructor options, instance
			 * options and parent options.
			 */
			function mergeAssets (parentVal, childVal) {
			  var res = Object.create(parentVal || null);
			  return childVal
			    ? extend(res, childVal)
			    : res
			}

			config._assetTypes.forEach(function (type) {
			  strats[type + 's'] = mergeAssets;
			});

			/**
			 * Watchers.
			 *
			 * Watchers hashes should not overwrite one
			 * another, so we merge them as arrays.
			 */
			strats.watch = function (parentVal, childVal) {
			  /* istanbul ignore if */
			  if (!childVal) { return parentVal }
			  if (!parentVal) { return childVal }
			  var ret = {};
			  extend(ret, parentVal);
			  for (var key in childVal) {
			    var parent = ret[key];
			    var child = childVal[key];
			    if (parent && !Array.isArray(parent)) {
			      parent = [parent];
			    }
			    ret[key] = parent
			      ? parent.concat(child)
			      : [child];
			  }
			  return ret
			};

			/**
			 * Other object hashes.
			 */
			strats.props =
			strats.methods =
			strats.computed = function (parentVal, childVal) {
			  if (!childVal) { return parentVal }
			  if (!parentVal) { return childVal }
			  var ret = Object.create(null);
			  extend(ret, parentVal);
			  extend(ret, childVal);
			  return ret
			};

			/**
			 * Default strategy.
			 */
			var defaultStrat = function (parentVal, childVal) {
			  return childVal === undefined
			    ? parentVal
			    : childVal
			};

			/**
			 * Validate component names
			 */
			function checkComponents (options) {
			  for (var key in options.components) {
			    var lower = key.toLowerCase();
			    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {
			      warn(
			        'Do not use built-in or reserved HTML elements as component ' +
			        'id: ' + key
			      );
			    }
			  }
			}

			/**
			 * Ensure all props option syntax are normalized into the
			 * Object-based format.
			 */
			function normalizeProps (options) {
			  var props = options.props;
			  if (!props) { return }
			  var res = {};
			  var i, val, name;
			  if (Array.isArray(props)) {
			    i = props.length;
			    while (i--) {
			      val = props[i];
			      if (typeof val === 'string') {
			        name = camelize(val);
			        res[name] = { type: null };
			      } else {
			        warn('props must be strings when using array syntax.');
			      }
			    }
			  } else if (isPlainObject(props)) {
			    for (var key in props) {
			      val = props[key];
			      name = camelize(key);
			      res[name] = isPlainObject(val)
			        ? val
			        : { type: val };
			    }
			  }
			  options.props = res;
			}

			/**
			 * Normalize raw function directives into object format.
			 */
			function normalizeDirectives (options) {
			  var dirs = options.directives;
			  if (dirs) {
			    for (var key in dirs) {
			      var def = dirs[key];
			      if (typeof def === 'function') {
			        dirs[key] = { bind: def, update: def };
			      }
			    }
			  }
			}

			/**
			 * Merge two option objects into a new one.
			 * Core utility used in both instantiation and inheritance.
			 */
			function mergeOptions (
			  parent,
			  child,
			  vm
			) {
			  {
			    checkComponents(child);
			  }
			  normalizeProps(child);
			  normalizeDirectives(child);
			  var extendsFrom = child.extends;
			  if (extendsFrom) {
			    parent = typeof extendsFrom === 'function'
			      ? mergeOptions(parent, extendsFrom.options, vm)
			      : mergeOptions(parent, extendsFrom, vm);
			  }
			  if (child.mixins) {
			    for (var i = 0, l = child.mixins.length; i < l; i++) {
			      var mixin = child.mixins[i];
			      if (mixin.prototype instanceof Vue$2) {
			        mixin = mixin.options;
			      }
			      parent = mergeOptions(parent, mixin, vm);
			    }
			  }
			  var options = {};
			  var key;
			  for (key in parent) {
			    mergeField(key);
			  }
			  for (key in child) {
			    if (!hasOwn(parent, key)) {
			      mergeField(key);
			    }
			  }
			  function mergeField (key) {
			    var strat = strats[key] || defaultStrat;
			    options[key] = strat(parent[key], child[key], vm, key);
			  }
			  return options
			}

			/**
			 * Resolve an asset.
			 * This function is used because child instances need access
			 * to assets defined in its ancestor chain.
			 */
			function resolveAsset (
			  options,
			  type,
			  id,
			  warnMissing
			) {
			  /* istanbul ignore if */
			  if (typeof id !== 'string') {
			    return
			  }
			  var assets = options[type];
			  var res = assets[id] ||
			    // camelCase ID
			    assets[camelize(id)] ||
			    // Pascal Case ID
			    assets[capitalize(camelize(id))];
			  if ("development" !== 'production' && warnMissing && !res) {
			    warn(
			      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,
			      options
			    );
			  }
			  return res
			}

			/*  */

			function validateProp (
			  key,
			  propOptions,
			  propsData,
			  vm
			) {
			  var prop = propOptions[key];
			  var absent = !hasOwn(propsData, key);
			  var value = propsData[key];
			  // handle boolean props
			  if (isBooleanType(prop.type)) {
			    if (absent && !hasOwn(prop, 'default')) {
			      value = false;
			    } else if (value === '' || value === hyphenate(key)) {
			      value = true;
			    }
			  }
			  // check default value
			  if (value === undefined) {
			    value = getPropDefaultValue(vm, prop, key);
			    // since the default value is a fresh copy,
			    // make sure to observe it.
			    var prevShouldConvert = observerState.shouldConvert;
			    observerState.shouldConvert = true;
			    observe(value);
			    observerState.shouldConvert = prevShouldConvert;
			  }
			  {
			    assertProp(prop, key, value, vm, absent);
			  }
			  return value
			}

			/**
			 * Get the default value of a prop.
			 */
			function getPropDefaultValue (vm, prop, key) {
			  // no default, return undefined
			  if (!hasOwn(prop, 'default')) {
			    return undefined
			  }
			  var def = prop.default;
			  // warn against non-factory defaults for Object & Array
			  if (isObject(def)) {
			    "development" !== 'production' && warn(
			      'Invalid default value for prop "' + key + '": ' +
			      'Props with type Object/Array must use a factory function ' +
			      'to return the default value.',
			      vm
			    );
			  }
			  // the raw prop value was also undefined from previous render,
			  // return previous default value to avoid unnecessary watcher trigger
			  if (vm && vm.$options.propsData &&
			    vm.$options.propsData[key] === undefined &&
			    vm[key] !== undefined) {
			    return vm[key]
			  }
			  // call factory function for non-Function types
			  return typeof def === 'function' && prop.type !== Function
			    ? def.call(vm)
			    : def
			}

			/**
			 * Assert whether a prop is valid.
			 */
			function assertProp (
			  prop,
			  name,
			  value,
			  vm,
			  absent
			) {
			  if (prop.required && absent) {
			    warn(
			      'Missing required prop: "' + name + '"',
			      vm
			    );
			    return
			  }
			  if (value == null && !prop.required) {
			    return
			  }
			  var type = prop.type;
			  var valid = !type || type === true;
			  var expectedTypes = [];
			  if (type) {
			    if (!Array.isArray(type)) {
			      type = [type];
			    }
			    for (var i = 0; i < type.length && !valid; i++) {
			      var assertedType = assertType(value, type[i]);
			      expectedTypes.push(assertedType.expectedType);
			      valid = assertedType.valid;
			    }
			  }
			  if (!valid) {
			    warn(
			      'Invalid prop: type check failed for prop "' + name + '".' +
			      ' Expected ' + expectedTypes.map(capitalize).join(', ') +
			      ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.',
			      vm
			    );
			    return
			  }
			  var validator = prop.validator;
			  if (validator) {
			    if (!validator(value)) {
			      warn(
			        'Invalid prop: custom validator check failed for prop "' + name + '".',
			        vm
			      );
			    }
			  }
			}

			/**
			 * Assert the type of a value
			 */
			function assertType (value, type) {
			  var valid;
			  var expectedType = getType(type);
			  if (expectedType === 'String') {
			    valid = typeof value === (expectedType = 'string');
			  } else if (expectedType === 'Number') {
			    valid = typeof value === (expectedType = 'number');
			  } else if (expectedType === 'Boolean') {
			    valid = typeof value === (expectedType = 'boolean');
			  } else if (expectedType === 'Function') {
			    valid = typeof value === (expectedType = 'function');
			  } else if (expectedType === 'Object') {
			    valid = isPlainObject(value);
			  } else if (expectedType === 'Array') {
			    valid = Array.isArray(value);
			  } else {
			    valid = value instanceof type;
			  }
			  return {
			    valid: valid,
			    expectedType: expectedType
			  }
			}

			/**
			 * Use function string name to check built-in types,
			 * because a simple equality check will fail when running
			 * across different vms / iframes.
			 */
			function getType (fn) {
			  var match = fn && fn.toString().match(/^\s*function (\w+)/);
			  return match && match[1]
			}

			function isBooleanType (fn) {
			  if (!Array.isArray(fn)) {
			    return getType(fn) === 'Boolean'
			  }
			  for (var i = 0, len = fn.length; i < len; i++) {
			    if (getType(fn[i]) === 'Boolean') {
			      return true
			    }
			  }
			  /* istanbul ignore next */
			  return false
			}



			var util = Object.freeze({
				defineReactive: defineReactive$$1,
				_toString: _toString,
				toNumber: toNumber,
				makeMap: makeMap,
				isBuiltInTag: isBuiltInTag,
				remove: remove$1,
				hasOwn: hasOwn,
				isPrimitive: isPrimitive,
				cached: cached,
				camelize: camelize,
				capitalize: capitalize,
				hyphenate: hyphenate,
				bind: bind$1,
				toArray: toArray,
				extend: extend,
				isObject: isObject,
				isPlainObject: isPlainObject,
				toObject: toObject,
				noop: noop,
				no: no,
				genStaticKeys: genStaticKeys,
				looseEqual: looseEqual,
				looseIndexOf: looseIndexOf,
				isReserved: isReserved,
				def: def,
				parsePath: parsePath,
				hasProto: hasProto,
				inBrowser: inBrowser,
				UA: UA,
				isIE: isIE,
				isIE9: isIE9,
				isEdge: isEdge,
				isAndroid: isAndroid,
				isIOS: isIOS,
				devtools: devtools,
				nextTick: nextTick,
				get _Set () { return _Set; },
				mergeOptions: mergeOptions,
				resolveAsset: resolveAsset,
				get warn () { return warn; },
				get formatComponentName () { return formatComponentName; },
				validateProp: validateProp
			});

			/*  */

			function initUse (Vue) {
			  Vue.use = function (plugin) {
			    /* istanbul ignore if */
			    if (plugin.installed) {
			      return
			    }
			    // additional parameters
			    var args = toArray(arguments, 1);
			    args.unshift(this);
			    if (typeof plugin.install === 'function') {
			      plugin.install.apply(plugin, args);
			    } else {
			      plugin.apply(null, args);
			    }
			    plugin.installed = true;
			    return this
			  };
			}

			/*  */

			function initMixin$1 (Vue) {
			  Vue.mixin = function (mixin) {
			    Vue.options = mergeOptions(Vue.options, mixin);
			  };
			}

			/*  */

			function initExtend (Vue) {
			  /**
			   * Each instance constructor, including Vue, has a unique
			   * cid. This enables us to create wrapped "child
			   * constructors" for prototypal inheritance and cache them.
			   */
			  Vue.cid = 0;
			  var cid = 1;

			  /**
			   * Class inheritance
			   */
			  Vue.extend = function (extendOptions) {
			    extendOptions = extendOptions || {};
			    var Super = this;
			    var isFirstExtend = Super.cid === 0;
			    if (isFirstExtend && extendOptions._Ctor) {
			      return extendOptions._Ctor
			    }
			    var name = extendOptions.name || Super.options.name;
			    {
			      if (!/^[a-zA-Z][\w-]*$/.test(name)) {
			        warn(
			          'Invalid component name: "' + name + '". Component names ' +
			          'can only contain alphanumeric characaters and the hyphen.'
			        );
			      }
			    }
			    var Sub = function VueComponent (options) {
			      this._init(options);
			    };
			    Sub.prototype = Object.create(Super.prototype);
			    Sub.prototype.constructor = Sub;
			    Sub.cid = cid++;
			    Sub.options = mergeOptions(
			      Super.options,
			      extendOptions
			    );
			    Sub['super'] = Super;
			    // allow further extension
			    Sub.extend = Super.extend;
			    // create asset registers, so extended classes
			    // can have their private assets too.
			    config._assetTypes.forEach(function (type) {
			      Sub[type] = Super[type];
			    });
			    // enable recursive self-lookup
			    if (name) {
			      Sub.options.components[name] = Sub;
			    }
			    // keep a reference to the super options at extension time.
			    // later at instantiation we can check if Super's options have
			    // been updated.
			    Sub.superOptions = Super.options;
			    Sub.extendOptions = extendOptions;
			    // cache constructor
			    if (isFirstExtend) {
			      extendOptions._Ctor = Sub;
			    }
			    return Sub
			  };
			}

			/*  */

			function initAssetRegisters (Vue) {
			  /**
			   * Create asset registration methods.
			   */
			  config._assetTypes.forEach(function (type) {
			    Vue[type] = function (
			      id,
			      definition
			    ) {
			      if (!definition) {
			        return this.options[type + 's'][id]
			      } else {
			        /* istanbul ignore if */
			        {
			          if (type === 'component' && config.isReservedTag(id)) {
			            warn(
			              'Do not use built-in or reserved HTML elements as component ' +
			              'id: ' + id
			            );
			          }
			        }
			        if (type === 'component' && isPlainObject(definition)) {
			          definition.name = definition.name || id;
			          definition = Vue.extend(definition);
			        }
			        if (type === 'directive' && typeof definition === 'function') {
			          definition = { bind: definition, update: definition };
			        }
			        this.options[type + 's'][id] = definition;
			        return definition
			      }
			    };
			  });
			}

			var KeepAlive = {
			  name: 'keep-alive',
			  abstract: true,
			  created: function created () {
			    this.cache = Object.create(null);
			  },
			  render: function render () {
			    var vnode = getFirstComponentChild(this.$slots.default);
			    if (vnode && vnode.componentOptions) {
			      var opts = vnode.componentOptions;
			      var key = vnode.key == null
			        // same constructor may get registered as different local components
			        // so cid alone is not enough (#3269)
			        ? opts.Ctor.cid + '::' + opts.tag
			        : vnode.key;
			      if (this.cache[key]) {
			        vnode.child = this.cache[key].child;
			      } else {
			        this.cache[key] = vnode;
			      }
			      vnode.data.keepAlive = true;
			    }
			    return vnode
			  },
			  destroyed: function destroyed () {
			    var this$1 = this;

			    for (var key in this.cache) {
			      var vnode = this$1.cache[key];
			      callHook(vnode.child, 'deactivated');
			      vnode.child.$destroy();
			    }
			  }
			};

			var builtInComponents = {
			  KeepAlive: KeepAlive
			};

			/*  */

			function initGlobalAPI (Vue) {
			  // config
			  var configDef = {};
			  configDef.get = function () { return config; };
			  {
			    configDef.set = function () {
			      warn(
			        'Do not replace the Vue.config object, set individual fields instead.'
			      );
			    };
			  }
			  Object.defineProperty(Vue, 'config', configDef);
			  Vue.util = util;
			  Vue.set = set;
			  Vue.delete = del;
			  Vue.nextTick = nextTick;

			  Vue.options = Object.create(null);
			  config._assetTypes.forEach(function (type) {
			    Vue.options[type + 's'] = Object.create(null);
			  });

			  extend(Vue.options.components, builtInComponents);

			  initUse(Vue);
			  initMixin$1(Vue);
			  initExtend(Vue);
			  initAssetRegisters(Vue);
			}

			initGlobalAPI(Vue$2);

			Object.defineProperty(Vue$2.prototype, '$isServer', {
			  get: function () { return config._isServer; }
			});

			Vue$2.version = '2.0.5';

			/*  */

			// attributes that should be using props for binding
			var mustUseProp = makeMap('value,selected,checked,muted');

			var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');

			var isBooleanAttr = makeMap(
			  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +
			  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +
			  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +
			  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +
			  'required,reversed,scoped,seamless,selected,sortable,translate,' +
			  'truespeed,typemustmatch,visible'
			);

			var isAttr = makeMap(
			  'accept,accept-charset,accesskey,action,align,alt,async,autocomplete,' +
			  'autofocus,autoplay,autosave,bgcolor,border,buffered,challenge,charset,' +
			  'checked,cite,class,code,codebase,color,cols,colspan,content,http-equiv,' +
			  'name,contenteditable,contextmenu,controls,coords,data,datetime,default,' +
			  'defer,dir,dirname,disabled,download,draggable,dropzone,enctype,method,for,' +
			  'form,formaction,headers,<th>,height,hidden,high,href,hreflang,http-equiv,' +
			  'icon,id,ismap,itemprop,keytype,kind,label,lang,language,list,loop,low,' +
			  'manifest,max,maxlength,media,method,GET,POST,min,multiple,email,file,' +
			  'muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,' +
			  'preload,radiogroup,readonly,rel,required,reversed,rows,rowspan,sandbox,' +
			  'scope,scoped,seamless,selected,shape,size,type,text,password,sizes,span,' +
			  'spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,' +
			  'target,title,type,usemap,value,width,wrap'
			);



			var xlinkNS = 'http://www.w3.org/1999/xlink';

			var isXlink = function (name) {
			  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'
			};

			var getXlinkProp = function (name) {
			  return isXlink(name) ? name.slice(6, name.length) : ''
			};

			var isFalsyAttrValue = function (val) {
			  return val == null || val === false
			};

			/*  */

			function genClassForVnode (vnode) {
			  var data = vnode.data;
			  var parentNode = vnode;
			  var childNode = vnode;
			  while (childNode.child) {
			    childNode = childNode.child._vnode;
			    if (childNode.data) {
			      data = mergeClassData(childNode.data, data);
			    }
			  }
			  while ((parentNode = parentNode.parent)) {
			    if (parentNode.data) {
			      data = mergeClassData(data, parentNode.data);
			    }
			  }
			  return genClassFromData(data)
			}

			function mergeClassData (child, parent) {
			  return {
			    staticClass: concat(child.staticClass, parent.staticClass),
			    class: child.class
			      ? [child.class, parent.class]
			      : parent.class
			  }
			}

			function genClassFromData (data) {
			  var dynamicClass = data.class;
			  var staticClass = data.staticClass;
			  if (staticClass || dynamicClass) {
			    return concat(staticClass, stringifyClass(dynamicClass))
			  }
			  /* istanbul ignore next */
			  return ''
			}

			function concat (a, b) {
			  return a ? b ? (a + ' ' + b) : a : (b || '')
			}

			function stringifyClass (value) {
			  var res = '';
			  if (!value) {
			    return res
			  }
			  if (typeof value === 'string') {
			    return value
			  }
			  if (Array.isArray(value)) {
			    var stringified;
			    for (var i = 0, l = value.length; i < l; i++) {
			      if (value[i]) {
			        if ((stringified = stringifyClass(value[i]))) {
			          res += stringified + ' ';
			        }
			      }
			    }
			    return res.slice(0, -1)
			  }
			  if (isObject(value)) {
			    for (var key in value) {
			      if (value[key]) { res += key + ' '; }
			    }
			    return res.slice(0, -1)
			  }
			  /* istanbul ignore next */
			  return res
			}

			/*  */

			var namespaceMap = {
			  svg: 'http://www.w3.org/2000/svg',
			  math: 'http://www.w3.org/1998/Math/MathML',
			  xhtml: 'http://www.w3.org/1999/xhtm'
			};

			var isHTMLTag = makeMap(
			  'html,body,base,head,link,meta,style,title,' +
			  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +
			  'div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,' +
			  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +
			  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +
			  'embed,object,param,source,canvas,script,noscript,del,ins,' +
			  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +
			  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +
			  'output,progress,select,textarea,' +
			  'details,dialog,menu,menuitem,summary,' +
			  'content,element,shadow,template'
			);

			var isUnaryTag = makeMap(
			  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +
			  'link,meta,param,source,track,wbr',
			  true
			);

			// Elements that you can, intentionally, leave open
			// (and which close themselves)
			var canBeLeftOpenTag = makeMap(
			  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source',
			  true
			);

			// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
			// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content
			var isNonPhrasingTag = makeMap(
			  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +
			  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +
			  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +
			  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +
			  'title,tr,track',
			  true
			);

			// this map is intentionally selective, only covering SVG elements that may
			// contain child elements.
			var isSVG = makeMap(
			  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font,' +
			  'font-face,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +
			  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',
			  true
			);

			var isPreTag = function (tag) { return tag === 'pre'; };

			var isReservedTag = function (tag) {
			  return isHTMLTag(tag) || isSVG(tag)
			};

			function getTagNamespace (tag) {
			  if (isSVG(tag)) {
			    return 'svg'
			  }
			  // basic support for MathML
			  // note it doesn't support other MathML elements being component roots
			  if (tag === 'math') {
			    return 'math'
			  }
			}

			var unknownElementCache = Object.create(null);
			function isUnknownElement (tag) {
			  /* istanbul ignore if */
			  if (!inBrowser) {
			    return true
			  }
			  if (isReservedTag(tag)) {
			    return false
			  }
			  tag = tag.toLowerCase();
			  /* istanbul ignore if */
			  if (unknownElementCache[tag] != null) {
			    return unknownElementCache[tag]
			  }
			  var el = document.createElement(tag);
			  if (tag.indexOf('-') > -1) {
			    // http://stackoverflow.com/a/28210364/1070244
			    return (unknownElementCache[tag] = (
			      el.constructor === window.HTMLUnknownElement ||
			      el.constructor === window.HTMLElement
			    ))
			  } else {
			    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))
			  }
			}

			/*  */

			/**
			 * Query an element selector if it's not an element already.
			 */
			function query (el) {
			  if (typeof el === 'string') {
			    var selector = el;
			    el = document.querySelector(el);
			    if (!el) {
			      "development" !== 'production' && warn(
			        'Cannot find element: ' + selector
			      );
			      return document.createElement('div')
			    }
			  }
			  return el
			}

			/*  */

			function createElement$1 (tagName, vnode) {
			  var elm = document.createElement(tagName);
			  if (tagName !== 'select') {
			    return elm
			  }
			  if (vnode.data && vnode.data.attrs && 'multiple' in vnode.data.attrs) {
			    elm.setAttribute('multiple', 'multiple');
			  }
			  return elm
			}

			function createElementNS (namespace, tagName) {
			  return document.createElementNS(namespaceMap[namespace], tagName)
			}

			function createTextNode (text) {
			  return document.createTextNode(text)
			}

			function createComment (text) {
			  return document.createComment(text)
			}

			function insertBefore (parentNode, newNode, referenceNode) {
			  parentNode.insertBefore(newNode, referenceNode);
			}

			function removeChild (node, child) {
			  node.removeChild(child);
			}

			function appendChild (node, child) {
			  node.appendChild(child);
			}

			function parentNode (node) {
			  return node.parentNode
			}

			function nextSibling (node) {
			  return node.nextSibling
			}

			function tagName (node) {
			  return node.tagName
			}

			function setTextContent (node, text) {
			  node.textContent = text;
			}

			function childNodes (node) {
			  return node.childNodes
			}

			function setAttribute (node, key, val) {
			  node.setAttribute(key, val);
			}


			var nodeOps = Object.freeze({
				createElement: createElement$1,
				createElementNS: createElementNS,
				createTextNode: createTextNode,
				createComment: createComment,
				insertBefore: insertBefore,
				removeChild: removeChild,
				appendChild: appendChild,
				parentNode: parentNode,
				nextSibling: nextSibling,
				tagName: tagName,
				setTextContent: setTextContent,
				childNodes: childNodes,
				setAttribute: setAttribute
			});

			/*  */

			var ref = {
			  create: function create (_, vnode) {
			    registerRef(vnode);
			  },
			  update: function update (oldVnode, vnode) {
			    if (oldVnode.data.ref !== vnode.data.ref) {
			      registerRef(oldVnode, true);
			      registerRef(vnode);
			    }
			  },
			  destroy: function destroy (vnode) {
			    registerRef(vnode, true);
			  }
			};

			function registerRef (vnode, isRemoval) {
			  var key = vnode.data.ref;
			  if (!key) { return }

			  var vm = vnode.context;
			  var ref = vnode.child || vnode.elm;
			  var refs = vm.$refs;
			  if (isRemoval) {
			    if (Array.isArray(refs[key])) {
			      remove$1(refs[key], ref);
			    } else if (refs[key] === ref) {
			      refs[key] = undefined;
			    }
			  } else {
			    if (vnode.data.refInFor) {
			      if (Array.isArray(refs[key])) {
			        refs[key].push(ref);
			      } else {
			        refs[key] = [ref];
			      }
			    } else {
			      refs[key] = ref;
			    }
			  }
			}

			/**
			 * Virtual DOM patching algorithm based on Snabbdom by
			 * Simon Friis Vindum (@paldepind)
			 * Licensed under the MIT License
			 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
			 *
			 * modified by Evan You (@yyx990803)
			 *

			/*
			 * Not type-checking this because this file is perf-critical and the cost
			 * of making flow understand it is not worth it.
			 */

			var emptyNode = new VNode('', {}, []);

			var hooks$1 = ['create', 'update', 'remove', 'destroy'];

			function isUndef (s) {
			  return s == null
			}

			function isDef (s) {
			  return s != null
			}

			function sameVnode (vnode1, vnode2) {
			  return (
			    vnode1.key === vnode2.key &&
			    vnode1.tag === vnode2.tag &&
			    vnode1.isComment === vnode2.isComment &&
			    !vnode1.data === !vnode2.data
			  )
			}

			function createKeyToOldIdx (children, beginIdx, endIdx) {
			  var i, key;
			  var map = {};
			  for (i = beginIdx; i <= endIdx; ++i) {
			    key = children[i].key;
			    if (isDef(key)) { map[key] = i; }
			  }
			  return map
			}

			function createPatchFunction (backend) {
			  var i, j;
			  var cbs = {};

			  var modules = backend.modules;
			  var nodeOps = backend.nodeOps;

			  for (i = 0; i < hooks$1.length; ++i) {
			    cbs[hooks$1[i]] = [];
			    for (j = 0; j < modules.length; ++j) {
			      if (modules[j][hooks$1[i]] !== undefined) { cbs[hooks$1[i]].push(modules[j][hooks$1[i]]); }
			    }
			  }

			  function emptyNodeAt (elm) {
			    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)
			  }

			  function createRmCb (childElm, listeners) {
			    function remove$$1 () {
			      if (--remove$$1.listeners === 0) {
			        removeElement(childElm);
			      }
			    }
			    remove$$1.listeners = listeners;
			    return remove$$1
			  }

			  function removeElement (el) {
			    var parent = nodeOps.parentNode(el);
			    // element may have already been removed due to v-html
			    if (parent) {
			      nodeOps.removeChild(parent, el);
			    }
			  }

			  function createElm (vnode, insertedVnodeQueue, nested) {
			    var i;
			    var data = vnode.data;
			    vnode.isRootInsert = !nested;
			    if (isDef(data)) {
			      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode); }
			      // after calling the init hook, if the vnode is a child component
			      // it should've created a child instance and mounted it. the child
			      // component also has set the placeholder vnode's elm.
			      // in that case we can just return the element and be done.
			      if (isDef(i = vnode.child)) {
			        initComponent(vnode, insertedVnodeQueue);
			        return vnode.elm
			      }
			    }
			    var children = vnode.children;
			    var tag = vnode.tag;
			    if (isDef(tag)) {
			      {
			        if (
			          !vnode.ns &&
			          !(config.ignoredElements && config.ignoredElements.indexOf(tag) > -1) &&
			          config.isUnknownElement(tag)
			        ) {
			          warn(
			            'Unknown custom element: <' + tag + '> - did you ' +
			            'register the component correctly? For recursive components, ' +
			            'make sure to provide the "name" option.',
			            vnode.context
			          );
			        }
			      }
			      vnode.elm = vnode.ns
			        ? nodeOps.createElementNS(vnode.ns, tag)
			        : nodeOps.createElement(tag, vnode);
			      setScope(vnode);
			      createChildren(vnode, children, insertedVnodeQueue);
			      if (isDef(data)) {
			        invokeCreateHooks(vnode, insertedVnodeQueue);
			      }
			    } else if (vnode.isComment) {
			      vnode.elm = nodeOps.createComment(vnode.text);
			    } else {
			      vnode.elm = nodeOps.createTextNode(vnode.text);
			    }
			    return vnode.elm
			  }

			  function createChildren (vnode, children, insertedVnodeQueue) {
			    if (Array.isArray(children)) {
			      for (var i = 0; i < children.length; ++i) {
			        nodeOps.appendChild(vnode.elm, createElm(children[i], insertedVnodeQueue, true));
			      }
			    } else if (isPrimitive(vnode.text)) {
			      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));
			    }
			  }

			  function isPatchable (vnode) {
			    while (vnode.child) {
			      vnode = vnode.child._vnode;
			    }
			    return isDef(vnode.tag)
			  }

			  function invokeCreateHooks (vnode, insertedVnodeQueue) {
			    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
			      cbs.create[i$1](emptyNode, vnode);
			    }
			    i = vnode.data.hook; // Reuse variable
			    if (isDef(i)) {
			      if (i.create) { i.create(emptyNode, vnode); }
			      if (i.insert) { insertedVnodeQueue.push(vnode); }
			    }
			  }

			  function initComponent (vnode, insertedVnodeQueue) {
			    if (vnode.data.pendingInsert) {
			      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
			    }
			    vnode.elm = vnode.child.$el;
			    if (isPatchable(vnode)) {
			      invokeCreateHooks(vnode, insertedVnodeQueue);
			      setScope(vnode);
			    } else {
			      // empty component root.
			      // skip all element-related modules except for ref (#3455)
			      registerRef(vnode);
			      // make sure to invoke the insert hook
			      insertedVnodeQueue.push(vnode);
			    }
			  }

			  // set scope id attribute for scoped CSS.
			  // this is implemented as a special case to avoid the overhead
			  // of going through the normal attribute patching process.
			  function setScope (vnode) {
			    var i;
			    if (isDef(i = vnode.context) && isDef(i = i.$options._scopeId)) {
			      nodeOps.setAttribute(vnode.elm, i, '');
			    }
			    if (isDef(i = activeInstance) &&
			        i !== vnode.context &&
			        isDef(i = i.$options._scopeId)) {
			      nodeOps.setAttribute(vnode.elm, i, '');
			    }
			  }

			  function addVnodes (parentElm, before, vnodes, startIdx, endIdx, insertedVnodeQueue) {
			    for (; startIdx <= endIdx; ++startIdx) {
			      nodeOps.insertBefore(parentElm, createElm(vnodes[startIdx], insertedVnodeQueue), before);
			    }
			  }

			  function invokeDestroyHook (vnode) {
			    var i, j;
			    var data = vnode.data;
			    if (isDef(data)) {
			      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }
			      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }
			    }
			    if (isDef(i = vnode.children)) {
			      for (j = 0; j < vnode.children.length; ++j) {
			        invokeDestroyHook(vnode.children[j]);
			      }
			    }
			  }

			  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {
			    for (; startIdx <= endIdx; ++startIdx) {
			      var ch = vnodes[startIdx];
			      if (isDef(ch)) {
			        if (isDef(ch.tag)) {
			          removeAndInvokeRemoveHook(ch);
			          invokeDestroyHook(ch);
			        } else { // Text node
			          nodeOps.removeChild(parentElm, ch.elm);
			        }
			      }
			    }
			  }

			  function removeAndInvokeRemoveHook (vnode, rm) {
			    if (rm || isDef(vnode.data)) {
			      var listeners = cbs.remove.length + 1;
			      if (!rm) {
			        // directly removing
			        rm = createRmCb(vnode.elm, listeners);
			      } else {
			        // we have a recursively passed down rm callback
			        // increase the listeners count
			        rm.listeners += listeners;
			      }
			      // recursively invoke hooks on child component root node
			      if (isDef(i = vnode.child) && isDef(i = i._vnode) && isDef(i.data)) {
			        removeAndInvokeRemoveHook(i, rm);
			      }
			      for (i = 0; i < cbs.remove.length; ++i) {
			        cbs.remove[i](vnode, rm);
			      }
			      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
			        i(vnode, rm);
			      } else {
			        rm();
			      }
			    } else {
			      removeElement(vnode.elm);
			    }
			  }

			  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
			    var oldStartIdx = 0;
			    var newStartIdx = 0;
			    var oldEndIdx = oldCh.length - 1;
			    var oldStartVnode = oldCh[0];
			    var oldEndVnode = oldCh[oldEndIdx];
			    var newEndIdx = newCh.length - 1;
			    var newStartVnode = newCh[0];
			    var newEndVnode = newCh[newEndIdx];
			    var oldKeyToIdx, idxInOld, elmToMove, before;

			    // removeOnly is a special flag used only by <transition-group>
			    // to ensure removed elements stay in correct relative positions
			    // during leaving transitions
			    var canMove = !removeOnly;

			    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
			      if (isUndef(oldStartVnode)) {
			        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
			      } else if (isUndef(oldEndVnode)) {
			        oldEndVnode = oldCh[--oldEndIdx];
			      } else if (sameVnode(oldStartVnode, newStartVnode)) {
			        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
			        oldStartVnode = oldCh[++oldStartIdx];
			        newStartVnode = newCh[++newStartIdx];
			      } else if (sameVnode(oldEndVnode, newEndVnode)) {
			        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
			        oldEndVnode = oldCh[--oldEndIdx];
			        newEndVnode = newCh[--newEndIdx];
			      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
			        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
			        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
			        oldStartVnode = oldCh[++oldStartIdx];
			        newEndVnode = newCh[--newEndIdx];
			      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
			        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
			        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
			        oldEndVnode = oldCh[--oldEndIdx];
			        newStartVnode = newCh[++newStartIdx];
			      } else {
			        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }
			        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;
			        if (isUndef(idxInOld)) { // New element
			          nodeOps.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
			          newStartVnode = newCh[++newStartIdx];
			        } else {
			          elmToMove = oldCh[idxInOld];
			          /* istanbul ignore if */
			          if ("development" !== 'production' && !elmToMove) {
			            warn(
			              'It seems there are duplicate keys that is causing an update error. ' +
			              'Make sure each v-for item has a unique key.'
			            );
			          }
			          if (elmToMove.tag !== newStartVnode.tag) {
			            // same key but different element. treat as new element
			            nodeOps.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
			            newStartVnode = newCh[++newStartIdx];
			          } else {
			            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
			            oldCh[idxInOld] = undefined;
			            canMove && nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);
			            newStartVnode = newCh[++newStartIdx];
			          }
			        }
			      }
			    }
			    if (oldStartIdx > oldEndIdx) {
			      before = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
			      addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
			    } else if (newStartIdx > newEndIdx) {
			      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
			    }
			  }

			  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {
			    if (oldVnode === vnode) {
			      return
			    }
			    // reuse element for static trees.
			    // note we only do this if the vnode is cloned -
			    // if the new node is not cloned it means the render functions have been
			    // reset by the hot-reload-api and we need to do a proper re-render.
			    if (vnode.isStatic &&
			        oldVnode.isStatic &&
			        vnode.key === oldVnode.key &&
			        (vnode.isCloned || vnode.isOnce)) {
			      vnode.elm = oldVnode.elm;
			      return
			    }
			    var i;
			    var data = vnode.data;
			    var hasData = isDef(data);
			    if (hasData && isDef(i = data.hook) && isDef(i = i.prepatch)) {
			      i(oldVnode, vnode);
			    }
			    var elm = vnode.elm = oldVnode.elm;
			    var oldCh = oldVnode.children;
			    var ch = vnode.children;
			    if (hasData && isPatchable(vnode)) {
			      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }
			      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }
			    }
			    if (isUndef(vnode.text)) {
			      if (isDef(oldCh) && isDef(ch)) {
			        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }
			      } else if (isDef(ch)) {
			        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }
			        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
			      } else if (isDef(oldCh)) {
			        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
			      } else if (isDef(oldVnode.text)) {
			        nodeOps.setTextContent(elm, '');
			      }
			    } else if (oldVnode.text !== vnode.text) {
			      nodeOps.setTextContent(elm, vnode.text);
			    }
			    if (hasData) {
			      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }
			    }
			  }

			  function invokeInsertHook (vnode, queue, initial) {
			    // delay insert hooks for component root nodes, invoke them after the
			    // element is really inserted
			    if (initial && vnode.parent) {
			      vnode.parent.data.pendingInsert = queue;
			    } else {
			      for (var i = 0; i < queue.length; ++i) {
			        queue[i].data.hook.insert(queue[i]);
			      }
			    }
			  }

			  var bailed = false;
			  function hydrate (elm, vnode, insertedVnodeQueue) {
			    {
			      if (!assertNodeMatch(elm, vnode)) {
			        return false
			      }
			    }
			    vnode.elm = elm;
			    var tag = vnode.tag;
			    var data = vnode.data;
			    var children = vnode.children;
			    if (isDef(data)) {
			      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }
			      if (isDef(i = vnode.child)) {
			        // child component. it should have hydrated its own tree.
			        initComponent(vnode, insertedVnodeQueue);
			        return true
			      }
			    }
			    if (isDef(tag)) {
			      if (isDef(children)) {
			        var childNodes = nodeOps.childNodes(elm);
			        // empty element, allow client to pick up and populate children
			        if (!childNodes.length) {
			          createChildren(vnode, children, insertedVnodeQueue);
			        } else {
			          var childrenMatch = true;
			          if (childNodes.length !== children.length) {
			            childrenMatch = false;
			          } else {
			            for (var i$1 = 0; i$1 < children.length; i$1++) {
			              if (!hydrate(childNodes[i$1], children[i$1], insertedVnodeQueue)) {
			                childrenMatch = false;
			                break
			              }
			            }
			          }
			          if (!childrenMatch) {
			            if ("development" !== 'production' &&
			                typeof console !== 'undefined' &&
			                !bailed) {
			              bailed = true;
			              console.warn('Parent: ', elm);
			              console.warn('Mismatching childNodes vs. VNodes: ', childNodes, children);
			            }
			            return false
			          }
			        }
			      }
			      if (isDef(data)) {
			        invokeCreateHooks(vnode, insertedVnodeQueue);
			      }
			    }
			    return true
			  }

			  function assertNodeMatch (node, vnode) {
			    if (vnode.tag) {
			      return (
			        vnode.tag.indexOf('vue-component') === 0 ||
			        vnode.tag === nodeOps.tagName(node).toLowerCase()
			      )
			    } else {
			      return _toString(vnode.text) === node.data
			    }
			  }

			  return function patch (oldVnode, vnode, hydrating, removeOnly) {
			    if (!vnode) {
			      if (oldVnode) { invokeDestroyHook(oldVnode); }
			      return
			    }

			    var elm, parent;
			    var isInitialPatch = false;
			    var insertedVnodeQueue = [];

			    if (!oldVnode) {
			      // empty mount, create new root element
			      isInitialPatch = true;
			      createElm(vnode, insertedVnodeQueue);
			    } else {
			      var isRealElement = isDef(oldVnode.nodeType);
			      if (!isRealElement && sameVnode(oldVnode, vnode)) {
			        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);
			      } else {
			        if (isRealElement) {
			          // mounting to a real element
			          // check if this is server-rendered content and if we can perform
			          // a successful hydration.
			          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute('server-rendered')) {
			            oldVnode.removeAttribute('server-rendered');
			            hydrating = true;
			          }
			          if (hydrating) {
			            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
			              invokeInsertHook(vnode, insertedVnodeQueue, true);
			              return oldVnode
			            } else {
			              warn(
			                'The client-side rendered virtual DOM tree is not matching ' +
			                'server-rendered content. This is likely caused by incorrect ' +
			                'HTML markup, for example nesting block-level elements inside ' +
			                '<p>, or missing <tbody>. Bailing hydration and performing ' +
			                'full client-side render.'
			              );
			            }
			          }
			          // either not server-rendered, or hydration failed.
			          // create an empty node and replace it
			          oldVnode = emptyNodeAt(oldVnode);
			        }
			        elm = oldVnode.elm;
			        parent = nodeOps.parentNode(elm);

			        createElm(vnode, insertedVnodeQueue);

			        // component root element replaced.
			        // update parent placeholder node element.
			        if (vnode.parent) {
			          vnode.parent.elm = vnode.elm;
			          if (isPatchable(vnode)) {
			            for (var i = 0; i < cbs.create.length; ++i) {
			              cbs.create[i](emptyNode, vnode.parent);
			            }
			          }
			        }

			        if (parent !== null) {
			          nodeOps.insertBefore(parent, vnode.elm, nodeOps.nextSibling(elm));
			          removeVnodes(parent, [oldVnode], 0, 0);
			        } else if (isDef(oldVnode.tag)) {
			          invokeDestroyHook(oldVnode);
			        }
			      }
			    }

			    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
			    return vnode.elm
			  }
			}

			/*  */

			var directives = {
			  create: updateDirectives,
			  update: updateDirectives,
			  destroy: function unbindDirectives (vnode) {
			    updateDirectives(vnode, emptyNode);
			  }
			};

			function updateDirectives (
			  oldVnode,
			  vnode
			) {
			  if (!oldVnode.data.directives && !vnode.data.directives) {
			    return
			  }
			  var isCreate = oldVnode === emptyNode;
			  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
			  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);

			  var dirsWithInsert = [];
			  var dirsWithPostpatch = [];

			  var key, oldDir, dir;
			  for (key in newDirs) {
			    oldDir = oldDirs[key];
			    dir = newDirs[key];
			    if (!oldDir) {
			      // new directive, bind
			      callHook$1(dir, 'bind', vnode, oldVnode);
			      if (dir.def && dir.def.inserted) {
			        dirsWithInsert.push(dir);
			      }
			    } else {
			      // existing directive, update
			      dir.oldValue = oldDir.value;
			      callHook$1(dir, 'update', vnode, oldVnode);
			      if (dir.def && dir.def.componentUpdated) {
			        dirsWithPostpatch.push(dir);
			      }
			    }
			  }

			  if (dirsWithInsert.length) {
			    var callInsert = function () {
			      dirsWithInsert.forEach(function (dir) {
			        callHook$1(dir, 'inserted', vnode, oldVnode);
			      });
			    };
			    if (isCreate) {
			      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert, 'dir-insert');
			    } else {
			      callInsert();
			    }
			  }

			  if (dirsWithPostpatch.length) {
			    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {
			      dirsWithPostpatch.forEach(function (dir) {
			        callHook$1(dir, 'componentUpdated', vnode, oldVnode);
			      });
			    }, 'dir-postpatch');
			  }

			  if (!isCreate) {
			    for (key in oldDirs) {
			      if (!newDirs[key]) {
			        // no longer present, unbind
			        callHook$1(oldDirs[key], 'unbind', oldVnode);
			      }
			    }
			  }
			}

			var emptyModifiers = Object.create(null);

			function normalizeDirectives$1 (
			  dirs,
			  vm
			) {
			  var res = Object.create(null);
			  if (!dirs) {
			    return res
			  }
			  var i, dir;
			  for (i = 0; i < dirs.length; i++) {
			    dir = dirs[i];
			    if (!dir.modifiers) {
			      dir.modifiers = emptyModifiers;
			    }
			    res[getRawDirName(dir)] = dir;
			    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
			  }
			  return res
			}

			function getRawDirName (dir) {
			  return dir.rawName || ((dir.name) + "." + (Object.keys(dir.modifiers || {}).join('.')))
			}

			function callHook$1 (dir, hook, vnode, oldVnode) {
			  var fn = dir.def && dir.def[hook];
			  if (fn) {
			    fn(vnode.elm, dir, vnode, oldVnode);
			  }
			}

			var baseModules = [
			  ref,
			  directives
			];

			/*  */

			function updateAttrs (oldVnode, vnode) {
			  if (!oldVnode.data.attrs && !vnode.data.attrs) {
			    return
			  }
			  var key, cur, old;
			  var elm = vnode.elm;
			  var oldAttrs = oldVnode.data.attrs || {};
			  var attrs = vnode.data.attrs || {};
			  // clone observed objects, as the user probably wants to mutate it
			  if (attrs.__ob__) {
			    attrs = vnode.data.attrs = extend({}, attrs);
			  }

			  for (key in attrs) {
			    cur = attrs[key];
			    old = oldAttrs[key];
			    if (old !== cur) {
			      setAttr(elm, key, cur);
			    }
			  }
			  for (key in oldAttrs) {
			    if (attrs[key] == null) {
			      if (isXlink(key)) {
			        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
			      } else if (!isEnumeratedAttr(key)) {
			        elm.removeAttribute(key);
			      }
			    }
			  }
			}

			function setAttr (el, key, value) {
			  if (isBooleanAttr(key)) {
			    // set attribute for blank value
			    // e.g. <option disabled>Select one</option>
			    if (isFalsyAttrValue(value)) {
			      el.removeAttribute(key);
			    } else {
			      el.setAttribute(key, key);
			    }
			  } else if (isEnumeratedAttr(key)) {
			    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');
			  } else if (isXlink(key)) {
			    if (isFalsyAttrValue(value)) {
			      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
			    } else {
			      el.setAttributeNS(xlinkNS, key, value);
			    }
			  } else {
			    if (isFalsyAttrValue(value)) {
			      el.removeAttribute(key);
			    } else {
			      el.setAttribute(key, value);
			    }
			  }
			}

			var attrs = {
			  create: updateAttrs,
			  update: updateAttrs
			};

			/*  */

			function updateClass (oldVnode, vnode) {
			  var el = vnode.elm;
			  var data = vnode.data;
			  var oldData = oldVnode.data;
			  if (!data.staticClass && !data.class &&
			      (!oldData || (!oldData.staticClass && !oldData.class))) {
			    return
			  }

			  var cls = genClassForVnode(vnode);

			  // handle transition classes
			  var transitionClass = el._transitionClasses;
			  if (transitionClass) {
			    cls = concat(cls, stringifyClass(transitionClass));
			  }

			  // set the class
			  if (cls !== el._prevClass) {
			    el.setAttribute('class', cls);
			    el._prevClass = cls;
			  }
			}

			var klass = {
			  create: updateClass,
			  update: updateClass
			};

			// skip type checking this file because we need to attach private properties
			// to elements

			function updateDOMListeners (oldVnode, vnode) {
			  if (!oldVnode.data.on && !vnode.data.on) {
			    return
			  }
			  var on = vnode.data.on || {};
			  var oldOn = oldVnode.data.on || {};
			  var add = vnode.elm._v_add || (vnode.elm._v_add = function (event, handler, capture) {
			    vnode.elm.addEventListener(event, handler, capture);
			  });
			  var remove = vnode.elm._v_remove || (vnode.elm._v_remove = function (event, handler) {
			    vnode.elm.removeEventListener(event, handler);
			  });
			  updateListeners(on, oldOn, add, remove, vnode.context);
			}

			var events = {
			  create: updateDOMListeners,
			  update: updateDOMListeners
			};

			/*  */

			function updateDOMProps (oldVnode, vnode) {
			  if (!oldVnode.data.domProps && !vnode.data.domProps) {
			    return
			  }
			  var key, cur;
			  var elm = vnode.elm;
			  var oldProps = oldVnode.data.domProps || {};
			  var props = vnode.data.domProps || {};
			  // clone observed objects, as the user probably wants to mutate it
			  if (props.__ob__) {
			    props = vnode.data.domProps = extend({}, props);
			  }

			  for (key in oldProps) {
			    if (props[key] == null) {
			      elm[key] = '';
			    }
			  }
			  for (key in props) {
			    // ignore children if the node has textContent or innerHTML,
			    // as these will throw away existing DOM nodes and cause removal errors
			    // on subsequent patches (#3360)
			    if ((key === 'textContent' || key === 'innerHTML') && vnode.children) {
			      vnode.children.length = 0;
			    }
			    cur = props[key];
			    if (key === 'value') {
			      // store value as _value as well since
			      // non-string values will be stringified
			      elm._value = cur;
			      // avoid resetting cursor position when value is the same
			      var strCur = cur == null ? '' : String(cur);
			      if (elm.value !== strCur && !elm.composing) {
			        elm.value = strCur;
			      }
			    } else {
			      elm[key] = cur;
			    }
			  }
			}

			var domProps = {
			  create: updateDOMProps,
			  update: updateDOMProps
			};

			/*  */

			var cssVarRE = /^--/;
			var setProp = function (el, name, val) {
			  /* istanbul ignore if */
			  if (cssVarRE.test(name)) {
			    el.style.setProperty(name, val);
			  } else {
			    el.style[normalize(name)] = val;
			  }
			};

			var prefixes = ['Webkit', 'Moz', 'ms'];

			var testEl;
			var normalize = cached(function (prop) {
			  testEl = testEl || document.createElement('div');
			  prop = camelize(prop);
			  if (prop !== 'filter' && (prop in testEl.style)) {
			    return prop
			  }
			  var upper = prop.charAt(0).toUpperCase() + prop.slice(1);
			  for (var i = 0; i < prefixes.length; i++) {
			    var prefixed = prefixes[i] + upper;
			    if (prefixed in testEl.style) {
			      return prefixed
			    }
			  }
			});

			function updateStyle (oldVnode, vnode) {
			  if ((!oldVnode.data || !oldVnode.data.style) && !vnode.data.style) {
			    return
			  }
			  var cur, name;
			  var el = vnode.elm;
			  var oldStyle = oldVnode.data.style || {};
			  var style = vnode.data.style || {};

			  // handle string
			  if (typeof style === 'string') {
			    el.style.cssText = style;
			    return
			  }

			  var needClone = style.__ob__;

			  // handle array syntax
			  if (Array.isArray(style)) {
			    style = vnode.data.style = toObject(style);
			  }

			  // clone the style for future updates,
			  // in case the user mutates the style object in-place.
			  if (needClone) {
			    style = vnode.data.style = extend({}, style);
			  }

			  for (name in oldStyle) {
			    if (style[name] == null) {
			      setProp(el, name, '');
			    }
			  }
			  for (name in style) {
			    cur = style[name];
			    if (cur !== oldStyle[name]) {
			      // ie9 setting to null has no effect, must use empty string
			      setProp(el, name, cur == null ? '' : cur);
			    }
			  }
			}

			var style = {
			  create: updateStyle,
			  update: updateStyle
			};

			/*  */

			/**
			 * Add class with compatibility for SVG since classList is not supported on
			 * SVG elements in IE
			 */
			function addClass (el, cls) {
			  /* istanbul ignore if */
			  if (!cls || !cls.trim()) {
			    return
			  }

			  /* istanbul ignore else */
			  if (el.classList) {
			    if (cls.indexOf(' ') > -1) {
			      cls.split(/\s+/).forEach(function (c) { return el.classList.add(c); });
			    } else {
			      el.classList.add(cls);
			    }
			  } else {
			    var cur = ' ' + el.getAttribute('class') + ' ';
			    if (cur.indexOf(' ' + cls + ' ') < 0) {
			      el.setAttribute('class', (cur + cls).trim());
			    }
			  }
			}

			/**
			 * Remove class with compatibility for SVG since classList is not supported on
			 * SVG elements in IE
			 */
			function removeClass (el, cls) {
			  /* istanbul ignore if */
			  if (!cls || !cls.trim()) {
			    return
			  }

			  /* istanbul ignore else */
			  if (el.classList) {
			    if (cls.indexOf(' ') > -1) {
			      cls.split(/\s+/).forEach(function (c) { return el.classList.remove(c); });
			    } else {
			      el.classList.remove(cls);
			    }
			  } else {
			    var cur = ' ' + el.getAttribute('class') + ' ';
			    var tar = ' ' + cls + ' ';
			    while (cur.indexOf(tar) >= 0) {
			      cur = cur.replace(tar, ' ');
			    }
			    el.setAttribute('class', cur.trim());
			  }
			}

			/*  */

			var hasTransition = inBrowser && !isIE9;
			var TRANSITION = 'transition';
			var ANIMATION = 'animation';

			// Transition property/event sniffing
			var transitionProp = 'transition';
			var transitionEndEvent = 'transitionend';
			var animationProp = 'animation';
			var animationEndEvent = 'animationend';
			if (hasTransition) {
			  /* istanbul ignore if */
			  if (window.ontransitionend === undefined &&
			    window.onwebkittransitionend !== undefined) {
			    transitionProp = 'WebkitTransition';
			    transitionEndEvent = 'webkitTransitionEnd';
			  }
			  if (window.onanimationend === undefined &&
			    window.onwebkitanimationend !== undefined) {
			    animationProp = 'WebkitAnimation';
			    animationEndEvent = 'webkitAnimationEnd';
			  }
			}

			var raf = (inBrowser && window.requestAnimationFrame) || setTimeout;
			function nextFrame (fn) {
			  raf(function () {
			    raf(fn);
			  });
			}

			function addTransitionClass (el, cls) {
			  (el._transitionClasses || (el._transitionClasses = [])).push(cls);
			  addClass(el, cls);
			}

			function removeTransitionClass (el, cls) {
			  if (el._transitionClasses) {
			    remove$1(el._transitionClasses, cls);
			  }
			  removeClass(el, cls);
			}

			function whenTransitionEnds (
			  el,
			  expectedType,
			  cb
			) {
			  var ref = getTransitionInfo(el, expectedType);
			  var type = ref.type;
			  var timeout = ref.timeout;
			  var propCount = ref.propCount;
			  if (!type) { return cb() }
			  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
			  var ended = 0;
			  var end = function () {
			    el.removeEventListener(event, onEnd);
			    cb();
			  };
			  var onEnd = function (e) {
			    if (e.target === el) {
			      if (++ended >= propCount) {
			        end();
			      }
			    }
			  };
			  setTimeout(function () {
			    if (ended < propCount) {
			      end();
			    }
			  }, timeout + 1);
			  el.addEventListener(event, onEnd);
			}

			var transformRE = /\b(transform|all)(,|$)/;

			function getTransitionInfo (el, expectedType) {
			  var styles = window.getComputedStyle(el);
			  var transitioneDelays = styles[transitionProp + 'Delay'].split(', ');
			  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');
			  var transitionTimeout = getTimeout(transitioneDelays, transitionDurations);
			  var animationDelays = styles[animationProp + 'Delay'].split(', ');
			  var animationDurations = styles[animationProp + 'Duration'].split(', ');
			  var animationTimeout = getTimeout(animationDelays, animationDurations);

			  var type;
			  var timeout = 0;
			  var propCount = 0;
			  /* istanbul ignore if */
			  if (expectedType === TRANSITION) {
			    if (transitionTimeout > 0) {
			      type = TRANSITION;
			      timeout = transitionTimeout;
			      propCount = transitionDurations.length;
			    }
			  } else if (expectedType === ANIMATION) {
			    if (animationTimeout > 0) {
			      type = ANIMATION;
			      timeout = animationTimeout;
			      propCount = animationDurations.length;
			    }
			  } else {
			    timeout = Math.max(transitionTimeout, animationTimeout);
			    type = timeout > 0
			      ? transitionTimeout > animationTimeout
			        ? TRANSITION
			        : ANIMATION
			      : null;
			    propCount = type
			      ? type === TRANSITION
			        ? transitionDurations.length
			        : animationDurations.length
			      : 0;
			  }
			  var hasTransform =
			    type === TRANSITION &&
			    transformRE.test(styles[transitionProp + 'Property']);
			  return {
			    type: type,
			    timeout: timeout,
			    propCount: propCount,
			    hasTransform: hasTransform
			  }
			}

			function getTimeout (delays, durations) {
			  /* istanbul ignore next */
			  while (delays.length < durations.length) {
			    delays = delays.concat(delays);
			  }

			  return Math.max.apply(null, durations.map(function (d, i) {
			    return toMs(d) + toMs(delays[i])
			  }))
			}

			function toMs (s) {
			  return Number(s.slice(0, -1)) * 1000
			}

			/*  */

			function enter (vnode) {
			  var el = vnode.elm;

			  // call leave callback now
			  if (el._leaveCb) {
			    el._leaveCb.cancelled = true;
			    el._leaveCb();
			  }

			  var data = resolveTransition(vnode.data.transition);
			  if (!data) {
			    return
			  }

			  /* istanbul ignore if */
			  if (el._enterCb || el.nodeType !== 1) {
			    return
			  }

			  var css = data.css;
			  var type = data.type;
			  var enterClass = data.enterClass;
			  var enterActiveClass = data.enterActiveClass;
			  var appearClass = data.appearClass;
			  var appearActiveClass = data.appearActiveClass;
			  var beforeEnter = data.beforeEnter;
			  var enter = data.enter;
			  var afterEnter = data.afterEnter;
			  var enterCancelled = data.enterCancelled;
			  var beforeAppear = data.beforeAppear;
			  var appear = data.appear;
			  var afterAppear = data.afterAppear;
			  var appearCancelled = data.appearCancelled;

			  // activeInstance will always be the <transition> component managing this
			  // transition. One edge case to check is when the <transition> is placed
			  // as the root node of a child component. In that case we need to check
			  // <transition>'s parent for appear check.
			  var transitionNode = activeInstance.$vnode;
			  var context = transitionNode && transitionNode.parent
			    ? transitionNode.parent.context
			    : activeInstance;

			  var isAppear = !context._isMounted || !vnode.isRootInsert;

			  if (isAppear && !appear && appear !== '') {
			    return
			  }

			  var startClass = isAppear ? appearClass : enterClass;
			  var activeClass = isAppear ? appearActiveClass : enterActiveClass;
			  var beforeEnterHook = isAppear ? (beforeAppear || beforeEnter) : beforeEnter;
			  var enterHook = isAppear ? (typeof appear === 'function' ? appear : enter) : enter;
			  var afterEnterHook = isAppear ? (afterAppear || afterEnter) : afterEnter;
			  var enterCancelledHook = isAppear ? (appearCancelled || enterCancelled) : enterCancelled;

			  var expectsCSS = css !== false && !isIE9;
			  var userWantsControl =
			    enterHook &&
			    // enterHook may be a bound method which exposes
			    // the length of original fn as _length
			    (enterHook._length || enterHook.length) > 1;

			  var cb = el._enterCb = once(function () {
			    if (expectsCSS) {
			      removeTransitionClass(el, activeClass);
			    }
			    if (cb.cancelled) {
			      if (expectsCSS) {
			        removeTransitionClass(el, startClass);
			      }
			      enterCancelledHook && enterCancelledHook(el);
			    } else {
			      afterEnterHook && afterEnterHook(el);
			    }
			    el._enterCb = null;
			  });

			  if (!vnode.data.show) {
			    // remove pending leave element on enter by injecting an insert hook
			    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {
			      var parent = el.parentNode;
			      var pendingNode = parent && parent._pending && parent._pending[vnode.key];
			      if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {
			        pendingNode.elm._leaveCb();
			      }
			      enterHook && enterHook(el, cb);
			    }, 'transition-insert');
			  }

			  // start enter transition
			  beforeEnterHook && beforeEnterHook(el);
			  if (expectsCSS) {
			    addTransitionClass(el, startClass);
			    addTransitionClass(el, activeClass);
			    nextFrame(function () {
			      removeTransitionClass(el, startClass);
			      if (!cb.cancelled && !userWantsControl) {
			        whenTransitionEnds(el, type, cb);
			      }
			    });
			  }

			  if (vnode.data.show) {
			    enterHook && enterHook(el, cb);
			  }

			  if (!expectsCSS && !userWantsControl) {
			    cb();
			  }
			}

			function leave (vnode, rm) {
			  var el = vnode.elm;

			  // call enter callback now
			  if (el._enterCb) {
			    el._enterCb.cancelled = true;
			    el._enterCb();
			  }

			  var data = resolveTransition(vnode.data.transition);
			  if (!data) {
			    return rm()
			  }

			  /* istanbul ignore if */
			  if (el._leaveCb || el.nodeType !== 1) {
			    return
			  }

			  var css = data.css;
			  var type = data.type;
			  var leaveClass = data.leaveClass;
			  var leaveActiveClass = data.leaveActiveClass;
			  var beforeLeave = data.beforeLeave;
			  var leave = data.leave;
			  var afterLeave = data.afterLeave;
			  var leaveCancelled = data.leaveCancelled;
			  var delayLeave = data.delayLeave;

			  var expectsCSS = css !== false && !isIE9;
			  var userWantsControl =
			    leave &&
			    // leave hook may be a bound method which exposes
			    // the length of original fn as _length
			    (leave._length || leave.length) > 1;

			  var cb = el._leaveCb = once(function () {
			    if (el.parentNode && el.parentNode._pending) {
			      el.parentNode._pending[vnode.key] = null;
			    }
			    if (expectsCSS) {
			      removeTransitionClass(el, leaveActiveClass);
			    }
			    if (cb.cancelled) {
			      if (expectsCSS) {
			        removeTransitionClass(el, leaveClass);
			      }
			      leaveCancelled && leaveCancelled(el);
			    } else {
			      rm();
			      afterLeave && afterLeave(el);
			    }
			    el._leaveCb = null;
			  });

			  if (delayLeave) {
			    delayLeave(performLeave);
			  } else {
			    performLeave();
			  }

			  function performLeave () {
			    // the delayed leave may have already been cancelled
			    if (cb.cancelled) {
			      return
			    }
			    // record leaving element
			    if (!vnode.data.show) {
			      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
			    }
			    beforeLeave && beforeLeave(el);
			    if (expectsCSS) {
			      addTransitionClass(el, leaveClass);
			      addTransitionClass(el, leaveActiveClass);
			      nextFrame(function () {
			        removeTransitionClass(el, leaveClass);
			        if (!cb.cancelled && !userWantsControl) {
			          whenTransitionEnds(el, type, cb);
			        }
			      });
			    }
			    leave && leave(el, cb);
			    if (!expectsCSS && !userWantsControl) {
			      cb();
			    }
			  }
			}

			function resolveTransition (def$$1) {
			  if (!def$$1) {
			    return
			  }
			  /* istanbul ignore else */
			  if (typeof def$$1 === 'object') {
			    var res = {};
			    if (def$$1.css !== false) {
			      extend(res, autoCssTransition(def$$1.name || 'v'));
			    }
			    extend(res, def$$1);
			    return res
			  } else if (typeof def$$1 === 'string') {
			    return autoCssTransition(def$$1)
			  }
			}

			var autoCssTransition = cached(function (name) {
			  return {
			    enterClass: (name + "-enter"),
			    leaveClass: (name + "-leave"),
			    appearClass: (name + "-enter"),
			    enterActiveClass: (name + "-enter-active"),
			    leaveActiveClass: (name + "-leave-active"),
			    appearActiveClass: (name + "-enter-active")
			  }
			});

			function once (fn) {
			  var called = false;
			  return function () {
			    if (!called) {
			      called = true;
			      fn();
			    }
			  }
			}

			var transition = inBrowser ? {
			  create: function create (_, vnode) {
			    if (!vnode.data.show) {
			      enter(vnode);
			    }
			  },
			  remove: function remove (vnode, rm) {
			    /* istanbul ignore else */
			    if (!vnode.data.show) {
			      leave(vnode, rm);
			    } else {
			      rm();
			    }
			  }
			} : {};

			var platformModules = [
			  attrs,
			  klass,
			  events,
			  domProps,
			  style,
			  transition
			];

			/*  */

			// the directive module should be applied last, after all
			// built-in modules have been applied.
			var modules = platformModules.concat(baseModules);

			var patch$1 = createPatchFunction({ nodeOps: nodeOps, modules: modules });

			/**
			 * Not type checking this file because flow doesn't like attaching
			 * properties to Elements.
			 */

			var modelableTagRE = /^input|select|textarea|vue-component-[0-9]+(-[0-9a-zA-Z_-]*)?$/;

			/* istanbul ignore if */
			if (isIE9) {
			  // http://www.matts411.com/post/internet-explorer-9-oninput/
			  document.addEventListener('selectionchange', function () {
			    var el = document.activeElement;
			    if (el && el.vmodel) {
			      trigger(el, 'input');
			    }
			  });
			}

			var model = {
			  inserted: function inserted (el, binding, vnode) {
			    {
			      if (!modelableTagRE.test(vnode.tag)) {
			        warn(
			          "v-model is not supported on element type: <" + (vnode.tag) + ">. " +
			          'If you are working with contenteditable, it\'s recommended to ' +
			          'wrap a library dedicated for that purpose inside a custom component.',
			          vnode.context
			        );
			      }
			    }
			    if (vnode.tag === 'select') {
			      var cb = function () {
			        setSelected(el, binding, vnode.context);
			      };
			      cb();
			      /* istanbul ignore if */
			      if (isIE || isEdge) {
			        setTimeout(cb, 0);
			      }
			    } else if (
			      (vnode.tag === 'textarea' || el.type === 'text') &&
			      !binding.modifiers.lazy
			    ) {
			      if (!isAndroid) {
			        el.addEventListener('compositionstart', onCompositionStart);
			        el.addEventListener('compositionend', onCompositionEnd);
			      }
			      /* istanbul ignore if */
			      if (isIE9) {
			        el.vmodel = true;
			      }
			    }
			  },
			  componentUpdated: function componentUpdated (el, binding, vnode) {
			    if (vnode.tag === 'select') {
			      setSelected(el, binding, vnode.context);
			      // in case the options rendered by v-for have changed,
			      // it's possible that the value is out-of-sync with the rendered options.
			      // detect such cases and filter out values that no longer has a matching
			      // option in the DOM.
			      var needReset = el.multiple
			        ? binding.value.some(function (v) { return hasNoMatchingOption(v, el.options); })
			        : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, el.options);
			      if (needReset) {
			        trigger(el, 'change');
			      }
			    }
			  }
			};

			function setSelected (el, binding, vm) {
			  var value = binding.value;
			  var isMultiple = el.multiple;
			  if (isMultiple && !Array.isArray(value)) {
			    "development" !== 'production' && warn(
			      "<select multiple v-model=\"" + (binding.expression) + "\"> " +
			      "expects an Array value for its binding, but got " + (Object.prototype.toString.call(value).slice(8, -1)),
			      vm
			    );
			    return
			  }
			  var selected, option;
			  for (var i = 0, l = el.options.length; i < l; i++) {
			    option = el.options[i];
			    if (isMultiple) {
			      selected = looseIndexOf(value, getValue(option)) > -1;
			      if (option.selected !== selected) {
			        option.selected = selected;
			      }
			    } else {
			      if (looseEqual(getValue(option), value)) {
			        if (el.selectedIndex !== i) {
			          el.selectedIndex = i;
			        }
			        return
			      }
			    }
			  }
			  if (!isMultiple) {
			    el.selectedIndex = -1;
			  }
			}

			function hasNoMatchingOption (value, options) {
			  for (var i = 0, l = options.length; i < l; i++) {
			    if (looseEqual(getValue(options[i]), value)) {
			      return false
			    }
			  }
			  return true
			}

			function getValue (option) {
			  return '_value' in option
			    ? option._value
			    : option.value
			}

			function onCompositionStart (e) {
			  e.target.composing = true;
			}

			function onCompositionEnd (e) {
			  e.target.composing = false;
			  trigger(e.target, 'input');
			}

			function trigger (el, type) {
			  var e = document.createEvent('HTMLEvents');
			  e.initEvent(type, true, true);
			  el.dispatchEvent(e);
			}

			/*  */

			// recursively search for possible transition defined inside the component root
			function locateNode (vnode) {
			  return vnode.child && (!vnode.data || !vnode.data.transition)
			    ? locateNode(vnode.child._vnode)
			    : vnode
			}

			var show = {
			  bind: function bind (el, ref, vnode) {
			    var value = ref.value;

			    vnode = locateNode(vnode);
			    var transition = vnode.data && vnode.data.transition;
			    if (value && transition && !isIE9) {
			      enter(vnode);
			    }
			    var originalDisplay = el.style.display === 'none' ? '' : el.style.display;
			    el.style.display = value ? originalDisplay : 'none';
			    el.__vOriginalDisplay = originalDisplay;
			  },
			  update: function update (el, ref, vnode) {
			    var value = ref.value;
			    var oldValue = ref.oldValue;

			    /* istanbul ignore if */
			    if (value === oldValue) { return }
			    vnode = locateNode(vnode);
			    var transition = vnode.data && vnode.data.transition;
			    if (transition && !isIE9) {
			      if (value) {
			        enter(vnode);
			        el.style.display = el.__vOriginalDisplay;
			      } else {
			        leave(vnode, function () {
			          el.style.display = 'none';
			        });
			      }
			    } else {
			      el.style.display = value ? el.__vOriginalDisplay : 'none';
			    }
			  }
			};

			var platformDirectives = {
			  model: model,
			  show: show
			};

			/*  */

			// Provides transition support for a single element/component.
			// supports transition mode (out-in / in-out)

			var transitionProps = {
			  name: String,
			  appear: Boolean,
			  css: Boolean,
			  mode: String,
			  type: String,
			  enterClass: String,
			  leaveClass: String,
			  enterActiveClass: String,
			  leaveActiveClass: String,
			  appearClass: String,
			  appearActiveClass: String
			};

			// in case the child is also an abstract component, e.g. <keep-alive>
			// we want to recursively retrieve the real component to be rendered
			function getRealChild (vnode) {
			  var compOptions = vnode && vnode.componentOptions;
			  if (compOptions && compOptions.Ctor.options.abstract) {
			    return getRealChild(getFirstComponentChild(compOptions.children))
			  } else {
			    return vnode
			  }
			}

			function extractTransitionData (comp) {
			  var data = {};
			  var options = comp.$options;
			  // props
			  for (var key in options.propsData) {
			    data[key] = comp[key];
			  }
			  // events.
			  // extract listeners and pass them directly to the transition methods
			  var listeners = options._parentListeners;
			  for (var key$1 in listeners) {
			    data[camelize(key$1)] = listeners[key$1].fn;
			  }
			  return data
			}

			function placeholder (h, rawChild) {
			  return /\d-keep-alive$/.test(rawChild.tag)
			    ? h('keep-alive')
			    : null
			}

			function hasParentTransition (vnode) {
			  while ((vnode = vnode.parent)) {
			    if (vnode.data.transition) {
			      return true
			    }
			  }
			}

			var Transition = {
			  name: 'transition',
			  props: transitionProps,
			  abstract: true,
			  render: function render (h) {
			    var this$1 = this;

			    var children = this.$slots.default;
			    if (!children) {
			      return
			    }

			    // filter out text nodes (possible whitespaces)
			    children = children.filter(function (c) { return c.tag; });
			    /* istanbul ignore if */
			    if (!children.length) {
			      return
			    }

			    // warn multiple elements
			    if ("development" !== 'production' && children.length > 1) {
			      warn(
			        '<transition> can only be used on a single element. Use ' +
			        '<transition-group> for lists.',
			        this.$parent
			      );
			    }

			    var mode = this.mode;

			    // warn invalid mode
			    if ("development" !== 'production' &&
			        mode && mode !== 'in-out' && mode !== 'out-in') {
			      warn(
			        'invalid <transition> mode: ' + mode,
			        this.$parent
			      );
			    }

			    var rawChild = children[0];

			    // if this is a component root node and the component's
			    // parent container node also has transition, skip.
			    if (hasParentTransition(this.$vnode)) {
			      return rawChild
			    }

			    // apply transition data to child
			    // use getRealChild() to ignore abstract components e.g. keep-alive
			    var child = getRealChild(rawChild);
			    /* istanbul ignore if */
			    if (!child) {
			      return rawChild
			    }

			    if (this._leaving) {
			      return placeholder(h, rawChild)
			    }

			    var key = child.key = child.key == null || child.isStatic
			      ? ("__v" + (child.tag + this._uid) + "__")
			      : child.key;
			    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
			    var oldRawChild = this._vnode;
			    var oldChild = getRealChild(oldRawChild);

			    // mark v-show
			    // so that the transition module can hand over the control to the directive
			    if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {
			      child.data.show = true;
			    }

			    if (oldChild && oldChild.data && oldChild.key !== key) {
			      // replace old child transition data with fresh one
			      // important for dynamic transitions!
			      var oldData = oldChild.data.transition = extend({}, data);

			      // handle transition mode
			      if (mode === 'out-in') {
			        // return placeholder node and queue update when leave finishes
			        this._leaving = true;
			        mergeVNodeHook(oldData, 'afterLeave', function () {
			          this$1._leaving = false;
			          this$1.$forceUpdate();
			        }, key);
			        return placeholder(h, rawChild)
			      } else if (mode === 'in-out') {
			        var delayedLeave;
			        var performLeave = function () { delayedLeave(); };
			        mergeVNodeHook(data, 'afterEnter', performLeave, key);
			        mergeVNodeHook(data, 'enterCancelled', performLeave, key);
			        mergeVNodeHook(oldData, 'delayLeave', function (leave) {
			          delayedLeave = leave;
			        }, key);
			      }
			    }

			    return rawChild
			  }
			};

			/*  */

			// Provides transition support for list items.
			// supports move transitions using the FLIP technique.

			// Because the vdom's children update algorithm is "unstable" - i.e.
			// it doesn't guarantee the relative positioning of removed elements,
			// we force transition-group to update its children into two passes:
			// in the first pass, we remove all nodes that need to be removed,
			// triggering their leaving transition; in the second pass, we insert/move
			// into the final disired state. This way in the second pass removed
			// nodes will remain where they should be.

			var props = extend({
			  tag: String,
			  moveClass: String
			}, transitionProps);

			delete props.mode;

			var TransitionGroup = {
			  props: props,

			  render: function render (h) {
			    var tag = this.tag || this.$vnode.data.tag || 'span';
			    var map = Object.create(null);
			    var prevChildren = this.prevChildren = this.children;
			    var rawChildren = this.$slots.default || [];
			    var children = this.children = [];
			    var transitionData = extractTransitionData(this);

			    for (var i = 0; i < rawChildren.length; i++) {
			      var c = rawChildren[i];
			      if (c.tag) {
			        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
			          children.push(c);
			          map[c.key] = c
			          ;(c.data || (c.data = {})).transition = transitionData;
			        } else {
			          var opts = c.componentOptions;
			          var name = opts
			            ? (opts.Ctor.options.name || opts.tag)
			            : c.tag;
			          warn(("<transition-group> children must be keyed: <" + name + ">"));
			        }
			      }
			    }

			    if (prevChildren) {
			      var kept = [];
			      var removed = [];
			      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
			        var c$1 = prevChildren[i$1];
			        c$1.data.transition = transitionData;
			        c$1.data.pos = c$1.elm.getBoundingClientRect();
			        if (map[c$1.key]) {
			          kept.push(c$1);
			        } else {
			          removed.push(c$1);
			        }
			      }
			      this.kept = h(tag, null, kept);
			      this.removed = removed;
			    }

			    return h(tag, null, children)
			  },

			  beforeUpdate: function beforeUpdate () {
			    // force removing pass
			    this.__patch__(
			      this._vnode,
			      this.kept,
			      false, // hydrating
			      true // removeOnly (!important, avoids unnecessary moves)
			    );
			    this._vnode = this.kept;
			  },

			  updated: function updated () {
			    var children = this.prevChildren;
			    var moveClass = this.moveClass || (this.name + '-move');
			    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
			      return
			    }

			    // we divide the work into three loops to avoid mixing DOM reads and writes
			    // in each iteration - which helps prevent layout thrashing.
			    children.forEach(callPendingCbs);
			    children.forEach(recordPosition);
			    children.forEach(applyTranslation);

			    // force reflow to put everything in position
			    var f = document.body.offsetHeight; // eslint-disable-line

			    children.forEach(function (c) {
			      if (c.data.moved) {
			        var el = c.elm;
			        var s = el.style;
			        addTransitionClass(el, moveClass);
			        s.transform = s.WebkitTransform = s.transitionDuration = '';
			        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {
			          if (!e || /transform$/.test(e.propertyName)) {
			            el.removeEventListener(transitionEndEvent, cb);
			            el._moveCb = null;
			            removeTransitionClass(el, moveClass);
			          }
			        });
			      }
			    });
			  },

			  methods: {
			    hasMove: function hasMove (el, moveClass) {
			      /* istanbul ignore if */
			      if (!hasTransition) {
			        return false
			      }
			      if (this._hasMove != null) {
			        return this._hasMove
			      }
			      addTransitionClass(el, moveClass);
			      var info = getTransitionInfo(el);
			      removeTransitionClass(el, moveClass);
			      return (this._hasMove = info.hasTransform)
			    }
			  }
			};

			function callPendingCbs (c) {
			  /* istanbul ignore if */
			  if (c.elm._moveCb) {
			    c.elm._moveCb();
			  }
			  /* istanbul ignore if */
			  if (c.elm._enterCb) {
			    c.elm._enterCb();
			  }
			}

			function recordPosition (c) {
			  c.data.newPos = c.elm.getBoundingClientRect();
			}

			function applyTranslation (c) {
			  var oldPos = c.data.pos;
			  var newPos = c.data.newPos;
			  var dx = oldPos.left - newPos.left;
			  var dy = oldPos.top - newPos.top;
			  if (dx || dy) {
			    c.data.moved = true;
			    var s = c.elm.style;
			    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
			    s.transitionDuration = '0s';
			  }
			}

			var platformComponents = {
			  Transition: Transition,
			  TransitionGroup: TransitionGroup
			};

			/*  */

			// install platform specific utils
			Vue$2.config.isUnknownElement = isUnknownElement;
			Vue$2.config.isReservedTag = isReservedTag;
			Vue$2.config.getTagNamespace = getTagNamespace;
			Vue$2.config.mustUseProp = mustUseProp;

			// install platform runtime directives & components
			extend(Vue$2.options.directives, platformDirectives);
			extend(Vue$2.options.components, platformComponents);

			// install platform patch function
			Vue$2.prototype.__patch__ = config._isServer ? noop : patch$1;

			// wrap mount
			Vue$2.prototype.$mount = function (
			  el,
			  hydrating
			) {
			  el = el && !config._isServer ? query(el) : undefined;
			  return this._mount(el, hydrating)
			};

			// devtools global hook
			/* istanbul ignore next */
			setTimeout(function () {
			  if (config.devtools) {
			    if (devtools) {
			      devtools.emit('init', Vue$2);
			    } else if (
			      "development" !== 'production' &&
			      inBrowser && /Chrome\/\d+/.test(window.navigator.userAgent)
			    ) {
			      console.log(
			        'Download the Vue Devtools for a better development experience:\n' +
			        'https://github.com/vuejs/vue-devtools'
			      );
			    }
			  }
			}, 0);

			/*  */

			// check whether current browser encodes a char inside attribute values
			function shouldDecode (content, encoded) {
			  var div = document.createElement('div');
			  div.innerHTML = "<div a=\"" + content + "\">";
			  return div.innerHTML.indexOf(encoded) > 0
			}

			// #3663
			// IE encodes newlines inside attribute values while other browsers don't
			var shouldDecodeNewlines = inBrowser ? shouldDecode('\n', '&#10;') : false;

			/*  */

			var decoder = document.createElement('div');

			function decode (html) {
			  decoder.innerHTML = html;
			  return decoder.textContent
			}

			/**
			 * Not type-checking this file because it's mostly vendor code.
			 */

			/*!
			 * HTML Parser By John Resig (ejohn.org)
			 * Modified by Juriy "kangax" Zaytsev
			 * Original code by Erik Arvidsson, Mozilla Public License
			 * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
			 */

			// Regular Expressions for parsing tags and attributes
			var singleAttrIdentifier = /([^\s"'<>/=]+)/;
			var singleAttrAssign = /(?:=)/;
			var singleAttrValues = [
			  // attr value double quotes
			  /"([^"]*)"+/.source,
			  // attr value, single quotes
			  /'([^']*)'+/.source,
			  // attr value, no quotes
			  /([^\s"'=<>`]+)/.source
			];
			var attribute = new RegExp(
			  '^\\s*' + singleAttrIdentifier.source +
			  '(?:\\s*(' + singleAttrAssign.source + ')' +
			  '\\s*(?:' + singleAttrValues.join('|') + '))?'
			);

			// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName
			// but for Vue templates we can enforce a simple charset
			var ncname = '[a-zA-Z_][\\w\\-\\.]*';
			var qnameCapture = '((?:' + ncname + '\\:)?' + ncname + ')';
			var startTagOpen = new RegExp('^<' + qnameCapture);
			var startTagClose = /^\s*(\/?)>/;
			var endTag = new RegExp('^<\\/' + qnameCapture + '[^>]*>');
			var doctype = /^<!DOCTYPE [^>]+>/i;
			var comment = /^<!--/;
			var conditionalComment = /^<!\[/;

			var IS_REGEX_CAPTURING_BROKEN = false;
			'x'.replace(/x(.)?/g, function (m, g) {
			  IS_REGEX_CAPTURING_BROKEN = g === '';
			});

			// Special Elements (can contain anything)
			var isScriptOrStyle = makeMap('script,style', true);
			var hasLang = function (attr) { return attr.name === 'lang' && attr.value !== 'html'; };
			var isSpecialTag = function (tag, isSFC, stack) {
			  if (isScriptOrStyle(tag)) {
			    return true
			  }
			  // top-level template that has a pre-processor
			  if (
			    isSFC &&
			    tag === 'template' &&
			    stack.length === 1 &&
			    stack[0].attrs.some(hasLang)
			  ) {
			    return true
			  }
			  return false
			};

			var reCache = {};

			var ltRE = /&lt;/g;
			var gtRE = /&gt;/g;
			var nlRE = /&#10;/g;
			var ampRE = /&amp;/g;
			var quoteRE = /&quot;/g;

			function decodeAttr (value, shouldDecodeNewlines) {
			  if (shouldDecodeNewlines) {
			    value = value.replace(nlRE, '\n');
			  }
			  return value
			    .replace(ltRE, '<')
			    .replace(gtRE, '>')
			    .replace(ampRE, '&')
			    .replace(quoteRE, '"')
			}

			function parseHTML (html, options) {
			  var stack = [];
			  var expectHTML = options.expectHTML;
			  var isUnaryTag$$1 = options.isUnaryTag || no;
			  var index = 0;
			  var last, lastTag;
			  while (html) {
			    last = html;
			    // Make sure we're not in a script or style element
			    if (!lastTag || !isSpecialTag(lastTag, options.sfc, stack)) {
			      var textEnd = html.indexOf('<');
			      if (textEnd === 0) {
			        // Comment:
			        if (comment.test(html)) {
			          var commentEnd = html.indexOf('-->');

			          if (commentEnd >= 0) {
			            advance(commentEnd + 3);
			            continue
			          }
			        }

			        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
			        if (conditionalComment.test(html)) {
			          var conditionalEnd = html.indexOf(']>');

			          if (conditionalEnd >= 0) {
			            advance(conditionalEnd + 2);
			            continue
			          }
			        }

			        // Doctype:
			        var doctypeMatch = html.match(doctype);
			        if (doctypeMatch) {
			          advance(doctypeMatch[0].length);
			          continue
			        }

			        // End tag:
			        var endTagMatch = html.match(endTag);
			        if (endTagMatch) {
			          var curIndex = index;
			          advance(endTagMatch[0].length);
			          parseEndTag(endTagMatch[0], endTagMatch[1], curIndex, index);
			          continue
			        }

			        // Start tag:
			        var startTagMatch = parseStartTag();
			        if (startTagMatch) {
			          handleStartTag(startTagMatch);
			          continue
			        }
			      }

			      var text = void 0, rest$1 = void 0, next = void 0;
			      if (textEnd > 0) {
			        rest$1 = html.slice(textEnd);
			        while (
			          !endTag.test(rest$1) &&
			          !startTagOpen.test(rest$1) &&
			          !comment.test(rest$1) &&
			          !conditionalComment.test(rest$1)
			        ) {
			          // < in plain text, be forgiving and treat it as text
			          next = rest$1.indexOf('<', 1);
			          if (next < 0) { break }
			          textEnd += next;
			          rest$1 = html.slice(textEnd);
			        }
			        text = html.substring(0, textEnd);
			        advance(textEnd);
			      }

			      if (textEnd < 0) {
			        text = html;
			        html = '';
			      }

			      if (options.chars && text) {
			        options.chars(text);
			      }
			    } else {
			      var stackedTag = lastTag.toLowerCase();
			      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));
			      var endTagLength = 0;
			      var rest = html.replace(reStackedTag, function (all, text, endTag) {
			        endTagLength = endTag.length;
			        if (stackedTag !== 'script' && stackedTag !== 'style' && stackedTag !== 'noscript') {
			          text = text
			            .replace(/<!--([\s\S]*?)-->/g, '$1')
			            .replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
			        }
			        if (options.chars) {
			          options.chars(text);
			        }
			        return ''
			      });
			      index += html.length - rest.length;
			      html = rest;
			      parseEndTag('</' + stackedTag + '>', stackedTag, index - endTagLength, index);
			    }

			    if (html === last && options.chars) {
			      options.chars(html);
			      break
			    }
			  }

			  // Clean up any remaining tags
			  parseEndTag();

			  function advance (n) {
			    index += n;
			    html = html.substring(n);
			  }

			  function parseStartTag () {
			    var start = html.match(startTagOpen);
			    if (start) {
			      var match = {
			        tagName: start[1],
			        attrs: [],
			        start: index
			      };
			      advance(start[0].length);
			      var end, attr;
			      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {
			        advance(attr[0].length);
			        match.attrs.push(attr);
			      }
			      if (end) {
			        match.unarySlash = end[1];
			        advance(end[0].length);
			        match.end = index;
			        return match
			      }
			    }
			  }

			  function handleStartTag (match) {
			    var tagName = match.tagName;
			    var unarySlash = match.unarySlash;

			    if (expectHTML) {
			      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
			        parseEndTag('', lastTag);
			      }
			      if (canBeLeftOpenTag(tagName) && lastTag === tagName) {
			        parseEndTag('', tagName);
			      }
			    }

			    var unary = isUnaryTag$$1(tagName) || tagName === 'html' && lastTag === 'head' || !!unarySlash;

			    var l = match.attrs.length;
			    var attrs = new Array(l);
			    for (var i = 0; i < l; i++) {
			      var args = match.attrs[i];
			      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778
			      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('""') === -1) {
			        if (args[3] === '') { delete args[3]; }
			        if (args[4] === '') { delete args[4]; }
			        if (args[5] === '') { delete args[5]; }
			      }
			      var value = args[3] || args[4] || args[5] || '';
			      attrs[i] = {
			        name: args[1],
			        value: decodeAttr(
			          value,
			          options.shouldDecodeNewlines
			        )
			      };
			    }

			    if (!unary) {
			      stack.push({ tag: tagName, attrs: attrs });
			      lastTag = tagName;
			      unarySlash = '';
			    }

			    if (options.start) {
			      options.start(tagName, attrs, unary, match.start, match.end);
			    }
			  }

			  function parseEndTag (tag, tagName, start, end) {
			    var pos;
			    if (start == null) { start = index; }
			    if (end == null) { end = index; }

			    // Find the closest opened tag of the same type
			    if (tagName) {
			      var needle = tagName.toLowerCase();
			      for (pos = stack.length - 1; pos >= 0; pos--) {
			        if (stack[pos].tag.toLowerCase() === needle) {
			          break
			        }
			      }
			    } else {
			      // If no tag name is provided, clean shop
			      pos = 0;
			    }

			    if (pos >= 0) {
			      // Close all the open elements, up the stack
			      for (var i = stack.length - 1; i >= pos; i--) {
			        if (options.end) {
			          options.end(stack[i].tag, start, end);
			        }
			      }

			      // Remove the open elements from the stack
			      stack.length = pos;
			      lastTag = pos && stack[pos - 1].tag;
			    } else if (tagName.toLowerCase() === 'br') {
			      if (options.start) {
			        options.start(tagName, [], true, start, end);
			      }
			    } else if (tagName.toLowerCase() === 'p') {
			      if (options.start) {
			        options.start(tagName, [], false, start, end);
			      }
			      if (options.end) {
			        options.end(tagName, start, end);
			      }
			    }
			  }
			}

			/*  */

			function parseFilters (exp) {
			  var inSingle = false;
			  var inDouble = false;
			  var curly = 0;
			  var square = 0;
			  var paren = 0;
			  var lastFilterIndex = 0;
			  var c, prev, i, expression, filters;

			  for (i = 0; i < exp.length; i++) {
			    prev = c;
			    c = exp.charCodeAt(i);
			    if (inSingle) {
			      // check single quote
			      if (c === 0x27 && prev !== 0x5C) { inSingle = !inSingle; }
			    } else if (inDouble) {
			      // check double quote
			      if (c === 0x22 && prev !== 0x5C) { inDouble = !inDouble; }
			    } else if (
			      c === 0x7C && // pipe
			      exp.charCodeAt(i + 1) !== 0x7C &&
			      exp.charCodeAt(i - 1) !== 0x7C &&
			      !curly && !square && !paren
			    ) {
			      if (expression === undefined) {
			        // first filter, end of expression
			        lastFilterIndex = i + 1;
			        expression = exp.slice(0, i).trim();
			      } else {
			        pushFilter();
			      }
			    } else {
			      switch (c) {
			        case 0x22: inDouble = true; break // "
			        case 0x27: inSingle = true; break // '
			        case 0x28: paren++; break         // (
			        case 0x29: paren--; break         // )
			        case 0x5B: square++; break        // [
			        case 0x5D: square--; break        // ]
			        case 0x7B: curly++; break         // {
			        case 0x7D: curly--; break         // }
			      }
			    }
			  }

			  if (expression === undefined) {
			    expression = exp.slice(0, i).trim();
			  } else if (lastFilterIndex !== 0) {
			    pushFilter();
			  }

			  function pushFilter () {
			    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
			    lastFilterIndex = i + 1;
			  }

			  if (filters) {
			    for (i = 0; i < filters.length; i++) {
			      expression = wrapFilter(expression, filters[i]);
			    }
			  }

			  return expression
			}

			function wrapFilter (exp, filter) {
			  var i = filter.indexOf('(');
			  if (i < 0) {
			    // _f: resolveFilter
			    return ("_f(\"" + filter + "\")(" + exp + ")")
			  } else {
			    var name = filter.slice(0, i);
			    var args = filter.slice(i + 1);
			    return ("_f(\"" + name + "\")(" + exp + "," + args)
			  }
			}

			/*  */

			var defaultTagRE = /\{\{((?:.|\n)+?)\}\}/g;
			var regexEscapeRE = /[-.*+?^${}()|[\]/\\]/g;

			var buildRegex = cached(function (delimiters) {
			  var open = delimiters[0].replace(regexEscapeRE, '\\$&');
			  var close = delimiters[1].replace(regexEscapeRE, '\\$&');
			  return new RegExp(open + '((?:.|\\n)+?)' + close, 'g')
			});

			function parseText (
			  text,
			  delimiters
			) {
			  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;
			  if (!tagRE.test(text)) {
			    return
			  }
			  var tokens = [];
			  var lastIndex = tagRE.lastIndex = 0;
			  var match, index;
			  while ((match = tagRE.exec(text))) {
			    index = match.index;
			    // push text token
			    if (index > lastIndex) {
			      tokens.push(JSON.stringify(text.slice(lastIndex, index)));
			    }
			    // tag token
			    var exp = parseFilters(match[1].trim());
			    tokens.push(("_s(" + exp + ")"));
			    lastIndex = index + match[0].length;
			  }
			  if (lastIndex < text.length) {
			    tokens.push(JSON.stringify(text.slice(lastIndex)));
			  }
			  return tokens.join('+')
			}

			/*  */

			function baseWarn (msg) {
			  console.error(("[Vue parser]: " + msg));
			}

			function pluckModuleFunction (
			  modules,
			  key
			) {
			  return modules
			    ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })
			    : []
			}

			function addProp (el, name, value) {
			  (el.props || (el.props = [])).push({ name: name, value: value });
			}

			function addAttr (el, name, value) {
			  (el.attrs || (el.attrs = [])).push({ name: name, value: value });
			}

			function addDirective (
			  el,
			  name,
			  rawName,
			  value,
			  arg,
			  modifiers
			) {
			  (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });
			}

			function addHandler (
			  el,
			  name,
			  value,
			  modifiers,
			  important
			) {
			  // check capture modifier
			  if (modifiers && modifiers.capture) {
			    delete modifiers.capture;
			    name = '!' + name; // mark the event as captured
			  }
			  var events;
			  if (modifiers && modifiers.native) {
			    delete modifiers.native;
			    events = el.nativeEvents || (el.nativeEvents = {});
			  } else {
			    events = el.events || (el.events = {});
			  }
			  var newHandler = { value: value, modifiers: modifiers };
			  var handlers = events[name];
			  /* istanbul ignore if */
			  if (Array.isArray(handlers)) {
			    important ? handlers.unshift(newHandler) : handlers.push(newHandler);
			  } else if (handlers) {
			    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
			  } else {
			    events[name] = newHandler;
			  }
			}

			function getBindingAttr (
			  el,
			  name,
			  getStatic
			) {
			  var dynamicValue =
			    getAndRemoveAttr(el, ':' + name) ||
			    getAndRemoveAttr(el, 'v-bind:' + name);
			  if (dynamicValue != null) {
			    return dynamicValue
			  } else if (getStatic !== false) {
			    var staticValue = getAndRemoveAttr(el, name);
			    if (staticValue != null) {
			      return JSON.stringify(staticValue)
			    }
			  }
			}

			function getAndRemoveAttr (el, name) {
			  var val;
			  if ((val = el.attrsMap[name]) != null) {
			    var list = el.attrsList;
			    for (var i = 0, l = list.length; i < l; i++) {
			      if (list[i].name === name) {
			        list.splice(i, 1);
			        break
			      }
			    }
			  }
			  return val
			}

			/*  */

			var dirRE = /^v-|^@|^:/;
			var forAliasRE = /(.*?)\s+(?:in|of)\s+(.*)/;
			var forIteratorRE = /\(([^,]*),([^,]*)(?:,([^,]*))?\)/;
			var bindRE = /^:|^v-bind:/;
			var onRE = /^@|^v-on:/;
			var argRE = /:(.*)$/;
			var modifierRE = /\.[^.]+/g;
			var specialNewlineRE = /\u2028|\u2029/g;

			var decodeHTMLCached = cached(decode);

			// configurable state
			var warn$1;
			var platformGetTagNamespace;
			var platformMustUseProp;
			var platformIsPreTag;
			var preTransforms;
			var transforms;
			var postTransforms;
			var delimiters;

			/**
			 * Convert HTML string to AST.
			 */
			function parse (
			  template,
			  options
			) {
			  warn$1 = options.warn || baseWarn;
			  platformGetTagNamespace = options.getTagNamespace || no;
			  platformMustUseProp = options.mustUseProp || no;
			  platformIsPreTag = options.isPreTag || no;
			  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');
			  transforms = pluckModuleFunction(options.modules, 'transformNode');
			  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');
			  delimiters = options.delimiters;
			  var stack = [];
			  var preserveWhitespace = options.preserveWhitespace !== false;
			  var root;
			  var currentParent;
			  var inVPre = false;
			  var inPre = false;
			  var warned = false;
			  parseHTML(template, {
			    expectHTML: options.expectHTML,
			    isUnaryTag: options.isUnaryTag,
			    shouldDecodeNewlines: options.shouldDecodeNewlines,
			    start: function start (tag, attrs, unary) {
			      // check namespace.
			      // inherit parent ns if there is one
			      var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);

			      // handle IE svg bug
			      /* istanbul ignore if */
			      if (options.isIE && ns === 'svg') {
			        attrs = guardIESVGBug(attrs);
			      }

			      var element = {
			        type: 1,
			        tag: tag,
			        attrsList: attrs,
			        attrsMap: makeAttrsMap(attrs, options.isIE),
			        parent: currentParent,
			        children: []
			      };
			      if (ns) {
			        element.ns = ns;
			      }

			      if ("client" !== 'server' && isForbiddenTag(element)) {
			        element.forbidden = true;
			        "development" !== 'production' && warn$1(
			          'Templates should only be responsible for mapping the state to the ' +
			          'UI. Avoid placing tags with side-effects in your templates, such as ' +
			          "<" + tag + ">."
			        );
			      }

			      // apply pre-transforms
			      for (var i = 0; i < preTransforms.length; i++) {
			        preTransforms[i](element, options);
			      }

			      if (!inVPre) {
			        processPre(element);
			        if (element.pre) {
			          inVPre = true;
			        }
			      }
			      if (platformIsPreTag(element.tag)) {
			        inPre = true;
			      }
			      if (inVPre) {
			        processRawAttrs(element);
			      } else {
			        processFor(element);
			        processIf(element);
			        processOnce(element);
			        processKey(element);

			        // determine whether this is a plain element after
			        // removing structural attributes
			        element.plain = !element.key && !attrs.length;

			        processRef(element);
			        processSlot(element);
			        processComponent(element);
			        for (var i$1 = 0; i$1 < transforms.length; i$1++) {
			          transforms[i$1](element, options);
			        }
			        processAttrs(element);
			      }

			      function checkRootConstraints (el) {
			        if ("development" !== 'production' && !warned) {
			          if (el.tag === 'slot' || el.tag === 'template') {
			            warned = true;
			            warn$1(
			              "Cannot use <" + (el.tag) + "> as component root element because it may " +
			              'contain multiple nodes:\n' + template
			            );
			          }
			          if (el.attrsMap.hasOwnProperty('v-for')) {
			            warned = true;
			            warn$1(
			              'Cannot use v-for on stateful component root element because ' +
			              'it renders multiple elements:\n' + template
			            );
			          }
			        }
			      }

			      // tree management
			      if (!root) {
			        root = element;
			        checkRootConstraints(root);
			      } else if (!stack.length) {
			        // allow 2 root elements with v-if and v-else
			        if (root.if && element.else) {
			          checkRootConstraints(element);
			          root.elseBlock = element;
			        } else if ("development" !== 'production' && !warned) {
			          warned = true;
			          warn$1(
			            ("Component template should contain exactly one root element:\n\n" + template)
			          );
			        }
			      }
			      if (currentParent && !element.forbidden) {
			        if (element.else) {
			          processElse(element, currentParent);
			        } else {
			          currentParent.children.push(element);
			          element.parent = currentParent;
			        }
			      }
			      if (!unary) {
			        currentParent = element;
			        stack.push(element);
			      }
			      // apply post-transforms
			      for (var i$2 = 0; i$2 < postTransforms.length; i$2++) {
			        postTransforms[i$2](element, options);
			      }
			    },

			    end: function end () {
			      // remove trailing whitespace
			      var element = stack[stack.length - 1];
			      var lastNode = element.children[element.children.length - 1];
			      if (lastNode && lastNode.type === 3 && lastNode.text === ' ') {
			        element.children.pop();
			      }
			      // pop stack
			      stack.length -= 1;
			      currentParent = stack[stack.length - 1];
			      // check pre state
			      if (element.pre) {
			        inVPre = false;
			      }
			      if (platformIsPreTag(element.tag)) {
			        inPre = false;
			      }
			    },

			    chars: function chars (text) {
			      if (!currentParent) {
			        if ("development" !== 'production' && !warned && text === template) {
			          warned = true;
			          warn$1(
			            'Component template requires a root element, rather than just text:\n\n' + template
			          );
			        }
			        return
			      }
			      text = inPre || text.trim()
			        ? decodeHTMLCached(text)
			        // only preserve whitespace if its not right after a starting tag
			        : preserveWhitespace && currentParent.children.length ? ' ' : '';
			      if (text) {
			        var expression;
			        if (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {
			          currentParent.children.push({
			            type: 2,
			            expression: expression,
			            text: text
			          });
			        } else {
			          // #3895 special character
			          text = text.replace(specialNewlineRE, '');
			          currentParent.children.push({
			            type: 3,
			            text: text
			          });
			        }
			      }
			    }
			  });
			  return root
			}

			function processPre (el) {
			  if (getAndRemoveAttr(el, 'v-pre') != null) {
			    el.pre = true;
			  }
			}

			function processRawAttrs (el) {
			  var l = el.attrsList.length;
			  if (l) {
			    var attrs = el.attrs = new Array(l);
			    for (var i = 0; i < l; i++) {
			      attrs[i] = {
			        name: el.attrsList[i].name,
			        value: JSON.stringify(el.attrsList[i].value)
			      };
			    }
			  } else if (!el.pre) {
			    // non root node in pre blocks with no attributes
			    el.plain = true;
			  }
			}

			function processKey (el) {
			  var exp = getBindingAttr(el, 'key');
			  if (exp) {
			    if ("development" !== 'production' && el.tag === 'template') {
			      warn$1("<template> cannot be keyed. Place the key on real elements instead.");
			    }
			    el.key = exp;
			  }
			}

			function processRef (el) {
			  var ref = getBindingAttr(el, 'ref');
			  if (ref) {
			    el.ref = ref;
			    el.refInFor = checkInFor(el);
			  }
			}

			function processFor (el) {
			  var exp;
			  if ((exp = getAndRemoveAttr(el, 'v-for'))) {
			    var inMatch = exp.match(forAliasRE);
			    if (!inMatch) {
			      "development" !== 'production' && warn$1(
			        ("Invalid v-for expression: " + exp)
			      );
			      return
			    }
			    el.for = inMatch[2].trim();
			    var alias = inMatch[1].trim();
			    var iteratorMatch = alias.match(forIteratorRE);
			    if (iteratorMatch) {
			      el.alias = iteratorMatch[1].trim();
			      el.iterator1 = iteratorMatch[2].trim();
			      if (iteratorMatch[3]) {
			        el.iterator2 = iteratorMatch[3].trim();
			      }
			    } else {
			      el.alias = alias;
			    }
			  }
			}

			function processIf (el) {
			  var exp = getAndRemoveAttr(el, 'v-if');
			  if (exp) {
			    el.if = exp;
			  }
			  if (getAndRemoveAttr(el, 'v-else') != null) {
			    el.else = true;
			  }
			}

			function processElse (el, parent) {
			  var prev = findPrevElement(parent.children);
			  if (prev && prev.if) {
			    prev.elseBlock = el;
			  } else {
			    warn$1(
			      ("v-else used on element <" + (el.tag) + "> without corresponding v-if.")
			    );
			  }
			}

			function processOnce (el) {
			  var once = getAndRemoveAttr(el, 'v-once');
			  if (once != null) {
			    el.once = true;
			  }
			}

			function processSlot (el) {
			  if (el.tag === 'slot') {
			    el.slotName = getBindingAttr(el, 'name');
			  } else {
			    var slotTarget = getBindingAttr(el, 'slot');
			    if (slotTarget) {
			      el.slotTarget = slotTarget;
			    }
			  }
			}

			function processComponent (el) {
			  var binding;
			  if ((binding = getBindingAttr(el, 'is'))) {
			    el.component = binding;
			  }
			  if (getAndRemoveAttr(el, 'inline-template') != null) {
			    el.inlineTemplate = true;
			  }
			}

			function processAttrs (el) {
			  var list = el.attrsList;
			  var i, l, name, rawName, value, arg, modifiers, isProp;
			  for (i = 0, l = list.length; i < l; i++) {
			    name = rawName = list[i].name;
			    value = list[i].value;
			    if (dirRE.test(name)) {
			      // mark element as dynamic
			      el.hasBindings = true;
			      // modifiers
			      modifiers = parseModifiers(name);
			      if (modifiers) {
			        name = name.replace(modifierRE, '');
			      }
			      if (bindRE.test(name)) { // v-bind
			        name = name.replace(bindRE, '');
			        if (modifiers && modifiers.prop) {
			          isProp = true;
			          name = camelize(name);
			          if (name === 'innerHtml') { name = 'innerHTML'; }
			        }
			        if (isProp || platformMustUseProp(name)) {
			          addProp(el, name, value);
			        } else {
			          addAttr(el, name, value);
			        }
			      } else if (onRE.test(name)) { // v-on
			        name = name.replace(onRE, '');
			        addHandler(el, name, value, modifiers);
			      } else { // normal directives
			        name = name.replace(dirRE, '');
			        // parse arg
			        var argMatch = name.match(argRE);
			        if (argMatch && (arg = argMatch[1])) {
			          name = name.slice(0, -(arg.length + 1));
			        }
			        addDirective(el, name, rawName, value, arg, modifiers);
			        if ("development" !== 'production' && name === 'model') {
			          checkForAliasModel(el, value);
			        }
			      }
			    } else {
			      // literal attribute
			      {
			        var expression = parseText(value, delimiters);
			        if (expression) {
			          warn$1(
			            name + "=\"" + value + "\": " +
			            'Interpolation inside attributes has been removed. ' +
			            'Use v-bind or the colon shorthand instead. For example, ' +
			            'instead of <div id="{{ val }}">, use <div :id="val">.'
			          );
			        }
			      }
			      addAttr(el, name, JSON.stringify(value));
			    }
			  }
			}

			function checkInFor (el) {
			  var parent = el;
			  while (parent) {
			    if (parent.for !== undefined) {
			      return true
			    }
			    parent = parent.parent;
			  }
			  return false
			}

			function parseModifiers (name) {
			  var match = name.match(modifierRE);
			  if (match) {
			    var ret = {};
			    match.forEach(function (m) { ret[m.slice(1)] = true; });
			    return ret
			  }
			}

			function makeAttrsMap (attrs, isIE) {
			  var map = {};
			  for (var i = 0, l = attrs.length; i < l; i++) {
			    if ("development" !== 'production' && map[attrs[i].name] && !isIE) {
			      warn$1('duplicate attribute: ' + attrs[i].name);
			    }
			    map[attrs[i].name] = attrs[i].value;
			  }
			  return map
			}

			function findPrevElement (children) {
			  var i = children.length;
			  while (i--) {
			    if (children[i].tag) { return children[i] }
			  }
			}

			function isForbiddenTag (el) {
			  return (
			    el.tag === 'style' ||
			    (el.tag === 'script' && (
			      !el.attrsMap.type ||
			      el.attrsMap.type === 'text/javascript'
			    ))
			  )
			}

			var ieNSBug = /^xmlns:NS\d+/;
			var ieNSPrefix = /^NS\d+:/;

			/* istanbul ignore next */
			function guardIESVGBug (attrs) {
			  var res = [];
			  for (var i = 0; i < attrs.length; i++) {
			    var attr = attrs[i];
			    if (!ieNSBug.test(attr.name)) {
			      attr.name = attr.name.replace(ieNSPrefix, '');
			      res.push(attr);
			    }
			  }
			  return res
			}

			function checkForAliasModel (el, value) {
			  var _el = el;
			  while (_el) {
			    if (_el.for && _el.alias === value) {
			      warn$1(
			        "<" + (el.tag) + " v-model=\"" + value + "\">: " +
			        "You are binding v-model directly to a v-for iteration alias. " +
			        "This will not be able to modify the v-for source array because " +
			        "writing to the alias is like modifying a function local variable. " +
			        "Consider using an array of objects and use v-model on an object property instead."
			      );
			    }
			    _el = _el.parent;
			  }
			}

			/*  */

			var isStaticKey;
			var isPlatformReservedTag;

			var genStaticKeysCached = cached(genStaticKeys$1);

			/**
			 * Goal of the optimizer: walk the generated template AST tree
			 * and detect sub-trees that are purely static, i.e. parts of
			 * the DOM that never needs to change.
			 *
			 * Once we detect these sub-trees, we can:
			 *
			 * 1. Hoist them into constants, so that we no longer need to
			 *    create fresh nodes for them on each re-render;
			 * 2. Completely skip them in the patching process.
			 */
			function optimize (root, options) {
			  if (!root) { return }
			  isStaticKey = genStaticKeysCached(options.staticKeys || '');
			  isPlatformReservedTag = options.isReservedTag || (function () { return false; });
			  // first pass: mark all non-static nodes.
			  markStatic(root);
			  // second pass: mark static roots.
			  markStaticRoots(root, false);
			}

			function genStaticKeys$1 (keys) {
			  return makeMap(
			    'type,tag,attrsList,attrsMap,plain,parent,children,attrs' +
			    (keys ? ',' + keys : '')
			  )
			}

			function markStatic (node) {
			  node.static = isStatic(node);
			  if (node.type === 1) {
			    for (var i = 0, l = node.children.length; i < l; i++) {
			      var child = node.children[i];
			      markStatic(child);
			      if (!child.static) {
			        node.static = false;
			      }
			    }
			  }
			}

			function markStaticRoots (node, isInFor) {
			  if (node.type === 1) {
			    if (node.static || node.once) {
			      node.staticInFor = isInFor;
			    }
			    if (node.static) {
			      node.staticRoot = true;
			      return
			    }
			    if (node.children) {
			      for (var i = 0, l = node.children.length; i < l; i++) {
			        markStaticRoots(node.children[i], isInFor || !!node.for);
			      }
			    }
			  }
			}

			function isStatic (node) {
			  if (node.type === 2) { // expression
			    return false
			  }
			  if (node.type === 3) { // text
			    return true
			  }
			  return !!(node.pre || (
			    !node.hasBindings && // no dynamic bindings
			    !node.if && !node.for && // not v-if or v-for or v-else
			    !isBuiltInTag(node.tag) && // not a built-in
			    isPlatformReservedTag(node.tag) && // not a component
			    !isDirectChildOfTemplateFor(node) &&
			    Object.keys(node).every(isStaticKey)
			  ))
			}

			function isDirectChildOfTemplateFor (node) {
			  while (node.parent) {
			    node = node.parent;
			    if (node.tag !== 'template') {
			      return false
			    }
			    if (node.for) {
			      return true
			    }
			  }
			  return false
			}

			/*  */

			var simplePathRE = /^\s*[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['.*?']|\[".*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*\s*$/;

			// keyCode aliases
			var keyCodes = {
			  esc: 27,
			  tab: 9,
			  enter: 13,
			  space: 32,
			  up: 38,
			  left: 37,
			  right: 39,
			  down: 40,
			  'delete': [8, 46]
			};

			var modifierCode = {
			  stop: '$event.stopPropagation();',
			  prevent: '$event.preventDefault();',
			  self: 'if($event.target !== $event.currentTarget)return;'
			};

			function genHandlers (events, native) {
			  var res = native ? 'nativeOn:{' : 'on:{';
			  for (var name in events) {
			    res += "\"" + name + "\":" + (genHandler(events[name])) + ",";
			  }
			  return res.slice(0, -1) + '}'
			}

			function genHandler (
			  handler
			) {
			  if (!handler) {
			    return 'function(){}'
			  } else if (Array.isArray(handler)) {
			    return ("[" + (handler.map(genHandler).join(',')) + "]")
			  } else if (!handler.modifiers) {
			    return simplePathRE.test(handler.value)
			      ? handler.value
			      : ("function($event){" + (handler.value) + "}")
			  } else {
			    var code = '';
			    var keys = [];
			    for (var key in handler.modifiers) {
			      if (modifierCode[key]) {
			        code += modifierCode[key];
			      } else {
			        keys.push(key);
			      }
			    }
			    if (keys.length) {
			      code = genKeyFilter(keys) + code;
			    }
			    var handlerCode = simplePathRE.test(handler.value)
			      ? handler.value + '($event)'
			      : handler.value;
			    return 'function($event){' + code + handlerCode + '}'
			  }
			}

			function genKeyFilter (keys) {
			  var code = keys.length === 1
			    ? normalizeKeyCode(keys[0])
			    : Array.prototype.concat.apply([], keys.map(normalizeKeyCode));
			  if (Array.isArray(code)) {
			    return ("if(" + (code.map(function (c) { return ("$event.keyCode!==" + c); }).join('&&')) + ")return;")
			  } else {
			    return ("if($event.keyCode!==" + code + ")return;")
			  }
			}

			function normalizeKeyCode (key) {
			  return (
			    parseInt(key, 10) || // number keyCode
			    keyCodes[key] || // built-in alias
			    ("_k(" + (JSON.stringify(key)) + ")") // custom alias
			  )
			}

			/*  */

			function bind$2 (el, dir) {
			  el.wrapData = function (code) {
			    return ("_b(" + code + "," + (dir.value) + (dir.modifiers && dir.modifiers.prop ? ',true' : '') + ")")
			  };
			}

			var baseDirectives = {
			  bind: bind$2,
			  cloak: noop
			};

			/*  */

			// configurable state
			var warn$2;
			var transforms$1;
			var dataGenFns;
			var platformDirectives$1;
			var staticRenderFns;
			var onceCount;
			var currentOptions;

			function generate (
			  ast,
			  options
			) {
			  // save previous staticRenderFns so generate calls can be nested
			  var prevStaticRenderFns = staticRenderFns;
			  var currentStaticRenderFns = staticRenderFns = [];
			  var prevOnceCount = onceCount;
			  onceCount = 0;
			  currentOptions = options;
			  warn$2 = options.warn || baseWarn;
			  transforms$1 = pluckModuleFunction(options.modules, 'transformCode');
			  dataGenFns = pluckModuleFunction(options.modules, 'genData');
			  platformDirectives$1 = options.directives || {};
			  var code = ast ? genElement(ast) : '_h("div")';
			  staticRenderFns = prevStaticRenderFns;
			  onceCount = prevOnceCount;
			  return {
			    render: ("with(this){return " + code + "}"),
			    staticRenderFns: currentStaticRenderFns
			  }
			}

			function genElement (el) {
			  if (el.staticRoot && !el.staticProcessed) {
			    return genStatic(el)
			  } else if (el.once && !el.onceProcessed) {
			    return genOnce(el)
			  } else if (el.for && !el.forProcessed) {
			    return genFor(el)
			  } else if (el.if && !el.ifProcessed) {
			    return genIf(el)
			  } else if (el.tag === 'template' && !el.slotTarget) {
			    return genChildren(el) || 'void 0'
			  } else if (el.tag === 'slot') {
			    return genSlot(el)
			  } else {
			    // component or element
			    var code;
			    if (el.component) {
			      code = genComponent(el.component, el);
			    } else {
			      var data = el.plain ? undefined : genData(el);

			      var children = el.inlineTemplate ? null : genChildren(el);
			      code = "_h('" + (el.tag) + "'" + (data ? ("," + data) : '') + (children ? ("," + children) : '') + ")";
			    }
			    // module transforms
			    for (var i = 0; i < transforms$1.length; i++) {
			      code = transforms$1[i](el, code);
			    }
			    return code
			  }
			}

			// hoist static sub-trees out
			function genStatic (el) {
			  el.staticProcessed = true;
			  staticRenderFns.push(("with(this){return " + (genElement(el)) + "}"));
			  return ("_m(" + (staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + ")")
			}

			// v-once
			function genOnce (el) {
			  el.onceProcessed = true;
			  if (el.staticInFor) {
			    var key = '';
			    var parent = el.parent;
			    while (parent) {
			      if (parent.for) {
			        key = parent.key;
			        break
			      }
			      parent = parent.parent;
			    }
			    if (!key) {
			      "development" !== 'production' && warn$2(
			        "v-once can only be used inside v-for that is keyed. "
			      );
			      return genElement(el)
			    }
			    return ("_o(" + (genElement(el)) + "," + (onceCount++) + (key ? ("," + key) : "") + ")")
			  } else {
			    return genStatic(el)
			  }
			}

			function genIf (el) {
			  var exp = el.if;
			  el.ifProcessed = true; // avoid recursion
			  return ("(" + exp + ")?" + (genElement(el)) + ":" + (genElse(el)))
			}

			function genElse (el) {
			  return el.elseBlock
			    ? genElement(el.elseBlock)
			    : '_e()'
			}

			function genFor (el) {
			  var exp = el.for;
			  var alias = el.alias;
			  var iterator1 = el.iterator1 ? ("," + (el.iterator1)) : '';
			  var iterator2 = el.iterator2 ? ("," + (el.iterator2)) : '';
			  el.forProcessed = true; // avoid recursion
			  return "_l((" + exp + ")," +
			    "function(" + alias + iterator1 + iterator2 + "){" +
			      "return " + (genElement(el)) +
			    '})'
			}

			function genData (el) {
			  var data = '{';

			  // directives first.
			  // directives may mutate the el's other properties before they are generated.
			  var dirs = genDirectives(el);
			  if (dirs) { data += dirs + ','; }

			  // key
			  if (el.key) {
			    data += "key:" + (el.key) + ",";
			  }
			  // ref
			  if (el.ref) {
			    data += "ref:" + (el.ref) + ",";
			  }
			  if (el.refInFor) {
			    data += "refInFor:true,";
			  }
			  // record original tag name for components using "is" attribute
			  if (el.component) {
			    data += "tag:\"" + (el.tag) + "\",";
			  }
			  // slot target
			  if (el.slotTarget) {
			    data += "slot:" + (el.slotTarget) + ",";
			  }
			  // module data generation functions
			  for (var i = 0; i < dataGenFns.length; i++) {
			    data += dataGenFns[i](el);
			  }
			  // attributes
			  if (el.attrs) {
			    data += "attrs:{" + (genProps(el.attrs)) + "},";
			  }
			  // DOM props
			  if (el.props) {
			    data += "domProps:{" + (genProps(el.props)) + "},";
			  }
			  // event handlers
			  if (el.events) {
			    data += (genHandlers(el.events)) + ",";
			  }
			  if (el.nativeEvents) {
			    data += (genHandlers(el.nativeEvents, true)) + ",";
			  }
			  // inline-template
			  if (el.inlineTemplate) {
			    var ast = el.children[0];
			    if ("development" !== 'production' && (
			      el.children.length > 1 || ast.type !== 1
			    )) {
			      warn$2('Inline-template components must have exactly one child element.');
			    }
			    if (ast.type === 1) {
			      var inlineRenderFns = generate(ast, currentOptions);
			      data += "inlineTemplate:{render:function(){" + (inlineRenderFns.render) + "},staticRenderFns:[" + (inlineRenderFns.staticRenderFns.map(function (code) { return ("function(){" + code + "}"); }).join(',')) + "]}";
			    }
			  }
			  data = data.replace(/,$/, '') + '}';
			  // v-bind data wrap
			  if (el.wrapData) {
			    data = el.wrapData(data);
			  }
			  return data
			}

			function genDirectives (el) {
			  var dirs = el.directives;
			  if (!dirs) { return }
			  var res = 'directives:[';
			  var hasRuntime = false;
			  var i, l, dir, needRuntime;
			  for (i = 0, l = dirs.length; i < l; i++) {
			    dir = dirs[i];
			    needRuntime = true;
			    var gen = platformDirectives$1[dir.name] || baseDirectives[dir.name];
			    if (gen) {
			      // compile-time directive that manipulates AST.
			      // returns true if it also needs a runtime counterpart.
			      needRuntime = !!gen(el, dir, warn$2);
			    }
			    if (needRuntime) {
			      hasRuntime = true;
			      res += "{name:\"" + (dir.name) + "\",rawName:\"" + (dir.rawName) + "\"" + (dir.value ? (",value:(" + (dir.value) + "),expression:" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (",arg:\"" + (dir.arg) + "\"") : '') + (dir.modifiers ? (",modifiers:" + (JSON.stringify(dir.modifiers))) : '') + "},";
			    }
			  }
			  if (hasRuntime) {
			    return res.slice(0, -1) + ']'
			  }
			}

			function genChildren (el) {
			  if (el.children.length) {
			    return '[' + el.children.map(genNode).join(',') + ']'
			  }
			}

			function genNode (node) {
			  if (node.type === 1) {
			    return genElement(node)
			  } else {
			    return genText(node)
			  }
			}

			function genText (text) {
			  return text.type === 2
			    ? text.expression // no need for () because already wrapped in _s()
			    : JSON.stringify(text.text)
			}

			function genSlot (el) {
			  var slotName = el.slotName || '"default"';
			  var children = genChildren(el);
			  return ("_t(" + slotName + (children ? ("," + children) : '') + ")")
			}

			// componentName is el.component, take it as argument to shun flow's pessimistic refinement
			function genComponent (componentName, el) {
			  var children = el.inlineTemplate ? null : genChildren(el);
			  return ("_h(" + componentName + "," + (genData(el)) + (children ? ("," + children) : '') + ")")
			}

			function genProps (props) {
			  var res = '';
			  for (var i = 0; i < props.length; i++) {
			    var prop = props[i];
			    res += "\"" + (prop.name) + "\":" + (prop.value) + ",";
			  }
			  return res.slice(0, -1)
			}

			/*  */

			/**
			 * Compile a template.
			 */
			function compile$1 (
			  template,
			  options
			) {
			  var ast = parse(template.trim(), options);
			  optimize(ast, options);
			  var code = generate(ast, options);
			  return {
			    ast: ast,
			    render: code.render,
			    staticRenderFns: code.staticRenderFns
			  }
			}

			/*  */

			// operators like typeof, instanceof and in are allowed
			var prohibitedKeywordRE = new RegExp('\\b' + (
			  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +
			  'super,throw,while,yield,delete,export,import,return,switch,default,' +
			  'extends,finally,continue,debugger,function,arguments'
			).split(',').join('\\b|\\b') + '\\b');
			// check valid identifier for v-for
			var identRE = /[A-Za-z_$][\w$]*/;
			// strip strings in expressions
			var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;

			// detect problematic expressions in a template
			function detectErrors (ast) {
			  var errors = [];
			  if (ast) {
			    checkNode(ast, errors);
			  }
			  return errors
			}

			function checkNode (node, errors) {
			  if (node.type === 1) {
			    for (var name in node.attrsMap) {
			      if (dirRE.test(name)) {
			        var value = node.attrsMap[name];
			        if (value) {
			          if (name === 'v-for') {
			            checkFor(node, ("v-for=\"" + value + "\""), errors);
			          } else {
			            checkExpression(value, (name + "=\"" + value + "\""), errors);
			          }
			        }
			      }
			    }
			    if (node.children) {
			      for (var i = 0; i < node.children.length; i++) {
			        checkNode(node.children[i], errors);
			      }
			    }
			  } else if (node.type === 2) {
			    checkExpression(node.expression, node.text, errors);
			  }
			}

			function checkFor (node, text, errors) {
			  checkExpression(node.for || '', text, errors);
			  checkIdentifier(node.alias, 'v-for alias', text, errors);
			  checkIdentifier(node.iterator1, 'v-for iterator', text, errors);
			  checkIdentifier(node.iterator2, 'v-for iterator', text, errors);
			}

			function checkIdentifier (ident, type, text, errors) {
			  if (typeof ident === 'string' && !identRE.test(ident)) {
			    errors.push(("- invalid " + type + " \"" + ident + "\" in expression: " + text));
			  }
			}

			function checkExpression (exp, text, errors) {
			  try {
			    new Function(("return " + exp));
			  } catch (e) {
			    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);
			    if (keywordMatch) {
			      errors.push(
			        "- avoid using JavaScript keyword as property name: " +
			        "\"" + (keywordMatch[0]) + "\" in expression " + text
			      );
			    } else {
			      errors.push(("- invalid expression: " + text));
			    }
			  }
			}

			/*  */

			function transformNode (el, options) {
			  var warn = options.warn || baseWarn;
			  var staticClass = getAndRemoveAttr(el, 'class');
			  if ("development" !== 'production' && staticClass) {
			    var expression = parseText(staticClass, options.delimiters);
			    if (expression) {
			      warn(
			        "class=\"" + staticClass + "\": " +
			        'Interpolation inside attributes has been removed. ' +
			        'Use v-bind or the colon shorthand instead. For example, ' +
			        'instead of <div class="{{ val }}">, use <div :class="val">.'
			      );
			    }
			  }
			  if (staticClass) {
			    el.staticClass = JSON.stringify(staticClass);
			  }
			  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);
			  if (classBinding) {
			    el.classBinding = classBinding;
			  }
			}

			function genData$1 (el) {
			  var data = '';
			  if (el.staticClass) {
			    data += "staticClass:" + (el.staticClass) + ",";
			  }
			  if (el.classBinding) {
			    data += "class:" + (el.classBinding) + ",";
			  }
			  return data
			}

			var klass$1 = {
			  staticKeys: ['staticClass'],
			  transformNode: transformNode,
			  genData: genData$1
			};

			/*  */

			function transformNode$1 (el) {
			  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);
			  if (styleBinding) {
			    el.styleBinding = styleBinding;
			  }
			}

			function genData$2 (el) {
			  return el.styleBinding
			    ? ("style:(" + (el.styleBinding) + "),")
			    : ''
			}

			var style$1 = {
			  transformNode: transformNode$1,
			  genData: genData$2
			};

			var modules$1 = [
			  klass$1,
			  style$1
			];

			/*  */

			var len;
			var str;
			var chr;
			var index$1;
			var expressionPos;
			var expressionEndPos;

			/**
			 * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)
			 *
			 * for loop possible cases:
			 *
			 * - test
			 * - test[idx]
			 * - test[test1[idx]]
			 * - test["a"][idx]
			 * - xxx.test[a[a].test1[idx]]
			 * - test.xxx.a["asa"][test1[idx]]
			 *
			 */

			function parseModel (val) {
			  str = val;
			  len = str.length;
			  index$1 = expressionPos = expressionEndPos = 0;

			  if (val.indexOf('[') < 0) {
			    return {
			      exp: val,
			      idx: null
			    }
			  }

			  while (!eof()) {
			    chr = next();
			    /* istanbul ignore if */
			    if (isStringStart(chr)) {
			      parseString(chr);
			    } else if (chr === 0x5B) {
			      parseBracket(chr);
			    }
			  }

			  return {
			    exp: val.substring(0, expressionPos),
			    idx: val.substring(expressionPos + 1, expressionEndPos)
			  }
			}

			function next () {
			  return str.charCodeAt(++index$1)
			}

			function eof () {
			  return index$1 >= len
			}

			function isStringStart (chr) {
			  return chr === 0x22 || chr === 0x27
			}

			function parseBracket (chr) {
			  var inBracket = 1;
			  expressionPos = index$1;
			  while (!eof()) {
			    chr = next();
			    if (isStringStart(chr)) {
			      parseString(chr);
			      continue
			    }
			    if (chr === 0x5B) { inBracket++; }
			    if (chr === 0x5D) { inBracket--; }
			    if (inBracket === 0) {
			      expressionEndPos = index$1;
			      break
			    }
			  }
			}

			function parseString (chr) {
			  var stringQuote = chr;
			  while (!eof()) {
			    chr = next();
			    if (chr === stringQuote) {
			      break
			    }
			  }
			}

			/*  */

			var warn$3;

			function model$1 (
			  el,
			  dir,
			  _warn
			) {
			  warn$3 = _warn;
			  var value = dir.value;
			  var modifiers = dir.modifiers;
			  var tag = el.tag;
			  var type = el.attrsMap.type;
			  {
			    var dynamicType = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];
			    if (tag === 'input' && dynamicType) {
			      warn$3(
			        "<input :type=\"" + dynamicType + "\" v-model=\"" + value + "\">:\n" +
			        "v-model does not support dynamic input types. Use v-if branches instead."
			      );
			    }
			  }
			  if (tag === 'select') {
			    genSelect(el, value, modifiers);
			  } else if (tag === 'input' && type === 'checkbox') {
			    genCheckboxModel(el, value, modifiers);
			  } else if (tag === 'input' && type === 'radio') {
			    genRadioModel(el, value, modifiers);
			  } else {
			    genDefaultModel(el, value, modifiers);
			  }
			  // ensure runtime directive metadata
			  return true
			}

			function genCheckboxModel (
			  el,
			  value,
			  modifiers
			) {
			  if ("development" !== 'production' &&
			    el.attrsMap.checked != null) {
			    warn$3(
			      "<" + (el.tag) + " v-model=\"" + value + "\" checked>:\n" +
			      "inline checked attributes will be ignored when using v-model. " +
			      'Declare initial values in the component\'s data option instead.'
			    );
			  }
			  var number = modifiers && modifiers.number;
			  var valueBinding = getBindingAttr(el, 'value') || 'null';
			  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';
			  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';
			  addProp(el, 'checked',
			    "Array.isArray(" + value + ")" +
			      "?_i(" + value + "," + valueBinding + ")>-1" +
			      ":_q(" + value + "," + trueValueBinding + ")"
			  );
			  addHandler(el, 'change',
			    "var $$a=" + value + "," +
			        '$$el=$event.target,' +
			        "$$c=$$el.checked?(" + trueValueBinding + "):(" + falseValueBinding + ");" +
			    'if(Array.isArray($$a)){' +
			      "var $$v=" + (number ? '_n(' + valueBinding + ')' : valueBinding) + "," +
			          '$$i=_i($$a,$$v);' +
			      "if($$c){$$i<0&&(" + value + "=$$a.concat($$v))}" +
			      "else{$$i>-1&&(" + value + "=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}" +
			    "}else{" + value + "=$$c}",
			    null, true
			  );
			}

			function genRadioModel (
			    el,
			    value,
			    modifiers
			) {
			  if ("development" !== 'production' &&
			    el.attrsMap.checked != null) {
			    warn$3(
			      "<" + (el.tag) + " v-model=\"" + value + "\" checked>:\n" +
			      "inline checked attributes will be ignored when using v-model. " +
			      'Declare initial values in the component\'s data option instead.'
			    );
			  }
			  var number = modifiers && modifiers.number;
			  var valueBinding = getBindingAttr(el, 'value') || 'null';
			  valueBinding = number ? ("_n(" + valueBinding + ")") : valueBinding;
			  addProp(el, 'checked', ("_q(" + value + "," + valueBinding + ")"));
			  addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);
			}

			function genDefaultModel (
			  el,
			  value,
			  modifiers
			) {
			  {
			    if (el.tag === 'input' && el.attrsMap.value) {
			      warn$3(
			        "<" + (el.tag) + " v-model=\"" + value + "\" value=\"" + (el.attrsMap.value) + "\">:\n" +
			        'inline value attributes will be ignored when using v-model. ' +
			        'Declare initial values in the component\'s data option instead.'
			      );
			    }
			    if (el.tag === 'textarea' && el.children.length) {
			      warn$3(
			        "<textarea v-model=\"" + value + "\">:\n" +
			        'inline content inside <textarea> will be ignored when using v-model. ' +
			        'Declare initial values in the component\'s data option instead.'
			      );
			    }
			  }

			  var type = el.attrsMap.type;
			  var ref = modifiers || {};
			  var lazy = ref.lazy;
			  var number = ref.number;
			  var trim = ref.trim;
			  var event = lazy || (isIE && type === 'range') ? 'change' : 'input';
			  var needCompositionGuard = !lazy && type !== 'range';
			  var isNative = el.tag === 'input' || el.tag === 'textarea';

			  var valueExpression = isNative
			    ? ("$event.target.value" + (trim ? '.trim()' : ''))
			    : "$event";
			  valueExpression = number || type === 'number'
			    ? ("_n(" + valueExpression + ")")
			    : valueExpression;
			  var code = genAssignmentCode(value, valueExpression);
			  if (isNative && needCompositionGuard) {
			    code = "if($event.target.composing)return;" + code;
			  }
			  // inputs with type="file" are read only and setting the input's
			  // value will throw an error.
			  if ("development" !== 'production' &&
			      type === 'file') {
			    warn$3(
			      "<" + (el.tag) + " v-model=\"" + value + "\" type=\"file\">:\n" +
			      "File inputs are read only. Use a v-on:change listener instead."
			    );
			  }
			  addProp(el, 'value', isNative ? ("_s(" + value + ")") : ("(" + value + ")"));
			  addHandler(el, event, code, null, true);
			}

			function genSelect (
			    el,
			    value,
			    modifiers
			) {
			  {
			    el.children.some(checkOptionWarning);
			  }

			  var number = modifiers && modifiers.number;
			  var assignment = "Array.prototype.filter" +
			    ".call($event.target.options,function(o){return o.selected})" +
			    ".map(function(o){var val = \"_value\" in o ? o._value : o.value;" +
			    "return " + (number ? '_n(val)' : 'val') + "})" +
			    (el.attrsMap.multiple == null ? '[0]' : '');

			  var code = genAssignmentCode(value, assignment);
			  addHandler(el, 'change', code, null, true);
			}

			function checkOptionWarning (option) {
			  if (option.type === 1 &&
			    option.tag === 'option' &&
			    option.attrsMap.selected != null) {
			    warn$3(
			      "<select v-model=\"" + (option.parent.attrsMap['v-model']) + "\">:\n" +
			      'inline selected attributes on <option> will be ignored when using v-model. ' +
			      'Declare initial values in the component\'s data option instead.'
			    );
			    return true
			  }
			  return false
			}

			function genAssignmentCode (value, assignment) {
			  var modelRs = parseModel(value);
			  if (modelRs.idx === null) {
			    return (value + "=" + assignment)
			  } else {
			    return "var $$exp = " + (modelRs.exp) + ", $$idx = " + (modelRs.idx) + ";" +
			      "if (!Array.isArray($$exp)){" +
			        value + "=" + assignment + "}" +
			      "else{$$exp.splice($$idx, 1, " + assignment + ")}"
			  }
			}

			/*  */

			function text (el, dir) {
			  if (dir.value) {
			    addProp(el, 'textContent', ("_s(" + (dir.value) + ")"));
			  }
			}

			/*  */

			function html (el, dir) {
			  if (dir.value) {
			    addProp(el, 'innerHTML', ("_s(" + (dir.value) + ")"));
			  }
			}

			var directives$1 = {
			  model: model$1,
			  text: text,
			  html: html
			};

			/*  */

			var cache = Object.create(null);

			var baseOptions = {
			  isIE: isIE,
			  expectHTML: true,
			  modules: modules$1,
			  staticKeys: genStaticKeys(modules$1),
			  directives: directives$1,
			  isReservedTag: isReservedTag,
			  isUnaryTag: isUnaryTag,
			  mustUseProp: mustUseProp,
			  getTagNamespace: getTagNamespace,
			  isPreTag: isPreTag
			};

			function compile$$1 (
			  template,
			  options
			) {
			  options = options
			    ? extend(extend({}, baseOptions), options)
			    : baseOptions;
			  return compile$1(template, options)
			}

			function compileToFunctions (
			  template,
			  options,
			  vm
			) {
			  var _warn = (options && options.warn) || warn;
			  // detect possible CSP restriction
			  /* istanbul ignore if */
			  {
			    try {
			      new Function('return 1');
			    } catch (e) {
			      if (e.toString().match(/unsafe-eval|CSP/)) {
			        _warn(
			          'It seems you are using the standalone build of Vue.js in an ' +
			          'environment with Content Security Policy that prohibits unsafe-eval. ' +
			          'The template compiler cannot work in this environment. Consider ' +
			          'relaxing the policy to allow unsafe-eval or pre-compiling your ' +
			          'templates into render functions.'
			        );
			      }
			    }
			  }
			  var key = options && options.delimiters
			    ? String(options.delimiters) + template
			    : template;
			  if (cache[key]) {
			    return cache[key]
			  }
			  var res = {};
			  var compiled = compile$$1(template, options);
			  res.render = makeFunction(compiled.render);
			  var l = compiled.staticRenderFns.length;
			  res.staticRenderFns = new Array(l);
			  for (var i = 0; i < l; i++) {
			    res.staticRenderFns[i] = makeFunction(compiled.staticRenderFns[i]);
			  }
			  {
			    if (res.render === noop || res.staticRenderFns.some(function (fn) { return fn === noop; })) {
			      _warn(
			        "failed to compile template:\n\n" + template + "\n\n" +
			        detectErrors(compiled.ast).join('\n') +
			        '\n\n',
			        vm
			      );
			    }
			  }
			  return (cache[key] = res)
			}

			function makeFunction (code) {
			  try {
			    return new Function(code)
			  } catch (e) {
			    return noop
			  }
			}

			/*  */

			var idToTemplate = cached(function (id) {
			  var el = query(id);
			  return el && el.innerHTML
			});

			var mount = Vue$2.prototype.$mount;
			Vue$2.prototype.$mount = function (
			  el,
			  hydrating
			) {
			  el = el && query(el);

			  /* istanbul ignore if */
			  if (el === document.body || el === document.documentElement) {
			    "development" !== 'production' && warn(
			      "Do not mount Vue to <html> or <body> - mount to normal elements instead."
			    );
			    return this
			  }

			  var options = this.$options;
			  // resolve template/el and convert to render function
			  if (!options.render) {
			    var template = options.template;
			    if (template) {
			      if (typeof template === 'string') {
			        if (template.charAt(0) === '#') {
			          template = idToTemplate(template);
			        }
			      } else if (template.nodeType) {
			        template = template.innerHTML;
			      } else {
			        {
			          warn('invalid template option:' + template, this);
			        }
			        return this
			      }
			    } else if (el) {
			      template = getOuterHTML(el);
			    }
			    if (template) {
			      var ref = compileToFunctions(template, {
			        warn: warn,
			        shouldDecodeNewlines: shouldDecodeNewlines,
			        delimiters: options.delimiters
			      }, this);
			      var render = ref.render;
			      var staticRenderFns = ref.staticRenderFns;
			      options.render = render;
			      options.staticRenderFns = staticRenderFns;
			    }
			  }
			  return mount.call(this, el, hydrating)
			};

			/**
			 * Get outerHTML of elements, taking care
			 * of SVG elements in IE as well.
			 */
			function getOuterHTML (el) {
			  if (el.outerHTML) {
			    return el.outerHTML
			  } else {
			    var container = document.createElement('div');
			    container.appendChild(el.cloneNode(true));
			    return container.innerHTML
			  }
			}

			Vue$2.compile = compileToFunctions;

			return Vue$2;

			})));


		/***/ },
		/* 3 */
		/***/ function(module, exports, __webpack_require__) {

			var Vue = __webpack_require__(2);
			new Vue({
			    el: '#gamearea',
			    data: {
			        length: 6,
			        message: 'Hello Vue!',
			        items: [
			            { name: 'vedge vedgeAnim edge' },
			            { name: 'vedge vedgeAnim edge' }
			        ]
			    }
			})

		/***/ },
		/* 4 */
		/***/ function(module, exports, __webpack_require__) {

			var $ = __webpack_require__(5);
			// Global variables
			var boardSize = 6;
			var tunnelLength = 12;
			var maxTunnelLength;
			var numProbes = 0;
			var probesList = [];
			var tunnel = new Tunnel();
			var finalTunnelGuess = [];
			var gameMode = -1;
			// 0 = Regular
			// 1 = Easy Mode
			var player1Name = "";
			var player2Name = "";
			var player1Score = 0;
			var player2Score = 0;
			var round = 1;
			var winningScore = 0;
			var winningPlayer = "";
			var computer = -1;
			// 0 = Humans
			// 1 = AI
			var gameState = -1;
			// 0 = badGuy placing tunnels
			// 1 = detector placing 1st hour probes
			// 2 = detector placing 2nd hour probes
			// 3 = detector placing 3rd hour probes
			// 4 = detector detecting


			// Clear the board before a new game
			var clearBoard = function () {
			    $(".animate").filter(function() {
			        $(this).removeClass("animate");
			    });
			    $(".final").filter(function() {
			        $(this).removeClass("final");
			    });
			    $(".detectedEdge").filter(function() {
			        $(this).removeClass("detectedEdge");
			    });
			    $(".reveal").filter(function() {
			        $(this).removeClass("reveal");
			    });
			}

			function Node(id) {
			    this.edges = [];
			    this.id = id;

			    this.addEdge = function(e0) {
			        this.edges.push(e0);
			    };

			    this.removeEdge = function(e0) {
			        var index = this.edges.indexOf(e0);
			        this.edges.splice(index, 1);
			    }
			}

			Node.prototype.toString = function nodeToString() {
			    var ret = this.id + ": ";
			    for (var i = 0; i < this.edges.length; i++) {
			        ret += (this.edges[i].id + " ");
			    }
			    return ret;
			}

			function Edge(n1, n2, id) {
			    this.n1 = n1;
			    this.n2 = n2;
			    this.id = id;
			    this.allNodes = [];
			}

			Edge.prototype.toString = function edgeToString() {
			    var ret = this.id + ": ";
			    console.log(ret)
			    for (var i = 0; i < this.allNodes.length; i++) {
			        ret += (this.allNodes[i].id + " ");
			    }
			    return ret;
			}

			function Tunnel() {
			    this.edges = {};
			    this.nodes = {};

			    this.addNode = function(node) {
			        var nodeId = node.id;
			        this.nodes[nodeId] = node;
			    };

			    this.removeNode = function(node) {
			        var nodeId = node.id;
			        delete this.nodes[nodeId];
			    };

			    this.addEdge = function(edge) {
			        var edgeId = edge.id;
			        this.edges[edgeId] = edge;
			    };

			    this.removeEdge = function(edge1) {
			        var edgeId = edge1.id;
			        delete this.edges[edgeId];
			    };

			    this.getStartNode = function() {
			        // Get all nodes that are touching the top row
			        var starts = [];
			        for (var nodeId in this.nodes) {
			            if (!this.nodes.hasOwnProperty(nodeId)) {
			                //not direct property of nodes
			                continue;
			            }

			            node = this.nodes[nodeId];
			            if (Number(node.id) < (boardSize + 1)) {
			                starts.push(node);
			            }
			        }

			        // Out of all nodes on top row, get all that have just one edge
			        var validStarts = [];
			        for (var i = 0; i < starts.length; i++) {
			            if (starts[i].edges.length == 1) {
			                validStarts.push(starts[i]);
			                console.log("valid starts: ", validStarts);
			            }
			        }

			        // If there is just one such node, it's our start
			        // Else there isn't a valid start node and tunnel is invalid
			        console.log("length of validStarts: ", validStarts.length);
			        if (validStarts.length == 1) {
			            console.log("validStarts[0] is ", validStarts[0]);
			            return validStarts[0];
			        }
			        else {
			            return null;
			        }
			    };

			    this.getEndNode = function() {
			        // Get all nodes that are touching the bottom row
			        var ends = [];
			        for (var nodeId in this.nodes) {
			            if (!this.nodes.hasOwnProperty(nodeId)) {
			                // Not direct property of nodes
			                continue;
			            }

			            node = this.nodes[nodeId];
			            if (Number(node.id) >= (boardSize * (boardSize + 1))) {
			                ends.push(node);
			            }
			        }

			        // Out of all nodes on top row, get all that have just one edge
			        var validEnds = [];
			        for (var i = 0; i < ends.length; i++) {
			            if (ends[i].edges.length == 1) {
			                validEnds.push(ends[i]);
			            }
			        }

			        // If there is just one such node, it's our start
			        // Else there isn't a valid start node and tunnel is invalid
			        if (validEnds.length == 1) {
			            return validEnds[0];
			        }
			        else {
			            return null;
			        }
			    };

			    this.validTunnel = function() {
			        console.log("EDGE INFO ", this.edges);
			        console.log("NODES ", this.nodes);
			        //duplicate nodes and edges
			        var allEdgeIds = [];
			        for (var item in this.edges) {
			            allEdgeIds.push(item);
			        }
			        console.log("All edge ids: ", allEdgeIds);
			        var allNodeIds = [];
			        for (var item in this.nodes) {
			            allNodeIds.push(item);
			        }
			        console.log("All nodes: ", allNodeIds);

			        var currNode = this.getStartNode();
			        console.log("Start node: ", currNode);

			        //if there is no start node, tunnel is invalid
			        if (currNode == null) {
			            return false;
			        }

			        //if there is no end node, tunnel is invalid
			        if (this.getEndNode() == null) {
			            return false;
			        }
			        console.log("end node: ", this.getEndNode());

			        //remove start node and it's only edge from total
			        allEdgeIds.splice(allEdgeIds.indexOf(currNode.edges[0].id), 1);

			        //get 2nd node
			        if(currNode.edges[0].n1 != currNode) {
			            currNode = currNode.edges[0].n1;
			        }
			        else {
			            currNode = currNode.edges[0].n2;
			        }

			        while (true) {
			            console.log("beg of loop", currNode.id);

			            //end conditions
			            if (currNode == this.getEndNode()) {
			                console.log("Reached end node");
			                //if we've removed all the edges we're good
			                if (allEdgeIds.length == 0) {
			                    return true;
			                }
			                else {
			                    console.log("AllEdgeIds does NOT == 0");
			                    return false;
			                }
			            }

			            //check that each node we reach only has 2 edges
			            if(currNode.edges.length != 2) {
			                console.log(currNode, "doesn't have 2 edges");
			                return false;
			            }

			            //check that one of the two edges is still alive
			            var nextEdge = null;
			            console.log("curr node edges:", currNode.edges);
			            console.log("All edge Ids: ", allEdgeIds);
			            for (var i = 0; i < currNode.edges.length; i++) {
			                console.log("currNode.edges[i].id ", currNode.edges[i].id);
			                if (allEdgeIds.indexOf(currNode.edges[i].id) > -1) {
			                    nextEdge = this.edges[currNode.edges[i].id];
			                }
			            }

			            //neither edge still in total list, tunnel invalid
			            if (nextEdge == null) {
			                console.log(nextEdge, "neither edge still in total list");
			                return false;
			            }

			            //clean up - remove curr node and curr edge
			            allEdgeIds.splice(allEdgeIds.indexOf(nextEdge.id), 1);

			            //get the next node
			            if(nextEdge.n1 != currNode) {
			                currNode = nextEdge.n1;
			            }
			            else {
			                currNode = nextEdge.n2;
			            }
			        }

			    };

			    this.clearTunnel = function() {
			        this.edges = {};
			        this.nodes = {};
			    }
			}

			Tunnel.prototype.toString = function tunnelToString() {
			    var ret = "tunnel: \n";
			    ret += "nodes: ";
			    for (var n in this.nodes) {
			        ret += (this.nodes[n].id + " ");
			    }
			    ret += "\nedges: ";
			    for (var e in this.edges) {
			        ret += (this.edges[e].id + " ");
			    }
			    ret += "\n";
			    return ret;
			}

			// Determine if was clicked before or not and add/remove edge from tunnel class
			var edges = document.getElementsByClassName("edge");

			var edgeClicked = function() {
			    var edgeId = this.getAttribute('x');
			    console.log(edgeId)
			    if (gameState == 0) {
			        $(this).toggleClass("animate");
			        if (edgeId in tunnel.edges) {
			            // Get nodes
			            tunnelLength++;
			            var n1 = tunnel.edges[edgeId].n1;
			            var n2 = tunnel.edges[edgeId].n2;
			            // Remove this edge from each node's edge list
			            n1.removeEdge(tunnel.edges[edgeId]);
			            n2.removeEdge(tunnel.edges[edgeId]);
			            if (n1.edges.length == 0) {
			                tunnel.removeNode(n1);
			            }
			            if (n2.edges.length == 0) {
			                tunnel.removeNode(n2);
			            }
			            tunnel.removeEdge(tunnel.edges[edgeId]);
			        } else {
			            // Check if there are no pieces
			            if (tunnelLength <= 0) {
			                remainingPieces.innerHTML = "There are no remaining edges! Please remove an edge to continue building.";
			                return;
			            }
			            tunnelLength--;
			            if (edgeId[0] == "h") {
			                console.log("slice: ", edgeId.slice(1));
			                var rNum = Math.floor(edgeId.slice(1) / boardSize);
			                console.log("rNum: ", rNum);
			                var n1Id = Number(edgeId.slice(1)) + rNum;
			                var n2Id = (n1Id + 1).toString();
			                console.log("n1Id: ", n1Id);
			                console.log("n2Id: ", n2Id);
			                var n1;
			                var n2;

			                if (n1Id in tunnel.nodes) {
			                    n1 = tunnel.nodes[n1Id];
			                } else {
			                    n1 = new Node(n1Id);
			                    tunnel.addNode(n1);
			                }

			                if (n2Id in tunnel.nodes) {
			                    n2 = tunnel.nodes[n2Id];
			                } else {
			                    n2 = new Node(n2Id);
			                    tunnel.addNode(n2);
			                }

			                var newEdge = new Edge(n1, n2, edgeId);
			                tunnel.addEdge(newEdge);
			                n1.addEdge(newEdge);
			                n2.addEdge(newEdge);
			            } else {
			                var n1Id = edgeId.slice(1);
			                var n2Id = (Number(edgeId.slice(1)) + boardSize + 1).toString();
			                console.log("n1Id: ", n1Id);
			                console.log("n2Id: ", n2Id);
			                var n1;
			                var n2;

			                if (n1Id in tunnel.nodes) {
			                    n1 = tunnel.nodes[n1Id];
			                } else {
			                    n1 = new Node(n1Id);
			                    tunnel.addNode(n1);
			                }

			                if (n2Id in tunnel.nodes) {
			                    n2 = tunnel.nodes[n2Id];
			                } else {
			                    n2 = new Node(n2Id);
			                    tunnel.addNode(n2);
			                }

			                var newEdge = new Edge(n1, n2, edgeId);
			                tunnel.addEdge(newEdge);
			                n1.addEdge(newEdge);
			                n2.addEdge(newEdge);
			            }
			        }

			        // this.style.background = this.style.background=='yellow'? '#63f9ff':'yellow';
			        remainingPieces.innerHTML = "Edges left: " + tunnelLength;
			        console.log(tunnel.edges);
			        console.log("Tunnel nodes: ", tunnel.nodes);
			    } else if (gameState == 4) {
			        if (finalTunnelGuess.indexOf(edgeId) > -1) {
			            finalTunnelGuess.splice(finalTunnelGuess.indexOf(edgeId), 1);
			        } else {
			            finalTunnelGuess.push(edgeId);
			        }
			        $(this).toggleClass("final");
			    }
			};

			for(var i = 0; i < edges.length; i++){
			    edges[i].addEventListener('click', edgeClicked, false);
			}

			// Get probes and add event listener to each one
			var probes = document.getElementsByClassName("probe");

			var probeClicked = function() {
			    if (gameState == 1 || gameState == 2 || gameState == 3) {
			        $(this).toggleClass("animate");
			        probeId = this.id;
			        console.log("Probe id: ", probeId);
			        index = probesList.indexOf(probeId);
			        console.log("Numprobes: " + numProbes);
			        console.log("Index: " + index);
			        if (index < 0) {
			            probesList.push(probeId.slice(1));
			            numProbes++;
			        } else {
			            probesList.splice(index, 1);
			            numProbes--;
			        }
			        // this.style.background = this.style.background == 'red' ? 'blue' : 'red';
			    }
			};

			for(var i=0;i<probes.length;i++){
			    probes[i].addEventListener('click', probeClicked, false);
			}

			var startGameInRegularMode = function () {
			    clearBoard();
			    gameMode = 0;
			    alert("Detector, please look away while Badguy builds a tunnel.");
			    startGame();
			}

			var startGameInEasyMode = function () {
			    clearBoard();
			    gameMode = 1;
			    alert("Detector, please look away while Badguy builds a tunnel.");
			    startGame();
			}

			var startGameAI = function () {
			    computer = 1;
			    gameMode = 0;
			    gameState = 0;
			    console.log("GAME STATE IN START AI ", gameState);
			    tunnel = createAITunnel();
			    startGame();
			}

			var startGameEasyAI = function () {
			    computer = 1;
			    gameMode = 1;
			    gameState = 0;
			    tunnel = createAITunnel();
			    startGame();
			}

			var startGame = function () {
			    clearBoard();
			    if (round == 1) {
			        tunnelLength = Math.floor(Math.random() * 13) + 8;
			        maxTunnelLength = tunnelLength;
			        alert("Maximum tunnel length is " + tunnelLength + ".");
			    } else {
			        tunnelLength = maxTunnelLength;
			    }
			    gameState++;
			    console.log("GAME STATE IS ", gameState);
			    document.getElementById('start').style.display = 'none';
			    document.getElementById('startEasy').style.display = 'none';
			    document.getElementById('startAI').style.display = 'none';
			    document.getElementById('startEasyAI').style.display = 'none';
			    document.getElementById('submitGuess').style.display = 'none';
			    if (gameState == 0) {
			        tunnelInfo.innerHTML = "Tunnel can be up to " + tunnelLength + " edges long.";
			        remainingPieces.innerHTML = "Edges left: " + tunnelLength;
			        document.getElementById('tunnelDone').style.display = 'block';
			    } else if (gameState == 1) {
			        message.innerHTML = "Computer opponent has constructed a tunnel. Detector, begin placing probes.";
			        document.getElementById('probesPlaced1').style.display = 'block';
			    }
			};

			var doneAddingTunnels = function () {
			    var valid = tunnel.validTunnel();
			    console.log(valid);

			    // If the tunnel isn't valid, don't let the game keep going
			    if(!valid) {
			        alert("Your tunnel is invalid. It must start on the top edge, end on the bottom edge, and be a single simple path.");
			        return;
			    }

			    document.getElementById('tunnelDone').style.display = 'none';
			    document.getElementById('probesPlaced1').style.display = 'block';
			    tunnelInfo.innerHTML = "";
			    remainingPieces.innerHTML = "";
			    currentTunnel.innerHTML = "";
			    message.innerHTML = "Done adding tunnels. Time for Detector to place first round of probes.";
			    for (var e in tunnel.edges) {
			        console.log("TRYING TO UNHIGHLIGHT");
			        console.log("tunnel.edges[e].id is ", tunnel.edges[e].id);
			        $("#" + tunnel.edges[e].id).toggleClass("animate");
			    }

			    // tunnelLength = 12;
			    // tunnel = createAITunnel();

			    console.log("final final tunnel:");
			    console.log("nodes");
			    for (var n in tunnel.nodes) {
			        console.log(tunnel.nodes[n] + "");
			    }
			    console.log("edges: ");
			    for (var e in tunnel.edges) {
			        console.log(tunnel.edges[e] + "");
			    }

			    gameState++;
			};

			var doneAddingProbes = function () {
			    message.innerHTML = "Done adding probes. Let's see how you did.";
			    for (var i = 0; i < probesList.length; i++) {
			        console.log("probesList[i] is ", probesList[i]);
			        if (probesList[i] in tunnel.nodes) {
			            console.log("we got in the if statement");
			            for (var j = 0; j < tunnel.nodes[probesList[i]].edges.length; j++) {
			                console.log("Found edge ", tunnel.nodes[probesList[i]].edges[j].id);
			                if (gameMode == 1) {
			                    $("#" + tunnel.nodes[probesList[i]].edges[j].id).addClass("animate");
			                }
			            }
			            $("#p" + probesList[i]).removeClass("animate");
			            $("#p" + probesList[i]).addClass("detectedEdge");
			        }
			    }

			    if (gameState == 1 || gameState == 2) {
			        //update score
			        if (computer == 1) {
			            //only need to update player1 score
			            player1Score += probesList.length;
			        } else {
			            if (round == 1) {
			                player1Score += probesList.length;
			            } else {
			                player2Score += probesList.length;
			            }
			        }

			        console.log("done with probe placement in round " + round);
			        console.log("player 1 score: " + player1Score);
			        console.log("player 2 score: " + player2Score);

			        probesList = [];
			        message.innerHTML = "Detector, please place another round of probes.";
			        document.getElementById('probesPlaced1').style.display = 'none';
			        document.getElementById('probesPlaced2').style.display = 'block';

			        gameState++;

			    } else if (gameState == 3) {
			        // Update score
			        if (computer == 1) {
			            // Only need to update player1 score
			            player1Score += probesList.length;
			        } else {
			            if (round == 1) {
			                player1Score += probesList.length;
			            } else {
			                player2Score += probesList.length;
			            }
			        }

			        console.log("done with probe placement in round " + round);
			        console.log("player 1 score: " + player1Score);
			        console.log("player 2 score: " + player2Score);

			        document.getElementById('probesPlaced2').style.display = 'none';
			        document.getElementById('submitGuess').style.display = 'block';
			        message.innerHTML = "Now, select all edges in the tunnel to submit your final guess.";
			        gameState++;
			    }

			    console.log("probes list after done ", probesList);
			};

			function restartGame() {
			    message.innerHTML = "";
			    round++;
			    if (computer == 1) {
			        if (gameMode == 0) { //regular ai
			            numProbes = 0;
			            probesList = [];
			            tunnel = new Tunnel();
			            finalTunnelGuess = [];
			            gameMode = -1;
			            computer = -1;
			            gameState = -1;
			            startGameAI();
			        } else {
			            numProbes = 0;
			            probesList = [];
			            tunnel = new Tunnel();
			            finalTunnelGuess = [];
			            gameMode = -1;
			            computer = -1;
			            gameState = -1;
			            startGameEasyAI();
			        }
			    } else {
			        if (gameMode == 0) {
			            numProbes = 0;
			            probesList = [];
			            tunnel = new Tunnel();
			            finalTunnelGuess = [];
			            gameMode = -1;
			            computer = -1;
			            gameState = -1;
			            startGameInRegularMode();
			        } else {
			            numProbes = 0;
			            probesList = [];
			            tunnel = new Tunnel();
			            finalTunnelGuess = [];
			            gameMode = -1;
			            computer = -1;
			            gameState = -1;
			            startGameInEasyMode();
			        }
			    }
			}

			var revealTunnel = function () {
			    for (var e in tunnel.edges) {
			        console.log("REVEALING TUNNEL");
			        console.log("tunnel.edges[e].id is ", tunnel.edges[e].id);
			        $("#" + tunnel.edges[e].id).removeClass("final");
			        $("#" + tunnel.edges[e].id).removeClass("animate");
			        $("#" + tunnel.edges[e].id).addClass("reveal");
			    }
			}

			var submitGuess = function () {
			    console.log("Final tunnel guess: ", finalTunnelGuess);
			    console.log("The actual tunnel: ", tunnel.edges);
			    console.log("Final tunnel guess LENGTH: ", finalTunnelGuess.length);
			    console.log("Tunnel length: ", Object.keys(tunnel.edges).length);
			    var clone = finalTunnelGuess.slice(0);
			    if (finalTunnelGuess.length != Object.keys(tunnel.edges).length) {
			        console.log("Tunnel length not the same");
			        if (round == 1) {
			            player1Score = 10000;
			            revealTunnel();
			            alert("You are a horrible Detector. Keep your day job. Your score is infinity.");
			        } else {
			            player2Score = 10000;
			            revealTunnel();
			            alert("You are a horrible Detector. Keep your day job. Your score is infinity.");
			        }
			    } else {
			        console.log("Tunnel length is good");
			        for (var i = 0; i < finalTunnelGuess.length; i++) {
			            console.log("Final tunnel guess: iteration ",i, finalTunnelGuess);
			            if (finalTunnelGuess[i] in tunnel.edges) {
			                console.log("Found match: " + finalTunnelGuess[i]);
			                clone.splice(clone.indexOf(finalTunnelGuess[i]), 1);
			                console.log("Clone: " + clone)
			            }
			        }
			        console.log("clone length ", clone.length);
			        if (!clone.length) {
			            if (round == 1) {
			                alert("Good job. Your score is " + player1Score + ".");
			            } else {
			                alert("Good job. Your score is " + player2Score + ".");
			            }
			        } else {
			            if (round == 1) {
			                player1Score = 10000;
			                revealTunnel();
			                alert("You are a horrible Detector. Keep your day job. Your score is infinity.");
			            } else {
			                player2Score = 10000;
			                revealTunnel();
			                alert("You are a horrible Detector. Keep your day job. Your score is infinity.");
			            }
			        }
			    }

			    if (round == 1 && computer != 1) {
			        // Popup that they need to switch roles
			        alert("Round 1 over. Now switch roles. The game will restart when you click OK.");
			        restartGame();
			    } else if (computer == 1) {
			        alert("Game over. You may submit your score.");
			        document.getElementById('submitGuess').style.display = 'none';
			        message.innerHTML = "";
			        document.getElementById("score").style.display="inline-block";
			    } else {
			        if (player1Score < player2Score ) {
			            winningScore = player1Score;
			            winningPlayer = player1Name;
			        } else {
			            winningScore = player2Score;
			            winningPlayer = player2Name;
			        }
			        if(computer != 1) {
			            if (player1Score < player2Score) {
			                alert("The game is over. Player 1 won with a score of " + player1Score + ". Player 1 can save their score.");
			            } else {
			                alert("The game is over. Player 2 won with a score of " + player2Score + ". Player 2 can save their score.");
			            }
			        } else {
			            alert("The game is over. Your score is " + player1Score + ". You can save your score.");
			            document.getElementById('submitGuess').style.display = 'none';
			            message.innerHTML = "";
			        }
			        document.getElementById('submitGuess').style.display = 'none';
			        message.innerHTML = "";
			        document.getElementById("score").style.display="inline-block";
			    }
			};


			// AI tunnel stuff
			function createAITunnel() {
			    var aiTunnel = new Tunnel();
			    var graph = new Graph();
			    graph.createGraph();
			    var currentTunnelLength = 0;

			    var start = Math.floor(Math.random() * (boardSize+1));
			    var currNodeFromGraph = graph.nodes[start];
			    var currNode = new Node(start);

			    var counter = 0;

			    while(true) {
			        console.log("curr node: " + currNode);

			        // Check if on end and if yes break
			        if (Math.floor(currNode.id / (boardSize+1)) == boardSize) {
			            console.log("on end!")
			            console.log("final tunnel: " + aiTunnel);
			            aiTunnel.addNode(currNode);
			            break;
			        }

			        // Pick an edge from the current nodes edges that's not the incoming edge
			        var potentialEdge = getRandomEdge(currNodeFromGraph, aiTunnel);
			        console.log("first potential edge: " + potentialEdge);

			        // See if adding that edge leaves enough pipes to get to the end
			        while (!potentialEdgeValid(potentialEdge, currNode, aiTunnel)) {
			            //while(false) {
			            potentialEdge = getRandomEdge(currNodeFromGraph, aiTunnel);
			            console.log("edge was invalid, got new one: " + potentialEdge);
			            //sleepFor(1000);
			        }

			        // Now we have a good edge, update it's n1
			        potentialEdge.n1 = currNode;

			        // Add the edge to currNode
			        currNode.addEdge(potentialEdge);

			        // Add them both to the tunnel
			        aiTunnel.addNode(currNode);
			        aiTunnel.addEdge(potentialEdge);

			        // Get the next node
			        var currNodeId = currNode.id;
			        var newNodeId = null;
			        // console.log("curr node id: " + currNodeId);
			        for (var i = 0; i < potentialEdge.allNodes.length; i++) {
			            // console.log("potentialEdge.allNodes[i].id: " + potentialEdge.allNodes[i].id );
			            if (potentialEdge.allNodes[i].id != currNodeId) {
			                newNodeId = potentialEdge.allNodes[i].id;
			            }
			        }
			        // console.log("new node id: " + newNodeId);

			        currNodeFromGraph = graph.nodes[newNodeId];
			        currNode = new Node(newNodeId);
			        currNode.addEdge(potentialEdge);
			        potentialEdge.n2 = currNode;
			        counter++;

			        console.log("tunnel: " + aiTunnel);

			    }

			    return aiTunnel;
			}

			function potentialEdgeValid(potentialEdge, currNode, tunnel) {

			    if(potentialEdge.id in tunnel.edges) {
			        console.log("edge exists, not valid");
			        return false;
			    }

			    tunnel.addEdge(potentialEdge);
			    tunnel.addNode(currNode);

			    var tunnelLengthSoFar = Object.keys(tunnel.edges).length;
			    var edgesLeft = tunnelLength - tunnelLengthSoFar;
			    var rowNum = getRowNum(potentialEdge);


			    console.log();
			    console.log("======= starting validation ========")
			    console.log("checking if edge " + potentialEdge.id + " is valid to add to tunnel: ");
			    console.log(tunnel + "");
			    console.log("tunnel len so far: " + tunnelLengthSoFar);
			    console.log("edges left so far: " + edgesLeft);
			    console.log("row num of edge: " + rowNum);

			    // Check that the other end of the new edge isn't already in the tunnel
			    // (This means we created a loop)
			    var currNodeId = currNode.id;
			    var newNodeId = null;
			    console.log("curr node id: " + currNodeId);
			    for (var i = 0; i < potentialEdge.allNodes.length; i++) {
			        //console.log("potentialEdge.allNodes[i].id: " + potentialEdge.allNodes[i].id );
			        if (potentialEdge.allNodes[i].id != currNodeId) {
			            newNodeId = potentialEdge.allNodes[i].id;
			        }
			    }
			    console.log("new node id: " + newNodeId);

			    if (newNodeId in tunnel.nodes) {
			        console.log("we created a loop, not valid");
			        tunnel.removeEdge(potentialEdge);
			        tunnel.removeNode(currNode);
			        return false;
			    }


			    // If the edge is horizontal then need (remaining pieces - (boardSize - rowNum)) >= 0
			    // Check if have enough nodes to end
			    var neededToEnd = -1;
			    if (potentialEdge.id[0] == "h") {
			        console.log("edge is horiz");
			        // Check if h edge below is already in tunnel
			        var edgeBelowId = Number(potentialEdge.id.slice(1)) + boardSize;
			        var edgeBelow = "h" + edgeBelowId;
			        if (edgeBelow in tunnel.edges) {
			            console.log("can't add this horiz edge because will cause box");
			            tunnel.removeEdge(potentialEdge);
			            tunnel.removeNode(currNode);
			            return false;
			        }
			        neededToEnd = boardSize - rowNum;
			    } else {
			        if (newNodeId > currNodeId) { //edge is going down
			            console.log("edge is v going down")
			            neededToEnd = (boardSize - rowNum) - 1;
			        } else {
			            console.log("edge is v going up");
			            // console.log("so for now returning false");
			            // return false;
			            // can't go up on the edges
			            var potEdgeIdNum = Number(potentialEdge.id.slice(1));
			            if(potEdgeIdNum % (boardSize + 1) == 0 || potEdgeIdNum % (boardSize + 1) == boardSize) {
			                console.log("can't go up on an outside edge");
			                tunnel.removeEdge(potentialEdge);
			                tunnel.removeNode(currNode);
			                return false;
			            }

			            neededToEnd = (boardSize - rowNum) + 1;
			        }
			    }
			    console.log("needed to end: " + neededToEnd);
			    console.log("======== done with check =========");
			    console.log();
			    tunnel.removeEdge(potentialEdge);
			    tunnel.removeNode(currNode);
			    return ((edgesLeft - neededToEnd) >= 0);

			    //if edge is vertical
			    //if edge is downward need (remaining pieces - (boardSize - rownum) - 1) >= 0
			    //else if upward need (remaining pieces - (boardSize - rownum) + 1) >= 0
			}

			function getRowNum(edge) {
			    var edgeId = Number(edge.id.slice(1));
			    if(edge.id[0] == "h") {
			        return Math.floor(edgeId / (boardSize));
			    } else {
			        return Math.floor(edgeId / (boardSize + 1));
			    }
			}

			function getRandomEdge(node, tunnel) {
			    // Given the tunnel and the current node
			    var nodeId = node.id;

			    var existingEdgeId;
			    if (nodeId in tunnel.nodes) {
			        var nodeFromTunnel = tunnel.nodes[nodeId];
			        existingEdgeId = nodeFromTunnel.edges[0];
			    } else {
			        existingEdgeId = "bad"
			    }

			    var potentialEdges = [];

			    for (var i = 0; i < node.edges.length; i++) {
			        if (node.edges[i].id != existingEdgeId) {
			            potentialEdges.push(node.edges[i]);
			        }
			    }

			    console.log("list of potential edge candidates for node " + nodeId);
			    for(var i = 0; i < potentialEdges.length; i++) {
			        console.log(potentialEdges[i].id);
			    }

			    var rand = potentialEdges[Math.floor(Math.random() * potentialEdges.length)];
			    return rand;
			}

			function Graph() {
			    this.nodes = {};
			    this.edges = {};
			    this.nodeIds = [];
			    this.edgeIds = [];

			    this.createGraph = function() {
			        console.log("!23")
			        for(var i = 0; i < ((boardSize+1)*(boardSize+1)); i++) {
			            var node = new Node(i);
			            this.nodes[i] = node;
			            this.nodeIds.push(i);
			            var horizontalEdgeIds = getHorizontalEdgesIds(i);
			            var verticalEdgeIds = getVerticalEdgesIds(i);

			            for(var j = 0; j < horizontalEdgeIds.length; j++) {
			                var edgeId = horizontalEdgeIds[j];
			                if (edgeId in this.edges) {
			                    // Add the node to the edge
			                    this.edges[edgeId].allNodes.push(node);
			                    node.addEdge(this.edges[edgeId]);
			                } else {
			                    // Create new edge and add it to edge object
			                    var edge = new Edge(null, null, edgeId);
			                    edge.allNodes.push(node);
			                    this.edges[edgeId] = edge;
			                    this.edgeIds.push(edgeId);
			                    node.addEdge(edge);
			                }
			            }

			            for (var j = 0; j < verticalEdgeIds.length; j++) {
			                var edgeId = verticalEdgeIds[j];
			                if (edgeId in this.edges) {
			                    // Add the node to it
			                    this.edges[edgeId].allNodes.push(node);
			                    node.addEdge(this.edges[edgeId]);
			                } else {
			                    // Create new edge
			                    var edge = new Edge(null, null, edgeId);
			                    edge.allNodes.push(node);
			                    this.edges[edgeId] = edge;
			                    this.edgeIds.push(edgeId);
			                    node.addEdge(this.edges[edgeId]);
			                }
			            }
			        }
			        console.log("nodes");
			        for (var n in this.nodes) {
			            console.log("" + this.nodes[n]);
			        }
			        console.log("edges");
			        for (var e in this.edges) {
			            console.log("" + this.edges[e]);
			        }
			    }
			}

			function getHorizontalEdgesIds(i) {
			    var horizontalEdgeIds = [];

			    // console.log("getting horizontal edges for node " + i);

			    // Create left and right edges
			    var rowNum = Math.floor(i / (boardSize + 1));
			    var leftEdge = i - (rowNum + 1);
			    var rightEdge = i - rowNum;
			    var leftEdgeId = "h" + leftEdge;
			    var rightEdgeId = "h" + rightEdge;

			    // console.log("row num: " + rowNum);
			    // console.log("left edge: " + leftEdge);
			    // console.log("right edge: " + rightEdge);

			    // If on left border, only has right edge
			    if (i % (boardSize + 1) == 0) {
			        // console.log("on left border");
			        leftEdgeId = null;
			    }

			    // If on right border only has left edge
			    if (i % (boardSize + 1) == 6) {
			        // console.log("on right border");
			        rightEdgeId = null;
			    }

			    // Add non null edges
			    if (leftEdgeId != null) {
			        horizontalEdgeIds.push(leftEdgeId);
			    }

			    if (rightEdgeId != null) {
			        horizontalEdgeIds.push(rightEdgeId);
			    }

			    // console.log("final result: " , horizontalEdgeIds);
			    return horizontalEdgeIds;
			}

			function getVerticalEdgesIds(i) {
			    var verticalEdgeIds = [];
			    // console.log("getting vertical edges for node " + i);

			    // If on the first row only has a down edge
			    if (i <= boardSize) {
			        // console.log("on first row");
			        var edgeId = "v" + i;
			        verticalEdgeIds.push(edgeId);
			        return verticalEdgeIds;
			    }

			    // If on the bottom row only has an up edge
			    if (i >= (boardSize * (boardSize + 1))) {
			        // console.log("on bottom row");
			        var upEdgeIdNum = i - (boardSize + 1);
			        var upEdgeId = "v" + upEdgeIdNum;
			        verticalEdgeIds.push(upEdgeId);
			        return verticalEdgeIds;
			    }

			    // Else has both edges
			    var downEdgeId = "v" + i;
			    var upEdgeIdNum = i - (boardSize + 1);
			    var upEdgeId = "v" + upEdgeIdNum;
			    verticalEdgeIds.push(downEdgeId);
			    verticalEdgeIds.push(upEdgeId);
			    // console.log("final result: ", verticalEdgeIds);
			    return verticalEdgeIds;
			}

			function edgeIsHorizontal(edge) {
			    var edgeId = edge.id;
			    var dir = edgeId.slice(0,1);
			    if (dir == "h") {
			        return true;
			    } else {
			        return false;
			    }
			}


			// Add button event listeners

			// Start game in normal mode
			document.getElementById('start').addEventListener('click', startGameInRegularMode, false);

			// Start game in easy mode
			document.getElementById('startEasy').addEventListener('click', startGameInEasyMode, false);

			// Start game with AI
			document.getElementById('startAI').addEventListener('click', startGameAI, false);

			// Start game with AI in easy mode
			document.getElementById('startEasyAI').addEventListener('click', startGameEasyAI, false);

			document.getElementById('tunnelDone').addEventListener('click', doneAddingTunnels, false);

			document.getElementById('probesPlaced1').addEventListener('click', doneAddingProbes, false);

			document.getElementById('probesPlaced2').addEventListener('click', doneAddingProbes, false);

			document.getElementById('submitGuess').addEventListener('click', submitGuess, false);



		/***/ },
		/* 5 */
		/***/ function(module, exports, __webpack_require__) {

			var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
			 * jQuery JavaScript Library v3.1.1
			 * https://jquery.com/
			 *
			 * Includes Sizzle.js
			 * https://sizzlejs.com/
			 *
			 * Copyright jQuery Foundation and other contributors
			 * Released under the MIT license
			 * https://jquery.org/license
			 *
			 * Date: 2016-09-22T22:30Z
			 */
			( function( global, factory ) {

				"use strict";

				if ( typeof module === "object" && typeof module.exports === "object" ) {

					// For CommonJS and CommonJS-like environments where a proper `window`
					// is present, execute the factory and get jQuery.
					// For environments that do not have a `window` with a `document`
					// (such as Node.js), expose a factory as module.exports.
					// This accentuates the need for the creation of a real `window`.
					// e.g. var jQuery = require("jquery")(window);
					// See ticket #14549 for more info.
					module.exports = global.document ?
						factory( global, true ) :
						function( w ) {
							if ( !w.document ) {
								throw new Error( "jQuery requires a window with a document" );
							}
							return factory( w );
						};
				} else {
					factory( global );
				}

			// Pass this if window is not defined yet
			} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

			// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
			// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
			// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
			// enough that all such attempts are guarded in a try block.
			"use strict";

			var arr = [];

			var document = window.document;

			var getProto = Object.getPrototypeOf;

			var slice = arr.slice;

			var concat = arr.concat;

			var push = arr.push;

			var indexOf = arr.indexOf;

			var class2type = {};

			var toString = class2type.toString;

			var hasOwn = class2type.hasOwnProperty;

			var fnToString = hasOwn.toString;

			var ObjectFunctionString = fnToString.call( Object );

			var support = {};



				function DOMEval( code, doc ) {
					doc = doc || document;

					var script = doc.createElement( "script" );

					script.text = code;
					doc.head.appendChild( script ).parentNode.removeChild( script );
				}
			/* global Symbol */
			// Defining this global in .eslintrc.json would create a danger of using the global
			// unguarded in another place, it seems safer to define global only for this module



			var
				version = "3.1.1",

				// Define a local copy of jQuery
				jQuery = function( selector, context ) {

					// The jQuery object is actually just the init constructor 'enhanced'
					// Need init if jQuery is called (just allow error to be thrown if not included)
					return new jQuery.fn.init( selector, context );
				},

				// Support: Android <=4.0 only
				// Make sure we trim BOM and NBSP
				rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

				// Matches dashed string for camelizing
				rmsPrefix = /^-ms-/,
				rdashAlpha = /-([a-z])/g,

				// Used by jQuery.camelCase as callback to replace()
				fcamelCase = function( all, letter ) {
					return letter.toUpperCase();
				};

			jQuery.fn = jQuery.prototype = {

				// The current version of jQuery being used
				jquery: version,

				constructor: jQuery,

				// The default length of a jQuery object is 0
				length: 0,

				toArray: function() {
					return slice.call( this );
				},

				// Get the Nth element in the matched element set OR
				// Get the whole matched element set as a clean array
				get: function( num ) {

					// Return all the elements in a clean array
					if ( num == null ) {
						return slice.call( this );
					}

					// Return just the one element from the set
					return num < 0 ? this[ num + this.length ] : this[ num ];
				},

				// Take an array of elements and push it onto the stack
				// (returning the new matched element set)
				pushStack: function( elems ) {

					// Build a new jQuery matched element set
					var ret = jQuery.merge( this.constructor(), elems );

					// Add the old object onto the stack (as a reference)
					ret.prevObject = this;

					// Return the newly-formed element set
					return ret;
				},

				// Execute a callback for every element in the matched set.
				each: function( callback ) {
					return jQuery.each( this, callback );
				},

				map: function( callback ) {
					return this.pushStack( jQuery.map( this, function( elem, i ) {
						return callback.call( elem, i, elem );
					} ) );
				},

				slice: function() {
					return this.pushStack( slice.apply( this, arguments ) );
				},

				first: function() {
					return this.eq( 0 );
				},

				last: function() {
					return this.eq( -1 );
				},

				eq: function( i ) {
					var len = this.length,
						j = +i + ( i < 0 ? len : 0 );
					return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
				},

				end: function() {
					return this.prevObject || this.constructor();
				},

				// For internal use only.
				// Behaves like an Array's method, not like a jQuery method.
				push: push,
				sort: arr.sort,
				splice: arr.splice
			};

			jQuery.extend = jQuery.fn.extend = function() {
				var options, name, src, copy, copyIsArray, clone,
					target = arguments[ 0 ] || {},
					i = 1,
					length = arguments.length,
					deep = false;

				// Handle a deep copy situation
				if ( typeof target === "boolean" ) {
					deep = target;

					// Skip the boolean and the target
					target = arguments[ i ] || {};
					i++;
				}

				// Handle case when target is a string or something (possible in deep copy)
				if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {
					target = {};
				}

				// Extend jQuery itself if only one argument is passed
				if ( i === length ) {
					target = this;
					i--;
				}

				for ( ; i < length; i++ ) {

					// Only deal with non-null/undefined values
					if ( ( options = arguments[ i ] ) != null ) {

						// Extend the base object
						for ( name in options ) {
							src = target[ name ];
							copy = options[ name ];

							// Prevent never-ending loop
							if ( target === copy ) {
								continue;
							}

							// Recurse if we're merging plain objects or arrays
							if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
								( copyIsArray = jQuery.isArray( copy ) ) ) ) {

								if ( copyIsArray ) {
									copyIsArray = false;
									clone = src && jQuery.isArray( src ) ? src : [];

								} else {
									clone = src && jQuery.isPlainObject( src ) ? src : {};
								}

								// Never move original objects, clone them
								target[ name ] = jQuery.extend( deep, clone, copy );

							// Don't bring in undefined values
							} else if ( copy !== undefined ) {
								target[ name ] = copy;
							}
						}
					}
				}

				// Return the modified object
				return target;
			};

			jQuery.extend( {

				// Unique for each copy of jQuery on the page
				expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

				// Assume jQuery is ready without the ready module
				isReady: true,

				error: function( msg ) {
					throw new Error( msg );
				},

				noop: function() {},

				isFunction: function( obj ) {
					return jQuery.type( obj ) === "function";
				},

				isArray: Array.isArray,

				isWindow: function( obj ) {
					return obj != null && obj === obj.window;
				},

				isNumeric: function( obj ) {

					// As of jQuery 3.0, isNumeric is limited to
					// strings and numbers (primitives or objects)
					// that can be coerced to finite numbers (gh-2662)
					var type = jQuery.type( obj );
					return ( type === "number" || type === "string" ) &&

						// parseFloat NaNs numeric-cast false positives ("")
						// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
						// subtraction forces infinities to NaN
						!isNaN( obj - parseFloat( obj ) );
				},

				isPlainObject: function( obj ) {
					var proto, Ctor;

					// Detect obvious negatives
					// Use toString instead of jQuery.type to catch host objects
					if ( !obj || toString.call( obj ) !== "[object Object]" ) {
						return false;
					}

					proto = getProto( obj );

					// Objects with no prototype (e.g., `Object.create( null )`) are plain
					if ( !proto ) {
						return true;
					}

					// Objects with prototype are plain iff they were constructed by a global Object function
					Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
					return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
				},

				isEmptyObject: function( obj ) {

					/* eslint-disable no-unused-vars */
					// See https://github.com/eslint/eslint/issues/6125
					var name;

					for ( name in obj ) {
						return false;
					}
					return true;
				},

				type: function( obj ) {
					if ( obj == null ) {
						return obj + "";
					}

					// Support: Android <=2.3 only (functionish RegExp)
					return typeof obj === "object" || typeof obj === "function" ?
						class2type[ toString.call( obj ) ] || "object" :
						typeof obj;
				},

				// Evaluates a script in a global context
				globalEval: function( code ) {
					DOMEval( code );
				},

				// Convert dashed to camelCase; used by the css and data modules
				// Support: IE <=9 - 11, Edge 12 - 13
				// Microsoft forgot to hump their vendor prefix (#9572)
				camelCase: function( string ) {
					return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
				},

				nodeName: function( elem, name ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
				},

				each: function( obj, callback ) {
					var length, i = 0;

					if ( isArrayLike( obj ) ) {
						length = obj.length;
						for ( ; i < length; i++ ) {
							if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
								break;
							}
						}
					} else {
						for ( i in obj ) {
							if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
								break;
							}
						}
					}

					return obj;
				},

				// Support: Android <=4.0 only
				trim: function( text ) {
					return text == null ?
						"" :
						( text + "" ).replace( rtrim, "" );
				},

				// results is for internal usage only
				makeArray: function( arr, results ) {
					var ret = results || [];

					if ( arr != null ) {
						if ( isArrayLike( Object( arr ) ) ) {
							jQuery.merge( ret,
								typeof arr === "string" ?
								[ arr ] : arr
							);
						} else {
							push.call( ret, arr );
						}
					}

					return ret;
				},

				inArray: function( elem, arr, i ) {
					return arr == null ? -1 : indexOf.call( arr, elem, i );
				},

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				merge: function( first, second ) {
					var len = +second.length,
						j = 0,
						i = first.length;

					for ( ; j < len; j++ ) {
						first[ i++ ] = second[ j ];
					}

					first.length = i;

					return first;
				},

				grep: function( elems, callback, invert ) {
					var callbackInverse,
						matches = [],
						i = 0,
						length = elems.length,
						callbackExpect = !invert;

					// Go through the array, only saving the items
					// that pass the validator function
					for ( ; i < length; i++ ) {
						callbackInverse = !callback( elems[ i ], i );
						if ( callbackInverse !== callbackExpect ) {
							matches.push( elems[ i ] );
						}
					}

					return matches;
				},

				// arg is for internal usage only
				map: function( elems, callback, arg ) {
					var length, value,
						i = 0,
						ret = [];

					// Go through the array, translating each of the items to their new values
					if ( isArrayLike( elems ) ) {
						length = elems.length;
						for ( ; i < length; i++ ) {
							value = callback( elems[ i ], i, arg );

							if ( value != null ) {
								ret.push( value );
							}
						}

					// Go through every key on the object,
					} else {
						for ( i in elems ) {
							value = callback( elems[ i ], i, arg );

							if ( value != null ) {
								ret.push( value );
							}
						}
					}

					// Flatten any nested arrays
					return concat.apply( [], ret );
				},

				// A global GUID counter for objects
				guid: 1,

				// Bind a function to a context, optionally partially applying any
				// arguments.
				proxy: function( fn, context ) {
					var tmp, args, proxy;

					if ( typeof context === "string" ) {
						tmp = fn[ context ];
						context = fn;
						fn = tmp;
					}

					// Quick check to determine if target is callable, in the spec
					// this throws a TypeError, but we will just return undefined.
					if ( !jQuery.isFunction( fn ) ) {
						return undefined;
					}

					// Simulated bind
					args = slice.call( arguments, 2 );
					proxy = function() {
						return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
					};

					// Set the guid of unique handler to the same of original handler, so it can be removed
					proxy.guid = fn.guid = fn.guid || jQuery.guid++;

					return proxy;
				},

				now: Date.now,

				// jQuery.support is not used in Core but other projects attach their
				// properties to it so it needs to exist.
				support: support
			} );

			if ( typeof Symbol === "function" ) {
				jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
			}

			// Populate the class2type map
			jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
			function( i, name ) {
				class2type[ "[object " + name + "]" ] = name.toLowerCase();
			} );

			function isArrayLike( obj ) {

				// Support: real iOS 8.2 only (not reproducible in simulator)
				// `in` check used to prevent JIT error (gh-2145)
				// hasOwn isn't used here due to false negatives
				// regarding Nodelist length in IE
				var length = !!obj && "length" in obj && obj.length,
					type = jQuery.type( obj );

				if ( type === "function" || jQuery.isWindow( obj ) ) {
					return false;
				}

				return type === "array" || length === 0 ||
					typeof length === "number" && length > 0 && ( length - 1 ) in obj;
			}
			var Sizzle =
			/*!
			 * Sizzle CSS Selector Engine v2.3.3
			 * https://sizzlejs.com/
			 *
			 * Copyright jQuery Foundation and other contributors
			 * Released under the MIT license
			 * http://jquery.org/license
			 *
			 * Date: 2016-08-08
			 */
			(function( window ) {

			var i,
				support,
				Expr,
				getText,
				isXML,
				tokenize,
				compile,
				select,
				outermostContext,
				sortInput,
				hasDuplicate,

				// Local document vars
				setDocument,
				document,
				docElem,
				documentIsHTML,
				rbuggyQSA,
				rbuggyMatches,
				matches,
				contains,

				// Instance-specific data
				expando = "sizzle" + 1 * new Date(),
				preferredDoc = window.document,
				dirruns = 0,
				done = 0,
				classCache = createCache(),
				tokenCache = createCache(),
				compilerCache = createCache(),
				sortOrder = function( a, b ) {
					if ( a === b ) {
						hasDuplicate = true;
					}
					return 0;
				},

				// Instance methods
				hasOwn = ({}).hasOwnProperty,
				arr = [],
				pop = arr.pop,
				push_native = arr.push,
				push = arr.push,
				slice = arr.slice,
				// Use a stripped-down indexOf as it's faster than native
				// https://jsperf.com/thor-indexof-vs-for/5
				indexOf = function( list, elem ) {
					var i = 0,
						len = list.length;
					for ( ; i < len; i++ ) {
						if ( list[i] === elem ) {
							return i;
						}
					}
					return -1;
				},

				booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

				// Regular expressions

				// http://www.w3.org/TR/css3-selectors/#whitespace
				whitespace = "[\\x20\\t\\r\\n\\f]",

				// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
				identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

				// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
				attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
					// Operator (capture 2)
					"*([*^$|!~]?=)" + whitespace +
					// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
					"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
					"*\\]",

				pseudos = ":(" + identifier + ")(?:\\((" +
					// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
					// 1. quoted (capture 3; capture 4 or capture 5)
					"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
					// 2. simple (capture 6)
					"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
					// 3. anything else (capture 2)
					".*" +
					")\\)|)",

				// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
				rwhitespace = new RegExp( whitespace + "+", "g" ),
				rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

				rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
				rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

				rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

				rpseudo = new RegExp( pseudos ),
				ridentifier = new RegExp( "^" + identifier + "$" ),

				matchExpr = {
					"ID": new RegExp( "^#(" + identifier + ")" ),
					"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
					"TAG": new RegExp( "^(" + identifier + "|[*])" ),
					"ATTR": new RegExp( "^" + attributes ),
					"PSEUDO": new RegExp( "^" + pseudos ),
					"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
						"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
						"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
					"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
					// For use in libraries implementing .is()
					// We use this for POS matching in `select`
					"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
						whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
				},

				rinputs = /^(?:input|select|textarea|button)$/i,
				rheader = /^h\d$/i,

				rnative = /^[^{]+\{\s*\[native \w/,

				// Easily-parseable/retrievable ID or TAG or CLASS selectors
				rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

				rsibling = /[+~]/,

				// CSS escapes
				// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
				runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
				funescape = function( _, escaped, escapedWhitespace ) {
					var high = "0x" + escaped - 0x10000;
					// NaN means non-codepoint
					// Support: Firefox<24
					// Workaround erroneous numeric interpretation of +"0x"
					return high !== high || escapedWhitespace ?
						escaped :
						high < 0 ?
							// BMP codepoint
							String.fromCharCode( high + 0x10000 ) :
							// Supplemental Plane codepoint (surrogate pair)
							String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
				},

				// CSS string/identifier serialization
				// https://drafts.csswg.org/cssom/#common-serializing-idioms
				rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
				fcssescape = function( ch, asCodePoint ) {
					if ( asCodePoint ) {

						// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
						if ( ch === "\0" ) {
							return "\uFFFD";
						}

						// Control characters and (dependent upon position) numbers get escaped as code points
						return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
					}

					// Other potentially-special ASCII characters get backslash-escaped
					return "\\" + ch;
				},

				// Used for iframes
				// See setDocument()
				// Removing the function wrapper causes a "Permission Denied"
				// error in IE
				unloadHandler = function() {
					setDocument();
				},

				disabledAncestor = addCombinator(
					function( elem ) {
						return elem.disabled === true && ("form" in elem || "label" in elem);
					},
					{ dir: "parentNode", next: "legend" }
				);

			// Optimize for push.apply( _, NodeList )
			try {
				push.apply(
					(arr = slice.call( preferredDoc.childNodes )),
					preferredDoc.childNodes
				);
				// Support: Android<4.0
				// Detect silently failing push.apply
				arr[ preferredDoc.childNodes.length ].nodeType;
			} catch ( e ) {
				push = { apply: arr.length ?

					// Leverage slice if possible
					function( target, els ) {
						push_native.apply( target, slice.call(els) );
					} :

					// Support: IE<9
					// Otherwise append directly
					function( target, els ) {
						var j = target.length,
							i = 0;
						// Can't trust NodeList.length
						while ( (target[j++] = els[i++]) ) {}
						target.length = j - 1;
					}
				};
			}

			function Sizzle( selector, context, results, seed ) {
				var m, i, elem, nid, match, groups, newSelector,
					newContext = context && context.ownerDocument,

					// nodeType defaults to 9, since context defaults to document
					nodeType = context ? context.nodeType : 9;

				results = results || [];

				// Return early from calls with invalid selector or context
				if ( typeof selector !== "string" || !selector ||
					nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

					return results;
				}

				// Try to shortcut find operations (as opposed to filters) in HTML documents
				if ( !seed ) {

					if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
						setDocument( context );
					}
					context = context || document;

					if ( documentIsHTML ) {

						// If the selector is sufficiently simple, try using a "get*By*" DOM method
						// (excepting DocumentFragment context, where the methods don't exist)
						if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

							// ID selector
							if ( (m = match[1]) ) {

								// Document context
								if ( nodeType === 9 ) {
									if ( (elem = context.getElementById( m )) ) {

										// Support: IE, Opera, Webkit
										// TODO: identify versions
										// getElementById can match elements by name instead of ID
										if ( elem.id === m ) {
											results.push( elem );
											return results;
										}
									} else {
										return results;
									}

								// Element context
								} else {

									// Support: IE, Opera, Webkit
									// TODO: identify versions
									// getElementById can match elements by name instead of ID
									if ( newContext && (elem = newContext.getElementById( m )) &&
										contains( context, elem ) &&
										elem.id === m ) {

										results.push( elem );
										return results;
									}
								}

							// Type selector
							} else if ( match[2] ) {
								push.apply( results, context.getElementsByTagName( selector ) );
								return results;

							// Class selector
							} else if ( (m = match[3]) && support.getElementsByClassName &&
								context.getElementsByClassName ) {

								push.apply( results, context.getElementsByClassName( m ) );
								return results;
							}
						}

						// Take advantage of querySelectorAll
						if ( support.qsa &&
							!compilerCache[ selector + " " ] &&
							(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

							if ( nodeType !== 1 ) {
								newContext = context;
								newSelector = selector;

							// qSA looks outside Element context, which is not what we want
							// Thanks to Andrew Dupont for this workaround technique
							// Support: IE <=8
							// Exclude object elements
							} else if ( context.nodeName.toLowerCase() !== "object" ) {

								// Capture the context ID, setting it first if necessary
								if ( (nid = context.getAttribute( "id" )) ) {
									nid = nid.replace( rcssescape, fcssescape );
								} else {
									context.setAttribute( "id", (nid = expando) );
								}

								// Prefix every selector in the list
								groups = tokenize( selector );
								i = groups.length;
								while ( i-- ) {
									groups[i] = "#" + nid + " " + toSelector( groups[i] );
								}
								newSelector = groups.join( "," );

								// Expand context for sibling selectors
								newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
									context;
							}

							if ( newSelector ) {
								try {
									push.apply( results,
										newContext.querySelectorAll( newSelector )
									);
									return results;
								} catch ( qsaError ) {
								} finally {
									if ( nid === expando ) {
										context.removeAttribute( "id" );
									}
								}
							}
						}
					}
				}

				// All others
				return select( selector.replace( rtrim, "$1" ), context, results, seed );
			}

			/**
			 * Create key-value caches of limited size
			 * @returns {function(string, object)} Returns the Object data after storing it on itself with
			 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
			 *	deleting the oldest entry
			 */
			function createCache() {
				var keys = [];

				function cache( key, value ) {
					// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
					if ( keys.push( key + " " ) > Expr.cacheLength ) {
						// Only keep the most recent entries
						delete cache[ keys.shift() ];
					}
					return (cache[ key + " " ] = value);
				}
				return cache;
			}

			/**
			 * Mark a function for special use by Sizzle
			 * @param {Function} fn The function to mark
			 */
			function markFunction( fn ) {
				fn[ expando ] = true;
				return fn;
			}

			/**
			 * Support testing using an element
			 * @param {Function} fn Passed the created element and returns a boolean result
			 */
			function assert( fn ) {
				var el = document.createElement("fieldset");

				try {
					return !!fn( el );
				} catch (e) {
					return false;
				} finally {
					// Remove from its parent by default
					if ( el.parentNode ) {
						el.parentNode.removeChild( el );
					}
					// release memory in IE
					el = null;
				}
			}

			/**
			 * Adds the same handler for all of the specified attrs
			 * @param {String} attrs Pipe-separated list of attributes
			 * @param {Function} handler The method that will be applied
			 */
			function addHandle( attrs, handler ) {
				var arr = attrs.split("|"),
					i = arr.length;

				while ( i-- ) {
					Expr.attrHandle[ arr[i] ] = handler;
				}
			}

			/**
			 * Checks document order of two siblings
			 * @param {Element} a
			 * @param {Element} b
			 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
			 */
			function siblingCheck( a, b ) {
				var cur = b && a,
					diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
						a.sourceIndex - b.sourceIndex;

				// Use IE sourceIndex if available on both nodes
				if ( diff ) {
					return diff;
				}

				// Check if b follows a
				if ( cur ) {
					while ( (cur = cur.nextSibling) ) {
						if ( cur === b ) {
							return -1;
						}
					}
				}

				return a ? 1 : -1;
			}

			/**
			 * Returns a function to use in pseudos for input types
			 * @param {String} type
			 */
			function createInputPseudo( type ) {
				return function( elem ) {
					var name = elem.nodeName.toLowerCase();
					return name === "input" && elem.type === type;
				};
			}

			/**
			 * Returns a function to use in pseudos for buttons
			 * @param {String} type
			 */
			function createButtonPseudo( type ) {
				return function( elem ) {
					var name = elem.nodeName.toLowerCase();
					return (name === "input" || name === "button") && elem.type === type;
				};
			}

			/**
			 * Returns a function to use in pseudos for :enabled/:disabled
			 * @param {Boolean} disabled true for :disabled; false for :enabled
			 */
			function createDisabledPseudo( disabled ) {

				// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
				return function( elem ) {

					// Only certain elements can match :enabled or :disabled
					// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
					// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
					if ( "form" in elem ) {

						// Check for inherited disabledness on relevant non-disabled elements:
						// * listed form-associated elements in a disabled fieldset
						//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
						//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
						// * option elements in a disabled optgroup
						//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
						// All such elements have a "form" property.
						if ( elem.parentNode && elem.disabled === false ) {

							// Option elements defer to a parent optgroup if present
							if ( "label" in elem ) {
								if ( "label" in elem.parentNode ) {
									return elem.parentNode.disabled === disabled;
								} else {
									return elem.disabled === disabled;
								}
							}

							// Support: IE 6 - 11
							// Use the isDisabled shortcut property to check for disabled fieldset ancestors
							return elem.isDisabled === disabled ||

								// Where there is no isDisabled, check manually
								/* jshint -W018 */
								elem.isDisabled !== !disabled &&
									disabledAncestor( elem ) === disabled;
						}

						return elem.disabled === disabled;

					// Try to winnow out elements that can't be disabled before trusting the disabled property.
					// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
					// even exist on them, let alone have a boolean value.
					} else if ( "label" in elem ) {
						return elem.disabled === disabled;
					}

					// Remaining elements are neither :enabled nor :disabled
					return false;
				};
			}

			/**
			 * Returns a function to use in pseudos for positionals
			 * @param {Function} fn
			 */
			function createPositionalPseudo( fn ) {
				return markFunction(function( argument ) {
					argument = +argument;
					return markFunction(function( seed, matches ) {
						var j,
							matchIndexes = fn( [], seed.length, argument ),
							i = matchIndexes.length;

						// Match elements found at the specified indexes
						while ( i-- ) {
							if ( seed[ (j = matchIndexes[i]) ] ) {
								seed[j] = !(matches[j] = seed[j]);
							}
						}
					});
				});
			}

			/**
			 * Checks a node for validity as a Sizzle context
			 * @param {Element|Object=} context
			 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
			 */
			function testContext( context ) {
				return context && typeof context.getElementsByTagName !== "undefined" && context;
			}

			// Expose support vars for convenience
			support = Sizzle.support = {};

			/**
			 * Detects XML nodes
			 * @param {Element|Object} elem An element or a document
			 * @returns {Boolean} True iff elem is a non-HTML XML node
			 */
			isXML = Sizzle.isXML = function( elem ) {
				// documentElement is verified for cases where it doesn't yet exist
				// (such as loading iframes in IE - #4833)
				var documentElement = elem && (elem.ownerDocument || elem).documentElement;
				return documentElement ? documentElement.nodeName !== "HTML" : false;
			};

			/**
			 * Sets document-related variables once based on the current document
			 * @param {Element|Object} [doc] An element or document object to use to set the document
			 * @returns {Object} Returns the current document
			 */
			setDocument = Sizzle.setDocument = function( node ) {
				var hasCompare, subWindow,
					doc = node ? node.ownerDocument || node : preferredDoc;

				// Return early if doc is invalid or already selected
				if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
					return document;
				}

				// Update global variables
				document = doc;
				docElem = document.documentElement;
				documentIsHTML = !isXML( document );

				// Support: IE 9-11, Edge
				// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
				if ( preferredDoc !== document &&
					(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

					// Support: IE 11, Edge
					if ( subWindow.addEventListener ) {
						subWindow.addEventListener( "unload", unloadHandler, false );

					// Support: IE 9 - 10 only
					} else if ( subWindow.attachEvent ) {
						subWindow.attachEvent( "onunload", unloadHandler );
					}
				}

				/* Attributes
				---------------------------------------------------------------------- */

				// Support: IE<8
				// Verify that getAttribute really returns attributes and not properties
				// (excepting IE8 booleans)
				support.attributes = assert(function( el ) {
					el.className = "i";
					return !el.getAttribute("className");
				});

				/* getElement(s)By*
				---------------------------------------------------------------------- */

				// Check if getElementsByTagName("*") returns only elements
				support.getElementsByTagName = assert(function( el ) {
					el.appendChild( document.createComment("") );
					return !el.getElementsByTagName("*").length;
				});

				// Support: IE<9
				support.getElementsByClassName = rnative.test( document.getElementsByClassName );

				// Support: IE<10
				// Check if getElementById returns elements by name
				// The broken getElementById methods don't pick up programmatically-set names,
				// so use a roundabout getElementsByName test
				support.getById = assert(function( el ) {
					docElem.appendChild( el ).id = expando;
					return !document.getElementsByName || !document.getElementsByName( expando ).length;
				});

				// ID filter and find
				if ( support.getById ) {
					Expr.filter["ID"] = function( id ) {
						var attrId = id.replace( runescape, funescape );
						return function( elem ) {
							return elem.getAttribute("id") === attrId;
						};
					};
					Expr.find["ID"] = function( id, context ) {
						if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
							var elem = context.getElementById( id );
							return elem ? [ elem ] : [];
						}
					};
				} else {
					Expr.filter["ID"] =  function( id ) {
						var attrId = id.replace( runescape, funescape );
						return function( elem ) {
							var node = typeof elem.getAttributeNode !== "undefined" &&
								elem.getAttributeNode("id");
							return node && node.value === attrId;
						};
					};

					// Support: IE 6 - 7 only
					// getElementById is not reliable as a find shortcut
					Expr.find["ID"] = function( id, context ) {
						if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
							var node, i, elems,
								elem = context.getElementById( id );

							if ( elem ) {

								// Verify the id attribute
								node = elem.getAttributeNode("id");
								if ( node && node.value === id ) {
									return [ elem ];
								}

								// Fall back on getElementsByName
								elems = context.getElementsByName( id );
								i = 0;
								while ( (elem = elems[i++]) ) {
									node = elem.getAttributeNode("id");
									if ( node && node.value === id ) {
										return [ elem ];
									}
								}
							}

							return [];
						}
					};
				}

				// Tag
				Expr.find["TAG"] = support.getElementsByTagName ?
					function( tag, context ) {
						if ( typeof context.getElementsByTagName !== "undefined" ) {
							return context.getElementsByTagName( tag );

						// DocumentFragment nodes don't have gEBTN
						} else if ( support.qsa ) {
							return context.querySelectorAll( tag );
						}
					} :

					function( tag, context ) {
						var elem,
							tmp = [],
							i = 0,
							// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
							results = context.getElementsByTagName( tag );

						// Filter out possible comments
						if ( tag === "*" ) {
							while ( (elem = results[i++]) ) {
								if ( elem.nodeType === 1 ) {
									tmp.push( elem );
								}
							}

							return tmp;
						}
						return results;
					};

				// Class
				Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
					if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
						return context.getElementsByClassName( className );
					}
				};

				/* QSA/matchesSelector
				---------------------------------------------------------------------- */

				// QSA and matchesSelector support

				// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
				rbuggyMatches = [];

				// qSa(:focus) reports false when true (Chrome 21)
				// We allow this because of a bug in IE8/9 that throws an error
				// whenever `document.activeElement` is accessed on an iframe
				// So, we allow :focus to pass through QSA all the time to avoid the IE error
				// See https://bugs.jquery.com/ticket/13378
				rbuggyQSA = [];

				if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
					// Build QSA regex
					// Regex strategy adopted from Diego Perini
					assert(function( el ) {
						// Select is set to empty string on purpose
						// This is to test IE's treatment of not explicitly
						// setting a boolean content attribute,
						// since its presence should be enough
						// https://bugs.jquery.com/ticket/12359
						docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
							"<select id='" + expando + "-\r\\' msallowcapture=''>" +
							"<option selected=''></option></select>";

						// Support: IE8, Opera 11-12.16
						// Nothing should be selected when empty strings follow ^= or $= or *=
						// The test attribute must be unknown in Opera but "safe" for WinRT
						// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
						if ( el.querySelectorAll("[msallowcapture^='']").length ) {
							rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
						}

						// Support: IE8
						// Boolean attributes and "value" are not treated correctly
						if ( !el.querySelectorAll("[selected]").length ) {
							rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
						}

						// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
						if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
							rbuggyQSA.push("~=");
						}

						// Webkit/Opera - :checked should return selected option elements
						// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
						// IE8 throws error here and will not see later tests
						if ( !el.querySelectorAll(":checked").length ) {
							rbuggyQSA.push(":checked");
						}

						// Support: Safari 8+, iOS 8+
						// https://bugs.webkit.org/show_bug.cgi?id=136851
						// In-page `selector#id sibling-combinator selector` fails
						if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
							rbuggyQSA.push(".#.+[+~]");
						}
					});

					assert(function( el ) {
						el.innerHTML = "<a href='' disabled='disabled'></a>" +
							"<select disabled='disabled'><option/></select>";

						// Support: Windows 8 Native Apps
						// The type and name attributes are restricted during .innerHTML assignment
						var input = document.createElement("input");
						input.setAttribute( "type", "hidden" );
						el.appendChild( input ).setAttribute( "name", "D" );

						// Support: IE8
						// Enforce case-sensitivity of name attribute
						if ( el.querySelectorAll("[name=d]").length ) {
							rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
						}

						// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
						// IE8 throws error here and will not see later tests
						if ( el.querySelectorAll(":enabled").length !== 2 ) {
							rbuggyQSA.push( ":enabled", ":disabled" );
						}

						// Support: IE9-11+
						// IE's :disabled selector does not pick up the children of disabled fieldsets
						docElem.appendChild( el ).disabled = true;
						if ( el.querySelectorAll(":disabled").length !== 2 ) {
							rbuggyQSA.push( ":enabled", ":disabled" );
						}

						// Opera 10-11 does not throw on post-comma invalid pseudos
						el.querySelectorAll("*,:x");
						rbuggyQSA.push(",.*:");
					});
				}

				if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
					docElem.webkitMatchesSelector ||
					docElem.mozMatchesSelector ||
					docElem.oMatchesSelector ||
					docElem.msMatchesSelector) )) ) {

					assert(function( el ) {
						// Check to see if it's possible to do matchesSelector
						// on a disconnected node (IE 9)
						support.disconnectedMatch = matches.call( el, "*" );

						// This should fail with an exception
						// Gecko does not error, returns false instead
						matches.call( el, "[s!='']:x" );
						rbuggyMatches.push( "!=", pseudos );
					});
				}

				rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
				rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

				/* Contains
				---------------------------------------------------------------------- */
				hasCompare = rnative.test( docElem.compareDocumentPosition );

				// Element contains another
				// Purposefully self-exclusive
				// As in, an element does not contain itself
				contains = hasCompare || rnative.test( docElem.contains ) ?
					function( a, b ) {
						var adown = a.nodeType === 9 ? a.documentElement : a,
							bup = b && b.parentNode;
						return a === bup || !!( bup && bup.nodeType === 1 && (
							adown.contains ?
								adown.contains( bup ) :
								a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
						));
					} :
					function( a, b ) {
						if ( b ) {
							while ( (b = b.parentNode) ) {
								if ( b === a ) {
									return true;
								}
							}
						}
						return false;
					};

				/* Sorting
				---------------------------------------------------------------------- */

				// Document order sorting
				sortOrder = hasCompare ?
				function( a, b ) {

					// Flag for duplicate removal
					if ( a === b ) {
						hasDuplicate = true;
						return 0;
					}

					// Sort on method existence if only one input has compareDocumentPosition
					var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
					if ( compare ) {
						return compare;
					}

					// Calculate position if both inputs belong to the same document
					compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
						a.compareDocumentPosition( b ) :

						// Otherwise we know they are disconnected
						1;

					// Disconnected nodes
					if ( compare & 1 ||
						(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

						// Choose the first element that is related to our preferred document
						if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
							return -1;
						}
						if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
							return 1;
						}

						// Maintain original order
						return sortInput ?
							( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
							0;
					}

					return compare & 4 ? -1 : 1;
				} :
				function( a, b ) {
					// Exit early if the nodes are identical
					if ( a === b ) {
						hasDuplicate = true;
						return 0;
					}

					var cur,
						i = 0,
						aup = a.parentNode,
						bup = b.parentNode,
						ap = [ a ],
						bp = [ b ];

					// Parentless nodes are either documents or disconnected
					if ( !aup || !bup ) {
						return a === document ? -1 :
							b === document ? 1 :
							aup ? -1 :
							bup ? 1 :
							sortInput ?
							( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
							0;

					// If the nodes are siblings, we can do a quick check
					} else if ( aup === bup ) {
						return siblingCheck( a, b );
					}

					// Otherwise we need full lists of their ancestors for comparison
					cur = a;
					while ( (cur = cur.parentNode) ) {
						ap.unshift( cur );
					}
					cur = b;
					while ( (cur = cur.parentNode) ) {
						bp.unshift( cur );
					}

					// Walk down the tree looking for a discrepancy
					while ( ap[i] === bp[i] ) {
						i++;
					}

					return i ?
						// Do a sibling check if the nodes have a common ancestor
						siblingCheck( ap[i], bp[i] ) :

						// Otherwise nodes in our document sort first
						ap[i] === preferredDoc ? -1 :
						bp[i] === preferredDoc ? 1 :
						0;
				};

				return document;
			};

			Sizzle.matches = function( expr, elements ) {
				return Sizzle( expr, null, null, elements );
			};

			Sizzle.matchesSelector = function( elem, expr ) {
				// Set document vars if needed
				if ( ( elem.ownerDocument || elem ) !== document ) {
					setDocument( elem );
				}

				// Make sure that attribute selectors are quoted
				expr = expr.replace( rattributeQuotes, "='$1']" );

				if ( support.matchesSelector && documentIsHTML &&
					!compilerCache[ expr + " " ] &&
					( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
					( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

					try {
						var ret = matches.call( elem, expr );

						// IE 9's matchesSelector returns false on disconnected nodes
						if ( ret || support.disconnectedMatch ||
								// As well, disconnected nodes are said to be in a document
								// fragment in IE 9
								elem.document && elem.document.nodeType !== 11 ) {
							return ret;
						}
					} catch (e) {}
				}

				return Sizzle( expr, document, null, [ elem ] ).length > 0;
			};

			Sizzle.contains = function( context, elem ) {
				// Set document vars if needed
				if ( ( context.ownerDocument || context ) !== document ) {
					setDocument( context );
				}
				return contains( context, elem );
			};

			Sizzle.attr = function( elem, name ) {
				// Set document vars if needed
				if ( ( elem.ownerDocument || elem ) !== document ) {
					setDocument( elem );
				}

				var fn = Expr.attrHandle[ name.toLowerCase() ],
					// Don't get fooled by Object.prototype properties (jQuery #13807)
					val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
						fn( elem, name, !documentIsHTML ) :
						undefined;

				return val !== undefined ?
					val :
					support.attributes || !documentIsHTML ?
						elem.getAttribute( name ) :
						(val = elem.getAttributeNode(name)) && val.specified ?
							val.value :
							null;
			};

			Sizzle.escape = function( sel ) {
				return (sel + "").replace( rcssescape, fcssescape );
			};

			Sizzle.error = function( msg ) {
				throw new Error( "Syntax error, unrecognized expression: " + msg );
			};

			/**
			 * Document sorting and removing duplicates
			 * @param {ArrayLike} results
			 */
			Sizzle.uniqueSort = function( results ) {
				var elem,
					duplicates = [],
					j = 0,
					i = 0;

				// Unless we *know* we can detect duplicates, assume their presence
				hasDuplicate = !support.detectDuplicates;
				sortInput = !support.sortStable && results.slice( 0 );
				results.sort( sortOrder );

				if ( hasDuplicate ) {
					while ( (elem = results[i++]) ) {
						if ( elem === results[ i ] ) {
							j = duplicates.push( i );
						}
					}
					while ( j-- ) {
						results.splice( duplicates[ j ], 1 );
					}
				}

				// Clear input after sorting to release objects
				// See https://github.com/jquery/sizzle/pull/225
				sortInput = null;

				return results;
			};

			/**
			 * Utility function for retrieving the text value of an array of DOM nodes
			 * @param {Array|Element} elem
			 */
			getText = Sizzle.getText = function( elem ) {
				var node,
					ret = "",
					i = 0,
					nodeType = elem.nodeType;

				if ( !nodeType ) {
					// If no nodeType, this is expected to be an array
					while ( (node = elem[i++]) ) {
						// Do not traverse comment nodes
						ret += getText( node );
					}
				} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
					// Use textContent for elements
					// innerText usage removed for consistency of new lines (jQuery #11153)
					if ( typeof elem.textContent === "string" ) {
						return elem.textContent;
					} else {
						// Traverse its children
						for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
							ret += getText( elem );
						}
					}
				} else if ( nodeType === 3 || nodeType === 4 ) {
					return elem.nodeValue;
				}
				// Do not include comment or processing instruction nodes

				return ret;
			};

			Expr = Sizzle.selectors = {

				// Can be adjusted by the user
				cacheLength: 50,

				createPseudo: markFunction,

				match: matchExpr,

				attrHandle: {},

				find: {},

				relative: {
					">": { dir: "parentNode", first: true },
					" ": { dir: "parentNode" },
					"+": { dir: "previousSibling", first: true },
					"~": { dir: "previousSibling" }
				},

				preFilter: {
					"ATTR": function( match ) {
						match[1] = match[1].replace( runescape, funescape );

						// Move the given value to match[3] whether quoted or unquoted
						match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

						if ( match[2] === "~=" ) {
							match[3] = " " + match[3] + " ";
						}

						return match.slice( 0, 4 );
					},

					"CHILD": function( match ) {
						/* matches from matchExpr["CHILD"]
							1 type (only|nth|...)
							2 what (child|of-type)
							3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
							4 xn-component of xn+y argument ([+-]?\d*n|)
							5 sign of xn-component
							6 x of xn-component
							7 sign of y-component
							8 y of y-component
						*/
						match[1] = match[1].toLowerCase();

						if ( match[1].slice( 0, 3 ) === "nth" ) {
							// nth-* requires argument
							if ( !match[3] ) {
								Sizzle.error( match[0] );
							}

							// numeric x and y parameters for Expr.filter.CHILD
							// remember that false/true cast respectively to 0/1
							match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
							match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

						// other types prohibit arguments
						} else if ( match[3] ) {
							Sizzle.error( match[0] );
						}

						return match;
					},

					"PSEUDO": function( match ) {
						var excess,
							unquoted = !match[6] && match[2];

						if ( matchExpr["CHILD"].test( match[0] ) ) {
							return null;
						}

						// Accept quoted arguments as-is
						if ( match[3] ) {
							match[2] = match[4] || match[5] || "";

						// Strip excess characters from unquoted arguments
						} else if ( unquoted && rpseudo.test( unquoted ) &&
							// Get excess from tokenize (recursively)
							(excess = tokenize( unquoted, true )) &&
							// advance to the next closing parenthesis
							(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

							// excess is a negative index
							match[0] = match[0].slice( 0, excess );
							match[2] = unquoted.slice( 0, excess );
						}

						// Return only captures needed by the pseudo filter method (type and argument)
						return match.slice( 0, 3 );
					}
				},

				filter: {

					"TAG": function( nodeNameSelector ) {
						var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
						return nodeNameSelector === "*" ?
							function() { return true; } :
							function( elem ) {
								return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
							};
					},

					"CLASS": function( className ) {
						var pattern = classCache[ className + " " ];

						return pattern ||
							(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
							classCache( className, function( elem ) {
								return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
							});
					},

					"ATTR": function( name, operator, check ) {
						return function( elem ) {
							var result = Sizzle.attr( elem, name );

							if ( result == null ) {
								return operator === "!=";
							}
							if ( !operator ) {
								return true;
							}

							result += "";

							return operator === "=" ? result === check :
								operator === "!=" ? result !== check :
								operator === "^=" ? check && result.indexOf( check ) === 0 :
								operator === "*=" ? check && result.indexOf( check ) > -1 :
								operator === "$=" ? check && result.slice( -check.length ) === check :
								operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
								operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
								false;
						};
					},

					"CHILD": function( type, what, argument, first, last ) {
						var simple = type.slice( 0, 3 ) !== "nth",
							forward = type.slice( -4 ) !== "last",
							ofType = what === "of-type";

						return first === 1 && last === 0 ?

							// Shortcut for :nth-*(n)
							function( elem ) {
								return !!elem.parentNode;
							} :

							function( elem, context, xml ) {
								var cache, uniqueCache, outerCache, node, nodeIndex, start,
									dir = simple !== forward ? "nextSibling" : "previousSibling",
									parent = elem.parentNode,
									name = ofType && elem.nodeName.toLowerCase(),
									useCache = !xml && !ofType,
									diff = false;

								if ( parent ) {

									// :(first|last|only)-(child|of-type)
									if ( simple ) {
										while ( dir ) {
											node = elem;
											while ( (node = node[ dir ]) ) {
												if ( ofType ?
													node.nodeName.toLowerCase() === name :
													node.nodeType === 1 ) {

													return false;
												}
											}
											// Reverse direction for :only-* (if we haven't yet done so)
											start = dir = type === "only" && !start && "nextSibling";
										}
										return true;
									}

									start = [ forward ? parent.firstChild : parent.lastChild ];

									// non-xml :nth-child(...) stores cache data on `parent`
									if ( forward && useCache ) {

										// Seek `elem` from a previously-cached index

										// ...in a gzip-friendly way
										node = parent;
										outerCache = node[ expando ] || (node[ expando ] = {});

										// Support: IE <9 only
										// Defend against cloned attroperties (jQuery gh-1709)
										uniqueCache = outerCache[ node.uniqueID ] ||
											(outerCache[ node.uniqueID ] = {});

										cache = uniqueCache[ type ] || [];
										nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
										diff = nodeIndex && cache[ 2 ];
										node = nodeIndex && parent.childNodes[ nodeIndex ];

										while ( (node = ++nodeIndex && node && node[ dir ] ||

											// Fallback to seeking `elem` from the start
											(diff = nodeIndex = 0) || start.pop()) ) {

											// When found, cache indexes on `parent` and break
											if ( node.nodeType === 1 && ++diff && node === elem ) {
												uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
												break;
											}
										}

									} else {
										// Use previously-cached element index if available
										if ( useCache ) {
											// ...in a gzip-friendly way
											node = elem;
											outerCache = node[ expando ] || (node[ expando ] = {});

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												(outerCache[ node.uniqueID ] = {});

											cache = uniqueCache[ type ] || [];
											nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
											diff = nodeIndex;
										}

										// xml :nth-child(...)
										// or :nth-last-child(...) or :nth(-last)?-of-type(...)
										if ( diff === false ) {
											// Use the same loop as above to seek `elem` from the start
											while ( (node = ++nodeIndex && node && node[ dir ] ||
												(diff = nodeIndex = 0) || start.pop()) ) {

												if ( ( ofType ?
													node.nodeName.toLowerCase() === name :
													node.nodeType === 1 ) &&
													++diff ) {

													// Cache the index of each encountered element
													if ( useCache ) {
														outerCache = node[ expando ] || (node[ expando ] = {});

														// Support: IE <9 only
														// Defend against cloned attroperties (jQuery gh-1709)
														uniqueCache = outerCache[ node.uniqueID ] ||
															(outerCache[ node.uniqueID ] = {});

														uniqueCache[ type ] = [ dirruns, diff ];
													}

													if ( node === elem ) {
														break;
													}
												}
											}
										}
									}

									// Incorporate the offset, then check against cycle size
									diff -= last;
									return diff === first || ( diff % first === 0 && diff / first >= 0 );
								}
							};
					},

					"PSEUDO": function( pseudo, argument ) {
						// pseudo-class names are case-insensitive
						// http://www.w3.org/TR/selectors/#pseudo-classes
						// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
						// Remember that setFilters inherits from pseudos
						var args,
							fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
								Sizzle.error( "unsupported pseudo: " + pseudo );

						// The user may use createPseudo to indicate that
						// arguments are needed to create the filter function
						// just as Sizzle does
						if ( fn[ expando ] ) {
							return fn( argument );
						}

						// But maintain support for old signatures
						if ( fn.length > 1 ) {
							args = [ pseudo, pseudo, "", argument ];
							return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
								markFunction(function( seed, matches ) {
									var idx,
										matched = fn( seed, argument ),
										i = matched.length;
									while ( i-- ) {
										idx = indexOf( seed, matched[i] );
										seed[ idx ] = !( matches[ idx ] = matched[i] );
									}
								}) :
								function( elem ) {
									return fn( elem, 0, args );
								};
						}

						return fn;
					}
				},

				pseudos: {
					// Potentially complex pseudos
					"not": markFunction(function( selector ) {
						// Trim the selector passed to compile
						// to avoid treating leading and trailing
						// spaces as combinators
						var input = [],
							results = [],
							matcher = compile( selector.replace( rtrim, "$1" ) );

						return matcher[ expando ] ?
							markFunction(function( seed, matches, context, xml ) {
								var elem,
									unmatched = matcher( seed, null, xml, [] ),
									i = seed.length;

								// Match elements unmatched by `matcher`
								while ( i-- ) {
									if ( (elem = unmatched[i]) ) {
										seed[i] = !(matches[i] = elem);
									}
								}
							}) :
							function( elem, context, xml ) {
								input[0] = elem;
								matcher( input, null, xml, results );
								// Don't keep the element (issue #299)
								input[0] = null;
								return !results.pop();
							};
					}),

					"has": markFunction(function( selector ) {
						return function( elem ) {
							return Sizzle( selector, elem ).length > 0;
						};
					}),

					"contains": markFunction(function( text ) {
						text = text.replace( runescape, funescape );
						return function( elem ) {
							return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
						};
					}),

					// "Whether an element is represented by a :lang() selector
					// is based solely on the element's language value
					// being equal to the identifier C,
					// or beginning with the identifier C immediately followed by "-".
					// The matching of C against the element's language value is performed case-insensitively.
					// The identifier C does not have to be a valid language name."
					// http://www.w3.org/TR/selectors/#lang-pseudo
					"lang": markFunction( function( lang ) {
						// lang value must be a valid identifier
						if ( !ridentifier.test(lang || "") ) {
							Sizzle.error( "unsupported lang: " + lang );
						}
						lang = lang.replace( runescape, funescape ).toLowerCase();
						return function( elem ) {
							var elemLang;
							do {
								if ( (elemLang = documentIsHTML ?
									elem.lang :
									elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

									elemLang = elemLang.toLowerCase();
									return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
								}
							} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
							return false;
						};
					}),

					// Miscellaneous
					"target": function( elem ) {
						var hash = window.location && window.location.hash;
						return hash && hash.slice( 1 ) === elem.id;
					},

					"root": function( elem ) {
						return elem === docElem;
					},

					"focus": function( elem ) {
						return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
					},

					// Boolean properties
					"enabled": createDisabledPseudo( false ),
					"disabled": createDisabledPseudo( true ),

					"checked": function( elem ) {
						// In CSS3, :checked should return both checked and selected elements
						// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
						var nodeName = elem.nodeName.toLowerCase();
						return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
					},

					"selected": function( elem ) {
						// Accessing this property makes selected-by-default
						// options in Safari work properly
						if ( elem.parentNode ) {
							elem.parentNode.selectedIndex;
						}

						return elem.selected === true;
					},

					// Contents
					"empty": function( elem ) {
						// http://www.w3.org/TR/selectors/#empty-pseudo
						// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
						//   but not by others (comment: 8; processing instruction: 7; etc.)
						// nodeType < 6 works because attributes (2) do not appear as children
						for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
							if ( elem.nodeType < 6 ) {
								return false;
							}
						}
						return true;
					},

					"parent": function( elem ) {
						return !Expr.pseudos["empty"]( elem );
					},

					// Element/input types
					"header": function( elem ) {
						return rheader.test( elem.nodeName );
					},

					"input": function( elem ) {
						return rinputs.test( elem.nodeName );
					},

					"button": function( elem ) {
						var name = elem.nodeName.toLowerCase();
						return name === "input" && elem.type === "button" || name === "button";
					},

					"text": function( elem ) {
						var attr;
						return elem.nodeName.toLowerCase() === "input" &&
							elem.type === "text" &&

							// Support: IE<8
							// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
							( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
					},

					// Position-in-collection
					"first": createPositionalPseudo(function() {
						return [ 0 ];
					}),

					"last": createPositionalPseudo(function( matchIndexes, length ) {
						return [ length - 1 ];
					}),

					"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
						return [ argument < 0 ? argument + length : argument ];
					}),

					"even": createPositionalPseudo(function( matchIndexes, length ) {
						var i = 0;
						for ( ; i < length; i += 2 ) {
							matchIndexes.push( i );
						}
						return matchIndexes;
					}),

					"odd": createPositionalPseudo(function( matchIndexes, length ) {
						var i = 1;
						for ( ; i < length; i += 2 ) {
							matchIndexes.push( i );
						}
						return matchIndexes;
					}),

					"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
						var i = argument < 0 ? argument + length : argument;
						for ( ; --i >= 0; ) {
							matchIndexes.push( i );
						}
						return matchIndexes;
					}),

					"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
						var i = argument < 0 ? argument + length : argument;
						for ( ; ++i < length; ) {
							matchIndexes.push( i );
						}
						return matchIndexes;
					})
				}
			};

			Expr.pseudos["nth"] = Expr.pseudos["eq"];

			// Add button/input type pseudos
			for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
				Expr.pseudos[ i ] = createInputPseudo( i );
			}
			for ( i in { submit: true, reset: true } ) {
				Expr.pseudos[ i ] = createButtonPseudo( i );
			}

			// Easy API for creating new setFilters
			function setFilters() {}
			setFilters.prototype = Expr.filters = Expr.pseudos;
			Expr.setFilters = new setFilters();

			tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
				var matched, match, tokens, type,
					soFar, groups, preFilters,
					cached = tokenCache[ selector + " " ];

				if ( cached ) {
					return parseOnly ? 0 : cached.slice( 0 );
				}

				soFar = selector;
				groups = [];
				preFilters = Expr.preFilter;

				while ( soFar ) {

					// Comma and first run
					if ( !matched || (match = rcomma.exec( soFar )) ) {
						if ( match ) {
							// Don't consume trailing commas as valid
							soFar = soFar.slice( match[0].length ) || soFar;
						}
						groups.push( (tokens = []) );
					}

					matched = false;

					// Combinators
					if ( (match = rcombinators.exec( soFar )) ) {
						matched = match.shift();
						tokens.push({
							value: matched,
							// Cast descendant combinators to space
							type: match[0].replace( rtrim, " " )
						});
						soFar = soFar.slice( matched.length );
					}

					// Filters
					for ( type in Expr.filter ) {
						if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
							(match = preFilters[ type ]( match ))) ) {
							matched = match.shift();
							tokens.push({
								value: matched,
								type: type,
								matches: match
							});
							soFar = soFar.slice( matched.length );
						}
					}

					if ( !matched ) {
						break;
					}
				}

				// Return the length of the invalid excess
				// if we're just parsing
				// Otherwise, throw an error or return tokens
				return parseOnly ?
					soFar.length :
					soFar ?
						Sizzle.error( selector ) :
						// Cache the tokens
						tokenCache( selector, groups ).slice( 0 );
			};

			function toSelector( tokens ) {
				var i = 0,
					len = tokens.length,
					selector = "";
				for ( ; i < len; i++ ) {
					selector += tokens[i].value;
				}
				return selector;
			}

			function addCombinator( matcher, combinator, base ) {
				var dir = combinator.dir,
					skip = combinator.next,
					key = skip || dir,
					checkNonElements = base && key === "parentNode",
					doneName = done++;

				return combinator.first ?
					// Check against closest ancestor/preceding element
					function( elem, context, xml ) {
						while ( (elem = elem[ dir ]) ) {
							if ( elem.nodeType === 1 || checkNonElements ) {
								return matcher( elem, context, xml );
							}
						}
						return false;
					} :

					// Check against all ancestor/preceding elements
					function( elem, context, xml ) {
						var oldCache, uniqueCache, outerCache,
							newCache = [ dirruns, doneName ];

						// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
						if ( xml ) {
							while ( (elem = elem[ dir ]) ) {
								if ( elem.nodeType === 1 || checkNonElements ) {
									if ( matcher( elem, context, xml ) ) {
										return true;
									}
								}
							}
						} else {
							while ( (elem = elem[ dir ]) ) {
								if ( elem.nodeType === 1 || checkNonElements ) {
									outerCache = elem[ expando ] || (elem[ expando ] = {});

									// Support: IE <9 only
									// Defend against cloned attroperties (jQuery gh-1709)
									uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

									if ( skip && skip === elem.nodeName.toLowerCase() ) {
										elem = elem[ dir ] || elem;
									} else if ( (oldCache = uniqueCache[ key ]) &&
										oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

										// Assign to newCache so results back-propagate to previous elements
										return (newCache[ 2 ] = oldCache[ 2 ]);
									} else {
										// Reuse newcache so results back-propagate to previous elements
										uniqueCache[ key ] = newCache;

										// A match means we're done; a fail means we have to keep checking
										if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
											return true;
										}
									}
								}
							}
						}
						return false;
					};
			}

			function elementMatcher( matchers ) {
				return matchers.length > 1 ?
					function( elem, context, xml ) {
						var i = matchers.length;
						while ( i-- ) {
							if ( !matchers[i]( elem, context, xml ) ) {
								return false;
							}
						}
						return true;
					} :
					matchers[0];
			}

			function multipleContexts( selector, contexts, results ) {
				var i = 0,
					len = contexts.length;
				for ( ; i < len; i++ ) {
					Sizzle( selector, contexts[i], results );
				}
				return results;
			}

			function condense( unmatched, map, filter, context, xml ) {
				var elem,
					newUnmatched = [],
					i = 0,
					len = unmatched.length,
					mapped = map != null;

				for ( ; i < len; i++ ) {
					if ( (elem = unmatched[i]) ) {
						if ( !filter || filter( elem, context, xml ) ) {
							newUnmatched.push( elem );
							if ( mapped ) {
								map.push( i );
							}
						}
					}
				}

				return newUnmatched;
			}

			function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
				if ( postFilter && !postFilter[ expando ] ) {
					postFilter = setMatcher( postFilter );
				}
				if ( postFinder && !postFinder[ expando ] ) {
					postFinder = setMatcher( postFinder, postSelector );
				}
				return markFunction(function( seed, results, context, xml ) {
					var temp, i, elem,
						preMap = [],
						postMap = [],
						preexisting = results.length,

						// Get initial elements from seed or context
						elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

						// Prefilter to get matcher input, preserving a map for seed-results synchronization
						matcherIn = preFilter && ( seed || !selector ) ?
							condense( elems, preMap, preFilter, context, xml ) :
							elems,

						matcherOut = matcher ?
							// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
							postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

								// ...intermediate processing is necessary
								[] :

								// ...otherwise use results directly
								results :
							matcherIn;

					// Find primary matches
					if ( matcher ) {
						matcher( matcherIn, matcherOut, context, xml );
					}

					// Apply postFilter
					if ( postFilter ) {
						temp = condense( matcherOut, postMap );
						postFilter( temp, [], context, xml );

						// Un-match failing elements by moving them back to matcherIn
						i = temp.length;
						while ( i-- ) {
							if ( (elem = temp[i]) ) {
								matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
							}
						}
					}

					if ( seed ) {
						if ( postFinder || preFilter ) {
							if ( postFinder ) {
								// Get the final matcherOut by condensing this intermediate into postFinder contexts
								temp = [];
								i = matcherOut.length;
								while ( i-- ) {
									if ( (elem = matcherOut[i]) ) {
										// Restore matcherIn since elem is not yet a final match
										temp.push( (matcherIn[i] = elem) );
									}
								}
								postFinder( null, (matcherOut = []), temp, xml );
							}

							// Move matched elements from seed to results to keep them synchronized
							i = matcherOut.length;
							while ( i-- ) {
								if ( (elem = matcherOut[i]) &&
									(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

									seed[temp] = !(results[temp] = elem);
								}
							}
						}

					// Add elements to results, through postFinder if defined
					} else {
						matcherOut = condense(
							matcherOut === results ?
								matcherOut.splice( preexisting, matcherOut.length ) :
								matcherOut
						);
						if ( postFinder ) {
							postFinder( null, results, matcherOut, xml );
						} else {
							push.apply( results, matcherOut );
						}
					}
				});
			}

			function matcherFromTokens( tokens ) {
				var checkContext, matcher, j,
					len = tokens.length,
					leadingRelative = Expr.relative[ tokens[0].type ],
					implicitRelative = leadingRelative || Expr.relative[" "],
					i = leadingRelative ? 1 : 0,

					// The foundational matcher ensures that elements are reachable from top-level context(s)
					matchContext = addCombinator( function( elem ) {
						return elem === checkContext;
					}, implicitRelative, true ),
					matchAnyContext = addCombinator( function( elem ) {
						return indexOf( checkContext, elem ) > -1;
					}, implicitRelative, true ),
					matchers = [ function( elem, context, xml ) {
						var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
							(checkContext = context).nodeType ?
								matchContext( elem, context, xml ) :
								matchAnyContext( elem, context, xml ) );
						// Avoid hanging onto element (issue #299)
						checkContext = null;
						return ret;
					} ];

				for ( ; i < len; i++ ) {
					if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
						matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
					} else {
						matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

						// Return special upon seeing a positional matcher
						if ( matcher[ expando ] ) {
							// Find the next relative operator (if any) for proper handling
							j = ++i;
							for ( ; j < len; j++ ) {
								if ( Expr.relative[ tokens[j].type ] ) {
									break;
								}
							}
							return setMatcher(
								i > 1 && elementMatcher( matchers ),
								i > 1 && toSelector(
									// If the preceding token was a descendant combinator, insert an implicit any-element `*`
									tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
								).replace( rtrim, "$1" ),
								matcher,
								i < j && matcherFromTokens( tokens.slice( i, j ) ),
								j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
								j < len && toSelector( tokens )
							);
						}
						matchers.push( matcher );
					}
				}

				return elementMatcher( matchers );
			}

			function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
				var bySet = setMatchers.length > 0,
					byElement = elementMatchers.length > 0,
					superMatcher = function( seed, context, xml, results, outermost ) {
						var elem, j, matcher,
							matchedCount = 0,
							i = "0",
							unmatched = seed && [],
							setMatched = [],
							contextBackup = outermostContext,
							// We must always have either seed elements or outermost context
							elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
							// Use integer dirruns iff this is the outermost matcher
							dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
							len = elems.length;

						if ( outermost ) {
							outermostContext = context === document || context || outermost;
						}

						// Add elements passing elementMatchers directly to results
						// Support: IE<9, Safari
						// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
						for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
							if ( byElement && elem ) {
								j = 0;
								if ( !context && elem.ownerDocument !== document ) {
									setDocument( elem );
									xml = !documentIsHTML;
								}
								while ( (matcher = elementMatchers[j++]) ) {
									if ( matcher( elem, context || document, xml) ) {
										results.push( elem );
										break;
									}
								}
								if ( outermost ) {
									dirruns = dirrunsUnique;
								}
							}

							// Track unmatched elements for set filters
							if ( bySet ) {
								// They will have gone through all possible matchers
								if ( (elem = !matcher && elem) ) {
									matchedCount--;
								}

								// Lengthen the array for every element, matched or not
								if ( seed ) {
									unmatched.push( elem );
								}
							}
						}

						// `i` is now the count of elements visited above, and adding it to `matchedCount`
						// makes the latter nonnegative.
						matchedCount += i;

						// Apply set filters to unmatched elements
						// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
						// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
						// no element matchers and no seed.
						// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
						// case, which will result in a "00" `matchedCount` that differs from `i` but is also
						// numerically zero.
						if ( bySet && i !== matchedCount ) {
							j = 0;
							while ( (matcher = setMatchers[j++]) ) {
								matcher( unmatched, setMatched, context, xml );
							}

							if ( seed ) {
								// Reintegrate element matches to eliminate the need for sorting
								if ( matchedCount > 0 ) {
									while ( i-- ) {
										if ( !(unmatched[i] || setMatched[i]) ) {
											setMatched[i] = pop.call( results );
										}
									}
								}

								// Discard index placeholder values to get only actual matches
								setMatched = condense( setMatched );
							}

							// Add matches to results
							push.apply( results, setMatched );

							// Seedless set matches succeeding multiple successful matchers stipulate sorting
							if ( outermost && !seed && setMatched.length > 0 &&
								( matchedCount + setMatchers.length ) > 1 ) {

								Sizzle.uniqueSort( results );
							}
						}

						// Override manipulation of globals by nested matchers
						if ( outermost ) {
							dirruns = dirrunsUnique;
							outermostContext = contextBackup;
						}

						return unmatched;
					};

				return bySet ?
					markFunction( superMatcher ) :
					superMatcher;
			}

			compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
				var i,
					setMatchers = [],
					elementMatchers = [],
					cached = compilerCache[ selector + " " ];

				if ( !cached ) {
					// Generate a function of recursive functions that can be used to check each element
					if ( !match ) {
						match = tokenize( selector );
					}
					i = match.length;
					while ( i-- ) {
						cached = matcherFromTokens( match[i] );
						if ( cached[ expando ] ) {
							setMatchers.push( cached );
						} else {
							elementMatchers.push( cached );
						}
					}

					// Cache the compiled function
					cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

					// Save selector and tokenization
					cached.selector = selector;
				}
				return cached;
			};

			/**
			 * A low-level selection function that works with Sizzle's compiled
			 *  selector functions
			 * @param {String|Function} selector A selector or a pre-compiled
			 *  selector function built with Sizzle.compile
			 * @param {Element} context
			 * @param {Array} [results]
			 * @param {Array} [seed] A set of elements to match against
			 */
			select = Sizzle.select = function( selector, context, results, seed ) {
				var i, tokens, token, type, find,
					compiled = typeof selector === "function" && selector,
					match = !seed && tokenize( (selector = compiled.selector || selector) );

				results = results || [];

				// Try to minimize operations if there is only one selector in the list and no seed
				// (the latter of which guarantees us context)
				if ( match.length === 1 ) {

					// Reduce context if the leading compound selector is an ID
					tokens = match[0] = match[0].slice( 0 );
					if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
							context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {

						context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
						if ( !context ) {
							return results;

						// Precompiled matchers will still verify ancestry, so step up a level
						} else if ( compiled ) {
							context = context.parentNode;
						}

						selector = selector.slice( tokens.shift().value.length );
					}

					// Fetch a seed set for right-to-left matching
					i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
					while ( i-- ) {
						token = tokens[i];

						// Abort if we hit a combinator
						if ( Expr.relative[ (type = token.type) ] ) {
							break;
						}
						if ( (find = Expr.find[ type ]) ) {
							// Search, expanding context for leading sibling combinators
							if ( (seed = find(
								token.matches[0].replace( runescape, funescape ),
								rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
							)) ) {

								// If seed is empty or no tokens remain, we can return early
								tokens.splice( i, 1 );
								selector = seed.length && toSelector( tokens );
								if ( !selector ) {
									push.apply( results, seed );
									return results;
								}

								break;
							}
						}
					}
				}

				// Compile and execute a filtering function if one is not provided
				// Provide `match` to avoid retokenization if we modified the selector above
				( compiled || compile( selector, match ) )(
					seed,
					context,
					!documentIsHTML,
					results,
					!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
				);
				return results;
			};

			// One-time assignments

			// Sort stability
			support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

			// Support: Chrome 14-35+
			// Always assume duplicates if they aren't passed to the comparison function
			support.detectDuplicates = !!hasDuplicate;

			// Initialize against the default document
			setDocument();

			// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
			// Detached nodes confoundingly follow *each other*
			support.sortDetached = assert(function( el ) {
				// Should return 1, but returns 4 (following)
				return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
			});

			// Support: IE<8
			// Prevent attribute/property "interpolation"
			// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
			if ( !assert(function( el ) {
				el.innerHTML = "<a href='#'></a>";
				return el.firstChild.getAttribute("href") === "#" ;
			}) ) {
				addHandle( "type|href|height|width", function( elem, name, isXML ) {
					if ( !isXML ) {
						return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
					}
				});
			}

			// Support: IE<9
			// Use defaultValue in place of getAttribute("value")
			if ( !support.attributes || !assert(function( el ) {
				el.innerHTML = "<input/>";
				el.firstChild.setAttribute( "value", "" );
				return el.firstChild.getAttribute( "value" ) === "";
			}) ) {
				addHandle( "value", function( elem, name, isXML ) {
					if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
						return elem.defaultValue;
					}
				});
			}

			// Support: IE<9
			// Use getAttributeNode to fetch booleans when getAttribute lies
			if ( !assert(function( el ) {
				return el.getAttribute("disabled") == null;
			}) ) {
				addHandle( booleans, function( elem, name, isXML ) {
					var val;
					if ( !isXML ) {
						return elem[ name ] === true ? name.toLowerCase() :
								(val = elem.getAttributeNode( name )) && val.specified ?
								val.value :
							null;
					}
				});
			}

			return Sizzle;

			})( window );



			jQuery.find = Sizzle;
			jQuery.expr = Sizzle.selectors;

			// Deprecated
			jQuery.expr[ ":" ] = jQuery.expr.pseudos;
			jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
			jQuery.text = Sizzle.getText;
			jQuery.isXMLDoc = Sizzle.isXML;
			jQuery.contains = Sizzle.contains;
			jQuery.escapeSelector = Sizzle.escape;




			var dir = function( elem, dir, until ) {
				var matched = [],
					truncate = until !== undefined;

				while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
					if ( elem.nodeType === 1 ) {
						if ( truncate && jQuery( elem ).is( until ) ) {
							break;
						}
						matched.push( elem );
					}
				}
				return matched;
			};


			var siblings = function( n, elem ) {
				var matched = [];

				for ( ; n; n = n.nextSibling ) {
					if ( n.nodeType === 1 && n !== elem ) {
						matched.push( n );
					}
				}

				return matched;
			};


			var rneedsContext = jQuery.expr.match.needsContext;

			var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



			var risSimple = /^.[^:#\[\.,]*$/;

			// Implement the identical functionality for filter and not
			function winnow( elements, qualifier, not ) {
				if ( jQuery.isFunction( qualifier ) ) {
					return jQuery.grep( elements, function( elem, i ) {
						return !!qualifier.call( elem, i, elem ) !== not;
					} );
				}

				// Single element
				if ( qualifier.nodeType ) {
					return jQuery.grep( elements, function( elem ) {
						return ( elem === qualifier ) !== not;
					} );
				}

				// Arraylike of elements (jQuery, arguments, Array)
				if ( typeof qualifier !== "string" ) {
					return jQuery.grep( elements, function( elem ) {
						return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
					} );
				}

				// Simple selector that can be filtered directly, removing non-Elements
				if ( risSimple.test( qualifier ) ) {
					return jQuery.filter( qualifier, elements, not );
				}

				// Complex selector, compare the two sets, removing non-Elements
				qualifier = jQuery.filter( qualifier, elements );
				return jQuery.grep( elements, function( elem ) {
					return ( indexOf.call( qualifier, elem ) > -1 ) !== not && elem.nodeType === 1;
				} );
			}

			jQuery.filter = function( expr, elems, not ) {
				var elem = elems[ 0 ];

				if ( not ) {
					expr = ":not(" + expr + ")";
				}

				if ( elems.length === 1 && elem.nodeType === 1 ) {
					return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
				}

				return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
					return elem.nodeType === 1;
				} ) );
			};

			jQuery.fn.extend( {
				find: function( selector ) {
					var i, ret,
						len = this.length,
						self = this;

					if ( typeof selector !== "string" ) {
						return this.pushStack( jQuery( selector ).filter( function() {
							for ( i = 0; i < len; i++ ) {
								if ( jQuery.contains( self[ i ], this ) ) {
									return true;
								}
							}
						} ) );
					}

					ret = this.pushStack( [] );

					for ( i = 0; i < len; i++ ) {
						jQuery.find( selector, self[ i ], ret );
					}

					return len > 1 ? jQuery.uniqueSort( ret ) : ret;
				},
				filter: function( selector ) {
					return this.pushStack( winnow( this, selector || [], false ) );
				},
				not: function( selector ) {
					return this.pushStack( winnow( this, selector || [], true ) );
				},
				is: function( selector ) {
					return !!winnow(
						this,

						// If this is a positional/relative selector, check membership in the returned set
						// so $("p:first").is("p:last") won't return true for a doc with two "p".
						typeof selector === "string" && rneedsContext.test( selector ) ?
							jQuery( selector ) :
							selector || [],
						false
					).length;
				}
			} );


			// Initialize a jQuery object


			// A central reference to the root jQuery(document)
			var rootjQuery,

				// A simple way to check for HTML strings
				// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
				// Strict HTML recognition (#11290: must start with <)
				// Shortcut simple #id case for speed
				rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

				init = jQuery.fn.init = function( selector, context, root ) {
					var match, elem;

					// HANDLE: $(""), $(null), $(undefined), $(false)
					if ( !selector ) {
						return this;
					}

					// Method init() accepts an alternate rootjQuery
					// so migrate can support jQuery.sub (gh-2101)
					root = root || rootjQuery;

					// Handle HTML strings
					if ( typeof selector === "string" ) {
						if ( selector[ 0 ] === "<" &&
							selector[ selector.length - 1 ] === ">" &&
							selector.length >= 3 ) {

							// Assume that strings that start and end with <> are HTML and skip the regex check
							match = [ null, selector, null ];

						} else {
							match = rquickExpr.exec( selector );
						}

						// Match html or make sure no context is specified for #id
						if ( match && ( match[ 1 ] || !context ) ) {

							// HANDLE: $(html) -> $(array)
							if ( match[ 1 ] ) {
								context = context instanceof jQuery ? context[ 0 ] : context;

								// Option to run scripts is true for back-compat
								// Intentionally let the error be thrown if parseHTML is not present
								jQuery.merge( this, jQuery.parseHTML(
									match[ 1 ],
									context && context.nodeType ? context.ownerDocument || context : document,
									true
								) );

								// HANDLE: $(html, props)
								if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
									for ( match in context ) {

										// Properties of context are called as methods if possible
										if ( jQuery.isFunction( this[ match ] ) ) {
											this[ match ]( context[ match ] );

										// ...and otherwise set as attributes
										} else {
											this.attr( match, context[ match ] );
										}
									}
								}

								return this;

							// HANDLE: $(#id)
							} else {
								elem = document.getElementById( match[ 2 ] );

								if ( elem ) {

									// Inject the element directly into the jQuery object
									this[ 0 ] = elem;
									this.length = 1;
								}
								return this;
							}

						// HANDLE: $(expr, $(...))
						} else if ( !context || context.jquery ) {
							return ( context || root ).find( selector );

						// HANDLE: $(expr, context)
						// (which is just equivalent to: $(context).find(expr)
						} else {
							return this.constructor( context ).find( selector );
						}

					// HANDLE: $(DOMElement)
					} else if ( selector.nodeType ) {
						this[ 0 ] = selector;
						this.length = 1;
						return this;

					// HANDLE: $(function)
					// Shortcut for document ready
					} else if ( jQuery.isFunction( selector ) ) {
						return root.ready !== undefined ?
							root.ready( selector ) :

							// Execute immediately if ready is not present
							selector( jQuery );
					}

					return jQuery.makeArray( selector, this );
				};

			// Give the init function the jQuery prototype for later instantiation
			init.prototype = jQuery.fn;

			// Initialize central reference
			rootjQuery = jQuery( document );


			var rparentsprev = /^(?:parents|prev(?:Until|All))/,

				// Methods guaranteed to produce a unique set when starting from a unique set
				guaranteedUnique = {
					children: true,
					contents: true,
					next: true,
					prev: true
				};

			jQuery.fn.extend( {
				has: function( target ) {
					var targets = jQuery( target, this ),
						l = targets.length;

					return this.filter( function() {
						var i = 0;
						for ( ; i < l; i++ ) {
							if ( jQuery.contains( this, targets[ i ] ) ) {
								return true;
							}
						}
					} );
				},

				closest: function( selectors, context ) {
					var cur,
						i = 0,
						l = this.length,
						matched = [],
						targets = typeof selectors !== "string" && jQuery( selectors );

					// Positional selectors never match, since there's no _selection_ context
					if ( !rneedsContext.test( selectors ) ) {
						for ( ; i < l; i++ ) {
							for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

								// Always skip document fragments
								if ( cur.nodeType < 11 && ( targets ?
									targets.index( cur ) > -1 :

									// Don't pass non-elements to Sizzle
									cur.nodeType === 1 &&
										jQuery.find.matchesSelector( cur, selectors ) ) ) {

									matched.push( cur );
									break;
								}
							}
						}
					}

					return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
				},

				// Determine the position of an element within the set
				index: function( elem ) {

					// No argument, return index in parent
					if ( !elem ) {
						return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
					}

					// Index in selector
					if ( typeof elem === "string" ) {
						return indexOf.call( jQuery( elem ), this[ 0 ] );
					}

					// Locate the position of the desired element
					return indexOf.call( this,

						// If it receives a jQuery object, the first element is used
						elem.jquery ? elem[ 0 ] : elem
					);
				},

				add: function( selector, context ) {
					return this.pushStack(
						jQuery.uniqueSort(
							jQuery.merge( this.get(), jQuery( selector, context ) )
						)
					);
				},

				addBack: function( selector ) {
					return this.add( selector == null ?
						this.prevObject : this.prevObject.filter( selector )
					);
				}
			} );

			function sibling( cur, dir ) {
				while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
				return cur;
			}

			jQuery.each( {
				parent: function( elem ) {
					var parent = elem.parentNode;
					return parent && parent.nodeType !== 11 ? parent : null;
				},
				parents: function( elem ) {
					return dir( elem, "parentNode" );
				},
				parentsUntil: function( elem, i, until ) {
					return dir( elem, "parentNode", until );
				},
				next: function( elem ) {
					return sibling( elem, "nextSibling" );
				},
				prev: function( elem ) {
					return sibling( elem, "previousSibling" );
				},
				nextAll: function( elem ) {
					return dir( elem, "nextSibling" );
				},
				prevAll: function( elem ) {
					return dir( elem, "previousSibling" );
				},
				nextUntil: function( elem, i, until ) {
					return dir( elem, "nextSibling", until );
				},
				prevUntil: function( elem, i, until ) {
					return dir( elem, "previousSibling", until );
				},
				siblings: function( elem ) {
					return siblings( ( elem.parentNode || {} ).firstChild, elem );
				},
				children: function( elem ) {
					return siblings( elem.firstChild );
				},
				contents: function( elem ) {
					return elem.contentDocument || jQuery.merge( [], elem.childNodes );
				}
			}, function( name, fn ) {
				jQuery.fn[ name ] = function( until, selector ) {
					var matched = jQuery.map( this, fn, until );

					if ( name.slice( -5 ) !== "Until" ) {
						selector = until;
					}

					if ( selector && typeof selector === "string" ) {
						matched = jQuery.filter( selector, matched );
					}

					if ( this.length > 1 ) {

						// Remove duplicates
						if ( !guaranteedUnique[ name ] ) {
							jQuery.uniqueSort( matched );
						}

						// Reverse order for parents* and prev-derivatives
						if ( rparentsprev.test( name ) ) {
							matched.reverse();
						}
					}

					return this.pushStack( matched );
				};
			} );
			var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



			// Convert String-formatted options into Object-formatted ones
			function createOptions( options ) {
				var object = {};
				jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
					object[ flag ] = true;
				} );
				return object;
			}

			/*
			 * Create a callback list using the following parameters:
			 *
			 *	options: an optional list of space-separated options that will change how
			 *			the callback list behaves or a more traditional option object
			 *
			 * By default a callback list will act like an event callback list and can be
			 * "fired" multiple times.
			 *
			 * Possible options:
			 *
			 *	once:			will ensure the callback list can only be fired once (like a Deferred)
			 *
			 *	memory:			will keep track of previous values and will call any callback added
			 *					after the list has been fired right away with the latest "memorized"
			 *					values (like a Deferred)
			 *
			 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
			 *
			 *	stopOnFalse:	interrupt callings when a callback returns false
			 *
			 */
			jQuery.Callbacks = function( options ) {

				// Convert options from String-formatted to Object-formatted if needed
				// (we check in cache first)
				options = typeof options === "string" ?
					createOptions( options ) :
					jQuery.extend( {}, options );

				var // Flag to know if list is currently firing
					firing,

					// Last fire value for non-forgettable lists
					memory,

					// Flag to know if list was already fired
					fired,

					// Flag to prevent firing
					locked,

					// Actual callback list
					list = [],

					// Queue of execution data for repeatable lists
					queue = [],

					// Index of currently firing callback (modified by add/remove as needed)
					firingIndex = -1,

					// Fire callbacks
					fire = function() {

						// Enforce single-firing
						locked = options.once;

						// Execute callbacks for all pending executions,
						// respecting firingIndex overrides and runtime changes
						fired = firing = true;
						for ( ; queue.length; firingIndex = -1 ) {
							memory = queue.shift();
							while ( ++firingIndex < list.length ) {

								// Run callback and check for early termination
								if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
									options.stopOnFalse ) {

									// Jump to end and forget the data so .add doesn't re-fire
									firingIndex = list.length;
									memory = false;
								}
							}
						}

						// Forget the data if we're done with it
						if ( !options.memory ) {
							memory = false;
						}

						firing = false;

						// Clean up if we're done firing for good
						if ( locked ) {

							// Keep an empty list if we have data for future add calls
							if ( memory ) {
								list = [];

							// Otherwise, this object is spent
							} else {
								list = "";
							}
						}
					},

					// Actual Callbacks object
					self = {

						// Add a callback or a collection of callbacks to the list
						add: function() {
							if ( list ) {

								// If we have memory from a past run, we should fire after adding
								if ( memory && !firing ) {
									firingIndex = list.length - 1;
									queue.push( memory );
								}

								( function add( args ) {
									jQuery.each( args, function( _, arg ) {
										if ( jQuery.isFunction( arg ) ) {
											if ( !options.unique || !self.has( arg ) ) {
												list.push( arg );
											}
										} else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {

											// Inspect recursively
											add( arg );
										}
									} );
								} )( arguments );

								if ( memory && !firing ) {
									fire();
								}
							}
							return this;
						},

						// Remove a callback from the list
						remove: function() {
							jQuery.each( arguments, function( _, arg ) {
								var index;
								while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
									list.splice( index, 1 );

									// Handle firing indexes
									if ( index <= firingIndex ) {
										firingIndex--;
									}
								}
							} );
							return this;
						},

						// Check if a given callback is in the list.
						// If no argument is given, return whether or not list has callbacks attached.
						has: function( fn ) {
							return fn ?
								jQuery.inArray( fn, list ) > -1 :
								list.length > 0;
						},

						// Remove all callbacks from the list
						empty: function() {
							if ( list ) {
								list = [];
							}
							return this;
						},

						// Disable .fire and .add
						// Abort any current/pending executions
						// Clear all callbacks and values
						disable: function() {
							locked = queue = [];
							list = memory = "";
							return this;
						},
						disabled: function() {
							return !list;
						},

						// Disable .fire
						// Also disable .add unless we have memory (since it would have no effect)
						// Abort any pending executions
						lock: function() {
							locked = queue = [];
							if ( !memory && !firing ) {
								list = memory = "";
							}
							return this;
						},
						locked: function() {
							return !!locked;
						},

						// Call all callbacks with the given context and arguments
						fireWith: function( context, args ) {
							if ( !locked ) {
								args = args || [];
								args = [ context, args.slice ? args.slice() : args ];
								queue.push( args );
								if ( !firing ) {
									fire();
								}
							}
							return this;
						},

						// Call all the callbacks with the given arguments
						fire: function() {
							self.fireWith( this, arguments );
							return this;
						},

						// To know if the callbacks have already been called at least once
						fired: function() {
							return !!fired;
						}
					};

				return self;
			};


			function Identity( v ) {
				return v;
			}
			function Thrower( ex ) {
				throw ex;
			}

			function adoptValue( value, resolve, reject ) {
				var method;

				try {

					// Check for promise aspect first to privilege synchronous behavior
					if ( value && jQuery.isFunction( ( method = value.promise ) ) ) {
						method.call( value ).done( resolve ).fail( reject );

					// Other thenables
					} else if ( value && jQuery.isFunction( ( method = value.then ) ) ) {
						method.call( value, resolve, reject );

					// Other non-thenables
					} else {

						// Support: Android 4.0 only
						// Strict mode functions invoked without .call/.apply get global-object context
						resolve.call( undefined, value );
					}

				// For Promises/A+, convert exceptions into rejections
				// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
				// Deferred#then to conditionally suppress rejection.
				} catch ( value ) {

					// Support: Android 4.0 only
					// Strict mode functions invoked without .call/.apply get global-object context
					reject.call( undefined, value );
				}
			}

			jQuery.extend( {

				Deferred: function( func ) {
					var tuples = [

							// action, add listener, callbacks,
							// ... .then handlers, argument index, [final state]
							[ "notify", "progress", jQuery.Callbacks( "memory" ),
								jQuery.Callbacks( "memory" ), 2 ],
							[ "resolve", "done", jQuery.Callbacks( "once memory" ),
								jQuery.Callbacks( "once memory" ), 0, "resolved" ],
							[ "reject", "fail", jQuery.Callbacks( "once memory" ),
								jQuery.Callbacks( "once memory" ), 1, "rejected" ]
						],
						state = "pending",
						promise = {
							state: function() {
								return state;
							},
							always: function() {
								deferred.done( arguments ).fail( arguments );
								return this;
							},
							"catch": function( fn ) {
								return promise.then( null, fn );
							},

							// Keep pipe for back-compat
							pipe: function( /* fnDone, fnFail, fnProgress */ ) {
								var fns = arguments;

								return jQuery.Deferred( function( newDefer ) {
									jQuery.each( tuples, function( i, tuple ) {

										// Map tuples (progress, done, fail) to arguments (done, fail, progress)
										var fn = jQuery.isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

										// deferred.progress(function() { bind to newDefer or newDefer.notify })
										// deferred.done(function() { bind to newDefer or newDefer.resolve })
										// deferred.fail(function() { bind to newDefer or newDefer.reject })
										deferred[ tuple[ 1 ] ]( function() {
											var returned = fn && fn.apply( this, arguments );
											if ( returned && jQuery.isFunction( returned.promise ) ) {
												returned.promise()
													.progress( newDefer.notify )
													.done( newDefer.resolve )
													.fail( newDefer.reject );
											} else {
												newDefer[ tuple[ 0 ] + "With" ](
													this,
													fn ? [ returned ] : arguments
												);
											}
										} );
									} );
									fns = null;
								} ).promise();
							},
							then: function( onFulfilled, onRejected, onProgress ) {
								var maxDepth = 0;
								function resolve( depth, deferred, handler, special ) {
									return function() {
										var that = this,
											args = arguments,
											mightThrow = function() {
												var returned, then;

												// Support: Promises/A+ section 2.3.3.3.3
												// https://promisesaplus.com/#point-59
												// Ignore double-resolution attempts
												if ( depth < maxDepth ) {
													return;
												}

												returned = handler.apply( that, args );

												// Support: Promises/A+ section 2.3.1
												// https://promisesaplus.com/#point-48
												if ( returned === deferred.promise() ) {
													throw new TypeError( "Thenable self-resolution" );
												}

												// Support: Promises/A+ sections 2.3.3.1, 3.5
												// https://promisesaplus.com/#point-54
												// https://promisesaplus.com/#point-75
												// Retrieve `then` only once
												then = returned &&

													// Support: Promises/A+ section 2.3.4
													// https://promisesaplus.com/#point-64
													// Only check objects and functions for thenability
													( typeof returned === "object" ||
														typeof returned === "function" ) &&
													returned.then;

												// Handle a returned thenable
												if ( jQuery.isFunction( then ) ) {

													// Special processors (notify) just wait for resolution
													if ( special ) {
														then.call(
															returned,
															resolve( maxDepth, deferred, Identity, special ),
															resolve( maxDepth, deferred, Thrower, special )
														);

													// Normal processors (resolve) also hook into progress
													} else {

														// ...and disregard older resolution values
														maxDepth++;

														then.call(
															returned,
															resolve( maxDepth, deferred, Identity, special ),
															resolve( maxDepth, deferred, Thrower, special ),
															resolve( maxDepth, deferred, Identity,
																deferred.notifyWith )
														);
													}

												// Handle all other returned values
												} else {

													// Only substitute handlers pass on context
													// and multiple values (non-spec behavior)
													if ( handler !== Identity ) {
														that = undefined;
														args = [ returned ];
													}

													// Process the value(s)
													// Default process is resolve
													( special || deferred.resolveWith )( that, args );
												}
											},

											// Only normal processors (resolve) catch and reject exceptions
											process = special ?
												mightThrow :
												function() {
													try {
														mightThrow();
													} catch ( e ) {

														if ( jQuery.Deferred.exceptionHook ) {
															jQuery.Deferred.exceptionHook( e,
																process.stackTrace );
														}

														// Support: Promises/A+ section 2.3.3.3.4.1
														// https://promisesaplus.com/#point-61
														// Ignore post-resolution exceptions
														if ( depth + 1 >= maxDepth ) {

															// Only substitute handlers pass on context
															// and multiple values (non-spec behavior)
															if ( handler !== Thrower ) {
																that = undefined;
																args = [ e ];
															}

															deferred.rejectWith( that, args );
														}
													}
												};

										// Support: Promises/A+ section 2.3.3.3.1
										// https://promisesaplus.com/#point-57
										// Re-resolve promises immediately to dodge false rejection from
										// subsequent errors
										if ( depth ) {
											process();
										} else {

											// Call an optional hook to record the stack, in case of exception
											// since it's otherwise lost when execution goes async
											if ( jQuery.Deferred.getStackHook ) {
												process.stackTrace = jQuery.Deferred.getStackHook();
											}
											window.setTimeout( process );
										}
									};
								}

								return jQuery.Deferred( function( newDefer ) {

									// progress_handlers.add( ... )
									tuples[ 0 ][ 3 ].add(
										resolve(
											0,
											newDefer,
											jQuery.isFunction( onProgress ) ?
												onProgress :
												Identity,
											newDefer.notifyWith
										)
									);

									// fulfilled_handlers.add( ... )
									tuples[ 1 ][ 3 ].add(
										resolve(
											0,
											newDefer,
											jQuery.isFunction( onFulfilled ) ?
												onFulfilled :
												Identity
										)
									);

									// rejected_handlers.add( ... )
									tuples[ 2 ][ 3 ].add(
										resolve(
											0,
											newDefer,
											jQuery.isFunction( onRejected ) ?
												onRejected :
												Thrower
										)
									);
								} ).promise();
							},

							// Get a promise for this deferred
							// If obj is provided, the promise aspect is added to the object
							promise: function( obj ) {
								return obj != null ? jQuery.extend( obj, promise ) : promise;
							}
						},
						deferred = {};

					// Add list-specific methods
					jQuery.each( tuples, function( i, tuple ) {
						var list = tuple[ 2 ],
							stateString = tuple[ 5 ];

						// promise.progress = list.add
						// promise.done = list.add
						// promise.fail = list.add
						promise[ tuple[ 1 ] ] = list.add;

						// Handle state
						if ( stateString ) {
							list.add(
								function() {

									// state = "resolved" (i.e., fulfilled)
									// state = "rejected"
									state = stateString;
								},

								// rejected_callbacks.disable
								// fulfilled_callbacks.disable
								tuples[ 3 - i ][ 2 ].disable,

								// progress_callbacks.lock
								tuples[ 0 ][ 2 ].lock
							);
						}

						// progress_handlers.fire
						// fulfilled_handlers.fire
						// rejected_handlers.fire
						list.add( tuple[ 3 ].fire );

						// deferred.notify = function() { deferred.notifyWith(...) }
						// deferred.resolve = function() { deferred.resolveWith(...) }
						// deferred.reject = function() { deferred.rejectWith(...) }
						deferred[ tuple[ 0 ] ] = function() {
							deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
							return this;
						};

						// deferred.notifyWith = list.fireWith
						// deferred.resolveWith = list.fireWith
						// deferred.rejectWith = list.fireWith
						deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
					} );

					// Make the deferred a promise
					promise.promise( deferred );

					// Call given func if any
					if ( func ) {
						func.call( deferred, deferred );
					}

					// All done!
					return deferred;
				},

				// Deferred helper
				when: function( singleValue ) {
					var

						// count of uncompleted subordinates
						remaining = arguments.length,

						// count of unprocessed arguments
						i = remaining,

						// subordinate fulfillment data
						resolveContexts = Array( i ),
						resolveValues = slice.call( arguments ),

						// the master Deferred
						master = jQuery.Deferred(),

						// subordinate callback factory
						updateFunc = function( i ) {
							return function( value ) {
								resolveContexts[ i ] = this;
								resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
								if ( !( --remaining ) ) {
									master.resolveWith( resolveContexts, resolveValues );
								}
							};
						};

					// Single- and empty arguments are adopted like Promise.resolve
					if ( remaining <= 1 ) {
						adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject );

						// Use .then() to unwrap secondary thenables (cf. gh-3000)
						if ( master.state() === "pending" ||
							jQuery.isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

							return master.then();
						}
					}

					// Multiple arguments are aggregated like Promise.all array elements
					while ( i-- ) {
						adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
					}

					return master.promise();
				}
			} );


			// These usually indicate a programmer mistake during development,
			// warn about them ASAP rather than swallowing them by default.
			var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

			jQuery.Deferred.exceptionHook = function( error, stack ) {

				// Support: IE 8 - 9 only
				// Console exists when dev tools are open, which can happen at any time
				if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
					window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
				}
			};




			jQuery.readyException = function( error ) {
				window.setTimeout( function() {
					throw error;
				} );
			};




			// The deferred used on DOM ready
			var readyList = jQuery.Deferred();

			jQuery.fn.ready = function( fn ) {

				readyList
					.then( fn )

					// Wrap jQuery.readyException in a function so that the lookup
					// happens at the time of error handling instead of callback
					// registration.
					.catch( function( error ) {
						jQuery.readyException( error );
					} );

				return this;
			};

			jQuery.extend( {

				// Is the DOM ready to be used? Set to true once it occurs.
				isReady: false,

				// A counter to track how many items to wait for before
				// the ready event fires. See #6781
				readyWait: 1,

				// Hold (or release) the ready event
				holdReady: function( hold ) {
					if ( hold ) {
						jQuery.readyWait++;
					} else {
						jQuery.ready( true );
					}
				},

				// Handle when the DOM is ready
				ready: function( wait ) {

					// Abort if there are pending holds or we're already ready
					if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
						return;
					}

					// Remember that the DOM is ready
					jQuery.isReady = true;

					// If a normal DOM Ready event fired, decrement, and wait if need be
					if ( wait !== true && --jQuery.readyWait > 0 ) {
						return;
					}

					// If there are functions bound, to execute
					readyList.resolveWith( document, [ jQuery ] );
				}
			} );

			jQuery.ready.then = readyList.then;

			// The ready event handler and self cleanup method
			function completed() {
				document.removeEventListener( "DOMContentLoaded", completed );
				window.removeEventListener( "load", completed );
				jQuery.ready();
			}

			// Catch cases where $(document).ready() is called
			// after the browser event has already occurred.
			// Support: IE <=9 - 10 only
			// Older IE sometimes signals "interactive" too soon
			if ( document.readyState === "complete" ||
				( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

				// Handle it asynchronously to allow scripts the opportunity to delay ready
				window.setTimeout( jQuery.ready );

			} else {

				// Use the handy event callback
				document.addEventListener( "DOMContentLoaded", completed );

				// A fallback to window.onload, that will always work
				window.addEventListener( "load", completed );
			}




			// Multifunctional method to get and set values of a collection
			// The value/s can optionally be executed if it's a function
			var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
				var i = 0,
					len = elems.length,
					bulk = key == null;

				// Sets many values
				if ( jQuery.type( key ) === "object" ) {
					chainable = true;
					for ( i in key ) {
						access( elems, fn, i, key[ i ], true, emptyGet, raw );
					}

				// Sets one value
				} else if ( value !== undefined ) {
					chainable = true;

					if ( !jQuery.isFunction( value ) ) {
						raw = true;
					}

					if ( bulk ) {

						// Bulk operations run against the entire set
						if ( raw ) {
							fn.call( elems, value );
							fn = null;

						// ...except when executing function values
						} else {
							bulk = fn;
							fn = function( elem, key, value ) {
								return bulk.call( jQuery( elem ), value );
							};
						}
					}

					if ( fn ) {
						for ( ; i < len; i++ ) {
							fn(
								elems[ i ], key, raw ?
								value :
								value.call( elems[ i ], i, fn( elems[ i ], key ) )
							);
						}
					}
				}

				if ( chainable ) {
					return elems;
				}

				// Gets
				if ( bulk ) {
					return fn.call( elems );
				}

				return len ? fn( elems[ 0 ], key ) : emptyGet;
			};
			var acceptData = function( owner ) {

				// Accepts only:
				//  - Node
				//    - Node.ELEMENT_NODE
				//    - Node.DOCUMENT_NODE
				//  - Object
				//    - Any
				return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
			};




			function Data() {
				this.expando = jQuery.expando + Data.uid++;
			}

			Data.uid = 1;

			Data.prototype = {

				cache: function( owner ) {

					// Check if the owner object already has a cache
					var value = owner[ this.expando ];

					// If not, create one
					if ( !value ) {
						value = {};

						// We can accept data for non-element nodes in modern browsers,
						// but we should not, see #8335.
						// Always return an empty object.
						if ( acceptData( owner ) ) {

							// If it is a node unlikely to be stringify-ed or looped over
							// use plain assignment
							if ( owner.nodeType ) {
								owner[ this.expando ] = value;

							// Otherwise secure it in a non-enumerable property
							// configurable must be true to allow the property to be
							// deleted when data is removed
							} else {
								Object.defineProperty( owner, this.expando, {
									value: value,
									configurable: true
								} );
							}
						}
					}

					return value;
				},
				set: function( owner, data, value ) {
					var prop,
						cache = this.cache( owner );

					// Handle: [ owner, key, value ] args
					// Always use camelCase key (gh-2257)
					if ( typeof data === "string" ) {
						cache[ jQuery.camelCase( data ) ] = value;

					// Handle: [ owner, { properties } ] args
					} else {

						// Copy the properties one-by-one to the cache object
						for ( prop in data ) {
							cache[ jQuery.camelCase( prop ) ] = data[ prop ];
						}
					}
					return cache;
				},
				get: function( owner, key ) {
					return key === undefined ?
						this.cache( owner ) :

						// Always use camelCase key (gh-2257)
						owner[ this.expando ] && owner[ this.expando ][ jQuery.camelCase( key ) ];
				},
				access: function( owner, key, value ) {

					// In cases where either:
					//
					//   1. No key was specified
					//   2. A string key was specified, but no value provided
					//
					// Take the "read" path and allow the get method to determine
					// which value to return, respectively either:
					//
					//   1. The entire cache object
					//   2. The data stored at the key
					//
					if ( key === undefined ||
							( ( key && typeof key === "string" ) && value === undefined ) ) {

						return this.get( owner, key );
					}

					// When the key is not a string, or both a key and value
					// are specified, set or extend (existing objects) with either:
					//
					//   1. An object of properties
					//   2. A key and value
					//
					this.set( owner, key, value );

					// Since the "set" path can have two possible entry points
					// return the expected data based on which path was taken[*]
					return value !== undefined ? value : key;
				},
				remove: function( owner, key ) {
					var i,
						cache = owner[ this.expando ];

					if ( cache === undefined ) {
						return;
					}

					if ( key !== undefined ) {

						// Support array or space separated string of keys
						if ( jQuery.isArray( key ) ) {

							// If key is an array of keys...
							// We always set camelCase keys, so remove that.
							key = key.map( jQuery.camelCase );
						} else {
							key = jQuery.camelCase( key );

							// If a key with the spaces exists, use it.
							// Otherwise, create an array by matching non-whitespace
							key = key in cache ?
								[ key ] :
								( key.match( rnothtmlwhite ) || [] );
						}

						i = key.length;

						while ( i-- ) {
							delete cache[ key[ i ] ];
						}
					}

					// Remove the expando if there's no more data
					if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

						// Support: Chrome <=35 - 45
						// Webkit & Blink performance suffers when deleting properties
						// from DOM nodes, so set to undefined instead
						// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
						if ( owner.nodeType ) {
							owner[ this.expando ] = undefined;
						} else {
							delete owner[ this.expando ];
						}
					}
				},
				hasData: function( owner ) {
					var cache = owner[ this.expando ];
					return cache !== undefined && !jQuery.isEmptyObject( cache );
				}
			};
			var dataPriv = new Data();

			var dataUser = new Data();



			//	Implementation Summary
			//
			//	1. Enforce API surface and semantic compatibility with 1.9.x branch
			//	2. Improve the module's maintainability by reducing the storage
			//		paths to a single mechanism.
			//	3. Use the same single mechanism to support "private" and "user" data.
			//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
			//	5. Avoid exposing implementation details on user objects (eg. expando properties)
			//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

			var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
				rmultiDash = /[A-Z]/g;

			function getData( data ) {
				if ( data === "true" ) {
					return true;
				}

				if ( data === "false" ) {
					return false;
				}

				if ( data === "null" ) {
					return null;
				}

				// Only convert to a number if it doesn't change the string
				if ( data === +data + "" ) {
					return +data;
				}

				if ( rbrace.test( data ) ) {
					return JSON.parse( data );
				}

				return data;
			}

			function dataAttr( elem, key, data ) {
				var name;

				// If nothing was found internally, try to fetch any
				// data from the HTML5 data-* attribute
				if ( data === undefined && elem.nodeType === 1 ) {
					name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
					data = elem.getAttribute( name );

					if ( typeof data === "string" ) {
						try {
							data = getData( data );
						} catch ( e ) {}

						// Make sure we set the data so it isn't changed later
						dataUser.set( elem, key, data );
					} else {
						data = undefined;
					}
				}
				return data;
			}

			jQuery.extend( {
				hasData: function( elem ) {
					return dataUser.hasData( elem ) || dataPriv.hasData( elem );
				},

				data: function( elem, name, data ) {
					return dataUser.access( elem, name, data );
				},

				removeData: function( elem, name ) {
					dataUser.remove( elem, name );
				},

				// TODO: Now that all calls to _data and _removeData have been replaced
				// with direct calls to dataPriv methods, these can be deprecated.
				_data: function( elem, name, data ) {
					return dataPriv.access( elem, name, data );
				},

				_removeData: function( elem, name ) {
					dataPriv.remove( elem, name );
				}
			} );

			jQuery.fn.extend( {
				data: function( key, value ) {
					var i, name, data,
						elem = this[ 0 ],
						attrs = elem && elem.attributes;

					// Gets all values
					if ( key === undefined ) {
						if ( this.length ) {
							data = dataUser.get( elem );

							if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
								i = attrs.length;
								while ( i-- ) {

									// Support: IE 11 only
									// The attrs elements can be null (#14894)
									if ( attrs[ i ] ) {
										name = attrs[ i ].name;
										if ( name.indexOf( "data-" ) === 0 ) {
											name = jQuery.camelCase( name.slice( 5 ) );
											dataAttr( elem, name, data[ name ] );
										}
									}
								}
								dataPriv.set( elem, "hasDataAttrs", true );
							}
						}

						return data;
					}

					// Sets multiple values
					if ( typeof key === "object" ) {
						return this.each( function() {
							dataUser.set( this, key );
						} );
					}

					return access( this, function( value ) {
						var data;

						// The calling jQuery object (element matches) is not empty
						// (and therefore has an element appears at this[ 0 ]) and the
						// `value` parameter was not undefined. An empty jQuery object
						// will result in `undefined` for elem = this[ 0 ] which will
						// throw an exception if an attempt to read a data cache is made.
						if ( elem && value === undefined ) {

							// Attempt to get data from the cache
							// The key will always be camelCased in Data
							data = dataUser.get( elem, key );
							if ( data !== undefined ) {
								return data;
							}

							// Attempt to "discover" the data in
							// HTML5 custom data-* attrs
							data = dataAttr( elem, key );
							if ( data !== undefined ) {
								return data;
							}

							// We tried really hard, but the data doesn't exist.
							return;
						}

						// Set the data...
						this.each( function() {

							// We always store the camelCased key
							dataUser.set( this, key, value );
						} );
					}, null, value, arguments.length > 1, null, true );
				},

				removeData: function( key ) {
					return this.each( function() {
						dataUser.remove( this, key );
					} );
				}
			} );


			jQuery.extend( {
				queue: function( elem, type, data ) {
					var queue;

					if ( elem ) {
						type = ( type || "fx" ) + "queue";
						queue = dataPriv.get( elem, type );

						// Speed up dequeue by getting out quickly if this is just a lookup
						if ( data ) {
							if ( !queue || jQuery.isArray( data ) ) {
								queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
							} else {
								queue.push( data );
							}
						}
						return queue || [];
					}
				},

				dequeue: function( elem, type ) {
					type = type || "fx";

					var queue = jQuery.queue( elem, type ),
						startLength = queue.length,
						fn = queue.shift(),
						hooks = jQuery._queueHooks( elem, type ),
						next = function() {
							jQuery.dequeue( elem, type );
						};

					// If the fx queue is dequeued, always remove the progress sentinel
					if ( fn === "inprogress" ) {
						fn = queue.shift();
						startLength--;
					}

					if ( fn ) {

						// Add a progress sentinel to prevent the fx queue from being
						// automatically dequeued
						if ( type === "fx" ) {
							queue.unshift( "inprogress" );
						}

						// Clear up the last queue stop function
						delete hooks.stop;
						fn.call( elem, next, hooks );
					}

					if ( !startLength && hooks ) {
						hooks.empty.fire();
					}
				},

				// Not public - generate a queueHooks object, or return the current one
				_queueHooks: function( elem, type ) {
					var key = type + "queueHooks";
					return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
						empty: jQuery.Callbacks( "once memory" ).add( function() {
							dataPriv.remove( elem, [ type + "queue", key ] );
						} )
					} );
				}
			} );

			jQuery.fn.extend( {
				queue: function( type, data ) {
					var setter = 2;

					if ( typeof type !== "string" ) {
						data = type;
						type = "fx";
						setter--;
					}

					if ( arguments.length < setter ) {
						return jQuery.queue( this[ 0 ], type );
					}

					return data === undefined ?
						this :
						this.each( function() {
							var queue = jQuery.queue( this, type, data );

							// Ensure a hooks for this queue
							jQuery._queueHooks( this, type );

							if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
								jQuery.dequeue( this, type );
							}
						} );
				},
				dequeue: function( type ) {
					return this.each( function() {
						jQuery.dequeue( this, type );
					} );
				},
				clearQueue: function( type ) {
					return this.queue( type || "fx", [] );
				},

				// Get a promise resolved when queues of a certain type
				// are emptied (fx is the type by default)
				promise: function( type, obj ) {
					var tmp,
						count = 1,
						defer = jQuery.Deferred(),
						elements = this,
						i = this.length,
						resolve = function() {
							if ( !( --count ) ) {
								defer.resolveWith( elements, [ elements ] );
							}
						};

					if ( typeof type !== "string" ) {
						obj = type;
						type = undefined;
					}
					type = type || "fx";

					while ( i-- ) {
						tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
						if ( tmp && tmp.empty ) {
							count++;
							tmp.empty.add( resolve );
						}
					}
					resolve();
					return defer.promise( obj );
				}
			} );
			var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

			var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


			var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

			var isHiddenWithinTree = function( elem, el ) {

					// isHiddenWithinTree might be called from jQuery#filter function;
					// in that case, element will be second argument
					elem = el || elem;

					// Inline style trumps all
					return elem.style.display === "none" ||
						elem.style.display === "" &&

						// Otherwise, check computed style
						// Support: Firefox <=43 - 45
						// Disconnected elements can have computed display: none, so first confirm that elem is
						// in the document.
						jQuery.contains( elem.ownerDocument, elem ) &&

						jQuery.css( elem, "display" ) === "none";
				};

			var swap = function( elem, options, callback, args ) {
				var ret, name,
					old = {};

				// Remember the old values, and insert the new ones
				for ( name in options ) {
					old[ name ] = elem.style[ name ];
					elem.style[ name ] = options[ name ];
				}

				ret = callback.apply( elem, args || [] );

				// Revert the old values
				for ( name in options ) {
					elem.style[ name ] = old[ name ];
				}

				return ret;
			};




			function adjustCSS( elem, prop, valueParts, tween ) {
				var adjusted,
					scale = 1,
					maxIterations = 20,
					currentValue = tween ?
						function() {
							return tween.cur();
						} :
						function() {
							return jQuery.css( elem, prop, "" );
						},
					initial = currentValue(),
					unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

					// Starting value computation is required for potential unit mismatches
					initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
						rcssNum.exec( jQuery.css( elem, prop ) );

				if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

					// Trust units reported by jQuery.css
					unit = unit || initialInUnit[ 3 ];

					// Make sure we update the tween properties later on
					valueParts = valueParts || [];

					// Iteratively approximate from a nonzero starting point
					initialInUnit = +initial || 1;

					do {

						// If previous iteration zeroed out, double until we get *something*.
						// Use string for doubling so we don't accidentally see scale as unchanged below
						scale = scale || ".5";

						// Adjust and apply
						initialInUnit = initialInUnit / scale;
						jQuery.style( elem, prop, initialInUnit + unit );

					// Update scale, tolerating zero or NaN from tween.cur()
					// Break the loop if scale is unchanged or perfect, or if we've just had enough.
					} while (
						scale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations
					);
				}

				if ( valueParts ) {
					initialInUnit = +initialInUnit || +initial || 0;

					// Apply relative offset (+=/-=) if specified
					adjusted = valueParts[ 1 ] ?
						initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
						+valueParts[ 2 ];
					if ( tween ) {
						tween.unit = unit;
						tween.start = initialInUnit;
						tween.end = adjusted;
					}
				}
				return adjusted;
			}


			var defaultDisplayMap = {};

			function getDefaultDisplay( elem ) {
				var temp,
					doc = elem.ownerDocument,
					nodeName = elem.nodeName,
					display = defaultDisplayMap[ nodeName ];

				if ( display ) {
					return display;
				}

				temp = doc.body.appendChild( doc.createElement( nodeName ) );
				display = jQuery.css( temp, "display" );

				temp.parentNode.removeChild( temp );

				if ( display === "none" ) {
					display = "block";
				}
				defaultDisplayMap[ nodeName ] = display;

				return display;
			}

			function showHide( elements, show ) {
				var display, elem,
					values = [],
					index = 0,
					length = elements.length;

				// Determine new display value for elements that need to change
				for ( ; index < length; index++ ) {
					elem = elements[ index ];
					if ( !elem.style ) {
						continue;
					}

					display = elem.style.display;
					if ( show ) {

						// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
						// check is required in this first loop unless we have a nonempty display value (either
						// inline or about-to-be-restored)
						if ( display === "none" ) {
							values[ index ] = dataPriv.get( elem, "display" ) || null;
							if ( !values[ index ] ) {
								elem.style.display = "";
							}
						}
						if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
							values[ index ] = getDefaultDisplay( elem );
						}
					} else {
						if ( display !== "none" ) {
							values[ index ] = "none";

							// Remember what we're overwriting
							dataPriv.set( elem, "display", display );
						}
					}
				}

				// Set the display of the elements in a second loop to avoid constant reflow
				for ( index = 0; index < length; index++ ) {
					if ( values[ index ] != null ) {
						elements[ index ].style.display = values[ index ];
					}
				}

				return elements;
			}

			jQuery.fn.extend( {
				show: function() {
					return showHide( this, true );
				},
				hide: function() {
					return showHide( this );
				},
				toggle: function( state ) {
					if ( typeof state === "boolean" ) {
						return state ? this.show() : this.hide();
					}

					return this.each( function() {
						if ( isHiddenWithinTree( this ) ) {
							jQuery( this ).show();
						} else {
							jQuery( this ).hide();
						}
					} );
				}
			} );
			var rcheckableType = ( /^(?:checkbox|radio)$/i );

			var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]+)/i );

			var rscriptType = ( /^$|\/(?:java|ecma)script/i );



			// We have to close these tags to support XHTML (#13200)
			var wrapMap = {

				// Support: IE <=9 only
				option: [ 1, "<select multiple='multiple'>", "</select>" ],

				// XHTML parsers do not magically insert elements in the
				// same way that tag soup parsers do. So we cannot shorten
				// this by omitting <tbody> or other required elements.
				thead: [ 1, "<table>", "</table>" ],
				col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
				tr: [ 2, "<table><tbody>", "</tbody></table>" ],
				td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

				_default: [ 0, "", "" ]
			};

			// Support: IE <=9 only
			wrapMap.optgroup = wrapMap.option;

			wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
			wrapMap.th = wrapMap.td;


			function getAll( context, tag ) {

				// Support: IE <=9 - 11 only
				// Use typeof to avoid zero-argument method invocation on host objects (#15151)
				var ret;

				if ( typeof context.getElementsByTagName !== "undefined" ) {
					ret = context.getElementsByTagName( tag || "*" );

				} else if ( typeof context.querySelectorAll !== "undefined" ) {
					ret = context.querySelectorAll( tag || "*" );

				} else {
					ret = [];
				}

				if ( tag === undefined || tag && jQuery.nodeName( context, tag ) ) {
					return jQuery.merge( [ context ], ret );
				}

				return ret;
			}


			// Mark scripts as having already been evaluated
			function setGlobalEval( elems, refElements ) {
				var i = 0,
					l = elems.length;

				for ( ; i < l; i++ ) {
					dataPriv.set(
						elems[ i ],
						"globalEval",
						!refElements || dataPriv.get( refElements[ i ], "globalEval" )
					);
				}
			}


			var rhtml = /<|&#?\w+;/;

			function buildFragment( elems, context, scripts, selection, ignored ) {
				var elem, tmp, tag, wrap, contains, j,
					fragment = context.createDocumentFragment(),
					nodes = [],
					i = 0,
					l = elems.length;

				for ( ; i < l; i++ ) {
					elem = elems[ i ];

					if ( elem || elem === 0 ) {

						// Add nodes directly
						if ( jQuery.type( elem ) === "object" ) {

							// Support: Android <=4.0 only, PhantomJS 1 only
							// push.apply(_, arraylike) throws on ancient WebKit
							jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

						// Convert non-html into a text node
						} else if ( !rhtml.test( elem ) ) {
							nodes.push( context.createTextNode( elem ) );

						// Convert html into DOM nodes
						} else {
							tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

							// Deserialize a standard representation
							tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
							wrap = wrapMap[ tag ] || wrapMap._default;
							tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

							// Descend through wrappers to the right content
							j = wrap[ 0 ];
							while ( j-- ) {
								tmp = tmp.lastChild;
							}

							// Support: Android <=4.0 only, PhantomJS 1 only
							// push.apply(_, arraylike) throws on ancient WebKit
							jQuery.merge( nodes, tmp.childNodes );

							// Remember the top-level container
							tmp = fragment.firstChild;

							// Ensure the created nodes are orphaned (#12392)
							tmp.textContent = "";
						}
					}
				}

				// Remove wrapper from fragment
				fragment.textContent = "";

				i = 0;
				while ( ( elem = nodes[ i++ ] ) ) {

					// Skip elements already in the context collection (trac-4087)
					if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
						if ( ignored ) {
							ignored.push( elem );
						}
						continue;
					}

					contains = jQuery.contains( elem.ownerDocument, elem );

					// Append to fragment
					tmp = getAll( fragment.appendChild( elem ), "script" );

					// Preserve script evaluation history
					if ( contains ) {
						setGlobalEval( tmp );
					}

					// Capture executables
					if ( scripts ) {
						j = 0;
						while ( ( elem = tmp[ j++ ] ) ) {
							if ( rscriptType.test( elem.type || "" ) ) {
								scripts.push( elem );
							}
						}
					}
				}

				return fragment;
			}


			( function() {
				var fragment = document.createDocumentFragment(),
					div = fragment.appendChild( document.createElement( "div" ) ),
					input = document.createElement( "input" );

				// Support: Android 4.0 - 4.3 only
				// Check state lost if the name is set (#11217)
				// Support: Windows Web Apps (WWA)
				// `name` and `type` must use .setAttribute for WWA (#14901)
				input.setAttribute( "type", "radio" );
				input.setAttribute( "checked", "checked" );
				input.setAttribute( "name", "t" );

				div.appendChild( input );

				// Support: Android <=4.1 only
				// Older WebKit doesn't clone checked state correctly in fragments
				support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

				// Support: IE <=11 only
				// Make sure textarea (and checkbox) defaultValue is properly cloned
				div.innerHTML = "<textarea>x</textarea>";
				support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
			} )();
			var documentElement = document.documentElement;



			var
				rkeyEvent = /^key/,
				rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
				rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

			function returnTrue() {
				return true;
			}

			function returnFalse() {
				return false;
			}

			// Support: IE <=9 only
			// See #13393 for more info
			function safeActiveElement() {
				try {
					return document.activeElement;
				} catch ( err ) { }
			}

			function on( elem, types, selector, data, fn, one ) {
				var origFn, type;

				// Types can be a map of types/handlers
				if ( typeof types === "object" ) {

					// ( types-Object, selector, data )
					if ( typeof selector !== "string" ) {

						// ( types-Object, data )
						data = data || selector;
						selector = undefined;
					}
					for ( type in types ) {
						on( elem, type, selector, data, types[ type ], one );
					}
					return elem;
				}

				if ( data == null && fn == null ) {

					// ( types, fn )
					fn = selector;
					data = selector = undefined;
				} else if ( fn == null ) {
					if ( typeof selector === "string" ) {

						// ( types, selector, fn )
						fn = data;
						data = undefined;
					} else {

						// ( types, data, fn )
						fn = data;
						data = selector;
						selector = undefined;
					}
				}
				if ( fn === false ) {
					fn = returnFalse;
				} else if ( !fn ) {
					return elem;
				}

				if ( one === 1 ) {
					origFn = fn;
					fn = function( event ) {

						// Can use an empty set, since event contains the info
						jQuery().off( event );
						return origFn.apply( this, arguments );
					};

					// Use same guid so caller can remove using origFn
					fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
				}
				return elem.each( function() {
					jQuery.event.add( this, types, fn, data, selector );
				} );
			}

			/*
			 * Helper functions for managing events -- not part of the public interface.
			 * Props to Dean Edwards' addEvent library for many of the ideas.
			 */
			jQuery.event = {

				global: {},

				add: function( elem, types, handler, data, selector ) {

					var handleObjIn, eventHandle, tmp,
						events, t, handleObj,
						special, handlers, type, namespaces, origType,
						elemData = dataPriv.get( elem );

					// Don't attach events to noData or text/comment nodes (but allow plain objects)
					if ( !elemData ) {
						return;
					}

					// Caller can pass in an object of custom data in lieu of the handler
					if ( handler.handler ) {
						handleObjIn = handler;
						handler = handleObjIn.handler;
						selector = handleObjIn.selector;
					}

					// Ensure that invalid selectors throw exceptions at attach time
					// Evaluate against documentElement in case elem is a non-element node (e.g., document)
					if ( selector ) {
						jQuery.find.matchesSelector( documentElement, selector );
					}

					// Make sure that the handler has a unique ID, used to find/remove it later
					if ( !handler.guid ) {
						handler.guid = jQuery.guid++;
					}

					// Init the element's event structure and main handler, if this is the first
					if ( !( events = elemData.events ) ) {
						events = elemData.events = {};
					}
					if ( !( eventHandle = elemData.handle ) ) {
						eventHandle = elemData.handle = function( e ) {

							// Discard the second event of a jQuery.event.trigger() and
							// when an event is called after a page has unloaded
							return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
								jQuery.event.dispatch.apply( elem, arguments ) : undefined;
						};
					}

					// Handle multiple events separated by a space
					types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
					t = types.length;
					while ( t-- ) {
						tmp = rtypenamespace.exec( types[ t ] ) || [];
						type = origType = tmp[ 1 ];
						namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

						// There *must* be a type, no attaching namespace-only handlers
						if ( !type ) {
							continue;
						}

						// If event changes its type, use the special event handlers for the changed type
						special = jQuery.event.special[ type ] || {};

						// If selector defined, determine special event api type, otherwise given type
						type = ( selector ? special.delegateType : special.bindType ) || type;

						// Update special based on newly reset type
						special = jQuery.event.special[ type ] || {};

						// handleObj is passed to all event handlers
						handleObj = jQuery.extend( {
							type: type,
							origType: origType,
							data: data,
							handler: handler,
							guid: handler.guid,
							selector: selector,
							needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
							namespace: namespaces.join( "." )
						}, handleObjIn );

						// Init the event handler queue if we're the first
						if ( !( handlers = events[ type ] ) ) {
							handlers = events[ type ] = [];
							handlers.delegateCount = 0;

							// Only use addEventListener if the special events handler returns false
							if ( !special.setup ||
								special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

								if ( elem.addEventListener ) {
									elem.addEventListener( type, eventHandle );
								}
							}
						}

						if ( special.add ) {
							special.add.call( elem, handleObj );

							if ( !handleObj.handler.guid ) {
								handleObj.handler.guid = handler.guid;
							}
						}

						// Add to the element's handler list, delegates in front
						if ( selector ) {
							handlers.splice( handlers.delegateCount++, 0, handleObj );
						} else {
							handlers.push( handleObj );
						}

						// Keep track of which events have ever been used, for event optimization
						jQuery.event.global[ type ] = true;
					}

				},

				// Detach an event or set of events from an element
				remove: function( elem, types, handler, selector, mappedTypes ) {

					var j, origCount, tmp,
						events, t, handleObj,
						special, handlers, type, namespaces, origType,
						elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

					if ( !elemData || !( events = elemData.events ) ) {
						return;
					}

					// Once for each type.namespace in types; type may be omitted
					types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
					t = types.length;
					while ( t-- ) {
						tmp = rtypenamespace.exec( types[ t ] ) || [];
						type = origType = tmp[ 1 ];
						namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

						// Unbind all events (on this namespace, if provided) for the element
						if ( !type ) {
							for ( type in events ) {
								jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
							}
							continue;
						}

						special = jQuery.event.special[ type ] || {};
						type = ( selector ? special.delegateType : special.bindType ) || type;
						handlers = events[ type ] || [];
						tmp = tmp[ 2 ] &&
							new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

						// Remove matching events
						origCount = j = handlers.length;
						while ( j-- ) {
							handleObj = handlers[ j ];

							if ( ( mappedTypes || origType === handleObj.origType ) &&
								( !handler || handler.guid === handleObj.guid ) &&
								( !tmp || tmp.test( handleObj.namespace ) ) &&
								( !selector || selector === handleObj.selector ||
									selector === "**" && handleObj.selector ) ) {
								handlers.splice( j, 1 );

								if ( handleObj.selector ) {
									handlers.delegateCount--;
								}
								if ( special.remove ) {
									special.remove.call( elem, handleObj );
								}
							}
						}

						// Remove generic event handler if we removed something and no more handlers exist
						// (avoids potential for endless recursion during removal of special event handlers)
						if ( origCount && !handlers.length ) {
							if ( !special.teardown ||
								special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

								jQuery.removeEvent( elem, type, elemData.handle );
							}

							delete events[ type ];
						}
					}

					// Remove data and the expando if it's no longer used
					if ( jQuery.isEmptyObject( events ) ) {
						dataPriv.remove( elem, "handle events" );
					}
				},

				dispatch: function( nativeEvent ) {

					// Make a writable jQuery.Event from the native event object
					var event = jQuery.event.fix( nativeEvent );

					var i, j, ret, matched, handleObj, handlerQueue,
						args = new Array( arguments.length ),
						handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
						special = jQuery.event.special[ event.type ] || {};

					// Use the fix-ed jQuery.Event rather than the (read-only) native event
					args[ 0 ] = event;

					for ( i = 1; i < arguments.length; i++ ) {
						args[ i ] = arguments[ i ];
					}

					event.delegateTarget = this;

					// Call the preDispatch hook for the mapped type, and let it bail if desired
					if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
						return;
					}

					// Determine handlers
					handlerQueue = jQuery.event.handlers.call( this, event, handlers );

					// Run delegates first; they may want to stop propagation beneath us
					i = 0;
					while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
						event.currentTarget = matched.elem;

						j = 0;
						while ( ( handleObj = matched.handlers[ j++ ] ) &&
							!event.isImmediatePropagationStopped() ) {

							// Triggered event must either 1) have no namespace, or 2) have namespace(s)
							// a subset or equal to those in the bound event (both can have no namespace).
							if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

								event.handleObj = handleObj;
								event.data = handleObj.data;

								ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
									handleObj.handler ).apply( matched.elem, args );

								if ( ret !== undefined ) {
									if ( ( event.result = ret ) === false ) {
										event.preventDefault();
										event.stopPropagation();
									}
								}
							}
						}
					}

					// Call the postDispatch hook for the mapped type
					if ( special.postDispatch ) {
						special.postDispatch.call( this, event );
					}

					return event.result;
				},

				handlers: function( event, handlers ) {
					var i, handleObj, sel, matchedHandlers, matchedSelectors,
						handlerQueue = [],
						delegateCount = handlers.delegateCount,
						cur = event.target;

					// Find delegate handlers
					if ( delegateCount &&

						// Support: IE <=9
						// Black-hole SVG <use> instance trees (trac-13180)
						cur.nodeType &&

						// Support: Firefox <=42
						// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
						// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
						// Support: IE 11 only
						// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
						!( event.type === "click" && event.button >= 1 ) ) {

						for ( ; cur !== this; cur = cur.parentNode || this ) {

							// Don't check non-elements (#13208)
							// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
							if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
								matchedHandlers = [];
								matchedSelectors = {};
								for ( i = 0; i < delegateCount; i++ ) {
									handleObj = handlers[ i ];

									// Don't conflict with Object.prototype properties (#13203)
									sel = handleObj.selector + " ";

									if ( matchedSelectors[ sel ] === undefined ) {
										matchedSelectors[ sel ] = handleObj.needsContext ?
											jQuery( sel, this ).index( cur ) > -1 :
											jQuery.find( sel, this, null, [ cur ] ).length;
									}
									if ( matchedSelectors[ sel ] ) {
										matchedHandlers.push( handleObj );
									}
								}
								if ( matchedHandlers.length ) {
									handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
								}
							}
						}
					}

					// Add the remaining (directly-bound) handlers
					cur = this;
					if ( delegateCount < handlers.length ) {
						handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
					}

					return handlerQueue;
				},

				addProp: function( name, hook ) {
					Object.defineProperty( jQuery.Event.prototype, name, {
						enumerable: true,
						configurable: true,

						get: jQuery.isFunction( hook ) ?
							function() {
								if ( this.originalEvent ) {
										return hook( this.originalEvent );
								}
							} :
							function() {
								if ( this.originalEvent ) {
										return this.originalEvent[ name ];
								}
							},

						set: function( value ) {
							Object.defineProperty( this, name, {
								enumerable: true,
								configurable: true,
								writable: true,
								value: value
							} );
						}
					} );
				},

				fix: function( originalEvent ) {
					return originalEvent[ jQuery.expando ] ?
						originalEvent :
						new jQuery.Event( originalEvent );
				},

				special: {
					load: {

						// Prevent triggered image.load events from bubbling to window.load
						noBubble: true
					},
					focus: {

						// Fire native event if possible so blur/focus sequence is correct
						trigger: function() {
							if ( this !== safeActiveElement() && this.focus ) {
								this.focus();
								return false;
							}
						},
						delegateType: "focusin"
					},
					blur: {
						trigger: function() {
							if ( this === safeActiveElement() && this.blur ) {
								this.blur();
								return false;
							}
						},
						delegateType: "focusout"
					},
					click: {

						// For checkbox, fire native event so checked state will be right
						trigger: function() {
							if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
								this.click();
								return false;
							}
						},

						// For cross-browser consistency, don't fire native .click() on links
						_default: function( event ) {
							return jQuery.nodeName( event.target, "a" );
						}
					},

					beforeunload: {
						postDispatch: function( event ) {

							// Support: Firefox 20+
							// Firefox doesn't alert if the returnValue field is not set.
							if ( event.result !== undefined && event.originalEvent ) {
								event.originalEvent.returnValue = event.result;
							}
						}
					}
				}
			};

			jQuery.removeEvent = function( elem, type, handle ) {

				// This "if" is needed for plain objects
				if ( elem.removeEventListener ) {
					elem.removeEventListener( type, handle );
				}
			};

			jQuery.Event = function( src, props ) {

				// Allow instantiation without the 'new' keyword
				if ( !( this instanceof jQuery.Event ) ) {
					return new jQuery.Event( src, props );
				}

				// Event object
				if ( src && src.type ) {
					this.originalEvent = src;
					this.type = src.type;

					// Events bubbling up the document may have been marked as prevented
					// by a handler lower down the tree; reflect the correct value.
					this.isDefaultPrevented = src.defaultPrevented ||
							src.defaultPrevented === undefined &&

							// Support: Android <=2.3 only
							src.returnValue === false ?
						returnTrue :
						returnFalse;

					// Create target properties
					// Support: Safari <=6 - 7 only
					// Target should not be a text node (#504, #13143)
					this.target = ( src.target && src.target.nodeType === 3 ) ?
						src.target.parentNode :
						src.target;

					this.currentTarget = src.currentTarget;
					this.relatedTarget = src.relatedTarget;

				// Event type
				} else {
					this.type = src;
				}

				// Put explicitly provided properties onto the event object
				if ( props ) {
					jQuery.extend( this, props );
				}

				// Create a timestamp if incoming event doesn't have one
				this.timeStamp = src && src.timeStamp || jQuery.now();

				// Mark it as fixed
				this[ jQuery.expando ] = true;
			};

			// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
			// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
			jQuery.Event.prototype = {
				constructor: jQuery.Event,
				isDefaultPrevented: returnFalse,
				isPropagationStopped: returnFalse,
				isImmediatePropagationStopped: returnFalse,
				isSimulated: false,

				preventDefault: function() {
					var e = this.originalEvent;

					this.isDefaultPrevented = returnTrue;

					if ( e && !this.isSimulated ) {
						e.preventDefault();
					}
				},
				stopPropagation: function() {
					var e = this.originalEvent;

					this.isPropagationStopped = returnTrue;

					if ( e && !this.isSimulated ) {
						e.stopPropagation();
					}
				},
				stopImmediatePropagation: function() {
					var e = this.originalEvent;

					this.isImmediatePropagationStopped = returnTrue;

					if ( e && !this.isSimulated ) {
						e.stopImmediatePropagation();
					}

					this.stopPropagation();
				}
			};

			// Includes all common event props including KeyEvent and MouseEvent specific props
			jQuery.each( {
				altKey: true,
				bubbles: true,
				cancelable: true,
				changedTouches: true,
				ctrlKey: true,
				detail: true,
				eventPhase: true,
				metaKey: true,
				pageX: true,
				pageY: true,
				shiftKey: true,
				view: true,
				"char": true,
				charCode: true,
				key: true,
				keyCode: true,
				button: true,
				buttons: true,
				clientX: true,
				clientY: true,
				offsetX: true,
				offsetY: true,
				pointerId: true,
				pointerType: true,
				screenX: true,
				screenY: true,
				targetTouches: true,
				toElement: true,
				touches: true,

				which: function( event ) {
					var button = event.button;

					// Add which for key events
					if ( event.which == null && rkeyEvent.test( event.type ) ) {
						return event.charCode != null ? event.charCode : event.keyCode;
					}

					// Add which for click: 1 === left; 2 === middle; 3 === right
					if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
						if ( button & 1 ) {
							return 1;
						}

						if ( button & 2 ) {
							return 3;
						}

						if ( button & 4 ) {
							return 2;
						}

						return 0;
					}

					return event.which;
				}
			}, jQuery.event.addProp );

			// Create mouseenter/leave events using mouseover/out and event-time checks
			// so that event delegation works in jQuery.
			// Do the same for pointerenter/pointerleave and pointerover/pointerout
			//
			// Support: Safari 7 only
			// Safari sends mouseenter too often; see:
			// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
			// for the description of the bug (it existed in older Chrome versions as well).
			jQuery.each( {
				mouseenter: "mouseover",
				mouseleave: "mouseout",
				pointerenter: "pointerover",
				pointerleave: "pointerout"
			}, function( orig, fix ) {
				jQuery.event.special[ orig ] = {
					delegateType: fix,
					bindType: fix,

					handle: function( event ) {
						var ret,
							target = this,
							related = event.relatedTarget,
							handleObj = event.handleObj;

						// For mouseenter/leave call the handler if related is outside the target.
						// NB: No relatedTarget if the mouse left/entered the browser window
						if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
							event.type = handleObj.origType;
							ret = handleObj.handler.apply( this, arguments );
							event.type = fix;
						}
						return ret;
					}
				};
			} );

			jQuery.fn.extend( {

				on: function( types, selector, data, fn ) {
					return on( this, types, selector, data, fn );
				},
				one: function( types, selector, data, fn ) {
					return on( this, types, selector, data, fn, 1 );
				},
				off: function( types, selector, fn ) {
					var handleObj, type;
					if ( types && types.preventDefault && types.handleObj ) {

						// ( event )  dispatched jQuery.Event
						handleObj = types.handleObj;
						jQuery( types.delegateTarget ).off(
							handleObj.namespace ?
								handleObj.origType + "." + handleObj.namespace :
								handleObj.origType,
							handleObj.selector,
							handleObj.handler
						);
						return this;
					}
					if ( typeof types === "object" ) {

						// ( types-object [, selector] )
						for ( type in types ) {
							this.off( type, selector, types[ type ] );
						}
						return this;
					}
					if ( selector === false || typeof selector === "function" ) {

						// ( types [, fn] )
						fn = selector;
						selector = undefined;
					}
					if ( fn === false ) {
						fn = returnFalse;
					}
					return this.each( function() {
						jQuery.event.remove( this, types, fn, selector );
					} );
				}
			} );


			var

				/* eslint-disable max-len */

				// See https://github.com/eslint/eslint/issues/3229
				rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

				/* eslint-enable */

				// Support: IE <=10 - 11, Edge 12 - 13
				// In IE/Edge using regex groups here causes severe slowdowns.
				// See https://connect.microsoft.com/IE/feedback/details/1736512/
				rnoInnerhtml = /<script|<style|<link/i,

				// checked="checked" or checked
				rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
				rscriptTypeMasked = /^true\/(.*)/,
				rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

			function manipulationTarget( elem, content ) {
				if ( jQuery.nodeName( elem, "table" ) &&
					jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

					return elem.getElementsByTagName( "tbody" )[ 0 ] || elem;
				}

				return elem;
			}

			// Replace/restore the type attribute of script elements for safe DOM manipulation
			function disableScript( elem ) {
				elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
				return elem;
			}
			function restoreScript( elem ) {
				var match = rscriptTypeMasked.exec( elem.type );

				if ( match ) {
					elem.type = match[ 1 ];
				} else {
					elem.removeAttribute( "type" );
				}

				return elem;
			}

			function cloneCopyEvent( src, dest ) {
				var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

				if ( dest.nodeType !== 1 ) {
					return;
				}

				// 1. Copy private data: events, handlers, etc.
				if ( dataPriv.hasData( src ) ) {
					pdataOld = dataPriv.access( src );
					pdataCur = dataPriv.set( dest, pdataOld );
					events = pdataOld.events;

					if ( events ) {
						delete pdataCur.handle;
						pdataCur.events = {};

						for ( type in events ) {
							for ( i = 0, l = events[ type ].length; i < l; i++ ) {
								jQuery.event.add( dest, type, events[ type ][ i ] );
							}
						}
					}
				}

				// 2. Copy user data
				if ( dataUser.hasData( src ) ) {
					udataOld = dataUser.access( src );
					udataCur = jQuery.extend( {}, udataOld );

					dataUser.set( dest, udataCur );
				}
			}

			// Fix IE bugs, see support tests
			function fixInput( src, dest ) {
				var nodeName = dest.nodeName.toLowerCase();

				// Fails to persist the checked state of a cloned checkbox or radio button.
				if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
					dest.checked = src.checked;

				// Fails to return the selected option to the default selected state when cloning options
				} else if ( nodeName === "input" || nodeName === "textarea" ) {
					dest.defaultValue = src.defaultValue;
				}
			}

			function domManip( collection, args, callback, ignored ) {

				// Flatten any nested arrays
				args = concat.apply( [], args );

				var fragment, first, scripts, hasScripts, node, doc,
					i = 0,
					l = collection.length,
					iNoClone = l - 1,
					value = args[ 0 ],
					isFunction = jQuery.isFunction( value );

				// We can't cloneNode fragments that contain checked, in WebKit
				if ( isFunction ||
						( l > 1 && typeof value === "string" &&
							!support.checkClone && rchecked.test( value ) ) ) {
					return collection.each( function( index ) {
						var self = collection.eq( index );
						if ( isFunction ) {
							args[ 0 ] = value.call( this, index, self.html() );
						}
						domManip( self, args, callback, ignored );
					} );
				}

				if ( l ) {
					fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
					first = fragment.firstChild;

					if ( fragment.childNodes.length === 1 ) {
						fragment = first;
					}

					// Require either new content or an interest in ignored elements to invoke the callback
					if ( first || ignored ) {
						scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
						hasScripts = scripts.length;

						// Use the original fragment for the last item
						// instead of the first because it can end up
						// being emptied incorrectly in certain situations (#8070).
						for ( ; i < l; i++ ) {
							node = fragment;

							if ( i !== iNoClone ) {
								node = jQuery.clone( node, true, true );

								// Keep references to cloned scripts for later restoration
								if ( hasScripts ) {

									// Support: Android <=4.0 only, PhantomJS 1 only
									// push.apply(_, arraylike) throws on ancient WebKit
									jQuery.merge( scripts, getAll( node, "script" ) );
								}
							}

							callback.call( collection[ i ], node, i );
						}

						if ( hasScripts ) {
							doc = scripts[ scripts.length - 1 ].ownerDocument;

							// Reenable scripts
							jQuery.map( scripts, restoreScript );

							// Evaluate executable scripts on first document insertion
							for ( i = 0; i < hasScripts; i++ ) {
								node = scripts[ i ];
								if ( rscriptType.test( node.type || "" ) &&
									!dataPriv.access( node, "globalEval" ) &&
									jQuery.contains( doc, node ) ) {

									if ( node.src ) {

										// Optional AJAX dependency, but won't run scripts if not present
										if ( jQuery._evalUrl ) {
											jQuery._evalUrl( node.src );
										}
									} else {
										DOMEval( node.textContent.replace( rcleanScript, "" ), doc );
									}
								}
							}
						}
					}
				}

				return collection;
			}

			function remove( elem, selector, keepData ) {
				var node,
					nodes = selector ? jQuery.filter( selector, elem ) : elem,
					i = 0;

				for ( ; ( node = nodes[ i ] ) != null; i++ ) {
					if ( !keepData && node.nodeType === 1 ) {
						jQuery.cleanData( getAll( node ) );
					}

					if ( node.parentNode ) {
						if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
							setGlobalEval( getAll( node, "script" ) );
						}
						node.parentNode.removeChild( node );
					}
				}

				return elem;
			}

			jQuery.extend( {
				htmlPrefilter: function( html ) {
					return html.replace( rxhtmlTag, "<$1></$2>" );
				},

				clone: function( elem, dataAndEvents, deepDataAndEvents ) {
					var i, l, srcElements, destElements,
						clone = elem.cloneNode( true ),
						inPage = jQuery.contains( elem.ownerDocument, elem );

					// Fix IE cloning issues
					if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
							!jQuery.isXMLDoc( elem ) ) {

						// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
						destElements = getAll( clone );
						srcElements = getAll( elem );

						for ( i = 0, l = srcElements.length; i < l; i++ ) {
							fixInput( srcElements[ i ], destElements[ i ] );
						}
					}

					// Copy the events from the original to the clone
					if ( dataAndEvents ) {
						if ( deepDataAndEvents ) {
							srcElements = srcElements || getAll( elem );
							destElements = destElements || getAll( clone );

							for ( i = 0, l = srcElements.length; i < l; i++ ) {
								cloneCopyEvent( srcElements[ i ], destElements[ i ] );
							}
						} else {
							cloneCopyEvent( elem, clone );
						}
					}

					// Preserve script evaluation history
					destElements = getAll( clone, "script" );
					if ( destElements.length > 0 ) {
						setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
					}

					// Return the cloned set
					return clone;
				},

				cleanData: function( elems ) {
					var data, elem, type,
						special = jQuery.event.special,
						i = 0;

					for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
						if ( acceptData( elem ) ) {
							if ( ( data = elem[ dataPriv.expando ] ) ) {
								if ( data.events ) {
									for ( type in data.events ) {
										if ( special[ type ] ) {
											jQuery.event.remove( elem, type );

										// This is a shortcut to avoid jQuery.event.remove's overhead
										} else {
											jQuery.removeEvent( elem, type, data.handle );
										}
									}
								}

								// Support: Chrome <=35 - 45+
								// Assign undefined instead of using delete, see Data#remove
								elem[ dataPriv.expando ] = undefined;
							}
							if ( elem[ dataUser.expando ] ) {

								// Support: Chrome <=35 - 45+
								// Assign undefined instead of using delete, see Data#remove
								elem[ dataUser.expando ] = undefined;
							}
						}
					}
				}
			} );

			jQuery.fn.extend( {
				detach: function( selector ) {
					return remove( this, selector, true );
				},

				remove: function( selector ) {
					return remove( this, selector );
				},

				text: function( value ) {
					return access( this, function( value ) {
						return value === undefined ?
							jQuery.text( this ) :
							this.empty().each( function() {
								if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
									this.textContent = value;
								}
							} );
					}, null, value, arguments.length );
				},

				append: function() {
					return domManip( this, arguments, function( elem ) {
						if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
							var target = manipulationTarget( this, elem );
							target.appendChild( elem );
						}
					} );
				},

				prepend: function() {
					return domManip( this, arguments, function( elem ) {
						if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
							var target = manipulationTarget( this, elem );
							target.insertBefore( elem, target.firstChild );
						}
					} );
				},

				before: function() {
					return domManip( this, arguments, function( elem ) {
						if ( this.parentNode ) {
							this.parentNode.insertBefore( elem, this );
						}
					} );
				},

				after: function() {
					return domManip( this, arguments, function( elem ) {
						if ( this.parentNode ) {
							this.parentNode.insertBefore( elem, this.nextSibling );
						}
					} );
				},

				empty: function() {
					var elem,
						i = 0;

					for ( ; ( elem = this[ i ] ) != null; i++ ) {
						if ( elem.nodeType === 1 ) {

							// Prevent memory leaks
							jQuery.cleanData( getAll( elem, false ) );

							// Remove any remaining nodes
							elem.textContent = "";
						}
					}

					return this;
				},

				clone: function( dataAndEvents, deepDataAndEvents ) {
					dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
					deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

					return this.map( function() {
						return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
					} );
				},

				html: function( value ) {
					return access( this, function( value ) {
						var elem = this[ 0 ] || {},
							i = 0,
							l = this.length;

						if ( value === undefined && elem.nodeType === 1 ) {
							return elem.innerHTML;
						}

						// See if we can take a shortcut and just use innerHTML
						if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
							!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

							value = jQuery.htmlPrefilter( value );

							try {
								for ( ; i < l; i++ ) {
									elem = this[ i ] || {};

									// Remove element nodes and prevent memory leaks
									if ( elem.nodeType === 1 ) {
										jQuery.cleanData( getAll( elem, false ) );
										elem.innerHTML = value;
									}
								}

								elem = 0;

							// If using innerHTML throws an exception, use the fallback method
							} catch ( e ) {}
						}

						if ( elem ) {
							this.empty().append( value );
						}
					}, null, value, arguments.length );
				},

				replaceWith: function() {
					var ignored = [];

					// Make the changes, replacing each non-ignored context element with the new content
					return domManip( this, arguments, function( elem ) {
						var parent = this.parentNode;

						if ( jQuery.inArray( this, ignored ) < 0 ) {
							jQuery.cleanData( getAll( this ) );
							if ( parent ) {
								parent.replaceChild( elem, this );
							}
						}

					// Force callback invocation
					}, ignored );
				}
			} );

			jQuery.each( {
				appendTo: "append",
				prependTo: "prepend",
				insertBefore: "before",
				insertAfter: "after",
				replaceAll: "replaceWith"
			}, function( name, original ) {
				jQuery.fn[ name ] = function( selector ) {
					var elems,
						ret = [],
						insert = jQuery( selector ),
						last = insert.length - 1,
						i = 0;

					for ( ; i <= last; i++ ) {
						elems = i === last ? this : this.clone( true );
						jQuery( insert[ i ] )[ original ]( elems );

						// Support: Android <=4.0 only, PhantomJS 1 only
						// .get() because push.apply(_, arraylike) throws on ancient WebKit
						push.apply( ret, elems.get() );
					}

					return this.pushStack( ret );
				};
			} );
			var rmargin = ( /^margin/ );

			var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

			var getStyles = function( elem ) {

					// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
					// IE throws on elements created in popups
					// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
					var view = elem.ownerDocument.defaultView;

					if ( !view || !view.opener ) {
						view = window;
					}

					return view.getComputedStyle( elem );
				};



			( function() {

				// Executing both pixelPosition & boxSizingReliable tests require only one layout
				// so they're executed at the same time to save the second computation.
				function computeStyleTests() {

					// This is a singleton, we need to execute it only once
					if ( !div ) {
						return;
					}

					div.style.cssText =
						"box-sizing:border-box;" +
						"position:relative;display:block;" +
						"margin:auto;border:1px;padding:1px;" +
						"top:1%;width:50%";
					div.innerHTML = "";
					documentElement.appendChild( container );

					var divStyle = window.getComputedStyle( div );
					pixelPositionVal = divStyle.top !== "1%";

					// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
					reliableMarginLeftVal = divStyle.marginLeft === "2px";
					boxSizingReliableVal = divStyle.width === "4px";

					// Support: Android 4.0 - 4.3 only
					// Some styles come back with percentage values, even though they shouldn't
					div.style.marginRight = "50%";
					pixelMarginRightVal = divStyle.marginRight === "4px";

					documentElement.removeChild( container );

					// Nullify the div so it wouldn't be stored in the memory and
					// it will also be a sign that checks already performed
					div = null;
				}

				var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,
					container = document.createElement( "div" ),
					div = document.createElement( "div" );

				// Finish early in limited (non-browser) environments
				if ( !div.style ) {
					return;
				}

				// Support: IE <=9 - 11 only
				// Style of cloned element affects source element cloned (#8908)
				div.style.backgroundClip = "content-box";
				div.cloneNode( true ).style.backgroundClip = "";
				support.clearCloneStyle = div.style.backgroundClip === "content-box";

				container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
					"padding:0;margin-top:1px;position:absolute";
				container.appendChild( div );

				jQuery.extend( support, {
					pixelPosition: function() {
						computeStyleTests();
						return pixelPositionVal;
					},
					boxSizingReliable: function() {
						computeStyleTests();
						return boxSizingReliableVal;
					},
					pixelMarginRight: function() {
						computeStyleTests();
						return pixelMarginRightVal;
					},
					reliableMarginLeft: function() {
						computeStyleTests();
						return reliableMarginLeftVal;
					}
				} );
			} )();


			function curCSS( elem, name, computed ) {
				var width, minWidth, maxWidth, ret,
					style = elem.style;

				computed = computed || getStyles( elem );

				// Support: IE <=9 only
				// getPropertyValue is only needed for .css('filter') (#12537)
				if ( computed ) {
					ret = computed.getPropertyValue( name ) || computed[ name ];

					if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
						ret = jQuery.style( elem, name );
					}

					// A tribute to the "awesome hack by Dean Edwards"
					// Android Browser returns percentage for some values,
					// but width seems to be reliably pixels.
					// This is against the CSSOM draft spec:
					// https://drafts.csswg.org/cssom/#resolved-values
					if ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {

						// Remember the original values
						width = style.width;
						minWidth = style.minWidth;
						maxWidth = style.maxWidth;

						// Put in the new values to get a computed value out
						style.minWidth = style.maxWidth = style.width = ret;
						ret = computed.width;

						// Revert the changed values
						style.width = width;
						style.minWidth = minWidth;
						style.maxWidth = maxWidth;
					}
				}

				return ret !== undefined ?

					// Support: IE <=9 - 11 only
					// IE returns zIndex value as an integer.
					ret + "" :
					ret;
			}


			function addGetHookIf( conditionFn, hookFn ) {

				// Define the hook, we'll check on the first run if it's really needed.
				return {
					get: function() {
						if ( conditionFn() ) {

							// Hook not needed (or it's not possible to use it due
							// to missing dependency), remove it.
							delete this.get;
							return;
						}

						// Hook needed; redefine it so that the support test is not executed again.
						return ( this.get = hookFn ).apply( this, arguments );
					}
				};
			}


			var

				// Swappable if display is none or starts with table
				// except "table", "table-cell", or "table-caption"
				// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
				rdisplayswap = /^(none|table(?!-c[ea]).+)/,
				cssShow = { position: "absolute", visibility: "hidden", display: "block" },
				cssNormalTransform = {
					letterSpacing: "0",
					fontWeight: "400"
				},

				cssPrefixes = [ "Webkit", "Moz", "ms" ],
				emptyStyle = document.createElement( "div" ).style;

			// Return a css property mapped to a potentially vendor prefixed property
			function vendorPropName( name ) {

				// Shortcut for names that are not vendor prefixed
				if ( name in emptyStyle ) {
					return name;
				}

				// Check for vendor prefixed names
				var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
					i = cssPrefixes.length;

				while ( i-- ) {
					name = cssPrefixes[ i ] + capName;
					if ( name in emptyStyle ) {
						return name;
					}
				}
			}

			function setPositiveNumber( elem, value, subtract ) {

				// Any relative (+/-) values have already been
				// normalized at this point
				var matches = rcssNum.exec( value );
				return matches ?

					// Guard against undefined "subtract", e.g., when used as in cssHooks
					Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
					value;
			}

			function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
				var i,
					val = 0;

				// If we already have the right measurement, avoid augmentation
				if ( extra === ( isBorderBox ? "border" : "content" ) ) {
					i = 4;

				// Otherwise initialize for horizontal or vertical properties
				} else {
					i = name === "width" ? 1 : 0;
				}

				for ( ; i < 4; i += 2 ) {

					// Both box models exclude margin, so add it if we want it
					if ( extra === "margin" ) {
						val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
					}

					if ( isBorderBox ) {

						// border-box includes padding, so remove it if we want content
						if ( extra === "content" ) {
							val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
						}

						// At this point, extra isn't border nor margin, so remove border
						if ( extra !== "margin" ) {
							val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
						}
					} else {

						// At this point, extra isn't content, so add padding
						val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

						// At this point, extra isn't content nor padding, so add border
						if ( extra !== "padding" ) {
							val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
						}
					}
				}

				return val;
			}

			function getWidthOrHeight( elem, name, extra ) {

				// Start with offset property, which is equivalent to the border-box value
				var val,
					valueIsBorderBox = true,
					styles = getStyles( elem ),
					isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

				// Support: IE <=11 only
				// Running getBoundingClientRect on a disconnected node
				// in IE throws an error.
				if ( elem.getClientRects().length ) {
					val = elem.getBoundingClientRect()[ name ];
				}

				// Some non-html elements return undefined for offsetWidth, so check for null/undefined
				// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
				// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
				if ( val <= 0 || val == null ) {

					// Fall back to computed then uncomputed css if necessary
					val = curCSS( elem, name, styles );
					if ( val < 0 || val == null ) {
						val = elem.style[ name ];
					}

					// Computed unit is not pixels. Stop here and return.
					if ( rnumnonpx.test( val ) ) {
						return val;
					}

					// Check for style in case a browser which returns unreliable values
					// for getComputedStyle silently falls back to the reliable elem.style
					valueIsBorderBox = isBorderBox &&
						( support.boxSizingReliable() || val === elem.style[ name ] );

					// Normalize "", auto, and prepare for extra
					val = parseFloat( val ) || 0;
				}

				// Use the active box-sizing model to add/subtract irrelevant styles
				return ( val +
					augmentWidthOrHeight(
						elem,
						name,
						extra || ( isBorderBox ? "border" : "content" ),
						valueIsBorderBox,
						styles
					)
				) + "px";
			}

			jQuery.extend( {

				// Add in style property hooks for overriding the default
				// behavior of getting and setting a style property
				cssHooks: {
					opacity: {
						get: function( elem, computed ) {
							if ( computed ) {

								// We should always get a number back from opacity
								var ret = curCSS( elem, "opacity" );
								return ret === "" ? "1" : ret;
							}
						}
					}
				},

				// Don't automatically add "px" to these possibly-unitless properties
				cssNumber: {
					"animationIterationCount": true,
					"columnCount": true,
					"fillOpacity": true,
					"flexGrow": true,
					"flexShrink": true,
					"fontWeight": true,
					"lineHeight": true,
					"opacity": true,
					"order": true,
					"orphans": true,
					"widows": true,
					"zIndex": true,
					"zoom": true
				},

				// Add in properties whose names you wish to fix before
				// setting or getting the value
				cssProps: {
					"float": "cssFloat"
				},

				// Get and set the style property on a DOM Node
				style: function( elem, name, value, extra ) {

					// Don't set styles on text and comment nodes
					if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
						return;
					}

					// Make sure that we're working with the right name
					var ret, type, hooks,
						origName = jQuery.camelCase( name ),
						style = elem.style;

					name = jQuery.cssProps[ origName ] ||
						( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

					// Gets hook for the prefixed version, then unprefixed version
					hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

					// Check if we're setting a value
					if ( value !== undefined ) {
						type = typeof value;

						// Convert "+=" or "-=" to relative numbers (#7345)
						if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
							value = adjustCSS( elem, name, ret );

							// Fixes bug #9237
							type = "number";
						}

						// Make sure that null and NaN values aren't set (#7116)
						if ( value == null || value !== value ) {
							return;
						}

						// If a number was passed in, add the unit (except for certain CSS properties)
						if ( type === "number" ) {
							value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
						}

						// background-* props affect original clone's values
						if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
							style[ name ] = "inherit";
						}

						// If a hook was provided, use that value, otherwise just set the specified value
						if ( !hooks || !( "set" in hooks ) ||
							( value = hooks.set( elem, value, extra ) ) !== undefined ) {

							style[ name ] = value;
						}

					} else {

						// If a hook was provided get the non-computed value from there
						if ( hooks && "get" in hooks &&
							( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

							return ret;
						}

						// Otherwise just get the value from the style object
						return style[ name ];
					}
				},

				css: function( elem, name, extra, styles ) {
					var val, num, hooks,
						origName = jQuery.camelCase( name );

					// Make sure that we're working with the right name
					name = jQuery.cssProps[ origName ] ||
						( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

					// Try prefixed name followed by the unprefixed name
					hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

					// If a hook was provided get the computed value from there
					if ( hooks && "get" in hooks ) {
						val = hooks.get( elem, true, extra );
					}

					// Otherwise, if a way to get the computed value exists, use that
					if ( val === undefined ) {
						val = curCSS( elem, name, styles );
					}

					// Convert "normal" to computed value
					if ( val === "normal" && name in cssNormalTransform ) {
						val = cssNormalTransform[ name ];
					}

					// Make numeric if forced or a qualifier was provided and val looks numeric
					if ( extra === "" || extra ) {
						num = parseFloat( val );
						return extra === true || isFinite( num ) ? num || 0 : val;
					}
					return val;
				}
			} );

			jQuery.each( [ "height", "width" ], function( i, name ) {
				jQuery.cssHooks[ name ] = {
					get: function( elem, computed, extra ) {
						if ( computed ) {

							// Certain elements can have dimension info if we invisibly show them
							// but it must have a current display style that would benefit
							return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

								// Support: Safari 8+
								// Table columns in Safari have non-zero offsetWidth & zero
								// getBoundingClientRect().width unless display is changed.
								// Support: IE <=11 only
								// Running getBoundingClientRect on a disconnected node
								// in IE throws an error.
								( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
									swap( elem, cssShow, function() {
										return getWidthOrHeight( elem, name, extra );
									} ) :
									getWidthOrHeight( elem, name, extra );
						}
					},

					set: function( elem, value, extra ) {
						var matches,
							styles = extra && getStyles( elem ),
							subtract = extra && augmentWidthOrHeight(
								elem,
								name,
								extra,
								jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
								styles
							);

						// Convert to pixels if value adjustment is needed
						if ( subtract && ( matches = rcssNum.exec( value ) ) &&
							( matches[ 3 ] || "px" ) !== "px" ) {

							elem.style[ name ] = value;
							value = jQuery.css( elem, name );
						}

						return setPositiveNumber( elem, value, subtract );
					}
				};
			} );

			jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
				function( elem, computed ) {
					if ( computed ) {
						return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
							elem.getBoundingClientRect().left -
								swap( elem, { marginLeft: 0 }, function() {
									return elem.getBoundingClientRect().left;
								} )
							) + "px";
					}
				}
			);

			// These hooks are used by animate to expand properties
			jQuery.each( {
				margin: "",
				padding: "",
				border: "Width"
			}, function( prefix, suffix ) {
				jQuery.cssHooks[ prefix + suffix ] = {
					expand: function( value ) {
						var i = 0,
							expanded = {},

							// Assumes a single number if not a string
							parts = typeof value === "string" ? value.split( " " ) : [ value ];

						for ( ; i < 4; i++ ) {
							expanded[ prefix + cssExpand[ i ] + suffix ] =
								parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
						}

						return expanded;
					}
				};

				if ( !rmargin.test( prefix ) ) {
					jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
				}
			} );

			jQuery.fn.extend( {
				css: function( name, value ) {
					return access( this, function( elem, name, value ) {
						var styles, len,
							map = {},
							i = 0;

						if ( jQuery.isArray( name ) ) {
							styles = getStyles( elem );
							len = name.length;

							for ( ; i < len; i++ ) {
								map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
							}

							return map;
						}

						return value !== undefined ?
							jQuery.style( elem, name, value ) :
							jQuery.css( elem, name );
					}, name, value, arguments.length > 1 );
				}
			} );


			function Tween( elem, options, prop, end, easing ) {
				return new Tween.prototype.init( elem, options, prop, end, easing );
			}
			jQuery.Tween = Tween;

			Tween.prototype = {
				constructor: Tween,
				init: function( elem, options, prop, end, easing, unit ) {
					this.elem = elem;
					this.prop = prop;
					this.easing = easing || jQuery.easing._default;
					this.options = options;
					this.start = this.now = this.cur();
					this.end = end;
					this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
				},
				cur: function() {
					var hooks = Tween.propHooks[ this.prop ];

					return hooks && hooks.get ?
						hooks.get( this ) :
						Tween.propHooks._default.get( this );
				},
				run: function( percent ) {
					var eased,
						hooks = Tween.propHooks[ this.prop ];

					if ( this.options.duration ) {
						this.pos = eased = jQuery.easing[ this.easing ](
							percent, this.options.duration * percent, 0, 1, this.options.duration
						);
					} else {
						this.pos = eased = percent;
					}
					this.now = ( this.end - this.start ) * eased + this.start;

					if ( this.options.step ) {
						this.options.step.call( this.elem, this.now, this );
					}

					if ( hooks && hooks.set ) {
						hooks.set( this );
					} else {
						Tween.propHooks._default.set( this );
					}
					return this;
				}
			};

			Tween.prototype.init.prototype = Tween.prototype;

			Tween.propHooks = {
				_default: {
					get: function( tween ) {
						var result;

						// Use a property on the element directly when it is not a DOM element,
						// or when there is no matching style property that exists.
						if ( tween.elem.nodeType !== 1 ||
							tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
							return tween.elem[ tween.prop ];
						}

						// Passing an empty string as a 3rd parameter to .css will automatically
						// attempt a parseFloat and fallback to a string if the parse fails.
						// Simple values such as "10px" are parsed to Float;
						// complex values such as "rotate(1rad)" are returned as-is.
						result = jQuery.css( tween.elem, tween.prop, "" );

						// Empty strings, null, undefined and "auto" are converted to 0.
						return !result || result === "auto" ? 0 : result;
					},
					set: function( tween ) {

						// Use step hook for back compat.
						// Use cssHook if its there.
						// Use .style if available and use plain properties where available.
						if ( jQuery.fx.step[ tween.prop ] ) {
							jQuery.fx.step[ tween.prop ]( tween );
						} else if ( tween.elem.nodeType === 1 &&
							( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
								jQuery.cssHooks[ tween.prop ] ) ) {
							jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
						} else {
							tween.elem[ tween.prop ] = tween.now;
						}
					}
				}
			};

			// Support: IE <=9 only
			// Panic based approach to setting things on disconnected nodes
			Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
				set: function( tween ) {
					if ( tween.elem.nodeType && tween.elem.parentNode ) {
						tween.elem[ tween.prop ] = tween.now;
					}
				}
			};

			jQuery.easing = {
				linear: function( p ) {
					return p;
				},
				swing: function( p ) {
					return 0.5 - Math.cos( p * Math.PI ) / 2;
				},
				_default: "swing"
			};

			jQuery.fx = Tween.prototype.init;

			// Back compat <1.8 extension point
			jQuery.fx.step = {};




			var
				fxNow, timerId,
				rfxtypes = /^(?:toggle|show|hide)$/,
				rrun = /queueHooks$/;

			function raf() {
				if ( timerId ) {
					window.requestAnimationFrame( raf );
					jQuery.fx.tick();
				}
			}

			// Animations created synchronously will run synchronously
			function createFxNow() {
				window.setTimeout( function() {
					fxNow = undefined;
				} );
				return ( fxNow = jQuery.now() );
			}

			// Generate parameters to create a standard animation
			function genFx( type, includeWidth ) {
				var which,
					i = 0,
					attrs = { height: type };

				// If we include width, step value is 1 to do all cssExpand values,
				// otherwise step value is 2 to skip over Left and Right
				includeWidth = includeWidth ? 1 : 0;
				for ( ; i < 4; i += 2 - includeWidth ) {
					which = cssExpand[ i ];
					attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
				}

				if ( includeWidth ) {
					attrs.opacity = attrs.width = type;
				}

				return attrs;
			}

			function createTween( value, prop, animation ) {
				var tween,
					collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
					index = 0,
					length = collection.length;
				for ( ; index < length; index++ ) {
					if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

						// We're done with this property
						return tween;
					}
				}
			}

			function defaultPrefilter( elem, props, opts ) {
				var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
					isBox = "width" in props || "height" in props,
					anim = this,
					orig = {},
					style = elem.style,
					hidden = elem.nodeType && isHiddenWithinTree( elem ),
					dataShow = dataPriv.get( elem, "fxshow" );

				// Queue-skipping animations hijack the fx hooks
				if ( !opts.queue ) {
					hooks = jQuery._queueHooks( elem, "fx" );
					if ( hooks.unqueued == null ) {
						hooks.unqueued = 0;
						oldfire = hooks.empty.fire;
						hooks.empty.fire = function() {
							if ( !hooks.unqueued ) {
								oldfire();
							}
						};
					}
					hooks.unqueued++;

					anim.always( function() {

						// Ensure the complete handler is called before this completes
						anim.always( function() {
							hooks.unqueued--;
							if ( !jQuery.queue( elem, "fx" ).length ) {
								hooks.empty.fire();
							}
						} );
					} );
				}

				// Detect show/hide animations
				for ( prop in props ) {
					value = props[ prop ];
					if ( rfxtypes.test( value ) ) {
						delete props[ prop ];
						toggle = toggle || value === "toggle";
						if ( value === ( hidden ? "hide" : "show" ) ) {

							// Pretend to be hidden if this is a "show" and
							// there is still data from a stopped show/hide
							if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
								hidden = true;

							// Ignore all other no-op show/hide data
							} else {
								continue;
							}
						}
						orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
					}
				}

				// Bail out if this is a no-op like .hide().hide()
				propTween = !jQuery.isEmptyObject( props );
				if ( !propTween && jQuery.isEmptyObject( orig ) ) {
					return;
				}

				// Restrict "overflow" and "display" styles during box animations
				if ( isBox && elem.nodeType === 1 ) {

					// Support: IE <=9 - 11, Edge 12 - 13
					// Record all 3 overflow attributes because IE does not infer the shorthand
					// from identically-valued overflowX and overflowY
					opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

					// Identify a display type, preferring old show/hide data over the CSS cascade
					restoreDisplay = dataShow && dataShow.display;
					if ( restoreDisplay == null ) {
						restoreDisplay = dataPriv.get( elem, "display" );
					}
					display = jQuery.css( elem, "display" );
					if ( display === "none" ) {
						if ( restoreDisplay ) {
							display = restoreDisplay;
						} else {

							// Get nonempty value(s) by temporarily forcing visibility
							showHide( [ elem ], true );
							restoreDisplay = elem.style.display || restoreDisplay;
							display = jQuery.css( elem, "display" );
							showHide( [ elem ] );
						}
					}

					// Animate inline elements as inline-block
					if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
						if ( jQuery.css( elem, "float" ) === "none" ) {

							// Restore the original display value at the end of pure show/hide animations
							if ( !propTween ) {
								anim.done( function() {
									style.display = restoreDisplay;
								} );
								if ( restoreDisplay == null ) {
									display = style.display;
									restoreDisplay = display === "none" ? "" : display;
								}
							}
							style.display = "inline-block";
						}
					}
				}

				if ( opts.overflow ) {
					style.overflow = "hidden";
					anim.always( function() {
						style.overflow = opts.overflow[ 0 ];
						style.overflowX = opts.overflow[ 1 ];
						style.overflowY = opts.overflow[ 2 ];
					} );
				}

				// Implement show/hide animations
				propTween = false;
				for ( prop in orig ) {

					// General show/hide setup for this element animation
					if ( !propTween ) {
						if ( dataShow ) {
							if ( "hidden" in dataShow ) {
								hidden = dataShow.hidden;
							}
						} else {
							dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
						}

						// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
						if ( toggle ) {
							dataShow.hidden = !hidden;
						}

						// Show elements before animating them
						if ( hidden ) {
							showHide( [ elem ], true );
						}

						/* eslint-disable no-loop-func */

						anim.done( function() {

						/* eslint-enable no-loop-func */

							// The final step of a "hide" animation is actually hiding the element
							if ( !hidden ) {
								showHide( [ elem ] );
							}
							dataPriv.remove( elem, "fxshow" );
							for ( prop in orig ) {
								jQuery.style( elem, prop, orig[ prop ] );
							}
						} );
					}

					// Per-property setup
					propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
					if ( !( prop in dataShow ) ) {
						dataShow[ prop ] = propTween.start;
						if ( hidden ) {
							propTween.end = propTween.start;
							propTween.start = 0;
						}
					}
				}
			}

			function propFilter( props, specialEasing ) {
				var index, name, easing, value, hooks;

				// camelCase, specialEasing and expand cssHook pass
				for ( index in props ) {
					name = jQuery.camelCase( index );
					easing = specialEasing[ name ];
					value = props[ index ];
					if ( jQuery.isArray( value ) ) {
						easing = value[ 1 ];
						value = props[ index ] = value[ 0 ];
					}

					if ( index !== name ) {
						props[ name ] = value;
						delete props[ index ];
					}

					hooks = jQuery.cssHooks[ name ];
					if ( hooks && "expand" in hooks ) {
						value = hooks.expand( value );
						delete props[ name ];

						// Not quite $.extend, this won't overwrite existing keys.
						// Reusing 'index' because we have the correct "name"
						for ( index in value ) {
							if ( !( index in props ) ) {
								props[ index ] = value[ index ];
								specialEasing[ index ] = easing;
							}
						}
					} else {
						specialEasing[ name ] = easing;
					}
				}
			}

			function Animation( elem, properties, options ) {
				var result,
					stopped,
					index = 0,
					length = Animation.prefilters.length,
					deferred = jQuery.Deferred().always( function() {

						// Don't match elem in the :animated selector
						delete tick.elem;
					} ),
					tick = function() {
						if ( stopped ) {
							return false;
						}
						var currentTime = fxNow || createFxNow(),
							remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

							// Support: Android 2.3 only
							// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
							temp = remaining / animation.duration || 0,
							percent = 1 - temp,
							index = 0,
							length = animation.tweens.length;

						for ( ; index < length; index++ ) {
							animation.tweens[ index ].run( percent );
						}

						deferred.notifyWith( elem, [ animation, percent, remaining ] );

						if ( percent < 1 && length ) {
							return remaining;
						} else {
							deferred.resolveWith( elem, [ animation ] );
							return false;
						}
					},
					animation = deferred.promise( {
						elem: elem,
						props: jQuery.extend( {}, properties ),
						opts: jQuery.extend( true, {
							specialEasing: {},
							easing: jQuery.easing._default
						}, options ),
						originalProperties: properties,
						originalOptions: options,
						startTime: fxNow || createFxNow(),
						duration: options.duration,
						tweens: [],
						createTween: function( prop, end ) {
							var tween = jQuery.Tween( elem, animation.opts, prop, end,
									animation.opts.specialEasing[ prop ] || animation.opts.easing );
							animation.tweens.push( tween );
							return tween;
						},
						stop: function( gotoEnd ) {
							var index = 0,

								// If we are going to the end, we want to run all the tweens
								// otherwise we skip this part
								length = gotoEnd ? animation.tweens.length : 0;
							if ( stopped ) {
								return this;
							}
							stopped = true;
							for ( ; index < length; index++ ) {
								animation.tweens[ index ].run( 1 );
							}

							// Resolve when we played the last frame; otherwise, reject
							if ( gotoEnd ) {
								deferred.notifyWith( elem, [ animation, 1, 0 ] );
								deferred.resolveWith( elem, [ animation, gotoEnd ] );
							} else {
								deferred.rejectWith( elem, [ animation, gotoEnd ] );
							}
							return this;
						}
					} ),
					props = animation.props;

				propFilter( props, animation.opts.specialEasing );

				for ( ; index < length; index++ ) {
					result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
					if ( result ) {
						if ( jQuery.isFunction( result.stop ) ) {
							jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
								jQuery.proxy( result.stop, result );
						}
						return result;
					}
				}

				jQuery.map( props, createTween, animation );

				if ( jQuery.isFunction( animation.opts.start ) ) {
					animation.opts.start.call( elem, animation );
				}

				jQuery.fx.timer(
					jQuery.extend( tick, {
						elem: elem,
						anim: animation,
						queue: animation.opts.queue
					} )
				);

				// attach callbacks from options
				return animation.progress( animation.opts.progress )
					.done( animation.opts.done, animation.opts.complete )
					.fail( animation.opts.fail )
					.always( animation.opts.always );
			}

			jQuery.Animation = jQuery.extend( Animation, {

				tweeners: {
					"*": [ function( prop, value ) {
						var tween = this.createTween( prop, value );
						adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
						return tween;
					} ]
				},

				tweener: function( props, callback ) {
					if ( jQuery.isFunction( props ) ) {
						callback = props;
						props = [ "*" ];
					} else {
						props = props.match( rnothtmlwhite );
					}

					var prop,
						index = 0,
						length = props.length;

					for ( ; index < length; index++ ) {
						prop = props[ index ];
						Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
						Animation.tweeners[ prop ].unshift( callback );
					}
				},

				prefilters: [ defaultPrefilter ],

				prefilter: function( callback, prepend ) {
					if ( prepend ) {
						Animation.prefilters.unshift( callback );
					} else {
						Animation.prefilters.push( callback );
					}
				}
			} );

			jQuery.speed = function( speed, easing, fn ) {
				var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
					complete: fn || !fn && easing ||
						jQuery.isFunction( speed ) && speed,
					duration: speed,
					easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
				};

				// Go to the end state if fx are off or if document is hidden
				if ( jQuery.fx.off || document.hidden ) {
					opt.duration = 0;

				} else {
					if ( typeof opt.duration !== "number" ) {
						if ( opt.duration in jQuery.fx.speeds ) {
							opt.duration = jQuery.fx.speeds[ opt.duration ];

						} else {
							opt.duration = jQuery.fx.speeds._default;
						}
					}
				}

				// Normalize opt.queue - true/undefined/null -> "fx"
				if ( opt.queue == null || opt.queue === true ) {
					opt.queue = "fx";
				}

				// Queueing
				opt.old = opt.complete;

				opt.complete = function() {
					if ( jQuery.isFunction( opt.old ) ) {
						opt.old.call( this );
					}

					if ( opt.queue ) {
						jQuery.dequeue( this, opt.queue );
					}
				};

				return opt;
			};

			jQuery.fn.extend( {
				fadeTo: function( speed, to, easing, callback ) {

					// Show any hidden elements after setting opacity to 0
					return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

						// Animate to the value specified
						.end().animate( { opacity: to }, speed, easing, callback );
				},
				animate: function( prop, speed, easing, callback ) {
					var empty = jQuery.isEmptyObject( prop ),
						optall = jQuery.speed( speed, easing, callback ),
						doAnimation = function() {

							// Operate on a copy of prop so per-property easing won't be lost
							var anim = Animation( this, jQuery.extend( {}, prop ), optall );

							// Empty animations, or finishing resolves immediately
							if ( empty || dataPriv.get( this, "finish" ) ) {
								anim.stop( true );
							}
						};
						doAnimation.finish = doAnimation;

					return empty || optall.queue === false ?
						this.each( doAnimation ) :
						this.queue( optall.queue, doAnimation );
				},
				stop: function( type, clearQueue, gotoEnd ) {
					var stopQueue = function( hooks ) {
						var stop = hooks.stop;
						delete hooks.stop;
						stop( gotoEnd );
					};

					if ( typeof type !== "string" ) {
						gotoEnd = clearQueue;
						clearQueue = type;
						type = undefined;
					}
					if ( clearQueue && type !== false ) {
						this.queue( type || "fx", [] );
					}

					return this.each( function() {
						var dequeue = true,
							index = type != null && type + "queueHooks",
							timers = jQuery.timers,
							data = dataPriv.get( this );

						if ( index ) {
							if ( data[ index ] && data[ index ].stop ) {
								stopQueue( data[ index ] );
							}
						} else {
							for ( index in data ) {
								if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
									stopQueue( data[ index ] );
								}
							}
						}

						for ( index = timers.length; index--; ) {
							if ( timers[ index ].elem === this &&
								( type == null || timers[ index ].queue === type ) ) {

								timers[ index ].anim.stop( gotoEnd );
								dequeue = false;
								timers.splice( index, 1 );
							}
						}

						// Start the next in the queue if the last step wasn't forced.
						// Timers currently will call their complete callbacks, which
						// will dequeue but only if they were gotoEnd.
						if ( dequeue || !gotoEnd ) {
							jQuery.dequeue( this, type );
						}
					} );
				},
				finish: function( type ) {
					if ( type !== false ) {
						type = type || "fx";
					}
					return this.each( function() {
						var index,
							data = dataPriv.get( this ),
							queue = data[ type + "queue" ],
							hooks = data[ type + "queueHooks" ],
							timers = jQuery.timers,
							length = queue ? queue.length : 0;

						// Enable finishing flag on private data
						data.finish = true;

						// Empty the queue first
						jQuery.queue( this, type, [] );

						if ( hooks && hooks.stop ) {
							hooks.stop.call( this, true );
						}

						// Look for any active animations, and finish them
						for ( index = timers.length; index--; ) {
							if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
								timers[ index ].anim.stop( true );
								timers.splice( index, 1 );
							}
						}

						// Look for any animations in the old queue and finish them
						for ( index = 0; index < length; index++ ) {
							if ( queue[ index ] && queue[ index ].finish ) {
								queue[ index ].finish.call( this );
							}
						}

						// Turn off finishing flag
						delete data.finish;
					} );
				}
			} );

			jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
				var cssFn = jQuery.fn[ name ];
				jQuery.fn[ name ] = function( speed, easing, callback ) {
					return speed == null || typeof speed === "boolean" ?
						cssFn.apply( this, arguments ) :
						this.animate( genFx( name, true ), speed, easing, callback );
				};
			} );

			// Generate shortcuts for custom animations
			jQuery.each( {
				slideDown: genFx( "show" ),
				slideUp: genFx( "hide" ),
				slideToggle: genFx( "toggle" ),
				fadeIn: { opacity: "show" },
				fadeOut: { opacity: "hide" },
				fadeToggle: { opacity: "toggle" }
			}, function( name, props ) {
				jQuery.fn[ name ] = function( speed, easing, callback ) {
					return this.animate( props, speed, easing, callback );
				};
			} );

			jQuery.timers = [];
			jQuery.fx.tick = function() {
				var timer,
					i = 0,
					timers = jQuery.timers;

				fxNow = jQuery.now();

				for ( ; i < timers.length; i++ ) {
					timer = timers[ i ];

					// Checks the timer has not already been removed
					if ( !timer() && timers[ i ] === timer ) {
						timers.splice( i--, 1 );
					}
				}

				if ( !timers.length ) {
					jQuery.fx.stop();
				}
				fxNow = undefined;
			};

			jQuery.fx.timer = function( timer ) {
				jQuery.timers.push( timer );
				if ( timer() ) {
					jQuery.fx.start();
				} else {
					jQuery.timers.pop();
				}
			};

			jQuery.fx.interval = 13;
			jQuery.fx.start = function() {
				if ( !timerId ) {
					timerId = window.requestAnimationFrame ?
						window.requestAnimationFrame( raf ) :
						window.setInterval( jQuery.fx.tick, jQuery.fx.interval );
				}
			};

			jQuery.fx.stop = function() {
				if ( window.cancelAnimationFrame ) {
					window.cancelAnimationFrame( timerId );
				} else {
					window.clearInterval( timerId );
				}

				timerId = null;
			};

			jQuery.fx.speeds = {
				slow: 600,
				fast: 200,

				// Default speed
				_default: 400
			};


			// Based off of the plugin by Clint Helfers, with permission.
			// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
			jQuery.fn.delay = function( time, type ) {
				time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
				type = type || "fx";

				return this.queue( type, function( next, hooks ) {
					var timeout = window.setTimeout( next, time );
					hooks.stop = function() {
						window.clearTimeout( timeout );
					};
				} );
			};


			( function() {
				var input = document.createElement( "input" ),
					select = document.createElement( "select" ),
					opt = select.appendChild( document.createElement( "option" ) );

				input.type = "checkbox";

				// Support: Android <=4.3 only
				// Default value for a checkbox should be "on"
				support.checkOn = input.value !== "";

				// Support: IE <=11 only
				// Must access selectedIndex to make default options select
				support.optSelected = opt.selected;

				// Support: IE <=11 only
				// An input loses its value after becoming a radio
				input = document.createElement( "input" );
				input.value = "t";
				input.type = "radio";
				support.radioValue = input.value === "t";
			} )();


			var boolHook,
				attrHandle = jQuery.expr.attrHandle;

			jQuery.fn.extend( {
				attr: function( name, value ) {
					return access( this, jQuery.attr, name, value, arguments.length > 1 );
				},

				removeAttr: function( name ) {
					return this.each( function() {
						jQuery.removeAttr( this, name );
					} );
				}
			} );

			jQuery.extend( {
				attr: function( elem, name, value ) {
					var ret, hooks,
						nType = elem.nodeType;

					// Don't get/set attributes on text, comment and attribute nodes
					if ( nType === 3 || nType === 8 || nType === 2 ) {
						return;
					}

					// Fallback to prop when attributes are not supported
					if ( typeof elem.getAttribute === "undefined" ) {
						return jQuery.prop( elem, name, value );
					}

					// Attribute hooks are determined by the lowercase version
					// Grab necessary hook if one is defined
					if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
						hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
							( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
					}

					if ( value !== undefined ) {
						if ( value === null ) {
							jQuery.removeAttr( elem, name );
							return;
						}

						if ( hooks && "set" in hooks &&
							( ret = hooks.set( elem, value, name ) ) !== undefined ) {
							return ret;
						}

						elem.setAttribute( name, value + "" );
						return value;
					}

					if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
						return ret;
					}

					ret = jQuery.find.attr( elem, name );

					// Non-existent attributes return null, we normalize to undefined
					return ret == null ? undefined : ret;
				},

				attrHooks: {
					type: {
						set: function( elem, value ) {
							if ( !support.radioValue && value === "radio" &&
								jQuery.nodeName( elem, "input" ) ) {
								var val = elem.value;
								elem.setAttribute( "type", value );
								if ( val ) {
									elem.value = val;
								}
								return value;
							}
						}
					}
				},

				removeAttr: function( elem, value ) {
					var name,
						i = 0,

						// Attribute names can contain non-HTML whitespace characters
						// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
						attrNames = value && value.match( rnothtmlwhite );

					if ( attrNames && elem.nodeType === 1 ) {
						while ( ( name = attrNames[ i++ ] ) ) {
							elem.removeAttribute( name );
						}
					}
				}
			} );

			// Hooks for boolean attributes
			boolHook = {
				set: function( elem, value, name ) {
					if ( value === false ) {

						// Remove boolean attributes when set to false
						jQuery.removeAttr( elem, name );
					} else {
						elem.setAttribute( name, name );
					}
					return name;
				}
			};

			jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
				var getter = attrHandle[ name ] || jQuery.find.attr;

				attrHandle[ name ] = function( elem, name, isXML ) {
					var ret, handle,
						lowercaseName = name.toLowerCase();

					if ( !isXML ) {

						// Avoid an infinite loop by temporarily removing this function from the getter
						handle = attrHandle[ lowercaseName ];
						attrHandle[ lowercaseName ] = ret;
						ret = getter( elem, name, isXML ) != null ?
							lowercaseName :
							null;
						attrHandle[ lowercaseName ] = handle;
					}
					return ret;
				};
			} );




			var rfocusable = /^(?:input|select|textarea|button)$/i,
				rclickable = /^(?:a|area)$/i;

			jQuery.fn.extend( {
				prop: function( name, value ) {
					return access( this, jQuery.prop, name, value, arguments.length > 1 );
				},

				removeProp: function( name ) {
					return this.each( function() {
						delete this[ jQuery.propFix[ name ] || name ];
					} );
				}
			} );

			jQuery.extend( {
				prop: function( elem, name, value ) {
					var ret, hooks,
						nType = elem.nodeType;

					// Don't get/set properties on text, comment and attribute nodes
					if ( nType === 3 || nType === 8 || nType === 2 ) {
						return;
					}

					if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

						// Fix name and attach hooks
						name = jQuery.propFix[ name ] || name;
						hooks = jQuery.propHooks[ name ];
					}

					if ( value !== undefined ) {
						if ( hooks && "set" in hooks &&
							( ret = hooks.set( elem, value, name ) ) !== undefined ) {
							return ret;
						}

						return ( elem[ name ] = value );
					}

					if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
						return ret;
					}

					return elem[ name ];
				},

				propHooks: {
					tabIndex: {
						get: function( elem ) {

							// Support: IE <=9 - 11 only
							// elem.tabIndex doesn't always return the
							// correct value when it hasn't been explicitly set
							// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
							// Use proper attribute retrieval(#12072)
							var tabindex = jQuery.find.attr( elem, "tabindex" );

							if ( tabindex ) {
								return parseInt( tabindex, 10 );
							}

							if (
								rfocusable.test( elem.nodeName ) ||
								rclickable.test( elem.nodeName ) &&
								elem.href
							) {
								return 0;
							}

							return -1;
						}
					}
				},

				propFix: {
					"for": "htmlFor",
					"class": "className"
				}
			} );

			// Support: IE <=11 only
			// Accessing the selectedIndex property
			// forces the browser to respect setting selected
			// on the option
			// The getter ensures a default option is selected
			// when in an optgroup
			// eslint rule "no-unused-expressions" is disabled for this code
			// since it considers such accessions noop
			if ( !support.optSelected ) {
				jQuery.propHooks.selected = {
					get: function( elem ) {

						/* eslint no-unused-expressions: "off" */

						var parent = elem.parentNode;
						if ( parent && parent.parentNode ) {
							parent.parentNode.selectedIndex;
						}
						return null;
					},
					set: function( elem ) {

						/* eslint no-unused-expressions: "off" */

						var parent = elem.parentNode;
						if ( parent ) {
							parent.selectedIndex;

							if ( parent.parentNode ) {
								parent.parentNode.selectedIndex;
							}
						}
					}
				};
			}

			jQuery.each( [
				"tabIndex",
				"readOnly",
				"maxLength",
				"cellSpacing",
				"cellPadding",
				"rowSpan",
				"colSpan",
				"useMap",
				"frameBorder",
				"contentEditable"
			], function() {
				jQuery.propFix[ this.toLowerCase() ] = this;
			} );




				// Strip and collapse whitespace according to HTML spec
				// https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace
				function stripAndCollapse( value ) {
					var tokens = value.match( rnothtmlwhite ) || [];
					return tokens.join( " " );
				}


			function getClass( elem ) {
				return elem.getAttribute && elem.getAttribute( "class" ) || "";
			}

			jQuery.fn.extend( {
				addClass: function( value ) {
					var classes, elem, cur, curValue, clazz, j, finalValue,
						i = 0;

					if ( jQuery.isFunction( value ) ) {
						return this.each( function( j ) {
							jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
						} );
					}

					if ( typeof value === "string" && value ) {
						classes = value.match( rnothtmlwhite ) || [];

						while ( ( elem = this[ i++ ] ) ) {
							curValue = getClass( elem );
							cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

							if ( cur ) {
								j = 0;
								while ( ( clazz = classes[ j++ ] ) ) {
									if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
										cur += clazz + " ";
									}
								}

								// Only assign if different to avoid unneeded rendering.
								finalValue = stripAndCollapse( cur );
								if ( curValue !== finalValue ) {
									elem.setAttribute( "class", finalValue );
								}
							}
						}
					}

					return this;
				},

				removeClass: function( value ) {
					var classes, elem, cur, curValue, clazz, j, finalValue,
						i = 0;

					if ( jQuery.isFunction( value ) ) {
						return this.each( function( j ) {
							jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
						} );
					}

					if ( !arguments.length ) {
						return this.attr( "class", "" );
					}

					if ( typeof value === "string" && value ) {
						classes = value.match( rnothtmlwhite ) || [];

						while ( ( elem = this[ i++ ] ) ) {
							curValue = getClass( elem );

							// This expression is here for better compressibility (see addClass)
							cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

							if ( cur ) {
								j = 0;
								while ( ( clazz = classes[ j++ ] ) ) {

									// Remove *all* instances
									while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
										cur = cur.replace( " " + clazz + " ", " " );
									}
								}

								// Only assign if different to avoid unneeded rendering.
								finalValue = stripAndCollapse( cur );
								if ( curValue !== finalValue ) {
									elem.setAttribute( "class", finalValue );
								}
							}
						}
					}

					return this;
				},

				toggleClass: function( value, stateVal ) {
					var type = typeof value;

					if ( typeof stateVal === "boolean" && type === "string" ) {
						return stateVal ? this.addClass( value ) : this.removeClass( value );
					}

					if ( jQuery.isFunction( value ) ) {
						return this.each( function( i ) {
							jQuery( this ).toggleClass(
								value.call( this, i, getClass( this ), stateVal ),
								stateVal
							);
						} );
					}

					return this.each( function() {
						var className, i, self, classNames;

						if ( type === "string" ) {

							// Toggle individual class names
							i = 0;
							self = jQuery( this );
							classNames = value.match( rnothtmlwhite ) || [];

							while ( ( className = classNames[ i++ ] ) ) {

								// Check each className given, space separated list
								if ( self.hasClass( className ) ) {
									self.removeClass( className );
								} else {
									self.addClass( className );
								}
							}

						// Toggle whole class name
						} else if ( value === undefined || type === "boolean" ) {
							className = getClass( this );
							if ( className ) {

								// Store className if set
								dataPriv.set( this, "__className__", className );
							}

							// If the element has a class name or if we're passed `false`,
							// then remove the whole classname (if there was one, the above saved it).
							// Otherwise bring back whatever was previously saved (if anything),
							// falling back to the empty string if nothing was stored.
							if ( this.setAttribute ) {
								this.setAttribute( "class",
									className || value === false ?
									"" :
									dataPriv.get( this, "__className__" ) || ""
								);
							}
						}
					} );
				},

				hasClass: function( selector ) {
					var className, elem,
						i = 0;

					className = " " + selector + " ";
					while ( ( elem = this[ i++ ] ) ) {
						if ( elem.nodeType === 1 &&
							( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
								return true;
						}
					}

					return false;
				}
			} );




			var rreturn = /\r/g;

			jQuery.fn.extend( {
				val: function( value ) {
					var hooks, ret, isFunction,
						elem = this[ 0 ];

					if ( !arguments.length ) {
						if ( elem ) {
							hooks = jQuery.valHooks[ elem.type ] ||
								jQuery.valHooks[ elem.nodeName.toLowerCase() ];

							if ( hooks &&
								"get" in hooks &&
								( ret = hooks.get( elem, "value" ) ) !== undefined
							) {
								return ret;
							}

							ret = elem.value;

							// Handle most common string cases
							if ( typeof ret === "string" ) {
								return ret.replace( rreturn, "" );
							}

							// Handle cases where value is null/undef or number
							return ret == null ? "" : ret;
						}

						return;
					}

					isFunction = jQuery.isFunction( value );

					return this.each( function( i ) {
						var val;

						if ( this.nodeType !== 1 ) {
							return;
						}

						if ( isFunction ) {
							val = value.call( this, i, jQuery( this ).val() );
						} else {
							val = value;
						}

						// Treat null/undefined as ""; convert numbers to string
						if ( val == null ) {
							val = "";

						} else if ( typeof val === "number" ) {
							val += "";

						} else if ( jQuery.isArray( val ) ) {
							val = jQuery.map( val, function( value ) {
								return value == null ? "" : value + "";
							} );
						}

						hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

						// If set returns undefined, fall back to normal setting
						if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
							this.value = val;
						}
					} );
				}
			} );

			jQuery.extend( {
				valHooks: {
					option: {
						get: function( elem ) {

							var val = jQuery.find.attr( elem, "value" );
							return val != null ?
								val :

								// Support: IE <=10 - 11 only
								// option.text throws exceptions (#14686, #14858)
								// Strip and collapse whitespace
								// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
								stripAndCollapse( jQuery.text( elem ) );
						}
					},
					select: {
						get: function( elem ) {
							var value, option, i,
								options = elem.options,
								index = elem.selectedIndex,
								one = elem.type === "select-one",
								values = one ? null : [],
								max = one ? index + 1 : options.length;

							if ( index < 0 ) {
								i = max;

							} else {
								i = one ? index : 0;
							}

							// Loop through all the selected options
							for ( ; i < max; i++ ) {
								option = options[ i ];

								// Support: IE <=9 only
								// IE8-9 doesn't update selected after form reset (#2551)
								if ( ( option.selected || i === index ) &&

										// Don't return options that are disabled or in a disabled optgroup
										!option.disabled &&
										( !option.parentNode.disabled ||
											!jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

									// Get the specific value for the option
									value = jQuery( option ).val();

									// We don't need an array for one selects
									if ( one ) {
										return value;
									}

									// Multi-Selects return an array
									values.push( value );
								}
							}

							return values;
						},

						set: function( elem, value ) {
							var optionSet, option,
								options = elem.options,
								values = jQuery.makeArray( value ),
								i = options.length;

							while ( i-- ) {
								option = options[ i ];

								/* eslint-disable no-cond-assign */

								if ( option.selected =
									jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
								) {
									optionSet = true;
								}

								/* eslint-enable no-cond-assign */
							}

							// Force browsers to behave consistently when non-matching value is set
							if ( !optionSet ) {
								elem.selectedIndex = -1;
							}
							return values;
						}
					}
				}
			} );

			// Radios and checkboxes getter/setter
			jQuery.each( [ "radio", "checkbox" ], function() {
				jQuery.valHooks[ this ] = {
					set: function( elem, value ) {
						if ( jQuery.isArray( value ) ) {
							return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
						}
					}
				};
				if ( !support.checkOn ) {
					jQuery.valHooks[ this ].get = function( elem ) {
						return elem.getAttribute( "value" ) === null ? "on" : elem.value;
					};
				}
			} );




			// Return jQuery for attributes-only inclusion


			var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;

			jQuery.extend( jQuery.event, {

				trigger: function( event, data, elem, onlyHandlers ) {

					var i, cur, tmp, bubbleType, ontype, handle, special,
						eventPath = [ elem || document ],
						type = hasOwn.call( event, "type" ) ? event.type : event,
						namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

					cur = tmp = elem = elem || document;

					// Don't do events on text and comment nodes
					if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
						return;
					}

					// focus/blur morphs to focusin/out; ensure we're not firing them right now
					if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
						return;
					}

					if ( type.indexOf( "." ) > -1 ) {

						// Namespaced trigger; create a regexp to match event type in handle()
						namespaces = type.split( "." );
						type = namespaces.shift();
						namespaces.sort();
					}
					ontype = type.indexOf( ":" ) < 0 && "on" + type;

					// Caller can pass in a jQuery.Event object, Object, or just an event type string
					event = event[ jQuery.expando ] ?
						event :
						new jQuery.Event( type, typeof event === "object" && event );

					// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
					event.isTrigger = onlyHandlers ? 2 : 3;
					event.namespace = namespaces.join( "." );
					event.rnamespace = event.namespace ?
						new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
						null;

					// Clean up the event in case it is being reused
					event.result = undefined;
					if ( !event.target ) {
						event.target = elem;
					}

					// Clone any incoming data and prepend the event, creating the handler arg list
					data = data == null ?
						[ event ] :
						jQuery.makeArray( data, [ event ] );

					// Allow special events to draw outside the lines
					special = jQuery.event.special[ type ] || {};
					if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
						return;
					}

					// Determine event propagation path in advance, per W3C events spec (#9951)
					// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
					if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

						bubbleType = special.delegateType || type;
						if ( !rfocusMorph.test( bubbleType + type ) ) {
							cur = cur.parentNode;
						}
						for ( ; cur; cur = cur.parentNode ) {
							eventPath.push( cur );
							tmp = cur;
						}

						// Only add window if we got to document (e.g., not plain obj or detached DOM)
						if ( tmp === ( elem.ownerDocument || document ) ) {
							eventPath.push( tmp.defaultView || tmp.parentWindow || window );
						}
					}

					// Fire handlers on the event path
					i = 0;
					while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {

						event.type = i > 1 ?
							bubbleType :
							special.bindType || type;

						// jQuery handler
						handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
							dataPriv.get( cur, "handle" );
						if ( handle ) {
							handle.apply( cur, data );
						}

						// Native handler
						handle = ontype && cur[ ontype ];
						if ( handle && handle.apply && acceptData( cur ) ) {
							event.result = handle.apply( cur, data );
							if ( event.result === false ) {
								event.preventDefault();
							}
						}
					}
					event.type = type;

					// If nobody prevented the default action, do it now
					if ( !onlyHandlers && !event.isDefaultPrevented() ) {

						if ( ( !special._default ||
							special._default.apply( eventPath.pop(), data ) === false ) &&
							acceptData( elem ) ) {

							// Call a native DOM method on the target with the same name as the event.
							// Don't do default actions on window, that's where global variables be (#6170)
							if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

								// Don't re-trigger an onFOO event when we call its FOO() method
								tmp = elem[ ontype ];

								if ( tmp ) {
									elem[ ontype ] = null;
								}

								// Prevent re-triggering of the same event, since we already bubbled it above
								jQuery.event.triggered = type;
								elem[ type ]();
								jQuery.event.triggered = undefined;

								if ( tmp ) {
									elem[ ontype ] = tmp;
								}
							}
						}
					}

					return event.result;
				},

				// Piggyback on a donor event to simulate a different one
				// Used only for `focus(in | out)` events
				simulate: function( type, elem, event ) {
					var e = jQuery.extend(
						new jQuery.Event(),
						event,
						{
							type: type,
							isSimulated: true
						}
					);

					jQuery.event.trigger( e, null, elem );
				}

			} );

			jQuery.fn.extend( {

				trigger: function( type, data ) {
					return this.each( function() {
						jQuery.event.trigger( type, data, this );
					} );
				},
				triggerHandler: function( type, data ) {
					var elem = this[ 0 ];
					if ( elem ) {
						return jQuery.event.trigger( type, data, elem, true );
					}
				}
			} );


			jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
				"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
				"change select submit keydown keypress keyup contextmenu" ).split( " " ),
				function( i, name ) {

				// Handle event binding
				jQuery.fn[ name ] = function( data, fn ) {
					return arguments.length > 0 ?
						this.on( name, null, data, fn ) :
						this.trigger( name );
				};
			} );

			jQuery.fn.extend( {
				hover: function( fnOver, fnOut ) {
					return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
				}
			} );




			support.focusin = "onfocusin" in window;


			// Support: Firefox <=44
			// Firefox doesn't have focus(in | out) events
			// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
			//
			// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
			// focus(in | out) events fire after focus & blur events,
			// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
			// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
			if ( !support.focusin ) {
				jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

					// Attach a single capturing handler on the document while someone wants focusin/focusout
					var handler = function( event ) {
						jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
					};

					jQuery.event.special[ fix ] = {
						setup: function() {
							var doc = this.ownerDocument || this,
								attaches = dataPriv.access( doc, fix );

							if ( !attaches ) {
								doc.addEventListener( orig, handler, true );
							}
							dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
						},
						teardown: function() {
							var doc = this.ownerDocument || this,
								attaches = dataPriv.access( doc, fix ) - 1;

							if ( !attaches ) {
								doc.removeEventListener( orig, handler, true );
								dataPriv.remove( doc, fix );

							} else {
								dataPriv.access( doc, fix, attaches );
							}
						}
					};
				} );
			}
			var location = window.location;

			var nonce = jQuery.now();

			var rquery = ( /\?/ );



			// Cross-browser xml parsing
			jQuery.parseXML = function( data ) {
				var xml;
				if ( !data || typeof data !== "string" ) {
					return null;
				}

				// Support: IE 9 - 11 only
				// IE throws on parseFromString with invalid input.
				try {
					xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
				} catch ( e ) {
					xml = undefined;
				}

				if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
					jQuery.error( "Invalid XML: " + data );
				}
				return xml;
			};


			var
				rbracket = /\[\]$/,
				rCRLF = /\r?\n/g,
				rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
				rsubmittable = /^(?:input|select|textarea|keygen)/i;

			function buildParams( prefix, obj, traditional, add ) {
				var name;

				if ( jQuery.isArray( obj ) ) {

					// Serialize array item.
					jQuery.each( obj, function( i, v ) {
						if ( traditional || rbracket.test( prefix ) ) {

							// Treat each array item as a scalar.
							add( prefix, v );

						} else {

							// Item is non-scalar (array or object), encode its numeric index.
							buildParams(
								prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
								v,
								traditional,
								add
							);
						}
					} );

				} else if ( !traditional && jQuery.type( obj ) === "object" ) {

					// Serialize object item.
					for ( name in obj ) {
						buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
					}

				} else {

					// Serialize scalar item.
					add( prefix, obj );
				}
			}

			// Serialize an array of form elements or a set of
			// key/values into a query string
			jQuery.param = function( a, traditional ) {
				var prefix,
					s = [],
					add = function( key, valueOrFunction ) {

						// If value is a function, invoke it and use its return value
						var value = jQuery.isFunction( valueOrFunction ) ?
							valueOrFunction() :
							valueOrFunction;

						s[ s.length ] = encodeURIComponent( key ) + "=" +
							encodeURIComponent( value == null ? "" : value );
					};

				// If an array was passed in, assume that it is an array of form elements.
				if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

					// Serialize the form elements
					jQuery.each( a, function() {
						add( this.name, this.value );
					} );

				} else {

					// If traditional, encode the "old" way (the way 1.3.2 or older
					// did it), otherwise encode params recursively.
					for ( prefix in a ) {
						buildParams( prefix, a[ prefix ], traditional, add );
					}
				}

				// Return the resulting serialization
				return s.join( "&" );
			};

			jQuery.fn.extend( {
				serialize: function() {
					return jQuery.param( this.serializeArray() );
				},
				serializeArray: function() {
					return this.map( function() {

						// Can add propHook for "elements" to filter or add form elements
						var elements = jQuery.prop( this, "elements" );
						return elements ? jQuery.makeArray( elements ) : this;
					} )
					.filter( function() {
						var type = this.type;

						// Use .is( ":disabled" ) so that fieldset[disabled] works
						return this.name && !jQuery( this ).is( ":disabled" ) &&
							rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
							( this.checked || !rcheckableType.test( type ) );
					} )
					.map( function( i, elem ) {
						var val = jQuery( this ).val();

						if ( val == null ) {
							return null;
						}

						if ( jQuery.isArray( val ) ) {
							return jQuery.map( val, function( val ) {
								return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
							} );
						}

						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					} ).get();
				}
			} );


			var
				r20 = /%20/g,
				rhash = /#.*$/,
				rantiCache = /([?&])_=[^&]*/,
				rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

				// #7653, #8125, #8152: local protocol detection
				rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
				rnoContent = /^(?:GET|HEAD)$/,
				rprotocol = /^\/\//,

				/* Prefilters
				 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
				 * 2) These are called:
				 *    - BEFORE asking for a transport
				 *    - AFTER param serialization (s.data is a string if s.processData is true)
				 * 3) key is the dataType
				 * 4) the catchall symbol "*" can be used
				 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
				 */
				prefilters = {},

				/* Transports bindings
				 * 1) key is the dataType
				 * 2) the catchall symbol "*" can be used
				 * 3) selection will start with transport dataType and THEN go to "*" if needed
				 */
				transports = {},

				// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
				allTypes = "*/".concat( "*" ),

				// Anchor tag for parsing the document origin
				originAnchor = document.createElement( "a" );
				originAnchor.href = location.href;

			// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
			function addToPrefiltersOrTransports( structure ) {

				// dataTypeExpression is optional and defaults to "*"
				return function( dataTypeExpression, func ) {

					if ( typeof dataTypeExpression !== "string" ) {
						func = dataTypeExpression;
						dataTypeExpression = "*";
					}

					var dataType,
						i = 0,
						dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

					if ( jQuery.isFunction( func ) ) {

						// For each dataType in the dataTypeExpression
						while ( ( dataType = dataTypes[ i++ ] ) ) {

							// Prepend if requested
							if ( dataType[ 0 ] === "+" ) {
								dataType = dataType.slice( 1 ) || "*";
								( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

							// Otherwise append
							} else {
								( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
							}
						}
					}
				};
			}

			// Base inspection function for prefilters and transports
			function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

				var inspected = {},
					seekingTransport = ( structure === transports );

				function inspect( dataType ) {
					var selected;
					inspected[ dataType ] = true;
					jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
						var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
						if ( typeof dataTypeOrTransport === "string" &&
							!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

							options.dataTypes.unshift( dataTypeOrTransport );
							inspect( dataTypeOrTransport );
							return false;
						} else if ( seekingTransport ) {
							return !( selected = dataTypeOrTransport );
						}
					} );
					return selected;
				}

				return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
			}

			// A special extend for ajax options
			// that takes "flat" options (not to be deep extended)
			// Fixes #9887
			function ajaxExtend( target, src ) {
				var key, deep,
					flatOptions = jQuery.ajaxSettings.flatOptions || {};

				for ( key in src ) {
					if ( src[ key ] !== undefined ) {
						( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
					}
				}
				if ( deep ) {
					jQuery.extend( true, target, deep );
				}

				return target;
			}

			/* Handles responses to an ajax request:
			 * - finds the right dataType (mediates between content-type and expected dataType)
			 * - returns the corresponding response
			 */
			function ajaxHandleResponses( s, jqXHR, responses ) {

				var ct, type, finalDataType, firstDataType,
					contents = s.contents,
					dataTypes = s.dataTypes;

				// Remove auto dataType and get content-type in the process
				while ( dataTypes[ 0 ] === "*" ) {
					dataTypes.shift();
					if ( ct === undefined ) {
						ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
					}
				}

				// Check if we're dealing with a known content-type
				if ( ct ) {
					for ( type in contents ) {
						if ( contents[ type ] && contents[ type ].test( ct ) ) {
							dataTypes.unshift( type );
							break;
						}
					}
				}

				// Check to see if we have a response for the expected dataType
				if ( dataTypes[ 0 ] in responses ) {
					finalDataType = dataTypes[ 0 ];
				} else {

					// Try convertible dataTypes
					for ( type in responses ) {
						if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
							finalDataType = type;
							break;
						}
						if ( !firstDataType ) {
							firstDataType = type;
						}
					}

					// Or just use first one
					finalDataType = finalDataType || firstDataType;
				}

				// If we found a dataType
				// We add the dataType to the list if needed
				// and return the corresponding response
				if ( finalDataType ) {
					if ( finalDataType !== dataTypes[ 0 ] ) {
						dataTypes.unshift( finalDataType );
					}
					return responses[ finalDataType ];
				}
			}

			/* Chain conversions given the request and the original response
			 * Also sets the responseXXX fields on the jqXHR instance
			 */
			function ajaxConvert( s, response, jqXHR, isSuccess ) {
				var conv2, current, conv, tmp, prev,
					converters = {},

					// Work with a copy of dataTypes in case we need to modify it for conversion
					dataTypes = s.dataTypes.slice();

				// Create converters map with lowercased keys
				if ( dataTypes[ 1 ] ) {
					for ( conv in s.converters ) {
						converters[ conv.toLowerCase() ] = s.converters[ conv ];
					}
				}

				current = dataTypes.shift();

				// Convert to each sequential dataType
				while ( current ) {

					if ( s.responseFields[ current ] ) {
						jqXHR[ s.responseFields[ current ] ] = response;
					}

					// Apply the dataFilter if provided
					if ( !prev && isSuccess && s.dataFilter ) {
						response = s.dataFilter( response, s.dataType );
					}

					prev = current;
					current = dataTypes.shift();

					if ( current ) {

						// There's only work to do if current dataType is non-auto
						if ( current === "*" ) {

							current = prev;

						// Convert response if prev dataType is non-auto and differs from current
						} else if ( prev !== "*" && prev !== current ) {

							// Seek a direct converter
							conv = converters[ prev + " " + current ] || converters[ "* " + current ];

							// If none found, seek a pair
							if ( !conv ) {
								for ( conv2 in converters ) {

									// If conv2 outputs current
									tmp = conv2.split( " " );
									if ( tmp[ 1 ] === current ) {

										// If prev can be converted to accepted input
										conv = converters[ prev + " " + tmp[ 0 ] ] ||
											converters[ "* " + tmp[ 0 ] ];
										if ( conv ) {

											// Condense equivalence converters
											if ( conv === true ) {
												conv = converters[ conv2 ];

											// Otherwise, insert the intermediate dataType
											} else if ( converters[ conv2 ] !== true ) {
												current = tmp[ 0 ];
												dataTypes.unshift( tmp[ 1 ] );
											}
											break;
										}
									}
								}
							}

							// Apply converter (if not an equivalence)
							if ( conv !== true ) {

								// Unless errors are allowed to bubble, catch and return them
								if ( conv && s.throws ) {
									response = conv( response );
								} else {
									try {
										response = conv( response );
									} catch ( e ) {
										return {
											state: "parsererror",
											error: conv ? e : "No conversion from " + prev + " to " + current
										};
									}
								}
							}
						}
					}
				}

				return { state: "success", data: response };
			}

			jQuery.extend( {

				// Counter for holding the number of active queries
				active: 0,

				// Last-Modified header cache for next request
				lastModified: {},
				etag: {},

				ajaxSettings: {
					url: location.href,
					type: "GET",
					isLocal: rlocalProtocol.test( location.protocol ),
					global: true,
					processData: true,
					async: true,
					contentType: "application/x-www-form-urlencoded; charset=UTF-8",

					/*
					timeout: 0,
					data: null,
					dataType: null,
					username: null,
					password: null,
					cache: null,
					throws: false,
					traditional: false,
					headers: {},
					*/

					accepts: {
						"*": allTypes,
						text: "text/plain",
						html: "text/html",
						xml: "application/xml, text/xml",
						json: "application/json, text/javascript"
					},

					contents: {
						xml: /\bxml\b/,
						html: /\bhtml/,
						json: /\bjson\b/
					},

					responseFields: {
						xml: "responseXML",
						text: "responseText",
						json: "responseJSON"
					},

					// Data converters
					// Keys separate source (or catchall "*") and destination types with a single space
					converters: {

						// Convert anything to text
						"* text": String,

						// Text to html (true = no transformation)
						"text html": true,

						// Evaluate text as a json expression
						"text json": JSON.parse,

						// Parse text as xml
						"text xml": jQuery.parseXML
					},

					// For options that shouldn't be deep extended:
					// you can add your own custom options here if
					// and when you create one that shouldn't be
					// deep extended (see ajaxExtend)
					flatOptions: {
						url: true,
						context: true
					}
				},

				// Creates a full fledged settings object into target
				// with both ajaxSettings and settings fields.
				// If target is omitted, writes into ajaxSettings.
				ajaxSetup: function( target, settings ) {
					return settings ?

						// Building a settings object
						ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

						// Extending ajaxSettings
						ajaxExtend( jQuery.ajaxSettings, target );
				},

				ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
				ajaxTransport: addToPrefiltersOrTransports( transports ),

				// Main method
				ajax: function( url, options ) {

					// If url is an object, simulate pre-1.5 signature
					if ( typeof url === "object" ) {
						options = url;
						url = undefined;
					}

					// Force options to be an object
					options = options || {};

					var transport,

						// URL without anti-cache param
						cacheURL,

						// Response headers
						responseHeadersString,
						responseHeaders,

						// timeout handle
						timeoutTimer,

						// Url cleanup var
						urlAnchor,

						// Request state (becomes false upon send and true upon completion)
						completed,

						// To know if global events are to be dispatched
						fireGlobals,

						// Loop variable
						i,

						// uncached part of the url
						uncached,

						// Create the final options object
						s = jQuery.ajaxSetup( {}, options ),

						// Callbacks context
						callbackContext = s.context || s,

						// Context for global events is callbackContext if it is a DOM node or jQuery collection
						globalEventContext = s.context &&
							( callbackContext.nodeType || callbackContext.jquery ) ?
								jQuery( callbackContext ) :
								jQuery.event,

						// Deferreds
						deferred = jQuery.Deferred(),
						completeDeferred = jQuery.Callbacks( "once memory" ),

						// Status-dependent callbacks
						statusCode = s.statusCode || {},

						// Headers (they are sent all at once)
						requestHeaders = {},
						requestHeadersNames = {},

						// Default abort message
						strAbort = "canceled",

						// Fake xhr
						jqXHR = {
							readyState: 0,

							// Builds headers hashtable if needed
							getResponseHeader: function( key ) {
								var match;
								if ( completed ) {
									if ( !responseHeaders ) {
										responseHeaders = {};
										while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
											responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
										}
									}
									match = responseHeaders[ key.toLowerCase() ];
								}
								return match == null ? null : match;
							},

							// Raw string
							getAllResponseHeaders: function() {
								return completed ? responseHeadersString : null;
							},

							// Caches the header
							setRequestHeader: function( name, value ) {
								if ( completed == null ) {
									name = requestHeadersNames[ name.toLowerCase() ] =
										requestHeadersNames[ name.toLowerCase() ] || name;
									requestHeaders[ name ] = value;
								}
								return this;
							},

							// Overrides response content-type header
							overrideMimeType: function( type ) {
								if ( completed == null ) {
									s.mimeType = type;
								}
								return this;
							},

							// Status-dependent callbacks
							statusCode: function( map ) {
								var code;
								if ( map ) {
									if ( completed ) {

										// Execute the appropriate callbacks
										jqXHR.always( map[ jqXHR.status ] );
									} else {

										// Lazy-add the new callbacks in a way that preserves old ones
										for ( code in map ) {
											statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
										}
									}
								}
								return this;
							},

							// Cancel the request
							abort: function( statusText ) {
								var finalText = statusText || strAbort;
								if ( transport ) {
									transport.abort( finalText );
								}
								done( 0, finalText );
								return this;
							}
						};

					// Attach deferreds
					deferred.promise( jqXHR );

					// Add protocol if not provided (prefilters might expect it)
					// Handle falsy url in the settings object (#10093: consistency with old signature)
					// We also use the url parameter if available
					s.url = ( ( url || s.url || location.href ) + "" )
						.replace( rprotocol, location.protocol + "//" );

					// Alias method option to type as per ticket #12004
					s.type = options.method || options.type || s.method || s.type;

					// Extract dataTypes list
					s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

					// A cross-domain request is in order when the origin doesn't match the current origin.
					if ( s.crossDomain == null ) {
						urlAnchor = document.createElement( "a" );

						// Support: IE <=8 - 11, Edge 12 - 13
						// IE throws exception on accessing the href property if url is malformed,
						// e.g. http://example.com:80x/
						try {
							urlAnchor.href = s.url;

							// Support: IE <=8 - 11 only
							// Anchor's host property isn't correctly set when s.url is relative
							urlAnchor.href = urlAnchor.href;
							s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
								urlAnchor.protocol + "//" + urlAnchor.host;
						} catch ( e ) {

							// If there is an error parsing the URL, assume it is crossDomain,
							// it can be rejected by the transport if it is invalid
							s.crossDomain = true;
						}
					}

					// Convert data if not already a string
					if ( s.data && s.processData && typeof s.data !== "string" ) {
						s.data = jQuery.param( s.data, s.traditional );
					}

					// Apply prefilters
					inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

					// If request was aborted inside a prefilter, stop there
					if ( completed ) {
						return jqXHR;
					}

					// We can fire global events as of now if asked to
					// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
					fireGlobals = jQuery.event && s.global;

					// Watch for a new set of requests
					if ( fireGlobals && jQuery.active++ === 0 ) {
						jQuery.event.trigger( "ajaxStart" );
					}

					// Uppercase the type
					s.type = s.type.toUpperCase();

					// Determine if request has content
					s.hasContent = !rnoContent.test( s.type );

					// Save the URL in case we're toying with the If-Modified-Since
					// and/or If-None-Match header later on
					// Remove hash to simplify url manipulation
					cacheURL = s.url.replace( rhash, "" );

					// More options handling for requests with no content
					if ( !s.hasContent ) {

						// Remember the hash so we can put it back
						uncached = s.url.slice( cacheURL.length );

						// If data is available, append data to url
						if ( s.data ) {
							cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

							// #9682: remove data so that it's not used in an eventual retry
							delete s.data;
						}

						// Add or update anti-cache param if needed
						if ( s.cache === false ) {
							cacheURL = cacheURL.replace( rantiCache, "$1" );
							uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
						}

						// Put hash and anti-cache on the URL that will be requested (gh-1732)
						s.url = cacheURL + uncached;

					// Change '%20' to '+' if this is encoded form body content (gh-2658)
					} else if ( s.data && s.processData &&
						( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
						s.data = s.data.replace( r20, "+" );
					}

					// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
					if ( s.ifModified ) {
						if ( jQuery.lastModified[ cacheURL ] ) {
							jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
						}
						if ( jQuery.etag[ cacheURL ] ) {
							jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
						}
					}

					// Set the correct header, if data is being sent
					if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
						jqXHR.setRequestHeader( "Content-Type", s.contentType );
					}

					// Set the Accepts header for the server, depending on the dataType
					jqXHR.setRequestHeader(
						"Accept",
						s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
							s.accepts[ s.dataTypes[ 0 ] ] +
								( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
							s.accepts[ "*" ]
					);

					// Check for headers option
					for ( i in s.headers ) {
						jqXHR.setRequestHeader( i, s.headers[ i ] );
					}

					// Allow custom headers/mimetypes and early abort
					if ( s.beforeSend &&
						( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

						// Abort if not done already and return
						return jqXHR.abort();
					}

					// Aborting is no longer a cancellation
					strAbort = "abort";

					// Install callbacks on deferreds
					completeDeferred.add( s.complete );
					jqXHR.done( s.success );
					jqXHR.fail( s.error );

					// Get transport
					transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

					// If no transport, we auto-abort
					if ( !transport ) {
						done( -1, "No Transport" );
					} else {
						jqXHR.readyState = 1;

						// Send global event
						if ( fireGlobals ) {
							globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
						}

						// If request was aborted inside ajaxSend, stop there
						if ( completed ) {
							return jqXHR;
						}

						// Timeout
						if ( s.async && s.timeout > 0 ) {
							timeoutTimer = window.setTimeout( function() {
								jqXHR.abort( "timeout" );
							}, s.timeout );
						}

						try {
							completed = false;
							transport.send( requestHeaders, done );
						} catch ( e ) {

							// Rethrow post-completion exceptions
							if ( completed ) {
								throw e;
							}

							// Propagate others as results
							done( -1, e );
						}
					}

					// Callback for when everything is done
					function done( status, nativeStatusText, responses, headers ) {
						var isSuccess, success, error, response, modified,
							statusText = nativeStatusText;

						// Ignore repeat invocations
						if ( completed ) {
							return;
						}

						completed = true;

						// Clear timeout if it exists
						if ( timeoutTimer ) {
							window.clearTimeout( timeoutTimer );
						}

						// Dereference transport for early garbage collection
						// (no matter how long the jqXHR object will be used)
						transport = undefined;

						// Cache response headers
						responseHeadersString = headers || "";

						// Set readyState
						jqXHR.readyState = status > 0 ? 4 : 0;

						// Determine if successful
						isSuccess = status >= 200 && status < 300 || status === 304;

						// Get response data
						if ( responses ) {
							response = ajaxHandleResponses( s, jqXHR, responses );
						}

						// Convert no matter what (that way responseXXX fields are always set)
						response = ajaxConvert( s, response, jqXHR, isSuccess );

						// If successful, handle type chaining
						if ( isSuccess ) {

							// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
							if ( s.ifModified ) {
								modified = jqXHR.getResponseHeader( "Last-Modified" );
								if ( modified ) {
									jQuery.lastModified[ cacheURL ] = modified;
								}
								modified = jqXHR.getResponseHeader( "etag" );
								if ( modified ) {
									jQuery.etag[ cacheURL ] = modified;
								}
							}

							// if no content
							if ( status === 204 || s.type === "HEAD" ) {
								statusText = "nocontent";

							// if not modified
							} else if ( status === 304 ) {
								statusText = "notmodified";

							// If we have data, let's convert it
							} else {
								statusText = response.state;
								success = response.data;
								error = response.error;
								isSuccess = !error;
							}
						} else {

							// Extract error from statusText and normalize for non-aborts
							error = statusText;
							if ( status || !statusText ) {
								statusText = "error";
								if ( status < 0 ) {
									status = 0;
								}
							}
						}

						// Set data for the fake xhr object
						jqXHR.status = status;
						jqXHR.statusText = ( nativeStatusText || statusText ) + "";

						// Success/Error
						if ( isSuccess ) {
							deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
						} else {
							deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
						}

						// Status-dependent callbacks
						jqXHR.statusCode( statusCode );
						statusCode = undefined;

						if ( fireGlobals ) {
							globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
								[ jqXHR, s, isSuccess ? success : error ] );
						}

						// Complete
						completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

						if ( fireGlobals ) {
							globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

							// Handle the global AJAX counter
							if ( !( --jQuery.active ) ) {
								jQuery.event.trigger( "ajaxStop" );
							}
						}
					}

					return jqXHR;
				},

				getJSON: function( url, data, callback ) {
					return jQuery.get( url, data, callback, "json" );
				},

				getScript: function( url, callback ) {
					return jQuery.get( url, undefined, callback, "script" );
				}
			} );

			jQuery.each( [ "get", "post" ], function( i, method ) {
				jQuery[ method ] = function( url, data, callback, type ) {

					// Shift arguments if data argument was omitted
					if ( jQuery.isFunction( data ) ) {
						type = type || callback;
						callback = data;
						data = undefined;
					}

					// The url can be an options object (which then must have .url)
					return jQuery.ajax( jQuery.extend( {
						url: url,
						type: method,
						dataType: type,
						data: data,
						success: callback
					}, jQuery.isPlainObject( url ) && url ) );
				};
			} );


			jQuery._evalUrl = function( url ) {
				return jQuery.ajax( {
					url: url,

					// Make this explicit, since user can override this through ajaxSetup (#11264)
					type: "GET",
					dataType: "script",
					cache: true,
					async: false,
					global: false,
					"throws": true
				} );
			};


			jQuery.fn.extend( {
				wrapAll: function( html ) {
					var wrap;

					if ( this[ 0 ] ) {
						if ( jQuery.isFunction( html ) ) {
							html = html.call( this[ 0 ] );
						}

						// The elements to wrap the target around
						wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

						if ( this[ 0 ].parentNode ) {
							wrap.insertBefore( this[ 0 ] );
						}

						wrap.map( function() {
							var elem = this;

							while ( elem.firstElementChild ) {
								elem = elem.firstElementChild;
							}

							return elem;
						} ).append( this );
					}

					return this;
				},

				wrapInner: function( html ) {
					if ( jQuery.isFunction( html ) ) {
						return this.each( function( i ) {
							jQuery( this ).wrapInner( html.call( this, i ) );
						} );
					}

					return this.each( function() {
						var self = jQuery( this ),
							contents = self.contents();

						if ( contents.length ) {
							contents.wrapAll( html );

						} else {
							self.append( html );
						}
					} );
				},

				wrap: function( html ) {
					var isFunction = jQuery.isFunction( html );

					return this.each( function( i ) {
						jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );
					} );
				},

				unwrap: function( selector ) {
					this.parent( selector ).not( "body" ).each( function() {
						jQuery( this ).replaceWith( this.childNodes );
					} );
					return this;
				}
			} );


			jQuery.expr.pseudos.hidden = function( elem ) {
				return !jQuery.expr.pseudos.visible( elem );
			};
			jQuery.expr.pseudos.visible = function( elem ) {
				return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
			};




			jQuery.ajaxSettings.xhr = function() {
				try {
					return new window.XMLHttpRequest();
				} catch ( e ) {}
			};

			var xhrSuccessStatus = {

					// File protocol always yields status code 0, assume 200
					0: 200,

					// Support: IE <=9 only
					// #1450: sometimes IE returns 1223 when it should be 204
					1223: 204
				},
				xhrSupported = jQuery.ajaxSettings.xhr();

			support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
			support.ajax = xhrSupported = !!xhrSupported;

			jQuery.ajaxTransport( function( options ) {
				var callback, errorCallback;

				// Cross domain only allowed if supported through XMLHttpRequest
				if ( support.cors || xhrSupported && !options.crossDomain ) {
					return {
						send: function( headers, complete ) {
							var i,
								xhr = options.xhr();

							xhr.open(
								options.type,
								options.url,
								options.async,
								options.username,
								options.password
							);

							// Apply custom fields if provided
							if ( options.xhrFields ) {
								for ( i in options.xhrFields ) {
									xhr[ i ] = options.xhrFields[ i ];
								}
							}

							// Override mime type if needed
							if ( options.mimeType && xhr.overrideMimeType ) {
								xhr.overrideMimeType( options.mimeType );
							}

							// X-Requested-With header
							// For cross-domain requests, seeing as conditions for a preflight are
							// akin to a jigsaw puzzle, we simply never set it to be sure.
							// (it can always be set on a per-request basis or even using ajaxSetup)
							// For same-domain requests, won't change header if already provided.
							if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
								headers[ "X-Requested-With" ] = "XMLHttpRequest";
							}

							// Set headers
							for ( i in headers ) {
								xhr.setRequestHeader( i, headers[ i ] );
							}

							// Callback
							callback = function( type ) {
								return function() {
									if ( callback ) {
										callback = errorCallback = xhr.onload =
											xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;

										if ( type === "abort" ) {
											xhr.abort();
										} else if ( type === "error" ) {

											// Support: IE <=9 only
											// On a manual native abort, IE9 throws
											// errors on any property access that is not readyState
											if ( typeof xhr.status !== "number" ) {
												complete( 0, "error" );
											} else {
												complete(

													// File: protocol always yields status 0; see #8605, #14207
													xhr.status,
													xhr.statusText
												);
											}
										} else {
											complete(
												xhrSuccessStatus[ xhr.status ] || xhr.status,
												xhr.statusText,

												// Support: IE <=9 only
												// IE9 has no XHR2 but throws on binary (trac-11426)
												// For XHR2 non-text, let the caller handle it (gh-2498)
												( xhr.responseType || "text" ) !== "text"  ||
												typeof xhr.responseText !== "string" ?
													{ binary: xhr.response } :
													{ text: xhr.responseText },
												xhr.getAllResponseHeaders()
											);
										}
									}
								};
							};

							// Listen to events
							xhr.onload = callback();
							errorCallback = xhr.onerror = callback( "error" );

							// Support: IE 9 only
							// Use onreadystatechange to replace onabort
							// to handle uncaught aborts
							if ( xhr.onabort !== undefined ) {
								xhr.onabort = errorCallback;
							} else {
								xhr.onreadystatechange = function() {

									// Check readyState before timeout as it changes
									if ( xhr.readyState === 4 ) {

										// Allow onerror to be called first,
										// but that will not handle a native abort
										// Also, save errorCallback to a variable
										// as xhr.onerror cannot be accessed
										window.setTimeout( function() {
											if ( callback ) {
												errorCallback();
											}
										} );
									}
								};
							}

							// Create the abort callback
							callback = callback( "abort" );

							try {

								// Do send the request (this may raise an exception)
								xhr.send( options.hasContent && options.data || null );
							} catch ( e ) {

								// #14683: Only rethrow if this hasn't been notified as an error yet
								if ( callback ) {
									throw e;
								}
							}
						},

						abort: function() {
							if ( callback ) {
								callback();
							}
						}
					};
				}
			} );




			// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
			jQuery.ajaxPrefilter( function( s ) {
				if ( s.crossDomain ) {
					s.contents.script = false;
				}
			} );

			// Install script dataType
			jQuery.ajaxSetup( {
				accepts: {
					script: "text/javascript, application/javascript, " +
						"application/ecmascript, application/x-ecmascript"
				},
				contents: {
					script: /\b(?:java|ecma)script\b/
				},
				converters: {
					"text script": function( text ) {
						jQuery.globalEval( text );
						return text;
					}
				}
			} );

			// Handle cache's special case and crossDomain
			jQuery.ajaxPrefilter( "script", function( s ) {
				if ( s.cache === undefined ) {
					s.cache = false;
				}
				if ( s.crossDomain ) {
					s.type = "GET";
				}
			} );

			// Bind script tag hack transport
			jQuery.ajaxTransport( "script", function( s ) {

				// This transport only deals with cross domain requests
				if ( s.crossDomain ) {
					var script, callback;
					return {
						send: function( _, complete ) {
							script = jQuery( "<script>" ).prop( {
								charset: s.scriptCharset,
								src: s.url
							} ).on(
								"load error",
								callback = function( evt ) {
									script.remove();
									callback = null;
									if ( evt ) {
										complete( evt.type === "error" ? 404 : 200, evt.type );
									}
								}
							);

							// Use native DOM manipulation to avoid our domManip AJAX trickery
							document.head.appendChild( script[ 0 ] );
						},
						abort: function() {
							if ( callback ) {
								callback();
							}
						}
					};
				}
			} );




			var oldCallbacks = [],
				rjsonp = /(=)\?(?=&|$)|\?\?/;

			// Default jsonp settings
			jQuery.ajaxSetup( {
				jsonp: "callback",
				jsonpCallback: function() {
					var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
					this[ callback ] = true;
					return callback;
				}
			} );

			// Detect, normalize options and install callbacks for jsonp requests
			jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

				var callbackName, overwritten, responseContainer,
					jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
						"url" :
						typeof s.data === "string" &&
							( s.contentType || "" )
								.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
							rjsonp.test( s.data ) && "data"
					);

				// Handle iff the expected data type is "jsonp" or we have a parameter to set
				if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

					// Get callback name, remembering preexisting value associated with it
					callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
						s.jsonpCallback() :
						s.jsonpCallback;

					// Insert callback into url or form data
					if ( jsonProp ) {
						s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
					} else if ( s.jsonp !== false ) {
						s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
					}

					// Use data converter to retrieve json after script execution
					s.converters[ "script json" ] = function() {
						if ( !responseContainer ) {
							jQuery.error( callbackName + " was not called" );
						}
						return responseContainer[ 0 ];
					};

					// Force json dataType
					s.dataTypes[ 0 ] = "json";

					// Install callback
					overwritten = window[ callbackName ];
					window[ callbackName ] = function() {
						responseContainer = arguments;
					};

					// Clean-up function (fires after converters)
					jqXHR.always( function() {

						// If previous value didn't exist - remove it
						if ( overwritten === undefined ) {
							jQuery( window ).removeProp( callbackName );

						// Otherwise restore preexisting value
						} else {
							window[ callbackName ] = overwritten;
						}

						// Save back as free
						if ( s[ callbackName ] ) {

							// Make sure that re-using the options doesn't screw things around
							s.jsonpCallback = originalSettings.jsonpCallback;

							// Save the callback name for future use
							oldCallbacks.push( callbackName );
						}

						// Call if it was a function and we have a response
						if ( responseContainer && jQuery.isFunction( overwritten ) ) {
							overwritten( responseContainer[ 0 ] );
						}

						responseContainer = overwritten = undefined;
					} );

					// Delegate to script
					return "script";
				}
			} );




			// Support: Safari 8 only
			// In Safari 8 documents created via document.implementation.createHTMLDocument
			// collapse sibling forms: the second one becomes a child of the first one.
			// Because of that, this security measure has to be disabled in Safari 8.
			// https://bugs.webkit.org/show_bug.cgi?id=137337
			support.createHTMLDocument = ( function() {
				var body = document.implementation.createHTMLDocument( "" ).body;
				body.innerHTML = "<form></form><form></form>";
				return body.childNodes.length === 2;
			} )();


			// Argument "data" should be string of html
			// context (optional): If specified, the fragment will be created in this context,
			// defaults to document
			// keepScripts (optional): If true, will include scripts passed in the html string
			jQuery.parseHTML = function( data, context, keepScripts ) {
				if ( typeof data !== "string" ) {
					return [];
				}
				if ( typeof context === "boolean" ) {
					keepScripts = context;
					context = false;
				}

				var base, parsed, scripts;

				if ( !context ) {

					// Stop scripts or inline event handlers from being executed immediately
					// by using document.implementation
					if ( support.createHTMLDocument ) {
						context = document.implementation.createHTMLDocument( "" );

						// Set the base href for the created document
						// so any parsed elements with URLs
						// are based on the document's URL (gh-2965)
						base = context.createElement( "base" );
						base.href = document.location.href;
						context.head.appendChild( base );
					} else {
						context = document;
					}
				}

				parsed = rsingleTag.exec( data );
				scripts = !keepScripts && [];

				// Single tag
				if ( parsed ) {
					return [ context.createElement( parsed[ 1 ] ) ];
				}

				parsed = buildFragment( [ data ], context, scripts );

				if ( scripts && scripts.length ) {
					jQuery( scripts ).remove();
				}

				return jQuery.merge( [], parsed.childNodes );
			};


			/**
			 * Load a url into a page
			 */
			jQuery.fn.load = function( url, params, callback ) {
				var selector, type, response,
					self = this,
					off = url.indexOf( " " );

				if ( off > -1 ) {
					selector = stripAndCollapse( url.slice( off ) );
					url = url.slice( 0, off );
				}

				// If it's a function
				if ( jQuery.isFunction( params ) ) {

					// We assume that it's the callback
					callback = params;
					params = undefined;

				// Otherwise, build a param string
				} else if ( params && typeof params === "object" ) {
					type = "POST";
				}

				// If we have elements to modify, make the request
				if ( self.length > 0 ) {
					jQuery.ajax( {
						url: url,

						// If "type" variable is undefined, then "GET" method will be used.
						// Make value of this field explicit since
						// user can override it through ajaxSetup method
						type: type || "GET",
						dataType: "html",
						data: params
					} ).done( function( responseText ) {

						// Save response for use in complete callback
						response = arguments;

						self.html( selector ?

							// If a selector was specified, locate the right elements in a dummy div
							// Exclude scripts to avoid IE 'Permission Denied' errors
							jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

							// Otherwise use the full result
							responseText );

					// If the request succeeds, this function gets "data", "status", "jqXHR"
					// but they are ignored because response was set above.
					// If it fails, this function gets "jqXHR", "status", "error"
					} ).always( callback && function( jqXHR, status ) {
						self.each( function() {
							callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
						} );
					} );
				}

				return this;
			};




			// Attach a bunch of functions for handling common AJAX events
			jQuery.each( [
				"ajaxStart",
				"ajaxStop",
				"ajaxComplete",
				"ajaxError",
				"ajaxSuccess",
				"ajaxSend"
			], function( i, type ) {
				jQuery.fn[ type ] = function( fn ) {
					return this.on( type, fn );
				};
			} );




			jQuery.expr.pseudos.animated = function( elem ) {
				return jQuery.grep( jQuery.timers, function( fn ) {
					return elem === fn.elem;
				} ).length;
			};




			/**
			 * Gets a window from an element
			 */
			function getWindow( elem ) {
				return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
			}

			jQuery.offset = {
				setOffset: function( elem, options, i ) {
					var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
						position = jQuery.css( elem, "position" ),
						curElem = jQuery( elem ),
						props = {};

					// Set position first, in-case top/left are set even on static elem
					if ( position === "static" ) {
						elem.style.position = "relative";
					}

					curOffset = curElem.offset();
					curCSSTop = jQuery.css( elem, "top" );
					curCSSLeft = jQuery.css( elem, "left" );
					calculatePosition = ( position === "absolute" || position === "fixed" ) &&
						( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

					// Need to be able to calculate position if either
					// top or left is auto and position is either absolute or fixed
					if ( calculatePosition ) {
						curPosition = curElem.position();
						curTop = curPosition.top;
						curLeft = curPosition.left;

					} else {
						curTop = parseFloat( curCSSTop ) || 0;
						curLeft = parseFloat( curCSSLeft ) || 0;
					}

					if ( jQuery.isFunction( options ) ) {

						// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
						options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
					}

					if ( options.top != null ) {
						props.top = ( options.top - curOffset.top ) + curTop;
					}
					if ( options.left != null ) {
						props.left = ( options.left - curOffset.left ) + curLeft;
					}

					if ( "using" in options ) {
						options.using.call( elem, props );

					} else {
						curElem.css( props );
					}
				}
			};

			jQuery.fn.extend( {
				offset: function( options ) {

					// Preserve chaining for setter
					if ( arguments.length ) {
						return options === undefined ?
							this :
							this.each( function( i ) {
								jQuery.offset.setOffset( this, options, i );
							} );
					}

					var docElem, win, rect, doc,
						elem = this[ 0 ];

					if ( !elem ) {
						return;
					}

					// Support: IE <=11 only
					// Running getBoundingClientRect on a
					// disconnected node in IE throws an error
					if ( !elem.getClientRects().length ) {
						return { top: 0, left: 0 };
					}

					rect = elem.getBoundingClientRect();

					// Make sure element is not hidden (display: none)
					if ( rect.width || rect.height ) {
						doc = elem.ownerDocument;
						win = getWindow( doc );
						docElem = doc.documentElement;

						return {
							top: rect.top + win.pageYOffset - docElem.clientTop,
							left: rect.left + win.pageXOffset - docElem.clientLeft
						};
					}

					// Return zeros for disconnected and hidden elements (gh-2310)
					return rect;
				},

				position: function() {
					if ( !this[ 0 ] ) {
						return;
					}

					var offsetParent, offset,
						elem = this[ 0 ],
						parentOffset = { top: 0, left: 0 };

					// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
					// because it is its only offset parent
					if ( jQuery.css( elem, "position" ) === "fixed" ) {

						// Assume getBoundingClientRect is there when computed position is fixed
						offset = elem.getBoundingClientRect();

					} else {

						// Get *real* offsetParent
						offsetParent = this.offsetParent();

						// Get correct offsets
						offset = this.offset();
						if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
							parentOffset = offsetParent.offset();
						}

						// Add offsetParent borders
						parentOffset = {
							top: parentOffset.top + jQuery.css( offsetParent[ 0 ], "borderTopWidth", true ),
							left: parentOffset.left + jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true )
						};
					}

					// Subtract parent offsets and element margins
					return {
						top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
						left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
					};
				},

				// This method will return documentElement in the following cases:
				// 1) For the element inside the iframe without offsetParent, this method will return
				//    documentElement of the parent window
				// 2) For the hidden or detached element
				// 3) For body or html element, i.e. in case of the html node - it will return itself
				//
				// but those exceptions were never presented as a real life use-cases
				// and might be considered as more preferable results.
				//
				// This logic, however, is not guaranteed and can change at any point in the future
				offsetParent: function() {
					return this.map( function() {
						var offsetParent = this.offsetParent;

						while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
							offsetParent = offsetParent.offsetParent;
						}

						return offsetParent || documentElement;
					} );
				}
			} );

			// Create scrollLeft and scrollTop methods
			jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
				var top = "pageYOffset" === prop;

				jQuery.fn[ method ] = function( val ) {
					return access( this, function( elem, method, val ) {
						var win = getWindow( elem );

						if ( val === undefined ) {
							return win ? win[ prop ] : elem[ method ];
						}

						if ( win ) {
							win.scrollTo(
								!top ? val : win.pageXOffset,
								top ? val : win.pageYOffset
							);

						} else {
							elem[ method ] = val;
						}
					}, method, val, arguments.length );
				};
			} );

			// Support: Safari <=7 - 9.1, Chrome <=37 - 49
			// Add the top/left cssHooks using jQuery.fn.position
			// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
			// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
			// getComputedStyle returns percent when specified for top/left/bottom/right;
			// rather than make the css module depend on the offset module, just check for it here
			jQuery.each( [ "top", "left" ], function( i, prop ) {
				jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
					function( elem, computed ) {
						if ( computed ) {
							computed = curCSS( elem, prop );

							// If curCSS returns percentage, fallback to offset
							return rnumnonpx.test( computed ) ?
								jQuery( elem ).position()[ prop ] + "px" :
								computed;
						}
					}
				);
			} );


			// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
			jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
				jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
					function( defaultExtra, funcName ) {

					// Margin is only for outerHeight, outerWidth
					jQuery.fn[ funcName ] = function( margin, value ) {
						var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
							extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

						return access( this, function( elem, type, value ) {
							var doc;

							if ( jQuery.isWindow( elem ) ) {

								// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
								return funcName.indexOf( "outer" ) === 0 ?
									elem[ "inner" + name ] :
									elem.document.documentElement[ "client" + name ];
							}

							// Get document width or height
							if ( elem.nodeType === 9 ) {
								doc = elem.documentElement;

								// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
								// whichever is greatest
								return Math.max(
									elem.body[ "scroll" + name ], doc[ "scroll" + name ],
									elem.body[ "offset" + name ], doc[ "offset" + name ],
									doc[ "client" + name ]
								);
							}

							return value === undefined ?

								// Get width or height on the element, requesting but not forcing parseFloat
								jQuery.css( elem, type, extra ) :

								// Set width or height on the element
								jQuery.style( elem, type, value, extra );
						}, type, chainable ? margin : undefined, chainable );
					};
				} );
			} );


			jQuery.fn.extend( {

				bind: function( types, data, fn ) {
					return this.on( types, null, data, fn );
				},
				unbind: function( types, fn ) {
					return this.off( types, null, fn );
				},

				delegate: function( selector, types, data, fn ) {
					return this.on( types, selector, data, fn );
				},
				undelegate: function( selector, types, fn ) {

					// ( namespace ) or ( selector, types [, fn] )
					return arguments.length === 1 ?
						this.off( selector, "**" ) :
						this.off( types, selector || "**", fn );
				}
			} );

			jQuery.parseJSON = JSON.parse;




			// Register as a named AMD module, since jQuery can be concatenated with other
			// files that may use define, but not via a proper concatenation script that
			// understands anonymous AMD modules. A named AMD is safest and most robust
			// way to register. Lowercase jquery is used because AMD module names are
			// derived from file names, and jQuery is normally delivered in a lowercase
			// file name. Do this after creating the global so that if an AMD module wants
			// to call noConflict to hide this version of jQuery, it will work.

			// Note that for maximum portability, libraries that are not jQuery should
			// declare themselves as anonymous modules, and avoid setting a global if an
			// AMD loader is present. jQuery is a special case. For more information, see
			// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

			if ( true ) {
				!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
					return jQuery;
				}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
			}




			var

				// Map over jQuery in case of overwrite
				_jQuery = window.jQuery,

				// Map over the $ in case of overwrite
				_$ = window.$;

			jQuery.noConflict = function( deep ) {
				if ( window.$ === jQuery ) {
					window.$ = _$;
				}

				if ( deep && window.jQuery === jQuery ) {
					window.jQuery = _jQuery;
				}

				return jQuery;
			};

			// Expose jQuery and $ identifiers, even in AMD
			// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
			// and CommonJS for browser emulators (#13566)
			if ( !noGlobal ) {
				window.jQuery = window.$ = jQuery;
			}





			return jQuery;
			} );


		/***/ },
		/* 6 */
		/***/ function(module, exports) {

			/******/ (function(modules) { // webpackBootstrap
			/******/ 	// The module cache
			/******/ 	var installedModules = {};

			/******/ 	// The require function
			/******/ 	function __webpack_require__(moduleId) {

			/******/ 		// Check if module is in cache
			/******/ 		if(installedModules[moduleId])
			/******/ 			return installedModules[moduleId].exports;

			/******/ 		// Create a new module (and put it into the cache)
			/******/ 		var module = installedModules[moduleId] = {
			/******/ 			exports: {},
			/******/ 			id: moduleId,
			/******/ 			loaded: false
			/******/ 		};

			/******/ 		// Execute the module function
			/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

			/******/ 		// Flag the module as loaded
			/******/ 		module.loaded = true;

			/******/ 		// Return the exports of the module
			/******/ 		return module.exports;
			/******/ 	}


			/******/ 	// expose the modules object (__webpack_modules__)
			/******/ 	__webpack_require__.m = modules;

			/******/ 	// expose the module cache
			/******/ 	__webpack_require__.c = installedModules;

			/******/ 	// __webpack_public_path__
			/******/ 	__webpack_require__.p = "";

			/******/ 	// Load entry module and return exports
			/******/ 	return __webpack_require__(0);
			/******/ })
			/************************************************************************/
			/******/ ([
			/* 0 */
			/***/ function(module, exports, __webpack_require__) {

				__webpack_require__(1);
				__webpack_require__(1);
				module.exports = __webpack_require__(6);


			/***/ },
			/* 1 */
			/***/ function(module, exports, __webpack_require__) {

				var Vue = __webpack_require__(2);
				var app1 = __webpack_require__(3);
				var logic = __webpack_require__(4);

			/***/ },
			/* 2 */
			/***/ function(module, exports, __webpack_require__) {

				/*!
				 * Vue.js v2.0.5
				 * (c) 2014-2016 Evan You
				 * Released under the MIT License.
				 */
				(function (global, factory) {
				   true ? module.exports = factory() :
				  typeof define === 'function' && define.amd ? define(factory) :
				  (global.Vue = factory());
				}(this, (function () { 'use strict';

				/*  */

				/**
				 * Convert a value to a string that is actually rendered.
				 */
				function _toString (val) {
				  return val == null
				    ? ''
				    : typeof val === 'object'
				      ? JSON.stringify(val, null, 2)
				      : String(val)
				}

				/**
				 * Convert a input value to a number for persistence.
				 * If the conversion fails, return original string.
				 */
				function toNumber (val) {
				  var n = parseFloat(val, 10);
				  return (n || n === 0) ? n : val
				}

				/**
				 * Make a map and return a function for checking if a key
				 * is in that map.
				 */
				function makeMap (
				  str,
				  expectsLowerCase
				) {
				  var map = Object.create(null);
				  var list = str.split(',');
				  for (var i = 0; i < list.length; i++) {
				    map[list[i]] = true;
				  }
				  return expectsLowerCase
				    ? function (val) { return map[val.toLowerCase()]; }
				    : function (val) { return map[val]; }
				}

				/**
				 * Check if a tag is a built-in tag.
				 */
				var isBuiltInTag = makeMap('slot,component', true);

				/**
				 * Remove an item from an array
				 */
				function remove$1 (arr, item) {
				  if (arr.length) {
				    var index = arr.indexOf(item);
				    if (index > -1) {
				      return arr.splice(index, 1)
				    }
				  }
				}

				/**
				 * Check whether the object has the property.
				 */
				var hasOwnProperty = Object.prototype.hasOwnProperty;
				function hasOwn (obj, key) {
				  return hasOwnProperty.call(obj, key)
				}

				/**
				 * Check if value is primitive
				 */
				function isPrimitive (value) {
				  return typeof value === 'string' || typeof value === 'number'
				}

				/**
				 * Create a cached version of a pure function.
				 */
				function cached (fn) {
				  var cache = Object.create(null);
				  return function cachedFn (str) {
				    var hit = cache[str];
				    return hit || (cache[str] = fn(str))
				  }
				}

				/**
				 * Camelize a hyphen-delmited string.
				 */
				var camelizeRE = /-(\w)/g;
				var camelize = cached(function (str) {
				  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })
				});

				/**
				 * Capitalize a string.
				 */
				var capitalize = cached(function (str) {
				  return str.charAt(0).toUpperCase() + str.slice(1)
				});

				/**
				 * Hyphenate a camelCase string.
				 */
				var hyphenateRE = /([^-])([A-Z])/g;
				var hyphenate = cached(function (str) {
				  return str
				    .replace(hyphenateRE, '$1-$2')
				    .replace(hyphenateRE, '$1-$2')
				    .toLowerCase()
				});

				/**
				 * Simple bind, faster than native
				 */
				function bind$1 (fn, ctx) {
				  function boundFn (a) {
				    var l = arguments.length;
				    return l
				      ? l > 1
				        ? fn.apply(ctx, arguments)
				        : fn.call(ctx, a)
				      : fn.call(ctx)
				  }
				  // record original fn length
				  boundFn._length = fn.length;
				  return boundFn
				}

				/**
				 * Convert an Array-like object to a real Array.
				 */
				function toArray (list, start) {
				  start = start || 0;
				  var i = list.length - start;
				  var ret = new Array(i);
				  while (i--) {
				    ret[i] = list[i + start];
				  }
				  return ret
				}

				/**
				 * Mix properties into target object.
				 */
				function extend (to, _from) {
				  for (var key in _from) {
				    to[key] = _from[key];
				  }
				  return to
				}

				/**
				 * Quick object check - this is primarily used to tell
				 * Objects from primitive values when we know the value
				 * is a JSON-compliant type.
				 */
				function isObject (obj) {
				  return obj !== null && typeof obj === 'object'
				}

				/**
				 * Strict object type check. Only returns true
				 * for plain JavaScript objects.
				 */
				var toString = Object.prototype.toString;
				var OBJECT_STRING = '[object Object]';
				function isPlainObject (obj) {
				  return toString.call(obj) === OBJECT_STRING
				}

				/**
				 * Merge an Array of Objects into a single Object.
				 */
				function toObject (arr) {
				  var res = {};
				  for (var i = 0; i < arr.length; i++) {
				    if (arr[i]) {
				      extend(res, arr[i]);
				    }
				  }
				  return res
				}

				/**
				 * Perform no operation.
				 */
				function noop () {}

				/**
				 * Always return false.
				 */
				var no = function () { return false; };

				/**
				 * Generate a static keys string from compiler modules.
				 */
				function genStaticKeys (modules) {
				  return modules.reduce(function (keys, m) {
				    return keys.concat(m.staticKeys || [])
				  }, []).join(',')
				}

				/**
				 * Check if two values are loosely equal - that is,
				 * if they are plain objects, do they have the same shape?
				 */
				function looseEqual (a, b) {
				  /* eslint-disable eqeqeq */
				  return a == b || (
				    isObject(a) && isObject(b)
				      ? JSON.stringify(a) === JSON.stringify(b)
				      : false
				  )
				  /* eslint-enable eqeqeq */
				}

				function looseIndexOf (arr, val) {
				  for (var i = 0; i < arr.length; i++) {
				    if (looseEqual(arr[i], val)) { return i }
				  }
				  return -1
				}

				/*  */

				var config = {
				  /**
				   * Option merge strategies (used in core/util/options)
				   */
				  optionMergeStrategies: Object.create(null),

				  /**
				   * Whether to suppress warnings.
				   */
				  silent: false,

				  /**
				   * Whether to enable devtools
				   */
				  devtools: "development" !== 'production',

				  /**
				   * Error handler for watcher errors
				   */
				  errorHandler: null,

				  /**
				   * Ignore certain custom elements
				   */
				  ignoredElements: null,

				  /**
				   * Custom user key aliases for v-on
				   */
				  keyCodes: Object.create(null),

				  /**
				   * Check if a tag is reserved so that it cannot be registered as a
				   * component. This is platform-dependent and may be overwritten.
				   */
				  isReservedTag: no,

				  /**
				   * Check if a tag is an unknown element.
				   * Platform-dependent.
				   */
				  isUnknownElement: no,

				  /**
				   * Get the namespace of an element
				   */
				  getTagNamespace: noop,

				  /**
				   * Check if an attribute must be bound using property, e.g. value
				   * Platform-dependent.
				   */
				  mustUseProp: no,

				  /**
				   * List of asset types that a component can own.
				   */
				  _assetTypes: [
				    'component',
				    'directive',
				    'filter'
				  ],

				  /**
				   * List of lifecycle hooks.
				   */
				  _lifecycleHooks: [
				    'beforeCreate',
				    'created',
				    'beforeMount',
				    'mounted',
				    'beforeUpdate',
				    'updated',
				    'beforeDestroy',
				    'destroyed',
				    'activated',
				    'deactivated'
				  ],

				  /**
				   * Max circular updates allowed in a scheduler flush cycle.
				   */
				  _maxUpdateCount: 100,

				  /**
				   * Server rendering?
				   */
				  _isServer: "client" === 'server'
				};

				/*  */

				/**
				 * Check if a string starts with $ or _
				 */
				function isReserved (str) {
				  var c = (str + '').charCodeAt(0);
				  return c === 0x24 || c === 0x5F
				}

				/**
				 * Define a property.
				 */
				function def (obj, key, val, enumerable) {
				  Object.defineProperty(obj, key, {
				    value: val,
				    enumerable: !!enumerable,
				    writable: true,
				    configurable: true
				  });
				}

				/**
				 * Parse simple path.
				 */
				var bailRE = /[^\w.$]/;
				function parsePath (path) {
				  if (bailRE.test(path)) {
				    return
				  } else {
				    var segments = path.split('.');
				    return function (obj) {
				      for (var i = 0; i < segments.length; i++) {
				        if (!obj) { return }
				        obj = obj[segments[i]];
				      }
				      return obj
				    }
				  }
				}

				/*  */
				/* globals MutationObserver */

				// can we use __proto__?
				var hasProto = '__proto__' in {};

				// Browser environment sniffing
				var inBrowser =
				  typeof window !== 'undefined' &&
				  Object.prototype.toString.call(window) !== '[object Object]';

				var UA = inBrowser && window.navigator.userAgent.toLowerCase();
				var isIE = UA && /msie|trident/.test(UA);
				var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
				var isEdge = UA && UA.indexOf('edge/') > 0;
				var isAndroid = UA && UA.indexOf('android') > 0;
				var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);

				// detect devtools
				var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

				/* istanbul ignore next */
				function isNative (Ctor) {
				  return /native code/.test(Ctor.toString())
				}

				/**
				 * Defer a task to execute it asynchronously.
				 */
				var nextTick = (function () {
				  var callbacks = [];
				  var pending = false;
				  var timerFunc;

				  function nextTickHandler () {
				    pending = false;
				    var copies = callbacks.slice(0);
				    callbacks.length = 0;
				    for (var i = 0; i < copies.length; i++) {
				      copies[i]();
				    }
				  }

				  // the nextTick behavior leverages the microtask queue, which can be accessed
				  // via either native Promise.then or MutationObserver.
				  // MutationObserver has wider support, however it is seriously bugged in
				  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
				  // completely stops working after triggering a few times... so, if native
				  // Promise is available, we will use it:
				  /* istanbul ignore if */
				  if (typeof Promise !== 'undefined' && isNative(Promise)) {
				    var p = Promise.resolve();
				    timerFunc = function () {
				      p.then(nextTickHandler);
				      // in problematic UIWebViews, Promise.then doesn't completely break, but
				      // it can get stuck in a weird state where callbacks are pushed into the
				      // microtask queue but the queue isn't being flushed, until the browser
				      // needs to do some other work, e.g. handle a timer. Therefore we can
				      // "force" the microtask queue to be flushed by adding an empty timer.
				      if (isIOS) { setTimeout(noop); }
				    };
				  } else if (typeof MutationObserver !== 'undefined' && (
				    isNative(MutationObserver) ||
				    // PhantomJS and iOS 7.x
				    MutationObserver.toString() === '[object MutationObserverConstructor]'
				  )) {
				    // use MutationObserver where native Promise is not available,
				    // e.g. PhantomJS IE11, iOS7, Android 4.4
				    var counter = 1;
				    var observer = new MutationObserver(nextTickHandler);
				    var textNode = document.createTextNode(String(counter));
				    observer.observe(textNode, {
				      characterData: true
				    });
				    timerFunc = function () {
				      counter = (counter + 1) % 2;
				      textNode.data = String(counter);
				    };
				  } else {
				    // fallback to setTimeout
				    /* istanbul ignore next */
				    timerFunc = function () {
				      setTimeout(nextTickHandler, 0);
				    };
				  }

				  return function queueNextTick (cb, ctx) {
				    var func = ctx
				      ? function () { cb.call(ctx); }
				      : cb;
				    callbacks.push(func);
				    if (!pending) {
				      pending = true;
				      timerFunc();
				    }
				  }
				})();

				var _Set;
				/* istanbul ignore if */
				if (typeof Set !== 'undefined' && isNative(Set)) {
				  // use native Set when available.
				  _Set = Set;
				} else {
				  // a non-standard Set polyfill that only works with primitive keys.
				  _Set = (function () {
				    function Set () {
				      this.set = Object.create(null);
				    }
				    Set.prototype.has = function has (key) {
				      return this.set[key] !== undefined
				    };
				    Set.prototype.add = function add (key) {
				      this.set[key] = 1;
				    };
				    Set.prototype.clear = function clear () {
				      this.set = Object.create(null);
				    };

				    return Set;
				  }());
				}

				/* not type checking this file because flow doesn't play well with Proxy */

				var hasProxy;
				var proxyHandlers;
				var initProxy;

				{
				  var allowedGlobals = makeMap(
				    'Infinity,undefined,NaN,isFinite,isNaN,' +
				    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +
				    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +
				    'require' // for Webpack/Browserify
				  );

				  hasProxy =
				    typeof Proxy !== 'undefined' &&
				    Proxy.toString().match(/native code/);

				  proxyHandlers = {
				    has: function has (target, key) {
				      var has = key in target;
				      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';
				      if (!has && !isAllowed) {
				        warn(
				          "Property or method \"" + key + "\" is not defined on the instance but " +
				          "referenced during render. Make sure to declare reactive data " +
				          "properties in the data option.",
				          target
				        );
				      }
				      return has || !isAllowed
				    }
				  };

				  initProxy = function initProxy (vm) {
				    if (hasProxy) {
				      vm._renderProxy = new Proxy(vm, proxyHandlers);
				    } else {
				      vm._renderProxy = vm;
				    }
				  };
				}

				/*  */


				var uid$2 = 0;

				/**
				 * A dep is an observable that can have multiple
				 * directives subscribing to it.
				 */
				var Dep = function Dep () {
				  this.id = uid$2++;
				  this.subs = [];
				};

				Dep.prototype.addSub = function addSub (sub) {
				  this.subs.push(sub);
				};

				Dep.prototype.removeSub = function removeSub (sub) {
				  remove$1(this.subs, sub);
				};

				Dep.prototype.depend = function depend () {
				  if (Dep.target) {
				    Dep.target.addDep(this);
				  }
				};

				Dep.prototype.notify = function notify () {
				  // stablize the subscriber list first
				  var subs = this.subs.slice();
				  for (var i = 0, l = subs.length; i < l; i++) {
				    subs[i].update();
				  }
				};

				// the current target watcher being evaluated.
				// this is globally unique because there could be only one
				// watcher being evaluated at any time.
				Dep.target = null;
				var targetStack = [];

				function pushTarget (_target) {
				  if (Dep.target) { targetStack.push(Dep.target); }
				  Dep.target = _target;
				}

				function popTarget () {
				  Dep.target = targetStack.pop();
				}

				/*  */


				var queue = [];
				var has$1 = {};
				var circular = {};
				var waiting = false;
				var flushing = false;
				var index = 0;

				/**
				 * Reset the scheduler's state.
				 */
				function resetSchedulerState () {
				  queue.length = 0;
				  has$1 = {};
				  {
				    circular = {};
				  }
				  waiting = flushing = false;
				}

				/**
				 * Flush both queues and run the watchers.
				 */
				function flushSchedulerQueue () {
				  flushing = true;

				  // Sort queue before flush.
				  // This ensures that:
				  // 1. Components are updated from parent to child. (because parent is always
				  //    created before the child)
				  // 2. A component's user watchers are run before its render watcher (because
				  //    user watchers are created before the render watcher)
				  // 3. If a component is destroyed during a parent component's watcher run,
				  //    its watchers can be skipped.
				  queue.sort(function (a, b) { return a.id - b.id; });

				  // do not cache length because more watchers might be pushed
				  // as we run existing watchers
				  for (index = 0; index < queue.length; index++) {
				    var watcher = queue[index];
				    var id = watcher.id;
				    has$1[id] = null;
				    watcher.run();
				    // in dev build, check and stop circular updates.
				    if ("development" !== 'production' && has$1[id] != null) {
				      circular[id] = (circular[id] || 0) + 1;
				      if (circular[id] > config._maxUpdateCount) {
				        warn(
				          'You may have an infinite update loop ' + (
				            watcher.user
				              ? ("in watcher with expression \"" + (watcher.expression) + "\"")
				              : "in a component render function."
				          ),
				          watcher.vm
				        );
				        break
				      }
				    }
				  }

				  // devtool hook
				  /* istanbul ignore if */
				  if (devtools && config.devtools) {
				    devtools.emit('flush');
				  }

				  resetSchedulerState();
				}

				/**
				 * Push a watcher into the watcher queue.
				 * Jobs with duplicate IDs will be skipped unless it's
				 * pushed when the queue is being flushed.
				 */
				function queueWatcher (watcher) {
				  var id = watcher.id;
				  if (has$1[id] == null) {
				    has$1[id] = true;
				    if (!flushing) {
				      queue.push(watcher);
				    } else {
				      // if already flushing, splice the watcher based on its id
				      // if already past its id, it will be run next immediately.
				      var i = queue.length - 1;
				      while (i >= 0 && queue[i].id > watcher.id) {
				        i--;
				      }
				      queue.splice(Math.max(i, index) + 1, 0, watcher);
				    }
				    // queue the flush
				    if (!waiting) {
				      waiting = true;
				      nextTick(flushSchedulerQueue);
				    }
				  }
				}

				/*  */

				var uid$1 = 0;

				/**
				 * A watcher parses an expression, collects dependencies,
				 * and fires callback when the expression value changes.
				 * This is used for both the $watch() api and directives.
				 */
				var Watcher = function Watcher (
				  vm,
				  expOrFn,
				  cb,
				  options
				) {
				  if ( options === void 0 ) options = {};

				  this.vm = vm;
				  vm._watchers.push(this);
				  // options
				  this.deep = !!options.deep;
				  this.user = !!options.user;
				  this.lazy = !!options.lazy;
				  this.sync = !!options.sync;
				  this.expression = expOrFn.toString();
				  this.cb = cb;
				  this.id = ++uid$1; // uid for batching
				  this.active = true;
				  this.dirty = this.lazy; // for lazy watchers
				  this.deps = [];
				  this.newDeps = [];
				  this.depIds = new _Set();
				  this.newDepIds = new _Set();
				  // parse expression for getter
				  if (typeof expOrFn === 'function') {
				    this.getter = expOrFn;
				  } else {
				    this.getter = parsePath(expOrFn);
				    if (!this.getter) {
				      this.getter = function () {};
				      "development" !== 'production' && warn(
				        "Failed watching path: \"" + expOrFn + "\" " +
				        'Watcher only accepts simple dot-delimited paths. ' +
				        'For full control, use a function instead.',
				        vm
				      );
				    }
				  }
				  this.value = this.lazy
				    ? undefined
				    : this.get();
				};

				/**
				 * Evaluate the getter, and re-collect dependencies.
				 */
				Watcher.prototype.get = function get () {
				  pushTarget(this);
				  var value = this.getter.call(this.vm, this.vm);
				  // "touch" every property so they are all tracked as
				  // dependencies for deep watching
				  if (this.deep) {
				    traverse(value);
				  }
				  popTarget();
				  this.cleanupDeps();
				  return value
				};

				/**
				 * Add a dependency to this directive.
				 */
				Watcher.prototype.addDep = function addDep (dep) {
				  var id = dep.id;
				  if (!this.newDepIds.has(id)) {
				    this.newDepIds.add(id);
				    this.newDeps.push(dep);
				    if (!this.depIds.has(id)) {
				      dep.addSub(this);
				    }
				  }
				};

				/**
				 * Clean up for dependency collection.
				 */
				Watcher.prototype.cleanupDeps = function cleanupDeps () {
				    var this$1 = this;

				  var i = this.deps.length;
				  while (i--) {
				    var dep = this$1.deps[i];
				    if (!this$1.newDepIds.has(dep.id)) {
				      dep.removeSub(this$1);
				    }
				  }
				  var tmp = this.depIds;
				  this.depIds = this.newDepIds;
				  this.newDepIds = tmp;
				  this.newDepIds.clear();
				  tmp = this.deps;
				  this.deps = this.newDeps;
				  this.newDeps = tmp;
				  this.newDeps.length = 0;
				};

				/**
				 * Subscriber interface.
				 * Will be called when a dependency changes.
				 */
				Watcher.prototype.update = function update () {
				  /* istanbul ignore else */
				  if (this.lazy) {
				    this.dirty = true;
				  } else if (this.sync) {
				    this.run();
				  } else {
				    queueWatcher(this);
				  }
				};

				/**
				 * Scheduler job interface.
				 * Will be called by the scheduler.
				 */
				Watcher.prototype.run = function run () {
				  if (this.active) {
				    var value = this.get();
				      if (
				        value !== this.value ||
				      // Deep watchers and watchers on Object/Arrays should fire even
				      // when the value is the same, because the value may
				      // have mutated.
				      isObject(value) ||
				      this.deep
				    ) {
				      // set new value
				      var oldValue = this.value;
				      this.value = value;
				      if (this.user) {
				        try {
				          this.cb.call(this.vm, value, oldValue);
				        } catch (e) {
				          "development" !== 'production' && warn(
				            ("Error in watcher \"" + (this.expression) + "\""),
				            this.vm
				          );
				          /* istanbul ignore else */
				          if (config.errorHandler) {
				            config.errorHandler.call(null, e, this.vm);
				          } else {
				            throw e
				          }
				        }
				      } else {
				        this.cb.call(this.vm, value, oldValue);
				      }
				    }
				  }
				};

				/**
				 * Evaluate the value of the watcher.
				 * This only gets called for lazy watchers.
				 */
				Watcher.prototype.evaluate = function evaluate () {
				  this.value = this.get();
				  this.dirty = false;
				};

				/**
				 * Depend on all deps collected by this watcher.
				 */
				Watcher.prototype.depend = function depend () {
				    var this$1 = this;

				  var i = this.deps.length;
				  while (i--) {
				    this$1.deps[i].depend();
				  }
				};

				/**
				 * Remove self from all dependencies' subscriber list.
				 */
				Watcher.prototype.teardown = function teardown () {
				    var this$1 = this;

				  if (this.active) {
				    // remove self from vm's watcher list
				    // this is a somewhat expensive operation so we skip it
				    // if the vm is being destroyed or is performing a v-for
				    // re-render (the watcher list is then filtered by v-for).
				    if (!this.vm._isBeingDestroyed && !this.vm._vForRemoving) {
				      remove$1(this.vm._watchers, this);
				    }
				    var i = this.deps.length;
				    while (i--) {
				      this$1.deps[i].removeSub(this$1);
				    }
				    this.active = false;
				  }
				};

				/**
				 * Recursively traverse an object to evoke all converted
				 * getters, so that every nested property inside the object
				 * is collected as a "deep" dependency.
				 */
				var seenObjects = new _Set();
				function traverse (val) {
				  seenObjects.clear();
				  _traverse(val, seenObjects);
				}

				function _traverse (val, seen) {
				  var i, keys;
				  var isA = Array.isArray(val);
				  if ((!isA && !isObject(val)) || !Object.isExtensible(val)) {
				    return
				  }
				  if (val.__ob__) {
				    var depId = val.__ob__.dep.id;
				    if (seen.has(depId)) {
				      return
				    }
				    seen.add(depId);
				  }
				  if (isA) {
				    i = val.length;
				    while (i--) { _traverse(val[i], seen); }
				  } else {
				    keys = Object.keys(val);
				    i = keys.length;
				    while (i--) { _traverse(val[keys[i]], seen); }
				  }
				}

				/*
				 * not type checking this file because flow doesn't play well with
				 * dynamically accessing methods on Array prototype
				 */

				var arrayProto = Array.prototype;
				var arrayMethods = Object.create(arrayProto);[
				  'push',
				  'pop',
				  'shift',
				  'unshift',
				  'splice',
				  'sort',
				  'reverse'
				]
				.forEach(function (method) {
				  // cache original method
				  var original = arrayProto[method];
				  def(arrayMethods, method, function mutator () {
				    var arguments$1 = arguments;

				    // avoid leaking arguments:
				    // http://jsperf.com/closure-with-arguments
				    var i = arguments.length;
				    var args = new Array(i);
				    while (i--) {
				      args[i] = arguments$1[i];
				    }
				    var result = original.apply(this, args);
				    var ob = this.__ob__;
				    var inserted;
				    switch (method) {
				      case 'push':
				        inserted = args;
				        break
				      case 'unshift':
				        inserted = args;
				        break
				      case 'splice':
				        inserted = args.slice(2);
				        break
				    }
				    if (inserted) { ob.observeArray(inserted); }
				    // notify change
				    ob.dep.notify();
				    return result
				  });
				});

				/*  */

				var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

				/**
				 * By default, when a reactive property is set, the new value is
				 * also converted to become reactive. However when passing down props,
				 * we don't want to force conversion because the value may be a nested value
				 * under a frozen data structure. Converting it would defeat the optimization.
				 */
				var observerState = {
				  shouldConvert: true,
				  isSettingProps: false
				};

				/**
				 * Observer class that are attached to each observed
				 * object. Once attached, the observer converts target
				 * object's property keys into getter/setters that
				 * collect dependencies and dispatches updates.
				 */
				var Observer = function Observer (value) {
				  this.value = value;
				  this.dep = new Dep();
				  this.vmCount = 0;
				  def(value, '__ob__', this);
				  if (Array.isArray(value)) {
				    var augment = hasProto
				      ? protoAugment
				      : copyAugment;
				    augment(value, arrayMethods, arrayKeys);
				    this.observeArray(value);
				  } else {
				    this.walk(value);
				  }
				};

				/**
				 * Walk through each property and convert them into
				 * getter/setters. This method should only be called when
				 * value type is Object.
				 */
				Observer.prototype.walk = function walk (obj) {
				  var keys = Object.keys(obj);
				  for (var i = 0; i < keys.length; i++) {
				    defineReactive$$1(obj, keys[i], obj[keys[i]]);
				  }
				};

				/**
				 * Observe a list of Array items.
				 */
				Observer.prototype.observeArray = function observeArray (items) {
				  for (var i = 0, l = items.length; i < l; i++) {
				    observe(items[i]);
				  }
				};

				// helpers

				/**
				 * Augment an target Object or Array by intercepting
				 * the prototype chain using __proto__
				 */
				function protoAugment (target, src) {
				  /* eslint-disable no-proto */
				  target.__proto__ = src;
				  /* eslint-enable no-proto */
				}

				/**
				 * Augment an target Object or Array by defining
				 * hidden properties.
				 *
				 * istanbul ignore next
				 */
				function copyAugment (target, src, keys) {
				  for (var i = 0, l = keys.length; i < l; i++) {
				    var key = keys[i];
				    def(target, key, src[key]);
				  }
				}

				/**
				 * Attempt to create an observer instance for a value,
				 * returns the new observer if successfully observed,
				 * or the existing observer if the value already has one.
				 */
				function observe (value) {
				  if (!isObject(value)) {
				    return
				  }
				  var ob;
				  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
				    ob = value.__ob__;
				  } else if (
				    observerState.shouldConvert &&
				    !config._isServer &&
				    (Array.isArray(value) || isPlainObject(value)) &&
				    Object.isExtensible(value) &&
				    !value._isVue
				  ) {
				    ob = new Observer(value);
				  }
				  return ob
				}

				/**
				 * Define a reactive property on an Object.
				 */
				function defineReactive$$1 (
				  obj,
				  key,
				  val,
				  customSetter
				) {
				  var dep = new Dep();

				  var property = Object.getOwnPropertyDescriptor(obj, key);
				  if (property && property.configurable === false) {
				    return
				  }

				  // cater for pre-defined getter/setters
				  var getter = property && property.get;
				  var setter = property && property.set;

				  var childOb = observe(val);
				  Object.defineProperty(obj, key, {
				    enumerable: true,
				    configurable: true,
				    get: function reactiveGetter () {
				      var value = getter ? getter.call(obj) : val;
				      if (Dep.target) {
				        dep.depend();
				        if (childOb) {
				          childOb.dep.depend();
				        }
				        if (Array.isArray(value)) {
				          dependArray(value);
				        }
				      }
				      return value
				    },
				    set: function reactiveSetter (newVal) {
				      var value = getter ? getter.call(obj) : val;
				      if (newVal === value) {
				        return
				      }
				      if ("development" !== 'production' && customSetter) {
				        customSetter();
				      }
				      if (setter) {
				        setter.call(obj, newVal);
				      } else {
				        val = newVal;
				      }
				      childOb = observe(newVal);
				      dep.notify();
				    }
				  });
				}

				/**
				 * Set a property on an object. Adds the new property and
				 * triggers change notification if the property doesn't
				 * already exist.
				 */
				function set (obj, key, val) {
				  if (Array.isArray(obj)) {
				    obj.length = Math.max(obj.length, key);
				    obj.splice(key, 1, val);
				    return val
				  }
				  if (hasOwn(obj, key)) {
				    obj[key] = val;
				    return
				  }
				  var ob = obj.__ob__;
				  if (obj._isVue || (ob && ob.vmCount)) {
				    "development" !== 'production' && warn(
				      'Avoid adding reactive properties to a Vue instance or its root $data ' +
				      'at runtime - declare it upfront in the data option.'
				    );
				    return
				  }
				  if (!ob) {
				    obj[key] = val;
				    return
				  }
				  defineReactive$$1(ob.value, key, val);
				  ob.dep.notify();
				  return val
				}

				/**
				 * Delete a property and trigger change if necessary.
				 */
				function del (obj, key) {
				  var ob = obj.__ob__;
				  if (obj._isVue || (ob && ob.vmCount)) {
				    "development" !== 'production' && warn(
				      'Avoid deleting properties on a Vue instance or its root $data ' +
				      '- just set it to null.'
				    );
				    return
				  }
				  if (!hasOwn(obj, key)) {
				    return
				  }
				  delete obj[key];
				  if (!ob) {
				    return
				  }
				  ob.dep.notify();
				}

				/**
				 * Collect dependencies on array elements when the array is touched, since
				 * we cannot intercept array element access like property getters.
				 */
				function dependArray (value) {
				  for (var e = void 0, i = 0, l = value.length; i < l; i++) {
				    e = value[i];
				    e && e.__ob__ && e.__ob__.dep.depend();
				    if (Array.isArray(e)) {
				      dependArray(e);
				    }
				  }
				}

				/*  */

				function initState (vm) {
				  vm._watchers = [];
				  initProps(vm);
				  initData(vm);
				  initComputed(vm);
				  initMethods(vm);
				  initWatch(vm);
				}

				function initProps (vm) {
				  var props = vm.$options.props;
				  if (props) {
				    var propsData = vm.$options.propsData || {};
				    var keys = vm.$options._propKeys = Object.keys(props);
				    var isRoot = !vm.$parent;
				    // root instance props should be converted
				    observerState.shouldConvert = isRoot;
				    var loop = function ( i ) {
				      var key = keys[i];
				      /* istanbul ignore else */
				      {
				        defineReactive$$1(vm, key, validateProp(key, props, propsData, vm), function () {
				          if (vm.$parent && !observerState.isSettingProps) {
				            warn(
				              "Avoid mutating a prop directly since the value will be " +
				              "overwritten whenever the parent component re-renders. " +
				              "Instead, use a data or computed property based on the prop's " +
				              "value. Prop being mutated: \"" + key + "\"",
				              vm
				            );
				          }
				        });
				      }
				    };

				    for (var i = 0; i < keys.length; i++) loop( i );
				    observerState.shouldConvert = true;
				  }
				}

				function initData (vm) {
				  var data = vm.$options.data;
				  data = vm._data = typeof data === 'function'
				    ? data.call(vm)
				    : data || {};
				  if (!isPlainObject(data)) {
				    data = {};
				    "development" !== 'production' && warn(
				      'data functions should return an object.',
				      vm
				    );
				  }
				  // proxy data on instance
				  var keys = Object.keys(data);
				  var props = vm.$options.props;
				  var i = keys.length;
				  while (i--) {
				    if (props && hasOwn(props, keys[i])) {
				      "development" !== 'production' && warn(
				        "The data property \"" + (keys[i]) + "\" is already declared as a prop. " +
				        "Use prop default value instead.",
				        vm
				      );
				    } else {
				      proxy(vm, keys[i]);
				    }
				  }
				  // observe data
				  observe(data);
				  data.__ob__ && data.__ob__.vmCount++;
				}

				var computedSharedDefinition = {
				  enumerable: true,
				  configurable: true,
				  get: noop,
				  set: noop
				};

				function initComputed (vm) {
				  var computed = vm.$options.computed;
				  if (computed) {
				    for (var key in computed) {
				      var userDef = computed[key];
				      if (typeof userDef === 'function') {
				        computedSharedDefinition.get = makeComputedGetter(userDef, vm);
				        computedSharedDefinition.set = noop;
				      } else {
				        computedSharedDefinition.get = userDef.get
				          ? userDef.cache !== false
				            ? makeComputedGetter(userDef.get, vm)
				            : bind$1(userDef.get, vm)
				          : noop;
				        computedSharedDefinition.set = userDef.set
				          ? bind$1(userDef.set, vm)
				          : noop;
				      }
				      Object.defineProperty(vm, key, computedSharedDefinition);
				    }
				  }
				}

				function makeComputedGetter (getter, owner) {
				  var watcher = new Watcher(owner, getter, noop, {
				    lazy: true
				  });
				  return function computedGetter () {
				    if (watcher.dirty) {
				      watcher.evaluate();
				    }
				    if (Dep.target) {
				      watcher.depend();
				    }
				    return watcher.value
				  }
				}

				function initMethods (vm) {
				  var methods = vm.$options.methods;
				  if (methods) {
				    for (var key in methods) {
				      vm[key] = methods[key] == null ? noop : bind$1(methods[key], vm);
				      {
				        methods[key] == null && warn(
				          "method \"" + key + "\" has an undefined value in the component definition. " +
				          "Did you reference the function correctly?",
				          vm
				        );
				        hasOwn(Vue$2.prototype, key) && warn(
				          ("Avoid overriding Vue's internal method \"" + key + "\"."),
				          vm
				        );
				      }
				    }
				  }
				}

				function initWatch (vm) {
				  var watch = vm.$options.watch;
				  if (watch) {
				    for (var key in watch) {
				      var handler = watch[key];
				      if (Array.isArray(handler)) {
				        for (var i = 0; i < handler.length; i++) {
				          createWatcher(vm, key, handler[i]);
				        }
				      } else {
				        createWatcher(vm, key, handler);
				      }
				    }
				  }
				}

				function createWatcher (vm, key, handler) {
				  var options;
				  if (isPlainObject(handler)) {
				    options = handler;
				    handler = handler.handler;
				  }
				  if (typeof handler === 'string') {
				    handler = vm[handler];
				  }
				  vm.$watch(key, handler, options);
				}

				function stateMixin (Vue) {
				  // flow somehow has problems with directly declared definition object
				  // when using Object.defineProperty, so we have to procedurally build up
				  // the object here.
				  var dataDef = {};
				  dataDef.get = function () {
				    return this._data
				  };
				  {
				    dataDef.set = function (newData) {
				      warn(
				        'Avoid replacing instance root $data. ' +
				        'Use nested data properties instead.',
				        this
				      );
				    };
				  }
				  Object.defineProperty(Vue.prototype, '$data', dataDef);

				  Vue.prototype.$set = set;
				  Vue.prototype.$delete = del;

				  Vue.prototype.$watch = function (
				    expOrFn,
				    cb,
				    options
				  ) {
				    var vm = this;
				    options = options || {};
				    options.user = true;
				    var watcher = new Watcher(vm, expOrFn, cb, options);
				    if (options.immediate) {
				      cb.call(vm, watcher.value);
				    }
				    return function unwatchFn () {
				      watcher.teardown();
				    }
				  };
				}

				function proxy (vm, key) {
				  if (!isReserved(key)) {
				    Object.defineProperty(vm, key, {
				      configurable: true,
				      enumerable: true,
				      get: function proxyGetter () {
				        return vm._data[key]
				      },
				      set: function proxySetter (val) {
				        vm._data[key] = val;
				      }
				    });
				  }
				}

				/*  */

				var VNode = function VNode (
				  tag,
				  data,
				  children,
				  text,
				  elm,
				  ns,
				  context,
				  componentOptions
				) {
				  this.tag = tag;
				  this.data = data;
				  this.children = children;
				  this.text = text;
				  this.elm = elm;
				  this.ns = ns;
				  this.context = context;
				  this.functionalContext = undefined;
				  this.key = data && data.key;
				  this.componentOptions = componentOptions;
				  this.child = undefined;
				  this.parent = undefined;
				  this.raw = false;
				  this.isStatic = false;
				  this.isRootInsert = true;
				  this.isComment = false;
				  this.isCloned = false;
				  this.isOnce = false;
				};

				var emptyVNode = function () {
				  var node = new VNode();
				  node.text = '';
				  node.isComment = true;
				  return node
				};

				// optimized shallow clone
				// used for static nodes and slot nodes because they may be reused across
				// multiple renders, cloning them avoids errors when DOM manipulations rely
				// on their elm reference.
				function cloneVNode (vnode) {
				  var cloned = new VNode(
				    vnode.tag,
				    vnode.data,
				    vnode.children,
				    vnode.text,
				    vnode.elm,
				    vnode.ns,
				    vnode.context,
				    vnode.componentOptions
				  );
				  cloned.isStatic = vnode.isStatic;
				  cloned.key = vnode.key;
				  cloned.isCloned = true;
				  return cloned
				}

				function cloneVNodes (vnodes) {
				  var res = new Array(vnodes.length);
				  for (var i = 0; i < vnodes.length; i++) {
				    res[i] = cloneVNode(vnodes[i]);
				  }
				  return res
				}

				/*  */

				function mergeVNodeHook (def, hookKey, hook, key) {
				  key = key + hookKey;
				  var injectedHash = def.__injected || (def.__injected = {});
				  if (!injectedHash[key]) {
				    injectedHash[key] = true;
				    var oldHook = def[hookKey];
				    if (oldHook) {
				      def[hookKey] = function () {
				        oldHook.apply(this, arguments);
				        hook.apply(this, arguments);
				      };
				    } else {
				      def[hookKey] = hook;
				    }
				  }
				}

				/*  */

				function updateListeners (
				  on,
				  oldOn,
				  add,
				  remove$$1,
				  vm
				) {
				  var name, cur, old, fn, event, capture;
				  for (name in on) {
				    cur = on[name];
				    old = oldOn[name];
				    if (!cur) {
				      "development" !== 'production' && warn(
				        "Invalid handler for event \"" + name + "\": got " + String(cur),
				        vm
				      );
				    } else if (!old) {
				      capture = name.charAt(0) === '!';
				      event = capture ? name.slice(1) : name;
				      if (Array.isArray(cur)) {
				        add(event, (cur.invoker = arrInvoker(cur)), capture);
				      } else {
				        if (!cur.invoker) {
				          fn = cur;
				          cur = on[name] = {};
				          cur.fn = fn;
				          cur.invoker = fnInvoker(cur);
				        }
				        add(event, cur.invoker, capture);
				      }
				    } else if (cur !== old) {
				      if (Array.isArray(old)) {
				        old.length = cur.length;
				        for (var i = 0; i < old.length; i++) { old[i] = cur[i]; }
				        on[name] = old;
				      } else {
				        old.fn = cur;
				        on[name] = old;
				      }
				    }
				  }
				  for (name in oldOn) {
				    if (!on[name]) {
				      event = name.charAt(0) === '!' ? name.slice(1) : name;
				      remove$$1(event, oldOn[name].invoker);
				    }
				  }
				}

				function arrInvoker (arr) {
				  return function (ev) {
				    var arguments$1 = arguments;

				    var single = arguments.length === 1;
				    for (var i = 0; i < arr.length; i++) {
				      single ? arr[i](ev) : arr[i].apply(null, arguments$1);
				    }
				  }
				}

				function fnInvoker (o) {
				  return function (ev) {
				    var single = arguments.length === 1;
				    single ? o.fn(ev) : o.fn.apply(null, arguments);
				  }
				}

				/*  */

				function normalizeChildren (
				  children,
				  ns,
				  nestedIndex
				) {
				  if (isPrimitive(children)) {
				    return [createTextVNode(children)]
				  }
				  if (Array.isArray(children)) {
				    var res = [];
				    for (var i = 0, l = children.length; i < l; i++) {
				      var c = children[i];
				      var last = res[res.length - 1];
				      //  nested
				      if (Array.isArray(c)) {
				        res.push.apply(res, normalizeChildren(c, ns, ((nestedIndex || '') + "_" + i)));
				      } else if (isPrimitive(c)) {
				        if (last && last.text) {
				          last.text += String(c);
				        } else if (c !== '') {
				          // convert primitive to vnode
				          res.push(createTextVNode(c));
				        }
				      } else if (c instanceof VNode) {
				        if (c.text && last && last.text) {
				          last.text += c.text;
				        } else {
				          // inherit parent namespace
				          if (ns) {
				            applyNS(c, ns);
				          }
				          // default key for nested array children (likely generated by v-for)
				          if (c.tag && c.key == null && nestedIndex != null) {
				            c.key = "__vlist" + nestedIndex + "_" + i + "__";
				          }
				          res.push(c);
				        }
				      }
				    }
				    return res
				  }
				}

				function createTextVNode (val) {
				  return new VNode(undefined, undefined, undefined, String(val))
				}

				function applyNS (vnode, ns) {
				  if (vnode.tag && !vnode.ns) {
				    vnode.ns = ns;
				    if (vnode.children) {
				      for (var i = 0, l = vnode.children.length; i < l; i++) {
				        applyNS(vnode.children[i], ns);
				      }
				    }
				  }
				}

				/*  */

				function getFirstComponentChild (children) {
				  return children && children.filter(function (c) { return c && c.componentOptions; })[0]
				}

				/*  */

				var activeInstance = null;

				function initLifecycle (vm) {
				  var options = vm.$options;

				  // locate first non-abstract parent
				  var parent = options.parent;
				  if (parent && !options.abstract) {
				    while (parent.$options.abstract && parent.$parent) {
				      parent = parent.$parent;
				    }
				    parent.$children.push(vm);
				  }

				  vm.$parent = parent;
				  vm.$root = parent ? parent.$root : vm;

				  vm.$children = [];
				  vm.$refs = {};

				  vm._watcher = null;
				  vm._inactive = false;
				  vm._isMounted = false;
				  vm._isDestroyed = false;
				  vm._isBeingDestroyed = false;
				}

				function lifecycleMixin (Vue) {
				  Vue.prototype._mount = function (
				    el,
				    hydrating
				  ) {
				    var vm = this;
				    vm.$el = el;
				    if (!vm.$options.render) {
				      vm.$options.render = emptyVNode;
				      {
				        /* istanbul ignore if */
				        if (vm.$options.template) {
				          warn(
				            'You are using the runtime-only build of Vue where the template ' +
				            'option is not available. Either pre-compile the templates into ' +
				            'render functions, or use the compiler-included build.',
				            vm
				          );
				        } else {
				          warn(
				            'Failed to mount component: template or render function not defined.',
				            vm
				          );
				        }
				      }
				    }
				    callHook(vm, 'beforeMount');
				    vm._watcher = new Watcher(vm, function () {
				      vm._update(vm._render(), hydrating);
				    }, noop);
				    hydrating = false;
				    // manually mounted instance, call mounted on self
				    // mounted is called for render-created child components in its inserted hook
				    if (vm.$vnode == null) {
				      vm._isMounted = true;
				      callHook(vm, 'mounted');
				    }
				    return vm
				  };

				  Vue.prototype._update = function (vnode, hydrating) {
				    var vm = this;
				    if (vm._isMounted) {
				      callHook(vm, 'beforeUpdate');
				    }
				    var prevEl = vm.$el;
				    var prevActiveInstance = activeInstance;
				    activeInstance = vm;
				    var prevVnode = vm._vnode;
				    vm._vnode = vnode;
				    if (!prevVnode) {
				      // Vue.prototype.__patch__ is injected in entry points
				      // based on the rendering backend used.
				      vm.$el = vm.__patch__(vm.$el, vnode, hydrating);
				    } else {
				      vm.$el = vm.__patch__(prevVnode, vnode);
				    }
				    activeInstance = prevActiveInstance;
				    // update __vue__ reference
				    if (prevEl) {
				      prevEl.__vue__ = null;
				    }
				    if (vm.$el) {
				      vm.$el.__vue__ = vm;
				    }
				    // if parent is an HOC, update its $el as well
				    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
				      vm.$parent.$el = vm.$el;
				    }
				    if (vm._isMounted) {
				      callHook(vm, 'updated');
				    }
				  };

				  Vue.prototype._updateFromParent = function (
				    propsData,
				    listeners,
				    parentVnode,
				    renderChildren
				  ) {
				    var vm = this;
				    var hasChildren = !!(vm.$options._renderChildren || renderChildren);
				    vm.$options._parentVnode = parentVnode;
				    vm.$options._renderChildren = renderChildren;
				    // update props
				    if (propsData && vm.$options.props) {
				      observerState.shouldConvert = false;
				      {
				        observerState.isSettingProps = true;
				      }
				      var propKeys = vm.$options._propKeys || [];
				      for (var i = 0; i < propKeys.length; i++) {
				        var key = propKeys[i];
				        vm[key] = validateProp(key, vm.$options.props, propsData, vm);
				      }
				      observerState.shouldConvert = true;
				      {
				        observerState.isSettingProps = false;
				      }
				      vm.$options.propsData = propsData;
				    }
				    // update listeners
				    if (listeners) {
				      var oldListeners = vm.$options._parentListeners;
				      vm.$options._parentListeners = listeners;
				      vm._updateListeners(listeners, oldListeners);
				    }
				    // resolve slots + force update if has children
				    if (hasChildren) {
				      vm.$slots = resolveSlots(renderChildren, vm._renderContext);
				      vm.$forceUpdate();
				    }
				  };

				  Vue.prototype.$forceUpdate = function () {
				    var vm = this;
				    if (vm._watcher) {
				      vm._watcher.update();
				    }
				  };

				  Vue.prototype.$destroy = function () {
				    var vm = this;
				    if (vm._isBeingDestroyed) {
				      return
				    }
				    callHook(vm, 'beforeDestroy');
				    vm._isBeingDestroyed = true;
				    // remove self from parent
				    var parent = vm.$parent;
				    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
				      remove$1(parent.$children, vm);
				    }
				    // teardown watchers
				    if (vm._watcher) {
				      vm._watcher.teardown();
				    }
				    var i = vm._watchers.length;
				    while (i--) {
				      vm._watchers[i].teardown();
				    }
				    // remove reference from data ob
				    // frozen object may not have observer.
				    if (vm._data.__ob__) {
				      vm._data.__ob__.vmCount--;
				    }
				    // call the last hook...
				    vm._isDestroyed = true;
				    callHook(vm, 'destroyed');
				    // turn off all instance listeners.
				    vm.$off();
				    // remove __vue__ reference
				    if (vm.$el) {
				      vm.$el.__vue__ = null;
				    }
				    // invoke destroy hooks on current rendered tree
				    vm.__patch__(vm._vnode, null);
				  };
				}

				function callHook (vm, hook) {
				  var handlers = vm.$options[hook];
				  if (handlers) {
				    for (var i = 0, j = handlers.length; i < j; i++) {
				      handlers[i].call(vm);
				    }
				  }
				  vm.$emit('hook:' + hook);
				}

				/*  */

				var hooks = { init: init, prepatch: prepatch, insert: insert, destroy: destroy$1 };
				var hooksToMerge = Object.keys(hooks);

				function createComponent (
				  Ctor,
				  data,
				  context,
				  children,
				  tag
				) {
				  if (!Ctor) {
				    return
				  }

				  if (isObject(Ctor)) {
				    Ctor = Vue$2.extend(Ctor);
				  }

				  if (typeof Ctor !== 'function') {
				    {
				      warn(("Invalid Component definition: " + (String(Ctor))), context);
				    }
				    return
				  }

				  // resolve constructor options in case global mixins are applied after
				  // component constructor creation
				  resolveConstructorOptions(Ctor);

				  // async component
				  if (!Ctor.cid) {
				    if (Ctor.resolved) {
				      Ctor = Ctor.resolved;
				    } else {
				      Ctor = resolveAsyncComponent(Ctor, function () {
				        // it's ok to queue this on every render because
				        // $forceUpdate is buffered by the scheduler.
				        context.$forceUpdate();
				      });
				      if (!Ctor) {
				        // return nothing if this is indeed an async component
				        // wait for the callback to trigger parent update.
				        return
				      }
				    }
				  }

				  data = data || {};

				  // extract props
				  var propsData = extractProps(data, Ctor);

				  // functional component
				  if (Ctor.options.functional) {
				    return createFunctionalComponent(Ctor, propsData, data, context, children)
				  }

				  // extract listeners, since these needs to be treated as
				  // child component listeners instead of DOM listeners
				  var listeners = data.on;
				  // replace with listeners with .native modifier
				  data.on = data.nativeOn;

				  if (Ctor.options.abstract) {
				    // abstract components do not keep anything
				    // other than props & listeners
				    data = {};
				  }

				  // merge component management hooks onto the placeholder node
				  mergeHooks(data);

				  // return a placeholder vnode
				  var name = Ctor.options.name || tag;
				  var vnode = new VNode(
				    ("vue-component-" + (Ctor.cid) + (name ? ("-" + name) : '')),
				    data, undefined, undefined, undefined, undefined, context,
				    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }
				  );
				  return vnode
				}

				function createFunctionalComponent (
				  Ctor,
				  propsData,
				  data,
				  context,
				  children
				) {
				  var props = {};
				  var propOptions = Ctor.options.props;
				  if (propOptions) {
				    for (var key in propOptions) {
				      props[key] = validateProp(key, propOptions, propsData);
				    }
				  }
				  var vnode = Ctor.options.render.call(
				    null,
				    // ensure the createElement function in functional components
				    // gets a unique context - this is necessary for correct named slot check
				    bind$1(createElement, { _self: Object.create(context) }),
				    {
				      props: props,
				      data: data,
				      parent: context,
				      children: normalizeChildren(children),
				      slots: function () { return resolveSlots(children, context); }
				    }
				  );
				  if (vnode instanceof VNode) {
				    vnode.functionalContext = context;
				    if (data.slot) {
				      (vnode.data || (vnode.data = {})).slot = data.slot;
				    }
				  }
				  return vnode
				}

				function createComponentInstanceForVnode (
				  vnode, // we know it's MountedComponentVNode but flow doesn't
				  parent // activeInstance in lifecycle state
				) {
				  var vnodeComponentOptions = vnode.componentOptions;
				  var options = {
				    _isComponent: true,
				    parent: parent,
				    propsData: vnodeComponentOptions.propsData,
				    _componentTag: vnodeComponentOptions.tag,
				    _parentVnode: vnode,
				    _parentListeners: vnodeComponentOptions.listeners,
				    _renderChildren: vnodeComponentOptions.children
				  };
				  // check inline-template render functions
				  var inlineTemplate = vnode.data.inlineTemplate;
				  if (inlineTemplate) {
				    options.render = inlineTemplate.render;
				    options.staticRenderFns = inlineTemplate.staticRenderFns;
				  }
				  return new vnodeComponentOptions.Ctor(options)
				}

				function init (vnode, hydrating) {
				  if (!vnode.child || vnode.child._isDestroyed) {
				    var child = vnode.child = createComponentInstanceForVnode(vnode, activeInstance);
				    child.$mount(hydrating ? vnode.elm : undefined, hydrating);
				  }
				}

				function prepatch (
				  oldVnode,
				  vnode
				) {
				  var options = vnode.componentOptions;
				  var child = vnode.child = oldVnode.child;
				  child._updateFromParent(
				    options.propsData, // updated props
				    options.listeners, // updated listeners
				    vnode, // new parent vnode
				    options.children // new children
				  );
				}

				function insert (vnode) {
				  if (!vnode.child._isMounted) {
				    vnode.child._isMounted = true;
				    callHook(vnode.child, 'mounted');
				  }
				  if (vnode.data.keepAlive) {
				    vnode.child._inactive = false;
				    callHook(vnode.child, 'activated');
				  }
				}

				function destroy$1 (vnode) {
				  if (!vnode.child._isDestroyed) {
				    if (!vnode.data.keepAlive) {
				      vnode.child.$destroy();
				    } else {
				      vnode.child._inactive = true;
				      callHook(vnode.child, 'deactivated');
				    }
				  }
				}

				function resolveAsyncComponent (
				  factory,
				  cb
				) {
				  if (factory.requested) {
				    // pool callbacks
				    factory.pendingCallbacks.push(cb);
				  } else {
				    factory.requested = true;
				    var cbs = factory.pendingCallbacks = [cb];
				    var sync = true;

				    var resolve = function (res) {
				      if (isObject(res)) {
				        res = Vue$2.extend(res);
				      }
				      // cache resolved
				      factory.resolved = res;
				      // invoke callbacks only if this is not a synchronous resolve
				      // (async resolves are shimmed as synchronous during SSR)
				      if (!sync) {
				        for (var i = 0, l = cbs.length; i < l; i++) {
				          cbs[i](res);
				        }
				      }
				    };

				    var reject = function (reason) {
				      "development" !== 'production' && warn(
				        "Failed to resolve async component: " + (String(factory)) +
				        (reason ? ("\nReason: " + reason) : '')
				      );
				    };

				    var res = factory(resolve, reject);

				    // handle promise
				    if (res && typeof res.then === 'function' && !factory.resolved) {
				      res.then(resolve, reject);
				    }

				    sync = false;
				    // return in case resolved synchronously
				    return factory.resolved
				  }
				}

				function extractProps (data, Ctor) {
				  // we are only extracting raw values here.
				  // validation and default values are handled in the child
				  // component itself.
				  var propOptions = Ctor.options.props;
				  if (!propOptions) {
				    return
				  }
				  var res = {};
				  var attrs = data.attrs;
				  var props = data.props;
				  var domProps = data.domProps;
				  if (attrs || props || domProps) {
				    for (var key in propOptions) {
				      var altKey = hyphenate(key);
				      checkProp(res, props, key, altKey, true) ||
				      checkProp(res, attrs, key, altKey) ||
				      checkProp(res, domProps, key, altKey);
				    }
				  }
				  return res
				}

				function checkProp (
				  res,
				  hash,
				  key,
				  altKey,
				  preserve
				) {
				  if (hash) {
				    if (hasOwn(hash, key)) {
				      res[key] = hash[key];
				      if (!preserve) {
				        delete hash[key];
				      }
				      return true
				    } else if (hasOwn(hash, altKey)) {
				      res[key] = hash[altKey];
				      if (!preserve) {
				        delete hash[altKey];
				      }
				      return true
				    }
				  }
				  return false
				}

				function mergeHooks (data) {
				  if (!data.hook) {
				    data.hook = {};
				  }
				  for (var i = 0; i < hooksToMerge.length; i++) {
				    var key = hooksToMerge[i];
				    var fromParent = data.hook[key];
				    var ours = hooks[key];
				    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;
				  }
				}

				function mergeHook$1 (a, b) {
				  // since all hooks have at most two args, use fixed args
				  // to avoid having to use fn.apply().
				  return function (_, __) {
				    a(_, __);
				    b(_, __);
				  }
				}

				/*  */

				// wrapper function for providing a more flexible interface
				// without getting yelled at by flow
				function createElement (
				  tag,
				  data,
				  children
				) {
				  if (data && (Array.isArray(data) || typeof data !== 'object')) {
				    children = data;
				    data = undefined;
				  }
				  // make sure to use real instance instead of proxy as context
				  return _createElement(this._self, tag, data, children)
				}

				function _createElement (
				  context,
				  tag,
				  data,
				  children
				) {
				  if (data && data.__ob__) {
				    "development" !== 'production' && warn(
				      "Avoid using observed data object as vnode data: " + (JSON.stringify(data)) + "\n" +
				      'Always create fresh vnode data objects in each render!',
				      context
				    );
				    return
				  }
				  if (!tag) {
				    // in case of component :is set to falsy value
				    return emptyVNode()
				  }
				  if (typeof tag === 'string') {
				    var Ctor;
				    var ns = config.getTagNamespace(tag);
				    if (config.isReservedTag(tag)) {
				      // platform built-in elements
				      return new VNode(
				        tag, data, normalizeChildren(children, ns),
				        undefined, undefined, ns, context
				      )
				    } else if ((Ctor = resolveAsset(context.$options, 'components', tag))) {
				      // component
				      return createComponent(Ctor, data, context, children, tag)
				    } else {
				      // unknown or unlisted namespaced elements
				      // check at runtime because it may get assigned a namespace when its
				      // parent normalizes children
				      var childNs = tag === 'foreignObject' ? 'xhtml' : ns;
				      return new VNode(
				        tag, data, normalizeChildren(children, childNs),
				        undefined, undefined, ns, context
				      )
				    }
				  } else {
				    // direct component options / constructor
				    return createComponent(tag, data, context, children)
				  }
				}

				/*  */

				function initRender (vm) {
				  vm.$vnode = null; // the placeholder node in parent tree
				  vm._vnode = null; // the root of the child tree
				  vm._staticTrees = null;
				  vm._renderContext = vm.$options._parentVnode && vm.$options._parentVnode.context;
				  vm.$slots = resolveSlots(vm.$options._renderChildren, vm._renderContext);
				  // bind the public createElement fn to this instance
				  // so that we get proper render context inside it.
				  vm.$createElement = bind$1(createElement, vm);
				  if (vm.$options.el) {
				    vm.$mount(vm.$options.el);
				  }
				}

				function renderMixin (Vue) {
				  Vue.prototype.$nextTick = function (fn) {
				    nextTick(fn, this);
				  };

				  Vue.prototype._render = function () {
				    var vm = this;
				    var ref = vm.$options;
				    var render = ref.render;
				    var staticRenderFns = ref.staticRenderFns;
				    var _parentVnode = ref._parentVnode;

				    if (vm._isMounted) {
				      // clone slot nodes on re-renders
				      for (var key in vm.$slots) {
				        vm.$slots[key] = cloneVNodes(vm.$slots[key]);
				      }
				    }

				    if (staticRenderFns && !vm._staticTrees) {
				      vm._staticTrees = [];
				    }
				    // set parent vnode. this allows render functions to have access
				    // to the data on the placeholder node.
				    vm.$vnode = _parentVnode;
				    // render self
				    var vnode;
				    try {
				      vnode = render.call(vm._renderProxy, vm.$createElement);
				    } catch (e) {
				      {
				        warn(("Error when rendering " + (formatComponentName(vm)) + ":"));
				      }
				      /* istanbul ignore else */
				      if (config.errorHandler) {
				        config.errorHandler.call(null, e, vm);
				      } else {
				        if (config._isServer) {
				          throw e
				        } else {
				          console.error(e);
				        }
				      }
				      // return previous vnode to prevent render error causing blank component
				      vnode = vm._vnode;
				    }
				    // return empty vnode in case the render function errored out
				    if (!(vnode instanceof VNode)) {
				      if ("development" !== 'production' && Array.isArray(vnode)) {
				        warn(
				          'Multiple root nodes returned from render function. Render function ' +
				          'should return a single root node.',
				          vm
				        );
				      }
				      vnode = emptyVNode();
				    }
				    // set parent
				    vnode.parent = _parentVnode;
				    return vnode
				  };

				  // shorthands used in render functions
				  Vue.prototype._h = createElement;
				  // toString for mustaches
				  Vue.prototype._s = _toString;
				  // number conversion
				  Vue.prototype._n = toNumber;
				  // empty vnode
				  Vue.prototype._e = emptyVNode;
				  // loose equal
				  Vue.prototype._q = looseEqual;
				  // loose indexOf
				  Vue.prototype._i = looseIndexOf;

				  // render static tree by index
				  Vue.prototype._m = function renderStatic (
				    index,
				    isInFor
				  ) {
				    var tree = this._staticTrees[index];
				    // if has already-rendered static tree and not inside v-for,
				    // we can reuse the same tree by doing a shallow clone.
				    if (tree && !isInFor) {
				      return Array.isArray(tree)
				        ? cloneVNodes(tree)
				        : cloneVNode(tree)
				    }
				    // otherwise, render a fresh tree.
				    tree = this._staticTrees[index] = this.$options.staticRenderFns[index].call(this._renderProxy);
				    markStatic(tree, ("__static__" + index), false);
				    return tree
				  };

				  // mark node as static (v-once)
				  Vue.prototype._o = function markOnce (
				    tree,
				    index,
				    key
				  ) {
				    markStatic(tree, ("__once__" + index + (key ? ("_" + key) : "")), true);
				    return tree
				  };

				  function markStatic (tree, key, isOnce) {
				    if (Array.isArray(tree)) {
				      for (var i = 0; i < tree.length; i++) {
				        if (tree[i] && typeof tree[i] !== 'string') {
				          markStaticNode(tree[i], (key + "_" + i), isOnce);
				        }
				      }
				    } else {
				      markStaticNode(tree, key, isOnce);
				    }
				  }

				  function markStaticNode (node, key, isOnce) {
				    node.isStatic = true;
				    node.key = key;
				    node.isOnce = isOnce;
				  }

				  // filter resolution helper
				  var identity = function (_) { return _; };
				  Vue.prototype._f = function resolveFilter (id) {
				    return resolveAsset(this.$options, 'filters', id, true) || identity
				  };

				  // render v-for
				  Vue.prototype._l = function renderList (
				    val,
				    render
				  ) {
				    var ret, i, l, keys, key;
				    if (Array.isArray(val)) {
				      ret = new Array(val.length);
				      for (i = 0, l = val.length; i < l; i++) {
				        ret[i] = render(val[i], i);
				      }
				    } else if (typeof val === 'number') {
				      ret = new Array(val);
				      for (i = 0; i < val; i++) {
				        ret[i] = render(i + 1, i);
				      }
				    } else if (isObject(val)) {
				      keys = Object.keys(val);
				      ret = new Array(keys.length);
				      for (i = 0, l = keys.length; i < l; i++) {
				        key = keys[i];
				        ret[i] = render(val[key], key, i);
				      }
				    }
				    return ret
				  };

				  // renderSlot
				  Vue.prototype._t = function (
				    name,
				    fallback
				  ) {
				    var slotNodes = this.$slots[name];
				    // warn duplicate slot usage
				    if (slotNodes && "development" !== 'production') {
				      slotNodes._rendered && warn(
				        "Duplicate presence of slot \"" + name + "\" found in the same render tree " +
				        "- this will likely cause render errors.",
				        this
				      );
				      slotNodes._rendered = true;
				    }
				    return slotNodes || fallback
				  };

				  // apply v-bind object
				  Vue.prototype._b = function bindProps (
				    data,
				    value,
				    asProp
				  ) {
				    if (value) {
				      if (!isObject(value)) {
				        "development" !== 'production' && warn(
				          'v-bind without argument expects an Object or Array value',
				          this
				        );
				      } else {
				        if (Array.isArray(value)) {
				          value = toObject(value);
				        }
				        for (var key in value) {
				          if (key === 'class' || key === 'style') {
				            data[key] = value[key];
				          } else {
				            var hash = asProp || config.mustUseProp(key)
				              ? data.domProps || (data.domProps = {})
				              : data.attrs || (data.attrs = {});
				            hash[key] = value[key];
				          }
				        }
				      }
				    }
				    return data
				  };

				  // expose v-on keyCodes
				  Vue.prototype._k = function getKeyCodes (key) {
				    return config.keyCodes[key]
				  };
				}

				function resolveSlots (
				  renderChildren,
				  context
				) {
				  var slots = {};
				  if (!renderChildren) {
				    return slots
				  }
				  var children = normalizeChildren(renderChildren) || [];
				  var defaultSlot = [];
				  var name, child;
				  for (var i = 0, l = children.length; i < l; i++) {
				    child = children[i];
				    // named slots should only be respected if the vnode was rendered in the
				    // same context.
				    if ((child.context === context || child.functionalContext === context) &&
				        child.data && (name = child.data.slot)) {
				      var slot = (slots[name] || (slots[name] = []));
				      if (child.tag === 'template') {
				        slot.push.apply(slot, child.children);
				      } else {
				        slot.push(child);
				      }
				    } else {
				      defaultSlot.push(child);
				    }
				  }
				  // ignore single whitespace
				  if (defaultSlot.length && !(
				    defaultSlot.length === 1 &&
				    (defaultSlot[0].text === ' ' || defaultSlot[0].isComment)
				  )) {
				    slots.default = defaultSlot;
				  }
				  return slots
				}

				/*  */

				function initEvents (vm) {
				  vm._events = Object.create(null);
				  // init parent attached events
				  var listeners = vm.$options._parentListeners;
				  var on = bind$1(vm.$on, vm);
				  var off = bind$1(vm.$off, vm);
				  vm._updateListeners = function (listeners, oldListeners) {
				    updateListeners(listeners, oldListeners || {}, on, off, vm);
				  };
				  if (listeners) {
				    vm._updateListeners(listeners);
				  }
				}

				function eventsMixin (Vue) {
				  Vue.prototype.$on = function (event, fn) {
				    var vm = this;(vm._events[event] || (vm._events[event] = [])).push(fn);
				    return vm
				  };

				  Vue.prototype.$once = function (event, fn) {
				    var vm = this;
				    function on () {
				      vm.$off(event, on);
				      fn.apply(vm, arguments);
				    }
				    on.fn = fn;
				    vm.$on(event, on);
				    return vm
				  };

				  Vue.prototype.$off = function (event, fn) {
				    var vm = this;
				    // all
				    if (!arguments.length) {
				      vm._events = Object.create(null);
				      return vm
				    }
				    // specific event
				    var cbs = vm._events[event];
				    if (!cbs) {
				      return vm
				    }
				    if (arguments.length === 1) {
				      vm._events[event] = null;
				      return vm
				    }
				    // specific handler
				    var cb;
				    var i = cbs.length;
				    while (i--) {
				      cb = cbs[i];
				      if (cb === fn || cb.fn === fn) {
				        cbs.splice(i, 1);
				        break
				      }
				    }
				    return vm
				  };

				  Vue.prototype.$emit = function (event) {
				    var vm = this;
				    var cbs = vm._events[event];
				    if (cbs) {
				      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
				      var args = toArray(arguments, 1);
				      for (var i = 0, l = cbs.length; i < l; i++) {
				        cbs[i].apply(vm, args);
				      }
				    }
				    return vm
				  };
				}

				/*  */

				var uid = 0;

				function initMixin (Vue) {
				  Vue.prototype._init = function (options) {
				    var vm = this;
				    // a uid
				    vm._uid = uid++;
				    // a flag to avoid this being observed
				    vm._isVue = true;
				    // merge options
				    if (options && options._isComponent) {
				      // optimize internal component instantiation
				      // since dynamic options merging is pretty slow, and none of the
				      // internal component options needs special treatment.
				      initInternalComponent(vm, options);
				    } else {
				      vm.$options = mergeOptions(
				        resolveConstructorOptions(vm.constructor),
				        options || {},
				        vm
				      );
				    }
				    /* istanbul ignore else */
				    {
				      initProxy(vm);
				    }
				    // expose real self
				    vm._self = vm;
				    initLifecycle(vm);
				    initEvents(vm);
				    callHook(vm, 'beforeCreate');
				    initState(vm);
				    callHook(vm, 'created');
				    initRender(vm);
				  };
				}

				function initInternalComponent (vm, options) {
				  var opts = vm.$options = Object.create(vm.constructor.options);
				  // doing this because it's faster than dynamic enumeration.
				  opts.parent = options.parent;
				  opts.propsData = options.propsData;
				  opts._parentVnode = options._parentVnode;
				  opts._parentListeners = options._parentListeners;
				  opts._renderChildren = options._renderChildren;
				  opts._componentTag = options._componentTag;
				  if (options.render) {
				    opts.render = options.render;
				    opts.staticRenderFns = options.staticRenderFns;
				  }
				}

				function resolveConstructorOptions (Ctor) {
				  var options = Ctor.options;
				  if (Ctor.super) {
				    var superOptions = Ctor.super.options;
				    var cachedSuperOptions = Ctor.superOptions;
				    var extendOptions = Ctor.extendOptions;
				    if (superOptions !== cachedSuperOptions) {
				      // super option changed
				      Ctor.superOptions = superOptions;
				      extendOptions.render = options.render;
				      extendOptions.staticRenderFns = options.staticRenderFns;
				      options = Ctor.options = mergeOptions(superOptions, extendOptions);
				      if (options.name) {
				        options.components[options.name] = Ctor;
				      }
				    }
				  }
				  return options
				}

				function Vue$2 (options) {
				  if ("development" !== 'production' &&
				    !(this instanceof Vue$2)) {
				    warn('Vue is a constructor and should be called with the `new` keyword');
				  }
				  this._init(options);
				}

				initMixin(Vue$2);
				stateMixin(Vue$2);
				eventsMixin(Vue$2);
				lifecycleMixin(Vue$2);
				renderMixin(Vue$2);

				var warn = noop;
				var formatComponentName;

				{
				  var hasConsole = typeof console !== 'undefined';

				  warn = function (msg, vm) {
				    if (hasConsole && (!config.silent)) {
				      console.error("[Vue warn]: " + msg + " " + (
				        vm ? formatLocation(formatComponentName(vm)) : ''
				      ));
				    }
				  };

				  formatComponentName = function (vm) {
				    if (vm.$root === vm) {
				      return 'root instance'
				    }
				    var name = vm._isVue
				      ? vm.$options.name || vm.$options._componentTag
				      : vm.name;
				    return (
				      (name ? ("component <" + name + ">") : "anonymous component") +
				      (vm._isVue && vm.$options.__file ? (" at " + (vm.$options.__file)) : '')
				    )
				  };

				  var formatLocation = function (str) {
				    if (str === 'anonymous component') {
				      str += " - use the \"name\" option for better debugging messages.";
				    }
				    return ("\n(found in " + str + ")")
				  };
				}

				/*  */

				/**
				 * Option overwriting strategies are functions that handle
				 * how to merge a parent option value and a child option
				 * value into the final value.
				 */
				var strats = config.optionMergeStrategies;

				/**
				 * Options with restrictions
				 */
				{
				  strats.el = strats.propsData = function (parent, child, vm, key) {
				    if (!vm) {
				      warn(
				        "option \"" + key + "\" can only be used during instance " +
				        'creation with the `new` keyword.'
				      );
				    }
				    return defaultStrat(parent, child)
				  };
				}

				/**
				 * Helper that recursively merges two data objects together.
				 */
				function mergeData (to, from) {
				  var key, toVal, fromVal;
				  for (key in from) {
				    toVal = to[key];
				    fromVal = from[key];
				    if (!hasOwn(to, key)) {
				      set(to, key, fromVal);
				    } else if (isObject(toVal) && isObject(fromVal)) {
				      mergeData(toVal, fromVal);
				    }
				  }
				  return to
				}

				/**
				 * Data
				 */
				strats.data = function (
				  parentVal,
				  childVal,
				  vm
				) {
				  if (!vm) {
				    // in a Vue.extend merge, both should be functions
				    if (!childVal) {
				      return parentVal
				    }
				    if (typeof childVal !== 'function') {
				      "development" !== 'production' && warn(
				        'The "data" option should be a function ' +
				        'that returns a per-instance value in component ' +
				        'definitions.',
				        vm
				      );
				      return parentVal
				    }
				    if (!parentVal) {
				      return childVal
				    }
				    // when parentVal & childVal are both present,
				    // we need to return a function that returns the
				    // merged result of both functions... no need to
				    // check if parentVal is a function here because
				    // it has to be a function to pass previous merges.
				    return function mergedDataFn () {
				      return mergeData(
				        childVal.call(this),
				        parentVal.call(this)
				      )
				    }
				  } else if (parentVal || childVal) {
				    return function mergedInstanceDataFn () {
				      // instance merge
				      var instanceData = typeof childVal === 'function'
				        ? childVal.call(vm)
				        : childVal;
				      var defaultData = typeof parentVal === 'function'
				        ? parentVal.call(vm)
				        : undefined;
				      if (instanceData) {
				        return mergeData(instanceData, defaultData)
				      } else {
				        return defaultData
				      }
				    }
				  }
				};

				/**
				 * Hooks and param attributes are merged as arrays.
				 */
				function mergeHook (
				  parentVal,
				  childVal
				) {
				  return childVal
				    ? parentVal
				      ? parentVal.concat(childVal)
				      : Array.isArray(childVal)
				        ? childVal
				        : [childVal]
				    : parentVal
				}

				config._lifecycleHooks.forEach(function (hook) {
				  strats[hook] = mergeHook;
				});

				/**
				 * Assets
				 *
				 * When a vm is present (instance creation), we need to do
				 * a three-way merge between constructor options, instance
				 * options and parent options.
				 */
				function mergeAssets (parentVal, childVal) {
				  var res = Object.create(parentVal || null);
				  return childVal
				    ? extend(res, childVal)
				    : res
				}

				config._assetTypes.forEach(function (type) {
				  strats[type + 's'] = mergeAssets;
				});

				/**
				 * Watchers.
				 *
				 * Watchers hashes should not overwrite one
				 * another, so we merge them as arrays.
				 */
				strats.watch = function (parentVal, childVal) {
				  /* istanbul ignore if */
				  if (!childVal) { return parentVal }
				  if (!parentVal) { return childVal }
				  var ret = {};
				  extend(ret, parentVal);
				  for (var key in childVal) {
				    var parent = ret[key];
				    var child = childVal[key];
				    if (parent && !Array.isArray(parent)) {
				      parent = [parent];
				    }
				    ret[key] = parent
				      ? parent.concat(child)
				      : [child];
				  }
				  return ret
				};

				/**
				 * Other object hashes.
				 */
				strats.props =
				strats.methods =
				strats.computed = function (parentVal, childVal) {
				  if (!childVal) { return parentVal }
				  if (!parentVal) { return childVal }
				  var ret = Object.create(null);
				  extend(ret, parentVal);
				  extend(ret, childVal);
				  return ret
				};

				/**
				 * Default strategy.
				 */
				var defaultStrat = function (parentVal, childVal) {
				  return childVal === undefined
				    ? parentVal
				    : childVal
				};

				/**
				 * Validate component names
				 */
				function checkComponents (options) {
				  for (var key in options.components) {
				    var lower = key.toLowerCase();
				    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {
				      warn(
				        'Do not use built-in or reserved HTML elements as component ' +
				        'id: ' + key
				      );
				    }
				  }
				}

				/**
				 * Ensure all props option syntax are normalized into the
				 * Object-based format.
				 */
				function normalizeProps (options) {
				  var props = options.props;
				  if (!props) { return }
				  var res = {};
				  var i, val, name;
				  if (Array.isArray(props)) {
				    i = props.length;
				    while (i--) {
				      val = props[i];
				      if (typeof val === 'string') {
				        name = camelize(val);
				        res[name] = { type: null };
				      } else {
				        warn('props must be strings when using array syntax.');
				      }
				    }
				  } else if (isPlainObject(props)) {
				    for (var key in props) {
				      val = props[key];
				      name = camelize(key);
				      res[name] = isPlainObject(val)
				        ? val
				        : { type: val };
				    }
				  }
				  options.props = res;
				}

				/**
				 * Normalize raw function directives into object format.
				 */
				function normalizeDirectives (options) {
				  var dirs = options.directives;
				  if (dirs) {
				    for (var key in dirs) {
				      var def = dirs[key];
				      if (typeof def === 'function') {
				        dirs[key] = { bind: def, update: def };
				      }
				    }
				  }
				}

				/**
				 * Merge two option objects into a new one.
				 * Core utility used in both instantiation and inheritance.
				 */
				function mergeOptions (
				  parent,
				  child,
				  vm
				) {
				  {
				    checkComponents(child);
				  }
				  normalizeProps(child);
				  normalizeDirectives(child);
				  var extendsFrom = child.extends;
				  if (extendsFrom) {
				    parent = typeof extendsFrom === 'function'
				      ? mergeOptions(parent, extendsFrom.options, vm)
				      : mergeOptions(parent, extendsFrom, vm);
				  }
				  if (child.mixins) {
				    for (var i = 0, l = child.mixins.length; i < l; i++) {
				      var mixin = child.mixins[i];
				      if (mixin.prototype instanceof Vue$2) {
				        mixin = mixin.options;
				      }
				      parent = mergeOptions(parent, mixin, vm);
				    }
				  }
				  var options = {};
				  var key;
				  for (key in parent) {
				    mergeField(key);
				  }
				  for (key in child) {
				    if (!hasOwn(parent, key)) {
				      mergeField(key);
				    }
				  }
				  function mergeField (key) {
				    var strat = strats[key] || defaultStrat;
				    options[key] = strat(parent[key], child[key], vm, key);
				  }
				  return options
				}

				/**
				 * Resolve an asset.
				 * This function is used because child instances need access
				 * to assets defined in its ancestor chain.
				 */
				function resolveAsset (
				  options,
				  type,
				  id,
				  warnMissing
				) {
				  /* istanbul ignore if */
				  if (typeof id !== 'string') {
				    return
				  }
				  var assets = options[type];
				  var res = assets[id] ||
				    // camelCase ID
				    assets[camelize(id)] ||
				    // Pascal Case ID
				    assets[capitalize(camelize(id))];
				  if ("development" !== 'production' && warnMissing && !res) {
				    warn(
				      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,
				      options
				    );
				  }
				  return res
				}

				/*  */

				function validateProp (
				  key,
				  propOptions,
				  propsData,
				  vm
				) {
				  var prop = propOptions[key];
				  var absent = !hasOwn(propsData, key);
				  var value = propsData[key];
				  // handle boolean props
				  if (isBooleanType(prop.type)) {
				    if (absent && !hasOwn(prop, 'default')) {
				      value = false;
				    } else if (value === '' || value === hyphenate(key)) {
				      value = true;
				    }
				  }
				  // check default value
				  if (value === undefined) {
				    value = getPropDefaultValue(vm, prop, key);
				    // since the default value is a fresh copy,
				    // make sure to observe it.
				    var prevShouldConvert = observerState.shouldConvert;
				    observerState.shouldConvert = true;
				    observe(value);
				    observerState.shouldConvert = prevShouldConvert;
				  }
				  {
				    assertProp(prop, key, value, vm, absent);
				  }
				  return value
				}

				/**
				 * Get the default value of a prop.
				 */
				function getPropDefaultValue (vm, prop, key) {
				  // no default, return undefined
				  if (!hasOwn(prop, 'default')) {
				    return undefined
				  }
				  var def = prop.default;
				  // warn against non-factory defaults for Object & Array
				  if (isObject(def)) {
				    "development" !== 'production' && warn(
				      'Invalid default value for prop "' + key + '": ' +
				      'Props with type Object/Array must use a factory function ' +
				      'to return the default value.',
				      vm
				    );
				  }
				  // the raw prop value was also undefined from previous render,
				  // return previous default value to avoid unnecessary watcher trigger
				  if (vm && vm.$options.propsData &&
				    vm.$options.propsData[key] === undefined &&
				    vm[key] !== undefined) {
				    return vm[key]
				  }
				  // call factory function for non-Function types
				  return typeof def === 'function' && prop.type !== Function
				    ? def.call(vm)
				    : def
				}

				/**
				 * Assert whether a prop is valid.
				 */
				function assertProp (
				  prop,
				  name,
				  value,
				  vm,
				  absent
				) {
				  if (prop.required && absent) {
				    warn(
				      'Missing required prop: "' + name + '"',
				      vm
				    );
				    return
				  }
				  if (value == null && !prop.required) {
				    return
				  }
				  var type = prop.type;
				  var valid = !type || type === true;
				  var expectedTypes = [];
				  if (type) {
				    if (!Array.isArray(type)) {
				      type = [type];
				    }
				    for (var i = 0; i < type.length && !valid; i++) {
				      var assertedType = assertType(value, type[i]);
				      expectedTypes.push(assertedType.expectedType);
				      valid = assertedType.valid;
				    }
				  }
				  if (!valid) {
				    warn(
				      'Invalid prop: type check failed for prop "' + name + '".' +
				      ' Expected ' + expectedTypes.map(capitalize).join(', ') +
				      ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.',
				      vm
				    );
				    return
				  }
				  var validator = prop.validator;
				  if (validator) {
				    if (!validator(value)) {
				      warn(
				        'Invalid prop: custom validator check failed for prop "' + name + '".',
				        vm
				      );
				    }
				  }
				}

				/**
				 * Assert the type of a value
				 */
				function assertType (value, type) {
				  var valid;
				  var expectedType = getType(type);
				  if (expectedType === 'String') {
				    valid = typeof value === (expectedType = 'string');
				  } else if (expectedType === 'Number') {
				    valid = typeof value === (expectedType = 'number');
				  } else if (expectedType === 'Boolean') {
				    valid = typeof value === (expectedType = 'boolean');
				  } else if (expectedType === 'Function') {
				    valid = typeof value === (expectedType = 'function');
				  } else if (expectedType === 'Object') {
				    valid = isPlainObject(value);
				  } else if (expectedType === 'Array') {
				    valid = Array.isArray(value);
				  } else {
				    valid = value instanceof type;
				  }
				  return {
				    valid: valid,
				    expectedType: expectedType
				  }
				}

				/**
				 * Use function string name to check built-in types,
				 * because a simple equality check will fail when running
				 * across different vms / iframes.
				 */
				function getType (fn) {
				  var match = fn && fn.toString().match(/^\s*function (\w+)/);
				  return match && match[1]
				}

				function isBooleanType (fn) {
				  if (!Array.isArray(fn)) {
				    return getType(fn) === 'Boolean'
				  }
				  for (var i = 0, len = fn.length; i < len; i++) {
				    if (getType(fn[i]) === 'Boolean') {
				      return true
				    }
				  }
				  /* istanbul ignore next */
				  return false
				}



				var util = Object.freeze({
					defineReactive: defineReactive$$1,
					_toString: _toString,
					toNumber: toNumber,
					makeMap: makeMap,
					isBuiltInTag: isBuiltInTag,
					remove: remove$1,
					hasOwn: hasOwn,
					isPrimitive: isPrimitive,
					cached: cached,
					camelize: camelize,
					capitalize: capitalize,
					hyphenate: hyphenate,
					bind: bind$1,
					toArray: toArray,
					extend: extend,
					isObject: isObject,
					isPlainObject: isPlainObject,
					toObject: toObject,
					noop: noop,
					no: no,
					genStaticKeys: genStaticKeys,
					looseEqual: looseEqual,
					looseIndexOf: looseIndexOf,
					isReserved: isReserved,
					def: def,
					parsePath: parsePath,
					hasProto: hasProto,
					inBrowser: inBrowser,
					UA: UA,
					isIE: isIE,
					isIE9: isIE9,
					isEdge: isEdge,
					isAndroid: isAndroid,
					isIOS: isIOS,
					devtools: devtools,
					nextTick: nextTick,
					get _Set () { return _Set; },
					mergeOptions: mergeOptions,
					resolveAsset: resolveAsset,
					get warn () { return warn; },
					get formatComponentName () { return formatComponentName; },
					validateProp: validateProp
				});

				/*  */

				function initUse (Vue) {
				  Vue.use = function (plugin) {
				    /* istanbul ignore if */
				    if (plugin.installed) {
				      return
				    }
				    // additional parameters
				    var args = toArray(arguments, 1);
				    args.unshift(this);
				    if (typeof plugin.install === 'function') {
				      plugin.install.apply(plugin, args);
				    } else {
				      plugin.apply(null, args);
				    }
				    plugin.installed = true;
				    return this
				  };
				}

				/*  */

				function initMixin$1 (Vue) {
				  Vue.mixin = function (mixin) {
				    Vue.options = mergeOptions(Vue.options, mixin);
				  };
				}

				/*  */

				function initExtend (Vue) {
				  /**
				   * Each instance constructor, including Vue, has a unique
				   * cid. This enables us to create wrapped "child
				   * constructors" for prototypal inheritance and cache them.
				   */
				  Vue.cid = 0;
				  var cid = 1;

				  /**
				   * Class inheritance
				   */
				  Vue.extend = function (extendOptions) {
				    extendOptions = extendOptions || {};
				    var Super = this;
				    var isFirstExtend = Super.cid === 0;
				    if (isFirstExtend && extendOptions._Ctor) {
				      return extendOptions._Ctor
				    }
				    var name = extendOptions.name || Super.options.name;
				    {
				      if (!/^[a-zA-Z][\w-]*$/.test(name)) {
				        warn(
				          'Invalid component name: "' + name + '". Component names ' +
				          'can only contain alphanumeric characaters and the hyphen.'
				        );
				      }
				    }
				    var Sub = function VueComponent (options) {
				      this._init(options);
				    };
				    Sub.prototype = Object.create(Super.prototype);
				    Sub.prototype.constructor = Sub;
				    Sub.cid = cid++;
				    Sub.options = mergeOptions(
				      Super.options,
				      extendOptions
				    );
				    Sub['super'] = Super;
				    // allow further extension
				    Sub.extend = Super.extend;
				    // create asset registers, so extended classes
				    // can have their private assets too.
				    config._assetTypes.forEach(function (type) {
				      Sub[type] = Super[type];
				    });
				    // enable recursive self-lookup
				    if (name) {
				      Sub.options.components[name] = Sub;
				    }
				    // keep a reference to the super options at extension time.
				    // later at instantiation we can check if Super's options have
				    // been updated.
				    Sub.superOptions = Super.options;
				    Sub.extendOptions = extendOptions;
				    // cache constructor
				    if (isFirstExtend) {
				      extendOptions._Ctor = Sub;
				    }
				    return Sub
				  };
				}

				/*  */

				function initAssetRegisters (Vue) {
				  /**
				   * Create asset registration methods.
				   */
				  config._assetTypes.forEach(function (type) {
				    Vue[type] = function (
				      id,
				      definition
				    ) {
				      if (!definition) {
				        return this.options[type + 's'][id]
				      } else {
				        /* istanbul ignore if */
				        {
				          if (type === 'component' && config.isReservedTag(id)) {
				            warn(
				              'Do not use built-in or reserved HTML elements as component ' +
				              'id: ' + id
				            );
				          }
				        }
				        if (type === 'component' && isPlainObject(definition)) {
				          definition.name = definition.name || id;
				          definition = Vue.extend(definition);
				        }
				        if (type === 'directive' && typeof definition === 'function') {
				          definition = { bind: definition, update: definition };
				        }
				        this.options[type + 's'][id] = definition;
				        return definition
				      }
				    };
				  });
				}

				var KeepAlive = {
				  name: 'keep-alive',
				  abstract: true,
				  created: function created () {
				    this.cache = Object.create(null);
				  },
				  render: function render () {
				    var vnode = getFirstComponentChild(this.$slots.default);
				    if (vnode && vnode.componentOptions) {
				      var opts = vnode.componentOptions;
				      var key = vnode.key == null
				        // same constructor may get registered as different local components
				        // so cid alone is not enough (#3269)
				        ? opts.Ctor.cid + '::' + opts.tag
				        : vnode.key;
				      if (this.cache[key]) {
				        vnode.child = this.cache[key].child;
				      } else {
				        this.cache[key] = vnode;
				      }
				      vnode.data.keepAlive = true;
				    }
				    return vnode
				  },
				  destroyed: function destroyed () {
				    var this$1 = this;

				    for (var key in this.cache) {
				      var vnode = this$1.cache[key];
				      callHook(vnode.child, 'deactivated');
				      vnode.child.$destroy();
				    }
				  }
				};

				var builtInComponents = {
				  KeepAlive: KeepAlive
				};

				/*  */

				function initGlobalAPI (Vue) {
				  // config
				  var configDef = {};
				  configDef.get = function () { return config; };
				  {
				    configDef.set = function () {
				      warn(
				        'Do not replace the Vue.config object, set individual fields instead.'
				      );
				    };
				  }
				  Object.defineProperty(Vue, 'config', configDef);
				  Vue.util = util;
				  Vue.set = set;
				  Vue.delete = del;
				  Vue.nextTick = nextTick;

				  Vue.options = Object.create(null);
				  config._assetTypes.forEach(function (type) {
				    Vue.options[type + 's'] = Object.create(null);
				  });

				  extend(Vue.options.components, builtInComponents);

				  initUse(Vue);
				  initMixin$1(Vue);
				  initExtend(Vue);
				  initAssetRegisters(Vue);
				}

				initGlobalAPI(Vue$2);

				Object.defineProperty(Vue$2.prototype, '$isServer', {
				  get: function () { return config._isServer; }
				});

				Vue$2.version = '2.0.5';

				/*  */

				// attributes that should be using props for binding
				var mustUseProp = makeMap('value,selected,checked,muted');

				var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');

				var isBooleanAttr = makeMap(
				  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +
				  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +
				  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +
				  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +
				  'required,reversed,scoped,seamless,selected,sortable,translate,' +
				  'truespeed,typemustmatch,visible'
				);

				var isAttr = makeMap(
				  'accept,accept-charset,accesskey,action,align,alt,async,autocomplete,' +
				  'autofocus,autoplay,autosave,bgcolor,border,buffered,challenge,charset,' +
				  'checked,cite,class,code,codebase,color,cols,colspan,content,http-equiv,' +
				  'name,contenteditable,contextmenu,controls,coords,data,datetime,default,' +
				  'defer,dir,dirname,disabled,download,draggable,dropzone,enctype,method,for,' +
				  'form,formaction,headers,<th>,height,hidden,high,href,hreflang,http-equiv,' +
				  'icon,id,ismap,itemprop,keytype,kind,label,lang,language,list,loop,low,' +
				  'manifest,max,maxlength,media,method,GET,POST,min,multiple,email,file,' +
				  'muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,' +
				  'preload,radiogroup,readonly,rel,required,reversed,rows,rowspan,sandbox,' +
				  'scope,scoped,seamless,selected,shape,size,type,text,password,sizes,span,' +
				  'spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,' +
				  'target,title,type,usemap,value,width,wrap'
				);



				var xlinkNS = 'http://www.w3.org/1999/xlink';

				var isXlink = function (name) {
				  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'
				};

				var getXlinkProp = function (name) {
				  return isXlink(name) ? name.slice(6, name.length) : ''
				};

				var isFalsyAttrValue = function (val) {
				  return val == null || val === false
				};

				/*  */

				function genClassForVnode (vnode) {
				  var data = vnode.data;
				  var parentNode = vnode;
				  var childNode = vnode;
				  while (childNode.child) {
				    childNode = childNode.child._vnode;
				    if (childNode.data) {
				      data = mergeClassData(childNode.data, data);
				    }
				  }
				  while ((parentNode = parentNode.parent)) {
				    if (parentNode.data) {
				      data = mergeClassData(data, parentNode.data);
				    }
				  }
				  return genClassFromData(data)
				}

				function mergeClassData (child, parent) {
				  return {
				    staticClass: concat(child.staticClass, parent.staticClass),
				    class: child.class
				      ? [child.class, parent.class]
				      : parent.class
				  }
				}

				function genClassFromData (data) {
				  var dynamicClass = data.class;
				  var staticClass = data.staticClass;
				  if (staticClass || dynamicClass) {
				    return concat(staticClass, stringifyClass(dynamicClass))
				  }
				  /* istanbul ignore next */
				  return ''
				}

				function concat (a, b) {
				  return a ? b ? (a + ' ' + b) : a : (b || '')
				}

				function stringifyClass (value) {
				  var res = '';
				  if (!value) {
				    return res
				  }
				  if (typeof value === 'string') {
				    return value
				  }
				  if (Array.isArray(value)) {
				    var stringified;
				    for (var i = 0, l = value.length; i < l; i++) {
				      if (value[i]) {
				        if ((stringified = stringifyClass(value[i]))) {
				          res += stringified + ' ';
				        }
				      }
				    }
				    return res.slice(0, -1)
				  }
				  if (isObject(value)) {
				    for (var key in value) {
				      if (value[key]) { res += key + ' '; }
				    }
				    return res.slice(0, -1)
				  }
				  /* istanbul ignore next */
				  return res
				}

				/*  */

				var namespaceMap = {
				  svg: 'http://www.w3.org/2000/svg',
				  math: 'http://www.w3.org/1998/Math/MathML',
				  xhtml: 'http://www.w3.org/1999/xhtm'
				};

				var isHTMLTag = makeMap(
				  'html,body,base,head,link,meta,style,title,' +
				  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +
				  'div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,' +
				  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +
				  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +
				  'embed,object,param,source,canvas,script,noscript,del,ins,' +
				  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +
				  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +
				  'output,progress,select,textarea,' +
				  'details,dialog,menu,menuitem,summary,' +
				  'content,element,shadow,template'
				);

				var isUnaryTag = makeMap(
				  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +
				  'link,meta,param,source,track,wbr',
				  true
				);

				// Elements that you can, intentionally, leave open
				// (and which close themselves)
				var canBeLeftOpenTag = makeMap(
				  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source',
				  true
				);

				// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
				// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content
				var isNonPhrasingTag = makeMap(
				  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +
				  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +
				  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +
				  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +
				  'title,tr,track',
				  true
				);

				// this map is intentionally selective, only covering SVG elements that may
				// contain child elements.
				var isSVG = makeMap(
				  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font,' +
				  'font-face,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +
				  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',
				  true
				);

				var isPreTag = function (tag) { return tag === 'pre'; };

				var isReservedTag = function (tag) {
				  return isHTMLTag(tag) || isSVG(tag)
				};

				function getTagNamespace (tag) {
				  if (isSVG(tag)) {
				    return 'svg'
				  }
				  // basic support for MathML
				  // note it doesn't support other MathML elements being component roots
				  if (tag === 'math') {
				    return 'math'
				  }
				}

				var unknownElementCache = Object.create(null);
				function isUnknownElement (tag) {
				  /* istanbul ignore if */
				  if (!inBrowser) {
				    return true
				  }
				  if (isReservedTag(tag)) {
				    return false
				  }
				  tag = tag.toLowerCase();
				  /* istanbul ignore if */
				  if (unknownElementCache[tag] != null) {
				    return unknownElementCache[tag]
				  }
				  var el = document.createElement(tag);
				  if (tag.indexOf('-') > -1) {
				    // http://stackoverflow.com/a/28210364/1070244
				    return (unknownElementCache[tag] = (
				      el.constructor === window.HTMLUnknownElement ||
				      el.constructor === window.HTMLElement
				    ))
				  } else {
				    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))
				  }
				}

				/*  */

				/**
				 * Query an element selector if it's not an element already.
				 */
				function query (el) {
				  if (typeof el === 'string') {
				    var selector = el;
				    el = document.querySelector(el);
				    if (!el) {
				      "development" !== 'production' && warn(
				        'Cannot find element: ' + selector
				      );
				      return document.createElement('div')
				    }
				  }
				  return el
				}

				/*  */

				function createElement$1 (tagName, vnode) {
				  var elm = document.createElement(tagName);
				  if (tagName !== 'select') {
				    return elm
				  }
				  if (vnode.data && vnode.data.attrs && 'multiple' in vnode.data.attrs) {
				    elm.setAttribute('multiple', 'multiple');
				  }
				  return elm
				}

				function createElementNS (namespace, tagName) {
				  return document.createElementNS(namespaceMap[namespace], tagName)
				}

				function createTextNode (text) {
				  return document.createTextNode(text)
				}

				function createComment (text) {
				  return document.createComment(text)
				}

				function insertBefore (parentNode, newNode, referenceNode) {
				  parentNode.insertBefore(newNode, referenceNode);
				}

				function removeChild (node, child) {
				  node.removeChild(child);
				}

				function appendChild (node, child) {
				  node.appendChild(child);
				}

				function parentNode (node) {
				  return node.parentNode
				}

				function nextSibling (node) {
				  return node.nextSibling
				}

				function tagName (node) {
				  return node.tagName
				}

				function setTextContent (node, text) {
				  node.textContent = text;
				}

				function childNodes (node) {
				  return node.childNodes
				}

				function setAttribute (node, key, val) {
				  node.setAttribute(key, val);
				}


				var nodeOps = Object.freeze({
					createElement: createElement$1,
					createElementNS: createElementNS,
					createTextNode: createTextNode,
					createComment: createComment,
					insertBefore: insertBefore,
					removeChild: removeChild,
					appendChild: appendChild,
					parentNode: parentNode,
					nextSibling: nextSibling,
					tagName: tagName,
					setTextContent: setTextContent,
					childNodes: childNodes,
					setAttribute: setAttribute
				});

				/*  */

				var ref = {
				  create: function create (_, vnode) {
				    registerRef(vnode);
				  },
				  update: function update (oldVnode, vnode) {
				    if (oldVnode.data.ref !== vnode.data.ref) {
				      registerRef(oldVnode, true);
				      registerRef(vnode);
				    }
				  },
				  destroy: function destroy (vnode) {
				    registerRef(vnode, true);
				  }
				};

				function registerRef (vnode, isRemoval) {
				  var key = vnode.data.ref;
				  if (!key) { return }

				  var vm = vnode.context;
				  var ref = vnode.child || vnode.elm;
				  var refs = vm.$refs;
				  if (isRemoval) {
				    if (Array.isArray(refs[key])) {
				      remove$1(refs[key], ref);
				    } else if (refs[key] === ref) {
				      refs[key] = undefined;
				    }
				  } else {
				    if (vnode.data.refInFor) {
				      if (Array.isArray(refs[key])) {
				        refs[key].push(ref);
				      } else {
				        refs[key] = [ref];
				      }
				    } else {
				      refs[key] = ref;
				    }
				  }
				}

				/**
				 * Virtual DOM patching algorithm based on Snabbdom by
				 * Simon Friis Vindum (@paldepind)
				 * Licensed under the MIT License
				 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
				 *
				 * modified by Evan You (@yyx990803)
				 *

				/*
				 * Not type-checking this because this file is perf-critical and the cost
				 * of making flow understand it is not worth it.
				 */

				var emptyNode = new VNode('', {}, []);

				var hooks$1 = ['create', 'update', 'remove', 'destroy'];

				function isUndef (s) {
				  return s == null
				}

				function isDef (s) {
				  return s != null
				}

				function sameVnode (vnode1, vnode2) {
				  return (
				    vnode1.key === vnode2.key &&
				    vnode1.tag === vnode2.tag &&
				    vnode1.isComment === vnode2.isComment &&
				    !vnode1.data === !vnode2.data
				  )
				}

				function createKeyToOldIdx (children, beginIdx, endIdx) {
				  var i, key;
				  var map = {};
				  for (i = beginIdx; i <= endIdx; ++i) {
				    key = children[i].key;
				    if (isDef(key)) { map[key] = i; }
				  }
				  return map
				}

				function createPatchFunction (backend) {
				  var i, j;
				  var cbs = {};

				  var modules = backend.modules;
				  var nodeOps = backend.nodeOps;

				  for (i = 0; i < hooks$1.length; ++i) {
				    cbs[hooks$1[i]] = [];
				    for (j = 0; j < modules.length; ++j) {
				      if (modules[j][hooks$1[i]] !== undefined) { cbs[hooks$1[i]].push(modules[j][hooks$1[i]]); }
				    }
				  }

				  function emptyNodeAt (elm) {
				    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)
				  }

				  function createRmCb (childElm, listeners) {
				    function remove$$1 () {
				      if (--remove$$1.listeners === 0) {
				        removeElement(childElm);
				      }
				    }
				    remove$$1.listeners = listeners;
				    return remove$$1
				  }

				  function removeElement (el) {
				    var parent = nodeOps.parentNode(el);
				    // element may have already been removed due to v-html
				    if (parent) {
				      nodeOps.removeChild(parent, el);
				    }
				  }

				  function createElm (vnode, insertedVnodeQueue, nested) {
				    var i;
				    var data = vnode.data;
				    vnode.isRootInsert = !nested;
				    if (isDef(data)) {
				      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode); }
				      // after calling the init hook, if the vnode is a child component
				      // it should've created a child instance and mounted it. the child
				      // component also has set the placeholder vnode's elm.
				      // in that case we can just return the element and be done.
				      if (isDef(i = vnode.child)) {
				        initComponent(vnode, insertedVnodeQueue);
				        return vnode.elm
				      }
				    }
				    var children = vnode.children;
				    var tag = vnode.tag;
				    if (isDef(tag)) {
				      {
				        if (
				          !vnode.ns &&
				          !(config.ignoredElements && config.ignoredElements.indexOf(tag) > -1) &&
				          config.isUnknownElement(tag)
				        ) {
				          warn(
				            'Unknown custom element: <' + tag + '> - did you ' +
				            'register the component correctly? For recursive components, ' +
				            'make sure to provide the "name" option.',
				            vnode.context
				          );
				        }
				      }
				      vnode.elm = vnode.ns
				        ? nodeOps.createElementNS(vnode.ns, tag)
				        : nodeOps.createElement(tag, vnode);
				      setScope(vnode);
				      createChildren(vnode, children, insertedVnodeQueue);
				      if (isDef(data)) {
				        invokeCreateHooks(vnode, insertedVnodeQueue);
				      }
				    } else if (vnode.isComment) {
				      vnode.elm = nodeOps.createComment(vnode.text);
				    } else {
				      vnode.elm = nodeOps.createTextNode(vnode.text);
				    }
				    return vnode.elm
				  }

				  function createChildren (vnode, children, insertedVnodeQueue) {
				    if (Array.isArray(children)) {
				      for (var i = 0; i < children.length; ++i) {
				        nodeOps.appendChild(vnode.elm, createElm(children[i], insertedVnodeQueue, true));
				      }
				    } else if (isPrimitive(vnode.text)) {
				      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));
				    }
				  }

				  function isPatchable (vnode) {
				    while (vnode.child) {
				      vnode = vnode.child._vnode;
				    }
				    return isDef(vnode.tag)
				  }

				  function invokeCreateHooks (vnode, insertedVnodeQueue) {
				    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
				      cbs.create[i$1](emptyNode, vnode);
				    }
				    i = vnode.data.hook; // Reuse variable
				    if (isDef(i)) {
				      if (i.create) { i.create(emptyNode, vnode); }
				      if (i.insert) { insertedVnodeQueue.push(vnode); }
				    }
				  }

				  function initComponent (vnode, insertedVnodeQueue) {
				    if (vnode.data.pendingInsert) {
				      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
				    }
				    vnode.elm = vnode.child.$el;
				    if (isPatchable(vnode)) {
				      invokeCreateHooks(vnode, insertedVnodeQueue);
				      setScope(vnode);
				    } else {
				      // empty component root.
				      // skip all element-related modules except for ref (#3455)
				      registerRef(vnode);
				      // make sure to invoke the insert hook
				      insertedVnodeQueue.push(vnode);
				    }
				  }

				  // set scope id attribute for scoped CSS.
				  // this is implemented as a special case to avoid the overhead
				  // of going through the normal attribute patching process.
				  function setScope (vnode) {
				    var i;
				    if (isDef(i = vnode.context) && isDef(i = i.$options._scopeId)) {
				      nodeOps.setAttribute(vnode.elm, i, '');
				    }
				    if (isDef(i = activeInstance) &&
				        i !== vnode.context &&
				        isDef(i = i.$options._scopeId)) {
				      nodeOps.setAttribute(vnode.elm, i, '');
				    }
				  }

				  function addVnodes (parentElm, before, vnodes, startIdx, endIdx, insertedVnodeQueue) {
				    for (; startIdx <= endIdx; ++startIdx) {
				      nodeOps.insertBefore(parentElm, createElm(vnodes[startIdx], insertedVnodeQueue), before);
				    }
				  }

				  function invokeDestroyHook (vnode) {
				    var i, j;
				    var data = vnode.data;
				    if (isDef(data)) {
				      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }
				      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }
				    }
				    if (isDef(i = vnode.children)) {
				      for (j = 0; j < vnode.children.length; ++j) {
				        invokeDestroyHook(vnode.children[j]);
				      }
				    }
				  }

				  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {
				    for (; startIdx <= endIdx; ++startIdx) {
				      var ch = vnodes[startIdx];
				      if (isDef(ch)) {
				        if (isDef(ch.tag)) {
				          removeAndInvokeRemoveHook(ch);
				          invokeDestroyHook(ch);
				        } else { // Text node
				          nodeOps.removeChild(parentElm, ch.elm);
				        }
				      }
				    }
				  }

				  function removeAndInvokeRemoveHook (vnode, rm) {
				    if (rm || isDef(vnode.data)) {
				      var listeners = cbs.remove.length + 1;
				      if (!rm) {
				        // directly removing
				        rm = createRmCb(vnode.elm, listeners);
				      } else {
				        // we have a recursively passed down rm callback
				        // increase the listeners count
				        rm.listeners += listeners;
				      }
				      // recursively invoke hooks on child component root node
				      if (isDef(i = vnode.child) && isDef(i = i._vnode) && isDef(i.data)) {
				        removeAndInvokeRemoveHook(i, rm);
				      }
				      for (i = 0; i < cbs.remove.length; ++i) {
				        cbs.remove[i](vnode, rm);
				      }
				      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
				        i(vnode, rm);
				      } else {
				        rm();
				      }
				    } else {
				      removeElement(vnode.elm);
				    }
				  }

				  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
				    var oldStartIdx = 0;
				    var newStartIdx = 0;
				    var oldEndIdx = oldCh.length - 1;
				    var oldStartVnode = oldCh[0];
				    var oldEndVnode = oldCh[oldEndIdx];
				    var newEndIdx = newCh.length - 1;
				    var newStartVnode = newCh[0];
				    var newEndVnode = newCh[newEndIdx];
				    var oldKeyToIdx, idxInOld, elmToMove, before;

				    // removeOnly is a special flag used only by <transition-group>
				    // to ensure removed elements stay in correct relative positions
				    // during leaving transitions
				    var canMove = !removeOnly;

				    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
				      if (isUndef(oldStartVnode)) {
				        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
				      } else if (isUndef(oldEndVnode)) {
				        oldEndVnode = oldCh[--oldEndIdx];
				      } else if (sameVnode(oldStartVnode, newStartVnode)) {
				        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
				        oldStartVnode = oldCh[++oldStartIdx];
				        newStartVnode = newCh[++newStartIdx];
				      } else if (sameVnode(oldEndVnode, newEndVnode)) {
				        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
				        oldEndVnode = oldCh[--oldEndIdx];
				        newEndVnode = newCh[--newEndIdx];
				      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
				        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
				        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
				        oldStartVnode = oldCh[++oldStartIdx];
				        newEndVnode = newCh[--newEndIdx];
				      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
				        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
				        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
				        oldEndVnode = oldCh[--oldEndIdx];
				        newStartVnode = newCh[++newStartIdx];
				      } else {
				        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }
				        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;
				        if (isUndef(idxInOld)) { // New element
				          nodeOps.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
				          newStartVnode = newCh[++newStartIdx];
				        } else {
				          elmToMove = oldCh[idxInOld];
				          /* istanbul ignore if */
				          if ("development" !== 'production' && !elmToMove) {
				            warn(
				              'It seems there are duplicate keys that is causing an update error. ' +
				              'Make sure each v-for item has a unique key.'
				            );
				          }
				          if (elmToMove.tag !== newStartVnode.tag) {
				            // same key but different element. treat as new element
				            nodeOps.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
				            newStartVnode = newCh[++newStartIdx];
				          } else {
				            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
				            oldCh[idxInOld] = undefined;
				            canMove && nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);
				            newStartVnode = newCh[++newStartIdx];
				          }
				        }
				      }
				    }
				    if (oldStartIdx > oldEndIdx) {
				      before = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
				      addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
				    } else if (newStartIdx > newEndIdx) {
				      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
				    }
				  }

				  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {
				    if (oldVnode === vnode) {
				      return
				    }
				    // reuse element for static trees.
				    // note we only do this if the vnode is cloned -
				    // if the new node is not cloned it means the render functions have been
				    // reset by the hot-reload-api and we need to do a proper re-render.
				    if (vnode.isStatic &&
				        oldVnode.isStatic &&
				        vnode.key === oldVnode.key &&
				        (vnode.isCloned || vnode.isOnce)) {
				      vnode.elm = oldVnode.elm;
				      return
				    }
				    var i;
				    var data = vnode.data;
				    var hasData = isDef(data);
				    if (hasData && isDef(i = data.hook) && isDef(i = i.prepatch)) {
				      i(oldVnode, vnode);
				    }
				    var elm = vnode.elm = oldVnode.elm;
				    var oldCh = oldVnode.children;
				    var ch = vnode.children;
				    if (hasData && isPatchable(vnode)) {
				      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }
				      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }
				    }
				    if (isUndef(vnode.text)) {
				      if (isDef(oldCh) && isDef(ch)) {
				        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }
				      } else if (isDef(ch)) {
				        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }
				        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
				      } else if (isDef(oldCh)) {
				        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
				      } else if (isDef(oldVnode.text)) {
				        nodeOps.setTextContent(elm, '');
				      }
				    } else if (oldVnode.text !== vnode.text) {
				      nodeOps.setTextContent(elm, vnode.text);
				    }
				    if (hasData) {
				      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }
				    }
				  }

				  function invokeInsertHook (vnode, queue, initial) {
				    // delay insert hooks for component root nodes, invoke them after the
				    // element is really inserted
				    if (initial && vnode.parent) {
				      vnode.parent.data.pendingInsert = queue;
				    } else {
				      for (var i = 0; i < queue.length; ++i) {
				        queue[i].data.hook.insert(queue[i]);
				      }
				    }
				  }

				  var bailed = false;
				  function hydrate (elm, vnode, insertedVnodeQueue) {
				    {
				      if (!assertNodeMatch(elm, vnode)) {
				        return false
				      }
				    }
				    vnode.elm = elm;
				    var tag = vnode.tag;
				    var data = vnode.data;
				    var children = vnode.children;
				    if (isDef(data)) {
				      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }
				      if (isDef(i = vnode.child)) {
				        // child component. it should have hydrated its own tree.
				        initComponent(vnode, insertedVnodeQueue);
				        return true
				      }
				    }
				    if (isDef(tag)) {
				      if (isDef(children)) {
				        var childNodes = nodeOps.childNodes(elm);
				        // empty element, allow client to pick up and populate children
				        if (!childNodes.length) {
				          createChildren(vnode, children, insertedVnodeQueue);
				        } else {
				          var childrenMatch = true;
				          if (childNodes.length !== children.length) {
				            childrenMatch = false;
				          } else {
				            for (var i$1 = 0; i$1 < children.length; i$1++) {
				              if (!hydrate(childNodes[i$1], children[i$1], insertedVnodeQueue)) {
				                childrenMatch = false;
				                break
				              }
				            }
				          }
				          if (!childrenMatch) {
				            if ("development" !== 'production' &&
				                typeof console !== 'undefined' &&
				                !bailed) {
				              bailed = true;
				              console.warn('Parent: ', elm);
				              console.warn('Mismatching childNodes vs. VNodes: ', childNodes, children);
				            }
				            return false
				          }
				        }
				      }
				      if (isDef(data)) {
				        invokeCreateHooks(vnode, insertedVnodeQueue);
				      }
				    }
				    return true
				  }

				  function assertNodeMatch (node, vnode) {
				    if (vnode.tag) {
				      return (
				        vnode.tag.indexOf('vue-component') === 0 ||
				        vnode.tag === nodeOps.tagName(node).toLowerCase()
				      )
				    } else {
				      return _toString(vnode.text) === node.data
				    }
				  }

				  return function patch (oldVnode, vnode, hydrating, removeOnly) {
				    if (!vnode) {
				      if (oldVnode) { invokeDestroyHook(oldVnode); }
				      return
				    }

				    var elm, parent;
				    var isInitialPatch = false;
				    var insertedVnodeQueue = [];

				    if (!oldVnode) {
				      // empty mount, create new root element
				      isInitialPatch = true;
				      createElm(vnode, insertedVnodeQueue);
				    } else {
				      var isRealElement = isDef(oldVnode.nodeType);
				      if (!isRealElement && sameVnode(oldVnode, vnode)) {
				        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);
				      } else {
				        if (isRealElement) {
				          // mounting to a real element
				          // check if this is server-rendered content and if we can perform
				          // a successful hydration.
				          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute('server-rendered')) {
				            oldVnode.removeAttribute('server-rendered');
				            hydrating = true;
				          }
				          if (hydrating) {
				            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
				              invokeInsertHook(vnode, insertedVnodeQueue, true);
				              return oldVnode
				            } else {
				              warn(
				                'The client-side rendered virtual DOM tree is not matching ' +
				                'server-rendered content. This is likely caused by incorrect ' +
				                'HTML markup, for example nesting block-level elements inside ' +
				                '<p>, or missing <tbody>. Bailing hydration and performing ' +
				                'full client-side render.'
				              );
				            }
				          }
				          // either not server-rendered, or hydration failed.
				          // create an empty node and replace it
				          oldVnode = emptyNodeAt(oldVnode);
				        }
				        elm = oldVnode.elm;
				        parent = nodeOps.parentNode(elm);

				        createElm(vnode, insertedVnodeQueue);

				        // component root element replaced.
				        // update parent placeholder node element.
				        if (vnode.parent) {
				          vnode.parent.elm = vnode.elm;
				          if (isPatchable(vnode)) {
				            for (var i = 0; i < cbs.create.length; ++i) {
				              cbs.create[i](emptyNode, vnode.parent);
				            }
				          }
				        }

				        if (parent !== null) {
				          nodeOps.insertBefore(parent, vnode.elm, nodeOps.nextSibling(elm));
				          removeVnodes(parent, [oldVnode], 0, 0);
				        } else if (isDef(oldVnode.tag)) {
				          invokeDestroyHook(oldVnode);
				        }
				      }
				    }

				    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
				    return vnode.elm
				  }
				}

				/*  */

				var directives = {
				  create: updateDirectives,
				  update: updateDirectives,
				  destroy: function unbindDirectives (vnode) {
				    updateDirectives(vnode, emptyNode);
				  }
				};

				function updateDirectives (
				  oldVnode,
				  vnode
				) {
				  if (!oldVnode.data.directives && !vnode.data.directives) {
				    return
				  }
				  var isCreate = oldVnode === emptyNode;
				  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
				  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);

				  var dirsWithInsert = [];
				  var dirsWithPostpatch = [];

				  var key, oldDir, dir;
				  for (key in newDirs) {
				    oldDir = oldDirs[key];
				    dir = newDirs[key];
				    if (!oldDir) {
				      // new directive, bind
				      callHook$1(dir, 'bind', vnode, oldVnode);
				      if (dir.def && dir.def.inserted) {
				        dirsWithInsert.push(dir);
				      }
				    } else {
				      // existing directive, update
				      dir.oldValue = oldDir.value;
				      callHook$1(dir, 'update', vnode, oldVnode);
				      if (dir.def && dir.def.componentUpdated) {
				        dirsWithPostpatch.push(dir);
				      }
				    }
				  }

				  if (dirsWithInsert.length) {
				    var callInsert = function () {
				      dirsWithInsert.forEach(function (dir) {
				        callHook$1(dir, 'inserted', vnode, oldVnode);
				      });
				    };
				    if (isCreate) {
				      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert, 'dir-insert');
				    } else {
				      callInsert();
				    }
				  }

				  if (dirsWithPostpatch.length) {
				    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {
				      dirsWithPostpatch.forEach(function (dir) {
				        callHook$1(dir, 'componentUpdated', vnode, oldVnode);
				      });
				    }, 'dir-postpatch');
				  }

				  if (!isCreate) {
				    for (key in oldDirs) {
				      if (!newDirs[key]) {
				        // no longer present, unbind
				        callHook$1(oldDirs[key], 'unbind', oldVnode);
				      }
				    }
				  }
				}

				var emptyModifiers = Object.create(null);

				function normalizeDirectives$1 (
				  dirs,
				  vm
				) {
				  var res = Object.create(null);
				  if (!dirs) {
				    return res
				  }
				  var i, dir;
				  for (i = 0; i < dirs.length; i++) {
				    dir = dirs[i];
				    if (!dir.modifiers) {
				      dir.modifiers = emptyModifiers;
				    }
				    res[getRawDirName(dir)] = dir;
				    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
				  }
				  return res
				}

				function getRawDirName (dir) {
				  return dir.rawName || ((dir.name) + "." + (Object.keys(dir.modifiers || {}).join('.')))
				}

				function callHook$1 (dir, hook, vnode, oldVnode) {
				  var fn = dir.def && dir.def[hook];
				  if (fn) {
				    fn(vnode.elm, dir, vnode, oldVnode);
				  }
				}

				var baseModules = [
				  ref,
				  directives
				];

				/*  */

				function updateAttrs (oldVnode, vnode) {
				  if (!oldVnode.data.attrs && !vnode.data.attrs) {
				    return
				  }
				  var key, cur, old;
				  var elm = vnode.elm;
				  var oldAttrs = oldVnode.data.attrs || {};
				  var attrs = vnode.data.attrs || {};
				  // clone observed objects, as the user probably wants to mutate it
				  if (attrs.__ob__) {
				    attrs = vnode.data.attrs = extend({}, attrs);
				  }

				  for (key in attrs) {
				    cur = attrs[key];
				    old = oldAttrs[key];
				    if (old !== cur) {
				      setAttr(elm, key, cur);
				    }
				  }
				  for (key in oldAttrs) {
				    if (attrs[key] == null) {
				      if (isXlink(key)) {
				        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
				      } else if (!isEnumeratedAttr(key)) {
				        elm.removeAttribute(key);
				      }
				    }
				  }
				}

				function setAttr (el, key, value) {
				  if (isBooleanAttr(key)) {
				    // set attribute for blank value
				    // e.g. <option disabled>Select one</option>
				    if (isFalsyAttrValue(value)) {
				      el.removeAttribute(key);
				    } else {
				      el.setAttribute(key, key);
				    }
				  } else if (isEnumeratedAttr(key)) {
				    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');
				  } else if (isXlink(key)) {
				    if (isFalsyAttrValue(value)) {
				      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
				    } else {
				      el.setAttributeNS(xlinkNS, key, value);
				    }
				  } else {
				    if (isFalsyAttrValue(value)) {
				      el.removeAttribute(key);
				    } else {
				      el.setAttribute(key, value);
				    }
				  }
				}

				var attrs = {
				  create: updateAttrs,
				  update: updateAttrs
				};

				/*  */

				function updateClass (oldVnode, vnode) {
				  var el = vnode.elm;
				  var data = vnode.data;
				  var oldData = oldVnode.data;
				  if (!data.staticClass && !data.class &&
				      (!oldData || (!oldData.staticClass && !oldData.class))) {
				    return
				  }

				  var cls = genClassForVnode(vnode);

				  // handle transition classes
				  var transitionClass = el._transitionClasses;
				  if (transitionClass) {
				    cls = concat(cls, stringifyClass(transitionClass));
				  }

				  // set the class
				  if (cls !== el._prevClass) {
				    el.setAttribute('class', cls);
				    el._prevClass = cls;
				  }
				}

				var klass = {
				  create: updateClass,
				  update: updateClass
				};

				// skip type checking this file because we need to attach private properties
				// to elements

				function updateDOMListeners (oldVnode, vnode) {
				  if (!oldVnode.data.on && !vnode.data.on) {
				    return
				  }
				  var on = vnode.data.on || {};
				  var oldOn = oldVnode.data.on || {};
				  var add = vnode.elm._v_add || (vnode.elm._v_add = function (event, handler, capture) {
				    vnode.elm.addEventListener(event, handler, capture);
				  });
				  var remove = vnode.elm._v_remove || (vnode.elm._v_remove = function (event, handler) {
				    vnode.elm.removeEventListener(event, handler);
				  });
				  updateListeners(on, oldOn, add, remove, vnode.context);
				}

				var events = {
				  create: updateDOMListeners,
				  update: updateDOMListeners
				};

				/*  */

				function updateDOMProps (oldVnode, vnode) {
				  if (!oldVnode.data.domProps && !vnode.data.domProps) {
				    return
				  }
				  var key, cur;
				  var elm = vnode.elm;
				  var oldProps = oldVnode.data.domProps || {};
				  var props = vnode.data.domProps || {};
				  // clone observed objects, as the user probably wants to mutate it
				  if (props.__ob__) {
				    props = vnode.data.domProps = extend({}, props);
				  }

				  for (key in oldProps) {
				    if (props[key] == null) {
				      elm[key] = '';
				    }
				  }
				  for (key in props) {
				    // ignore children if the node has textContent or innerHTML,
				    // as these will throw away existing DOM nodes and cause removal errors
				    // on subsequent patches (#3360)
				    if ((key === 'textContent' || key === 'innerHTML') && vnode.children) {
				      vnode.children.length = 0;
				    }
				    cur = props[key];
				    if (key === 'value') {
				      // store value as _value as well since
				      // non-string values will be stringified
				      elm._value = cur;
				      // avoid resetting cursor position when value is the same
				      var strCur = cur == null ? '' : String(cur);
				      if (elm.value !== strCur && !elm.composing) {
				        elm.value = strCur;
				      }
				    } else {
				      elm[key] = cur;
				    }
				  }
				}

				var domProps = {
				  create: updateDOMProps,
				  update: updateDOMProps
				};

				/*  */

				var cssVarRE = /^--/;
				var setProp = function (el, name, val) {
				  /* istanbul ignore if */
				  if (cssVarRE.test(name)) {
				    el.style.setProperty(name, val);
				  } else {
				    el.style[normalize(name)] = val;
				  }
				};

				var prefixes = ['Webkit', 'Moz', 'ms'];

				var testEl;
				var normalize = cached(function (prop) {
				  testEl = testEl || document.createElement('div');
				  prop = camelize(prop);
				  if (prop !== 'filter' && (prop in testEl.style)) {
				    return prop
				  }
				  var upper = prop.charAt(0).toUpperCase() + prop.slice(1);
				  for (var i = 0; i < prefixes.length; i++) {
				    var prefixed = prefixes[i] + upper;
				    if (prefixed in testEl.style) {
				      return prefixed
				    }
				  }
				});

				function updateStyle (oldVnode, vnode) {
				  if ((!oldVnode.data || !oldVnode.data.style) && !vnode.data.style) {
				    return
				  }
				  var cur, name;
				  var el = vnode.elm;
				  var oldStyle = oldVnode.data.style || {};
				  var style = vnode.data.style || {};

				  // handle string
				  if (typeof style === 'string') {
				    el.style.cssText = style;
				    return
				  }

				  var needClone = style.__ob__;

				  // handle array syntax
				  if (Array.isArray(style)) {
				    style = vnode.data.style = toObject(style);
				  }

				  // clone the style for future updates,
				  // in case the user mutates the style object in-place.
				  if (needClone) {
				    style = vnode.data.style = extend({}, style);
				  }

				  for (name in oldStyle) {
				    if (style[name] == null) {
				      setProp(el, name, '');
				    }
				  }
				  for (name in style) {
				    cur = style[name];
				    if (cur !== oldStyle[name]) {
				      // ie9 setting to null has no effect, must use empty string
				      setProp(el, name, cur == null ? '' : cur);
				    }
				  }
				}

				var style = {
				  create: updateStyle,
				  update: updateStyle
				};

				/*  */

				/**
				 * Add class with compatibility for SVG since classList is not supported on
				 * SVG elements in IE
				 */
				function addClass (el, cls) {
				  /* istanbul ignore if */
				  if (!cls || !cls.trim()) {
				    return
				  }

				  /* istanbul ignore else */
				  if (el.classList) {
				    if (cls.indexOf(' ') > -1) {
				      cls.split(/\s+/).forEach(function (c) { return el.classList.add(c); });
				    } else {
				      el.classList.add(cls);
				    }
				  } else {
				    var cur = ' ' + el.getAttribute('class') + ' ';
				    if (cur.indexOf(' ' + cls + ' ') < 0) {
				      el.setAttribute('class', (cur + cls).trim());
				    }
				  }
				}

				/**
				 * Remove class with compatibility for SVG since classList is not supported on
				 * SVG elements in IE
				 */
				function removeClass (el, cls) {
				  /* istanbul ignore if */
				  if (!cls || !cls.trim()) {
				    return
				  }

				  /* istanbul ignore else */
				  if (el.classList) {
				    if (cls.indexOf(' ') > -1) {
				      cls.split(/\s+/).forEach(function (c) { return el.classList.remove(c); });
				    } else {
				      el.classList.remove(cls);
				    }
				  } else {
				    var cur = ' ' + el.getAttribute('class') + ' ';
				    var tar = ' ' + cls + ' ';
				    while (cur.indexOf(tar) >= 0) {
				      cur = cur.replace(tar, ' ');
				    }
				    el.setAttribute('class', cur.trim());
				  }
				}

				/*  */

				var hasTransition = inBrowser && !isIE9;
				var TRANSITION = 'transition';
				var ANIMATION = 'animation';

				// Transition property/event sniffing
				var transitionProp = 'transition';
				var transitionEndEvent = 'transitionend';
				var animationProp = 'animation';
				var animationEndEvent = 'animationend';
				if (hasTransition) {
				  /* istanbul ignore if */
				  if (window.ontransitionend === undefined &&
				    window.onwebkittransitionend !== undefined) {
				    transitionProp = 'WebkitTransition';
				    transitionEndEvent = 'webkitTransitionEnd';
				  }
				  if (window.onanimationend === undefined &&
				    window.onwebkitanimationend !== undefined) {
				    animationProp = 'WebkitAnimation';
				    animationEndEvent = 'webkitAnimationEnd';
				  }
				}

				var raf = (inBrowser && window.requestAnimationFrame) || setTimeout;
				function nextFrame (fn) {
				  raf(function () {
				    raf(fn);
				  });
				}

				function addTransitionClass (el, cls) {
				  (el._transitionClasses || (el._transitionClasses = [])).push(cls);
				  addClass(el, cls);
				}

				function removeTransitionClass (el, cls) {
				  if (el._transitionClasses) {
				    remove$1(el._transitionClasses, cls);
				  }
				  removeClass(el, cls);
				}

				function whenTransitionEnds (
				  el,
				  expectedType,
				  cb
				) {
				  var ref = getTransitionInfo(el, expectedType);
				  var type = ref.type;
				  var timeout = ref.timeout;
				  var propCount = ref.propCount;
				  if (!type) { return cb() }
				  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
				  var ended = 0;
				  var end = function () {
				    el.removeEventListener(event, onEnd);
				    cb();
				  };
				  var onEnd = function (e) {
				    if (e.target === el) {
				      if (++ended >= propCount) {
				        end();
				      }
				    }
				  };
				  setTimeout(function () {
				    if (ended < propCount) {
				      end();
				    }
				  }, timeout + 1);
				  el.addEventListener(event, onEnd);
				}

				var transformRE = /\b(transform|all)(,|$)/;

				function getTransitionInfo (el, expectedType) {
				  var styles = window.getComputedStyle(el);
				  var transitioneDelays = styles[transitionProp + 'Delay'].split(', ');
				  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');
				  var transitionTimeout = getTimeout(transitioneDelays, transitionDurations);
				  var animationDelays = styles[animationProp + 'Delay'].split(', ');
				  var animationDurations = styles[animationProp + 'Duration'].split(', ');
				  var animationTimeout = getTimeout(animationDelays, animationDurations);

				  var type;
				  var timeout = 0;
				  var propCount = 0;
				  /* istanbul ignore if */
				  if (expectedType === TRANSITION) {
				    if (transitionTimeout > 0) {
				      type = TRANSITION;
				      timeout = transitionTimeout;
				      propCount = transitionDurations.length;
				    }
				  } else if (expectedType === ANIMATION) {
				    if (animationTimeout > 0) {
				      type = ANIMATION;
				      timeout = animationTimeout;
				      propCount = animationDurations.length;
				    }
				  } else {
				    timeout = Math.max(transitionTimeout, animationTimeout);
				    type = timeout > 0
				      ? transitionTimeout > animationTimeout
				        ? TRANSITION
				        : ANIMATION
				      : null;
				    propCount = type
				      ? type === TRANSITION
				        ? transitionDurations.length
				        : animationDurations.length
				      : 0;
				  }
				  var hasTransform =
				    type === TRANSITION &&
				    transformRE.test(styles[transitionProp + 'Property']);
				  return {
				    type: type,
				    timeout: timeout,
				    propCount: propCount,
				    hasTransform: hasTransform
				  }
				}

				function getTimeout (delays, durations) {
				  /* istanbul ignore next */
				  while (delays.length < durations.length) {
				    delays = delays.concat(delays);
				  }

				  return Math.max.apply(null, durations.map(function (d, i) {
				    return toMs(d) + toMs(delays[i])
				  }))
				}

				function toMs (s) {
				  return Number(s.slice(0, -1)) * 1000
				}

				/*  */

				function enter (vnode) {
				  var el = vnode.elm;

				  // call leave callback now
				  if (el._leaveCb) {
				    el._leaveCb.cancelled = true;
				    el._leaveCb();
				  }

				  var data = resolveTransition(vnode.data.transition);
				  if (!data) {
				    return
				  }

				  /* istanbul ignore if */
				  if (el._enterCb || el.nodeType !== 1) {
				    return
				  }

				  var css = data.css;
				  var type = data.type;
				  var enterClass = data.enterClass;
				  var enterActiveClass = data.enterActiveClass;
				  var appearClass = data.appearClass;
				  var appearActiveClass = data.appearActiveClass;
				  var beforeEnter = data.beforeEnter;
				  var enter = data.enter;
				  var afterEnter = data.afterEnter;
				  var enterCancelled = data.enterCancelled;
				  var beforeAppear = data.beforeAppear;
				  var appear = data.appear;
				  var afterAppear = data.afterAppear;
				  var appearCancelled = data.appearCancelled;

				  // activeInstance will always be the <transition> component managing this
				  // transition. One edge case to check is when the <transition> is placed
				  // as the root node of a child component. In that case we need to check
				  // <transition>'s parent for appear check.
				  var transitionNode = activeInstance.$vnode;
				  var context = transitionNode && transitionNode.parent
				    ? transitionNode.parent.context
				    : activeInstance;

				  var isAppear = !context._isMounted || !vnode.isRootInsert;

				  if (isAppear && !appear && appear !== '') {
				    return
				  }

				  var startClass = isAppear ? appearClass : enterClass;
				  var activeClass = isAppear ? appearActiveClass : enterActiveClass;
				  var beforeEnterHook = isAppear ? (beforeAppear || beforeEnter) : beforeEnter;
				  var enterHook = isAppear ? (typeof appear === 'function' ? appear : enter) : enter;
				  var afterEnterHook = isAppear ? (afterAppear || afterEnter) : afterEnter;
				  var enterCancelledHook = isAppear ? (appearCancelled || enterCancelled) : enterCancelled;

				  var expectsCSS = css !== false && !isIE9;
				  var userWantsControl =
				    enterHook &&
				    // enterHook may be a bound method which exposes
				    // the length of original fn as _length
				    (enterHook._length || enterHook.length) > 1;

				  var cb = el._enterCb = once(function () {
				    if (expectsCSS) {
				      removeTransitionClass(el, activeClass);
				    }
				    if (cb.cancelled) {
				      if (expectsCSS) {
				        removeTransitionClass(el, startClass);
				      }
				      enterCancelledHook && enterCancelledHook(el);
				    } else {
				      afterEnterHook && afterEnterHook(el);
				    }
				    el._enterCb = null;
				  });

				  if (!vnode.data.show) {
				    // remove pending leave element on enter by injecting an insert hook
				    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {
				      var parent = el.parentNode;
				      var pendingNode = parent && parent._pending && parent._pending[vnode.key];
				      if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {
				        pendingNode.elm._leaveCb();
				      }
				      enterHook && enterHook(el, cb);
				    }, 'transition-insert');
				  }

				  // start enter transition
				  beforeEnterHook && beforeEnterHook(el);
				  if (expectsCSS) {
				    addTransitionClass(el, startClass);
				    addTransitionClass(el, activeClass);
				    nextFrame(function () {
				      removeTransitionClass(el, startClass);
				      if (!cb.cancelled && !userWantsControl) {
				        whenTransitionEnds(el, type, cb);
				      }
				    });
				  }

				  if (vnode.data.show) {
				    enterHook && enterHook(el, cb);
				  }

				  if (!expectsCSS && !userWantsControl) {
				    cb();
				  }
				}

				function leave (vnode, rm) {
				  var el = vnode.elm;

				  // call enter callback now
				  if (el._enterCb) {
				    el._enterCb.cancelled = true;
				    el._enterCb();
				  }

				  var data = resolveTransition(vnode.data.transition);
				  if (!data) {
				    return rm()
				  }

				  /* istanbul ignore if */
				  if (el._leaveCb || el.nodeType !== 1) {
				    return
				  }

				  var css = data.css;
				  var type = data.type;
				  var leaveClass = data.leaveClass;
				  var leaveActiveClass = data.leaveActiveClass;
				  var beforeLeave = data.beforeLeave;
				  var leave = data.leave;
				  var afterLeave = data.afterLeave;
				  var leaveCancelled = data.leaveCancelled;
				  var delayLeave = data.delayLeave;

				  var expectsCSS = css !== false && !isIE9;
				  var userWantsControl =
				    leave &&
				    // leave hook may be a bound method which exposes
				    // the length of original fn as _length
				    (leave._length || leave.length) > 1;

				  var cb = el._leaveCb = once(function () {
				    if (el.parentNode && el.parentNode._pending) {
				      el.parentNode._pending[vnode.key] = null;
				    }
				    if (expectsCSS) {
				      removeTransitionClass(el, leaveActiveClass);
				    }
				    if (cb.cancelled) {
				      if (expectsCSS) {
				        removeTransitionClass(el, leaveClass);
				      }
				      leaveCancelled && leaveCancelled(el);
				    } else {
				      rm();
				      afterLeave && afterLeave(el);
				    }
				    el._leaveCb = null;
				  });

				  if (delayLeave) {
				    delayLeave(performLeave);
				  } else {
				    performLeave();
				  }

				  function performLeave () {
				    // the delayed leave may have already been cancelled
				    if (cb.cancelled) {
				      return
				    }
				    // record leaving element
				    if (!vnode.data.show) {
				      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
				    }
				    beforeLeave && beforeLeave(el);
				    if (expectsCSS) {
				      addTransitionClass(el, leaveClass);
				      addTransitionClass(el, leaveActiveClass);
				      nextFrame(function () {
				        removeTransitionClass(el, leaveClass);
				        if (!cb.cancelled && !userWantsControl) {
				          whenTransitionEnds(el, type, cb);
				        }
				      });
				    }
				    leave && leave(el, cb);
				    if (!expectsCSS && !userWantsControl) {
				      cb();
				    }
				  }
				}

				function resolveTransition (def$$1) {
				  if (!def$$1) {
				    return
				  }
				  /* istanbul ignore else */
				  if (typeof def$$1 === 'object') {
				    var res = {};
				    if (def$$1.css !== false) {
				      extend(res, autoCssTransition(def$$1.name || 'v'));
				    }
				    extend(res, def$$1);
				    return res
				  } else if (typeof def$$1 === 'string') {
				    return autoCssTransition(def$$1)
				  }
				}

				var autoCssTransition = cached(function (name) {
				  return {
				    enterClass: (name + "-enter"),
				    leaveClass: (name + "-leave"),
				    appearClass: (name + "-enter"),
				    enterActiveClass: (name + "-enter-active"),
				    leaveActiveClass: (name + "-leave-active"),
				    appearActiveClass: (name + "-enter-active")
				  }
				});

				function once (fn) {
				  var called = false;
				  return function () {
				    if (!called) {
				      called = true;
				      fn();
				    }
				  }
				}

				var transition = inBrowser ? {
				  create: function create (_, vnode) {
				    if (!vnode.data.show) {
				      enter(vnode);
				    }
				  },
				  remove: function remove (vnode, rm) {
				    /* istanbul ignore else */
				    if (!vnode.data.show) {
				      leave(vnode, rm);
				    } else {
				      rm();
				    }
				  }
				} : {};

				var platformModules = [
				  attrs,
				  klass,
				  events,
				  domProps,
				  style,
				  transition
				];

				/*  */

				// the directive module should be applied last, after all
				// built-in modules have been applied.
				var modules = platformModules.concat(baseModules);

				var patch$1 = createPatchFunction({ nodeOps: nodeOps, modules: modules });

				/**
				 * Not type checking this file because flow doesn't like attaching
				 * properties to Elements.
				 */

				var modelableTagRE = /^input|select|textarea|vue-component-[0-9]+(-[0-9a-zA-Z_-]*)?$/;

				/* istanbul ignore if */
				if (isIE9) {
				  // http://www.matts411.com/post/internet-explorer-9-oninput/
				  document.addEventListener('selectionchange', function () {
				    var el = document.activeElement;
				    if (el && el.vmodel) {
				      trigger(el, 'input');
				    }
				  });
				}

				var model = {
				  inserted: function inserted (el, binding, vnode) {
				    {
				      if (!modelableTagRE.test(vnode.tag)) {
				        warn(
				          "v-model is not supported on element type: <" + (vnode.tag) + ">. " +
				          'If you are working with contenteditable, it\'s recommended to ' +
				          'wrap a library dedicated for that purpose inside a custom component.',
				          vnode.context
				        );
				      }
				    }
				    if (vnode.tag === 'select') {
				      var cb = function () {
				        setSelected(el, binding, vnode.context);
				      };
				      cb();
				      /* istanbul ignore if */
				      if (isIE || isEdge) {
				        setTimeout(cb, 0);
				      }
				    } else if (
				      (vnode.tag === 'textarea' || el.type === 'text') &&
				      !binding.modifiers.lazy
				    ) {
				      if (!isAndroid) {
				        el.addEventListener('compositionstart', onCompositionStart);
				        el.addEventListener('compositionend', onCompositionEnd);
				      }
				      /* istanbul ignore if */
				      if (isIE9) {
				        el.vmodel = true;
				      }
				    }
				  },
				  componentUpdated: function componentUpdated (el, binding, vnode) {
				    if (vnode.tag === 'select') {
				      setSelected(el, binding, vnode.context);
				      // in case the options rendered by v-for have changed,
				      // it's possible that the value is out-of-sync with the rendered options.
				      // detect such cases and filter out values that no longer has a matching
				      // option in the DOM.
				      var needReset = el.multiple
				        ? binding.value.some(function (v) { return hasNoMatchingOption(v, el.options); })
				        : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, el.options);
				      if (needReset) {
				        trigger(el, 'change');
				      }
				    }
				  }
				};

				function setSelected (el, binding, vm) {
				  var value = binding.value;
				  var isMultiple = el.multiple;
				  if (isMultiple && !Array.isArray(value)) {
				    "development" !== 'production' && warn(
				      "<select multiple v-model=\"" + (binding.expression) + "\"> " +
				      "expects an Array value for its binding, but got " + (Object.prototype.toString.call(value).slice(8, -1)),
				      vm
				    );
				    return
				  }
				  var selected, option;
				  for (var i = 0, l = el.options.length; i < l; i++) {
				    option = el.options[i];
				    if (isMultiple) {
				      selected = looseIndexOf(value, getValue(option)) > -1;
				      if (option.selected !== selected) {
				        option.selected = selected;
				      }
				    } else {
				      if (looseEqual(getValue(option), value)) {
				        if (el.selectedIndex !== i) {
				          el.selectedIndex = i;
				        }
				        return
				      }
				    }
				  }
				  if (!isMultiple) {
				    el.selectedIndex = -1;
				  }
				}

				function hasNoMatchingOption (value, options) {
				  for (var i = 0, l = options.length; i < l; i++) {
				    if (looseEqual(getValue(options[i]), value)) {
				      return false
				    }
				  }
				  return true
				}

				function getValue (option) {
				  return '_value' in option
				    ? option._value
				    : option.value
				}

				function onCompositionStart (e) {
				  e.target.composing = true;
				}

				function onCompositionEnd (e) {
				  e.target.composing = false;
				  trigger(e.target, 'input');
				}

				function trigger (el, type) {
				  var e = document.createEvent('HTMLEvents');
				  e.initEvent(type, true, true);
				  el.dispatchEvent(e);
				}

				/*  */

				// recursively search for possible transition defined inside the component root
				function locateNode (vnode) {
				  return vnode.child && (!vnode.data || !vnode.data.transition)
				    ? locateNode(vnode.child._vnode)
				    : vnode
				}

				var show = {
				  bind: function bind (el, ref, vnode) {
				    var value = ref.value;

				    vnode = locateNode(vnode);
				    var transition = vnode.data && vnode.data.transition;
				    if (value && transition && !isIE9) {
				      enter(vnode);
				    }
				    var originalDisplay = el.style.display === 'none' ? '' : el.style.display;
				    el.style.display = value ? originalDisplay : 'none';
				    el.__vOriginalDisplay = originalDisplay;
				  },
				  update: function update (el, ref, vnode) {
				    var value = ref.value;
				    var oldValue = ref.oldValue;

				    /* istanbul ignore if */
				    if (value === oldValue) { return }
				    vnode = locateNode(vnode);
				    var transition = vnode.data && vnode.data.transition;
				    if (transition && !isIE9) {
				      if (value) {
				        enter(vnode);
				        el.style.display = el.__vOriginalDisplay;
				      } else {
				        leave(vnode, function () {
				          el.style.display = 'none';
				        });
				      }
				    } else {
				      el.style.display = value ? el.__vOriginalDisplay : 'none';
				    }
				  }
				};

				var platformDirectives = {
				  model: model,
				  show: show
				};

				/*  */

				// Provides transition support for a single element/component.
				// supports transition mode (out-in / in-out)

				var transitionProps = {
				  name: String,
				  appear: Boolean,
				  css: Boolean,
				  mode: String,
				  type: String,
				  enterClass: String,
				  leaveClass: String,
				  enterActiveClass: String,
				  leaveActiveClass: String,
				  appearClass: String,
				  appearActiveClass: String
				};

				// in case the child is also an abstract component, e.g. <keep-alive>
				// we want to recursively retrieve the real component to be rendered
				function getRealChild (vnode) {
				  var compOptions = vnode && vnode.componentOptions;
				  if (compOptions && compOptions.Ctor.options.abstract) {
				    return getRealChild(getFirstComponentChild(compOptions.children))
				  } else {
				    return vnode
				  }
				}

				function extractTransitionData (comp) {
				  var data = {};
				  var options = comp.$options;
				  // props
				  for (var key in options.propsData) {
				    data[key] = comp[key];
				  }
				  // events.
				  // extract listeners and pass them directly to the transition methods
				  var listeners = options._parentListeners;
				  for (var key$1 in listeners) {
				    data[camelize(key$1)] = listeners[key$1].fn;
				  }
				  return data
				}

				function placeholder (h, rawChild) {
				  return /\d-keep-alive$/.test(rawChild.tag)
				    ? h('keep-alive')
				    : null
				}

				function hasParentTransition (vnode) {
				  while ((vnode = vnode.parent)) {
				    if (vnode.data.transition) {
				      return true
				    }
				  }
				}

				var Transition = {
				  name: 'transition',
				  props: transitionProps,
				  abstract: true,
				  render: function render (h) {
				    var this$1 = this;

				    var children = this.$slots.default;
				    if (!children) {
				      return
				    }

				    // filter out text nodes (possible whitespaces)
				    children = children.filter(function (c) { return c.tag; });
				    /* istanbul ignore if */
				    if (!children.length) {
				      return
				    }

				    // warn multiple elements
				    if ("development" !== 'production' && children.length > 1) {
				      warn(
				        '<transition> can only be used on a single element. Use ' +
				        '<transition-group> for lists.',
				        this.$parent
				      );
				    }

				    var mode = this.mode;

				    // warn invalid mode
				    if ("development" !== 'production' &&
				        mode && mode !== 'in-out' && mode !== 'out-in') {
				      warn(
				        'invalid <transition> mode: ' + mode,
				        this.$parent
				      );
				    }

				    var rawChild = children[0];

				    // if this is a component root node and the component's
				    // parent container node also has transition, skip.
				    if (hasParentTransition(this.$vnode)) {
				      return rawChild
				    }

				    // apply transition data to child
				    // use getRealChild() to ignore abstract components e.g. keep-alive
				    var child = getRealChild(rawChild);
				    /* istanbul ignore if */
				    if (!child) {
				      return rawChild
				    }

				    if (this._leaving) {
				      return placeholder(h, rawChild)
				    }

				    var key = child.key = child.key == null || child.isStatic
				      ? ("__v" + (child.tag + this._uid) + "__")
				      : child.key;
				    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
				    var oldRawChild = this._vnode;
				    var oldChild = getRealChild(oldRawChild);

				    // mark v-show
				    // so that the transition module can hand over the control to the directive
				    if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {
				      child.data.show = true;
				    }

				    if (oldChild && oldChild.data && oldChild.key !== key) {
				      // replace old child transition data with fresh one
				      // important for dynamic transitions!
				      var oldData = oldChild.data.transition = extend({}, data);

				      // handle transition mode
				      if (mode === 'out-in') {
				        // return placeholder node and queue update when leave finishes
				        this._leaving = true;
				        mergeVNodeHook(oldData, 'afterLeave', function () {
				          this$1._leaving = false;
				          this$1.$forceUpdate();
				        }, key);
				        return placeholder(h, rawChild)
				      } else if (mode === 'in-out') {
				        var delayedLeave;
				        var performLeave = function () { delayedLeave(); };
				        mergeVNodeHook(data, 'afterEnter', performLeave, key);
				        mergeVNodeHook(data, 'enterCancelled', performLeave, key);
				        mergeVNodeHook(oldData, 'delayLeave', function (leave) {
				          delayedLeave = leave;
				        }, key);
				      }
				    }

				    return rawChild
				  }
				};

				/*  */

				// Provides transition support for list items.
				// supports move transitions using the FLIP technique.

				// Because the vdom's children update algorithm is "unstable" - i.e.
				// it doesn't guarantee the relative positioning of removed elements,
				// we force transition-group to update its children into two passes:
				// in the first pass, we remove all nodes that need to be removed,
				// triggering their leaving transition; in the second pass, we insert/move
				// into the final disired state. This way in the second pass removed
				// nodes will remain where they should be.

				var props = extend({
				  tag: String,
				  moveClass: String
				}, transitionProps);

				delete props.mode;

				var TransitionGroup = {
				  props: props,

				  render: function render (h) {
				    var tag = this.tag || this.$vnode.data.tag || 'span';
				    var map = Object.create(null);
				    var prevChildren = this.prevChildren = this.children;
				    var rawChildren = this.$slots.default || [];
				    var children = this.children = [];
				    var transitionData = extractTransitionData(this);

				    for (var i = 0; i < rawChildren.length; i++) {
				      var c = rawChildren[i];
				      if (c.tag) {
				        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
				          children.push(c);
				          map[c.key] = c
				          ;(c.data || (c.data = {})).transition = transitionData;
				        } else {
				          var opts = c.componentOptions;
				          var name = opts
				            ? (opts.Ctor.options.name || opts.tag)
				            : c.tag;
				          warn(("<transition-group> children must be keyed: <" + name + ">"));
				        }
				      }
				    }

				    if (prevChildren) {
				      var kept = [];
				      var removed = [];
				      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
				        var c$1 = prevChildren[i$1];
				        c$1.data.transition = transitionData;
				        c$1.data.pos = c$1.elm.getBoundingClientRect();
				        if (map[c$1.key]) {
				          kept.push(c$1);
				        } else {
				          removed.push(c$1);
				        }
				      }
				      this.kept = h(tag, null, kept);
				      this.removed = removed;
				    }

				    return h(tag, null, children)
				  },

				  beforeUpdate: function beforeUpdate () {
				    // force removing pass
				    this.__patch__(
				      this._vnode,
				      this.kept,
				      false, // hydrating
				      true // removeOnly (!important, avoids unnecessary moves)
				    );
				    this._vnode = this.kept;
				  },

				  updated: function updated () {
				    var children = this.prevChildren;
				    var moveClass = this.moveClass || (this.name + '-move');
				    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
				      return
				    }

				    // we divide the work into three loops to avoid mixing DOM reads and writes
				    // in each iteration - which helps prevent layout thrashing.
				    children.forEach(callPendingCbs);
				    children.forEach(recordPosition);
				    children.forEach(applyTranslation);

				    // force reflow to put everything in position
				    var f = document.body.offsetHeight; // eslint-disable-line

				    children.forEach(function (c) {
				      if (c.data.moved) {
				        var el = c.elm;
				        var s = el.style;
				        addTransitionClass(el, moveClass);
				        s.transform = s.WebkitTransform = s.transitionDuration = '';
				        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {
				          if (!e || /transform$/.test(e.propertyName)) {
				            el.removeEventListener(transitionEndEvent, cb);
				            el._moveCb = null;
				            removeTransitionClass(el, moveClass);
				          }
				        });
				      }
				    });
				  },

				  methods: {
				    hasMove: function hasMove (el, moveClass) {
				      /* istanbul ignore if */
				      if (!hasTransition) {
				        return false
				      }
				      if (this._hasMove != null) {
				        return this._hasMove
				      }
				      addTransitionClass(el, moveClass);
				      var info = getTransitionInfo(el);
				      removeTransitionClass(el, moveClass);
				      return (this._hasMove = info.hasTransform)
				    }
				  }
				};

				function callPendingCbs (c) {
				  /* istanbul ignore if */
				  if (c.elm._moveCb) {
				    c.elm._moveCb();
				  }
				  /* istanbul ignore if */
				  if (c.elm._enterCb) {
				    c.elm._enterCb();
				  }
				}

				function recordPosition (c) {
				  c.data.newPos = c.elm.getBoundingClientRect();
				}

				function applyTranslation (c) {
				  var oldPos = c.data.pos;
				  var newPos = c.data.newPos;
				  var dx = oldPos.left - newPos.left;
				  var dy = oldPos.top - newPos.top;
				  if (dx || dy) {
				    c.data.moved = true;
				    var s = c.elm.style;
				    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
				    s.transitionDuration = '0s';
				  }
				}

				var platformComponents = {
				  Transition: Transition,
				  TransitionGroup: TransitionGroup
				};

				/*  */

				// install platform specific utils
				Vue$2.config.isUnknownElement = isUnknownElement;
				Vue$2.config.isReservedTag = isReservedTag;
				Vue$2.config.getTagNamespace = getTagNamespace;
				Vue$2.config.mustUseProp = mustUseProp;

				// install platform runtime directives & components
				extend(Vue$2.options.directives, platformDirectives);
				extend(Vue$2.options.components, platformComponents);

				// install platform patch function
				Vue$2.prototype.__patch__ = config._isServer ? noop : patch$1;

				// wrap mount
				Vue$2.prototype.$mount = function (
				  el,
				  hydrating
				) {
				  el = el && !config._isServer ? query(el) : undefined;
				  return this._mount(el, hydrating)
				};

				// devtools global hook
				/* istanbul ignore next */
				setTimeout(function () {
				  if (config.devtools) {
				    if (devtools) {
				      devtools.emit('init', Vue$2);
				    } else if (
				      "development" !== 'production' &&
				      inBrowser && /Chrome\/\d+/.test(window.navigator.userAgent)
				    ) {
				      console.log(
				        'Download the Vue Devtools for a better development experience:\n' +
				        'https://github.com/vuejs/vue-devtools'
				      );
				    }
				  }
				}, 0);

				/*  */

				// check whether current browser encodes a char inside attribute values
				function shouldDecode (content, encoded) {
				  var div = document.createElement('div');
				  div.innerHTML = "<div a=\"" + content + "\">";
				  return div.innerHTML.indexOf(encoded) > 0
				}

				// #3663
				// IE encodes newlines inside attribute values while other browsers don't
				var shouldDecodeNewlines = inBrowser ? shouldDecode('\n', '&#10;') : false;

				/*  */

				var decoder = document.createElement('div');

				function decode (html) {
				  decoder.innerHTML = html;
				  return decoder.textContent
				}

				/**
				 * Not type-checking this file because it's mostly vendor code.
				 */

				/*!
				 * HTML Parser By John Resig (ejohn.org)
				 * Modified by Juriy "kangax" Zaytsev
				 * Original code by Erik Arvidsson, Mozilla Public License
				 * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
				 */

				// Regular Expressions for parsing tags and attributes
				var singleAttrIdentifier = /([^\s"'<>/=]+)/;
				var singleAttrAssign = /(?:=)/;
				var singleAttrValues = [
				  // attr value double quotes
				  /"([^"]*)"+/.source,
				  // attr value, single quotes
				  /'([^']*)'+/.source,
				  // attr value, no quotes
				  /([^\s"'=<>`]+)/.source
				];
				var attribute = new RegExp(
				  '^\\s*' + singleAttrIdentifier.source +
				  '(?:\\s*(' + singleAttrAssign.source + ')' +
				  '\\s*(?:' + singleAttrValues.join('|') + '))?'
				);

				// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName
				// but for Vue templates we can enforce a simple charset
				var ncname = '[a-zA-Z_][\\w\\-\\.]*';
				var qnameCapture = '((?:' + ncname + '\\:)?' + ncname + ')';
				var startTagOpen = new RegExp('^<' + qnameCapture);
				var startTagClose = /^\s*(\/?)>/;
				var endTag = new RegExp('^<\\/' + qnameCapture + '[^>]*>');
				var doctype = /^<!DOCTYPE [^>]+>/i;
				var comment = /^<!--/;
				var conditionalComment = /^<!\[/;

				var IS_REGEX_CAPTURING_BROKEN = false;
				'x'.replace(/x(.)?/g, function (m, g) {
				  IS_REGEX_CAPTURING_BROKEN = g === '';
				});

				// Special Elements (can contain anything)
				var isScriptOrStyle = makeMap('script,style', true);
				var hasLang = function (attr) { return attr.name === 'lang' && attr.value !== 'html'; };
				var isSpecialTag = function (tag, isSFC, stack) {
				  if (isScriptOrStyle(tag)) {
				    return true
				  }
				  // top-level template that has a pre-processor
				  if (
				    isSFC &&
				    tag === 'template' &&
				    stack.length === 1 &&
				    stack[0].attrs.some(hasLang)
				  ) {
				    return true
				  }
				  return false
				};

				var reCache = {};

				var ltRE = /&lt;/g;
				var gtRE = /&gt;/g;
				var nlRE = /&#10;/g;
				var ampRE = /&amp;/g;
				var quoteRE = /&quot;/g;

				function decodeAttr (value, shouldDecodeNewlines) {
				  if (shouldDecodeNewlines) {
				    value = value.replace(nlRE, '\n');
				  }
				  return value
				    .replace(ltRE, '<')
				    .replace(gtRE, '>')
				    .replace(ampRE, '&')
				    .replace(quoteRE, '"')
				}

				function parseHTML (html, options) {
				  var stack = [];
				  var expectHTML = options.expectHTML;
				  var isUnaryTag$$1 = options.isUnaryTag || no;
				  var index = 0;
				  var last, lastTag;
				  while (html) {
				    last = html;
				    // Make sure we're not in a script or style element
				    if (!lastTag || !isSpecialTag(lastTag, options.sfc, stack)) {
				      var textEnd = html.indexOf('<');
				      if (textEnd === 0) {
				        // Comment:
				        if (comment.test(html)) {
				          var commentEnd = html.indexOf('-->');

				          if (commentEnd >= 0) {
				            advance(commentEnd + 3);
				            continue
				          }
				        }

				        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
				        if (conditionalComment.test(html)) {
				          var conditionalEnd = html.indexOf(']>');

				          if (conditionalEnd >= 0) {
				            advance(conditionalEnd + 2);
				            continue
				          }
				        }

				        // Doctype:
				        var doctypeMatch = html.match(doctype);
				        if (doctypeMatch) {
				          advance(doctypeMatch[0].length);
				          continue
				        }

				        // End tag:
				        var endTagMatch = html.match(endTag);
				        if (endTagMatch) {
				          var curIndex = index;
				          advance(endTagMatch[0].length);
				          parseEndTag(endTagMatch[0], endTagMatch[1], curIndex, index);
				          continue
				        }

				        // Start tag:
				        var startTagMatch = parseStartTag();
				        if (startTagMatch) {
				          handleStartTag(startTagMatch);
				          continue
				        }
				      }

				      var text = void 0, rest$1 = void 0, next = void 0;
				      if (textEnd > 0) {
				        rest$1 = html.slice(textEnd);
				        while (
				          !endTag.test(rest$1) &&
				          !startTagOpen.test(rest$1) &&
				          !comment.test(rest$1) &&
				          !conditionalComment.test(rest$1)
				        ) {
				          // < in plain text, be forgiving and treat it as text
				          next = rest$1.indexOf('<', 1);
				          if (next < 0) { break }
				          textEnd += next;
				          rest$1 = html.slice(textEnd);
				        }
				        text = html.substring(0, textEnd);
				        advance(textEnd);
				      }

				      if (textEnd < 0) {
				        text = html;
				        html = '';
				      }

				      if (options.chars && text) {
				        options.chars(text);
				      }
				    } else {
				      var stackedTag = lastTag.toLowerCase();
				      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));
				      var endTagLength = 0;
				      var rest = html.replace(reStackedTag, function (all, text, endTag) {
				        endTagLength = endTag.length;
				        if (stackedTag !== 'script' && stackedTag !== 'style' && stackedTag !== 'noscript') {
				          text = text
				            .replace(/<!--([\s\S]*?)-->/g, '$1')
				            .replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
				        }
				        if (options.chars) {
				          options.chars(text);
				        }
				        return ''
				      });
				      index += html.length - rest.length;
				      html = rest;
				      parseEndTag('</' + stackedTag + '>', stackedTag, index - endTagLength, index);
				    }

				    if (html === last && options.chars) {
				      options.chars(html);
				      break
				    }
				  }

				  // Clean up any remaining tags
				  parseEndTag();

				  function advance (n) {
				    index += n;
				    html = html.substring(n);
				  }

				  function parseStartTag () {
				    var start = html.match(startTagOpen);
				    if (start) {
				      var match = {
				        tagName: start[1],
				        attrs: [],
				        start: index
				      };
				      advance(start[0].length);
				      var end, attr;
				      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {
				        advance(attr[0].length);
				        match.attrs.push(attr);
				      }
				      if (end) {
				        match.unarySlash = end[1];
				        advance(end[0].length);
				        match.end = index;
				        return match
				      }
				    }
				  }

				  function handleStartTag (match) {
				    var tagName = match.tagName;
				    var unarySlash = match.unarySlash;

				    if (expectHTML) {
				      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
				        parseEndTag('', lastTag);
				      }
				      if (canBeLeftOpenTag(tagName) && lastTag === tagName) {
				        parseEndTag('', tagName);
				      }
				    }

				    var unary = isUnaryTag$$1(tagName) || tagName === 'html' && lastTag === 'head' || !!unarySlash;

				    var l = match.attrs.length;
				    var attrs = new Array(l);
				    for (var i = 0; i < l; i++) {
				      var args = match.attrs[i];
				      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778
				      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('""') === -1) {
				        if (args[3] === '') { delete args[3]; }
				        if (args[4] === '') { delete args[4]; }
				        if (args[5] === '') { delete args[5]; }
				      }
				      var value = args[3] || args[4] || args[5] || '';
				      attrs[i] = {
				        name: args[1],
				        value: decodeAttr(
				          value,
				          options.shouldDecodeNewlines
				        )
				      };
				    }

				    if (!unary) {
				      stack.push({ tag: tagName, attrs: attrs });
				      lastTag = tagName;
				      unarySlash = '';
				    }

				    if (options.start) {
				      options.start(tagName, attrs, unary, match.start, match.end);
				    }
				  }

				  function parseEndTag (tag, tagName, start, end) {
				    var pos;
				    if (start == null) { start = index; }
				    if (end == null) { end = index; }

				    // Find the closest opened tag of the same type
				    if (tagName) {
				      var needle = tagName.toLowerCase();
				      for (pos = stack.length - 1; pos >= 0; pos--) {
				        if (stack[pos].tag.toLowerCase() === needle) {
				          break
				        }
				      }
				    } else {
				      // If no tag name is provided, clean shop
				      pos = 0;
				    }

				    if (pos >= 0) {
				      // Close all the open elements, up the stack
				      for (var i = stack.length - 1; i >= pos; i--) {
				        if (options.end) {
				          options.end(stack[i].tag, start, end);
				        }
				      }

				      // Remove the open elements from the stack
				      stack.length = pos;
				      lastTag = pos && stack[pos - 1].tag;
				    } else if (tagName.toLowerCase() === 'br') {
				      if (options.start) {
				        options.start(tagName, [], true, start, end);
				      }
				    } else if (tagName.toLowerCase() === 'p') {
				      if (options.start) {
				        options.start(tagName, [], false, start, end);
				      }
				      if (options.end) {
				        options.end(tagName, start, end);
				      }
				    }
				  }
				}

				/*  */

				function parseFilters (exp) {
				  var inSingle = false;
				  var inDouble = false;
				  var curly = 0;
				  var square = 0;
				  var paren = 0;
				  var lastFilterIndex = 0;
				  var c, prev, i, expression, filters;

				  for (i = 0; i < exp.length; i++) {
				    prev = c;
				    c = exp.charCodeAt(i);
				    if (inSingle) {
				      // check single quote
				      if (c === 0x27 && prev !== 0x5C) { inSingle = !inSingle; }
				    } else if (inDouble) {
				      // check double quote
				      if (c === 0x22 && prev !== 0x5C) { inDouble = !inDouble; }
				    } else if (
				      c === 0x7C && // pipe
				      exp.charCodeAt(i + 1) !== 0x7C &&
				      exp.charCodeAt(i - 1) !== 0x7C &&
				      !curly && !square && !paren
				    ) {
				      if (expression === undefined) {
				        // first filter, end of expression
				        lastFilterIndex = i + 1;
				        expression = exp.slice(0, i).trim();
				      } else {
				        pushFilter();
				      }
				    } else {
				      switch (c) {
				        case 0x22: inDouble = true; break // "
				        case 0x27: inSingle = true; break // '
				        case 0x28: paren++; break         // (
				        case 0x29: paren--; break         // )
				        case 0x5B: square++; break        // [
				        case 0x5D: square--; break        // ]
				        case 0x7B: curly++; break         // {
				        case 0x7D: curly--; break         // }
				      }
				    }
				  }

				  if (expression === undefined) {
				    expression = exp.slice(0, i).trim();
				  } else if (lastFilterIndex !== 0) {
				    pushFilter();
				  }

				  function pushFilter () {
				    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
				    lastFilterIndex = i + 1;
				  }

				  if (filters) {
				    for (i = 0; i < filters.length; i++) {
				      expression = wrapFilter(expression, filters[i]);
				    }
				  }

				  return expression
				}

				function wrapFilter (exp, filter) {
				  var i = filter.indexOf('(');
				  if (i < 0) {
				    // _f: resolveFilter
				    return ("_f(\"" + filter + "\")(" + exp + ")")
				  } else {
				    var name = filter.slice(0, i);
				    var args = filter.slice(i + 1);
				    return ("_f(\"" + name + "\")(" + exp + "," + args)
				  }
				}

				/*  */

				var defaultTagRE = /\{\{((?:.|\n)+?)\}\}/g;
				var regexEscapeRE = /[-.*+?^${}()|[\]/\\]/g;

				var buildRegex = cached(function (delimiters) {
				  var open = delimiters[0].replace(regexEscapeRE, '\\$&');
				  var close = delimiters[1].replace(regexEscapeRE, '\\$&');
				  return new RegExp(open + '((?:.|\\n)+?)' + close, 'g')
				});

				function parseText (
				  text,
				  delimiters
				) {
				  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;
				  if (!tagRE.test(text)) {
				    return
				  }
				  var tokens = [];
				  var lastIndex = tagRE.lastIndex = 0;
				  var match, index;
				  while ((match = tagRE.exec(text))) {
				    index = match.index;
				    // push text token
				    if (index > lastIndex) {
				      tokens.push(JSON.stringify(text.slice(lastIndex, index)));
				    }
				    // tag token
				    var exp = parseFilters(match[1].trim());
				    tokens.push(("_s(" + exp + ")"));
				    lastIndex = index + match[0].length;
				  }
				  if (lastIndex < text.length) {
				    tokens.push(JSON.stringify(text.slice(lastIndex)));
				  }
				  return tokens.join('+')
				}

				/*  */

				function baseWarn (msg) {
				  console.error(("[Vue parser]: " + msg));
				}

				function pluckModuleFunction (
				  modules,
				  key
				) {
				  return modules
				    ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })
				    : []
				}

				function addProp (el, name, value) {
				  (el.props || (el.props = [])).push({ name: name, value: value });
				}

				function addAttr (el, name, value) {
				  (el.attrs || (el.attrs = [])).push({ name: name, value: value });
				}

				function addDirective (
				  el,
				  name,
				  rawName,
				  value,
				  arg,
				  modifiers
				) {
				  (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });
				}

				function addHandler (
				  el,
				  name,
				  value,
				  modifiers,
				  important
				) {
				  // check capture modifier
				  if (modifiers && modifiers.capture) {
				    delete modifiers.capture;
				    name = '!' + name; // mark the event as captured
				  }
				  var events;
				  if (modifiers && modifiers.native) {
				    delete modifiers.native;
				    events = el.nativeEvents || (el.nativeEvents = {});
				  } else {
				    events = el.events || (el.events = {});
				  }
				  var newHandler = { value: value, modifiers: modifiers };
				  var handlers = events[name];
				  /* istanbul ignore if */
				  if (Array.isArray(handlers)) {
				    important ? handlers.unshift(newHandler) : handlers.push(newHandler);
				  } else if (handlers) {
				    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
				  } else {
				    events[name] = newHandler;
				  }
				}

				function getBindingAttr (
				  el,
				  name,
				  getStatic
				) {
				  var dynamicValue =
				    getAndRemoveAttr(el, ':' + name) ||
				    getAndRemoveAttr(el, 'v-bind:' + name);
				  if (dynamicValue != null) {
				    return dynamicValue
				  } else if (getStatic !== false) {
				    var staticValue = getAndRemoveAttr(el, name);
				    if (staticValue != null) {
				      return JSON.stringify(staticValue)
				    }
				  }
				}

				function getAndRemoveAttr (el, name) {
				  var val;
				  if ((val = el.attrsMap[name]) != null) {
				    var list = el.attrsList;
				    for (var i = 0, l = list.length; i < l; i++) {
				      if (list[i].name === name) {
				        list.splice(i, 1);
				        break
				      }
				    }
				  }
				  return val
				}

				/*  */

				var dirRE = /^v-|^@|^:/;
				var forAliasRE = /(.*?)\s+(?:in|of)\s+(.*)/;
				var forIteratorRE = /\(([^,]*),([^,]*)(?:,([^,]*))?\)/;
				var bindRE = /^:|^v-bind:/;
				var onRE = /^@|^v-on:/;
				var argRE = /:(.*)$/;
				var modifierRE = /\.[^.]+/g;
				var specialNewlineRE = /\u2028|\u2029/g;

				var decodeHTMLCached = cached(decode);

				// configurable state
				var warn$1;
				var platformGetTagNamespace;
				var platformMustUseProp;
				var platformIsPreTag;
				var preTransforms;
				var transforms;
				var postTransforms;
				var delimiters;

				/**
				 * Convert HTML string to AST.
				 */
				function parse (
				  template,
				  options
				) {
				  warn$1 = options.warn || baseWarn;
				  platformGetTagNamespace = options.getTagNamespace || no;
				  platformMustUseProp = options.mustUseProp || no;
				  platformIsPreTag = options.isPreTag || no;
				  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');
				  transforms = pluckModuleFunction(options.modules, 'transformNode');
				  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');
				  delimiters = options.delimiters;
				  var stack = [];
				  var preserveWhitespace = options.preserveWhitespace !== false;
				  var root;
				  var currentParent;
				  var inVPre = false;
				  var inPre = false;
				  var warned = false;
				  parseHTML(template, {
				    expectHTML: options.expectHTML,
				    isUnaryTag: options.isUnaryTag,
				    shouldDecodeNewlines: options.shouldDecodeNewlines,
				    start: function start (tag, attrs, unary) {
				      // check namespace.
				      // inherit parent ns if there is one
				      var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);

				      // handle IE svg bug
				      /* istanbul ignore if */
				      if (options.isIE && ns === 'svg') {
				        attrs = guardIESVGBug(attrs);
				      }

				      var element = {
				        type: 1,
				        tag: tag,
				        attrsList: attrs,
				        attrsMap: makeAttrsMap(attrs, options.isIE),
				        parent: currentParent,
				        children: []
				      };
				      if (ns) {
				        element.ns = ns;
				      }

				      if ("client" !== 'server' && isForbiddenTag(element)) {
				        element.forbidden = true;
				        "development" !== 'production' && warn$1(
				          'Templates should only be responsible for mapping the state to the ' +
				          'UI. Avoid placing tags with side-effects in your templates, such as ' +
				          "<" + tag + ">."
				        );
				      }

				      // apply pre-transforms
				      for (var i = 0; i < preTransforms.length; i++) {
				        preTransforms[i](element, options);
				      }

				      if (!inVPre) {
				        processPre(element);
				        if (element.pre) {
				          inVPre = true;
				        }
				      }
				      if (platformIsPreTag(element.tag)) {
				        inPre = true;
				      }
				      if (inVPre) {
				        processRawAttrs(element);
				      } else {
				        processFor(element);
				        processIf(element);
				        processOnce(element);
				        processKey(element);

				        // determine whether this is a plain element after
				        // removing structural attributes
				        element.plain = !element.key && !attrs.length;

				        processRef(element);
				        processSlot(element);
				        processComponent(element);
				        for (var i$1 = 0; i$1 < transforms.length; i$1++) {
				          transforms[i$1](element, options);
				        }
				        processAttrs(element);
				      }

				      function checkRootConstraints (el) {
				        if ("development" !== 'production' && !warned) {
				          if (el.tag === 'slot' || el.tag === 'template') {
				            warned = true;
				            warn$1(
				              "Cannot use <" + (el.tag) + "> as component root element because it may " +
				              'contain multiple nodes:\n' + template
				            );
				          }
				          if (el.attrsMap.hasOwnProperty('v-for')) {
				            warned = true;
				            warn$1(
				              'Cannot use v-for on stateful component root element because ' +
				              'it renders multiple elements:\n' + template
				            );
				          }
				        }
				      }

				      // tree management
				      if (!root) {
				        root = element;
				        checkRootConstraints(root);
				      } else if (!stack.length) {
				        // allow 2 root elements with v-if and v-else
				        if (root.if && element.else) {
				          checkRootConstraints(element);
				          root.elseBlock = element;
				        } else if ("development" !== 'production' && !warned) {
				          warned = true;
				          warn$1(
				            ("Component template should contain exactly one root element:\n\n" + template)
				          );
				        }
				      }
				      if (currentParent && !element.forbidden) {
				        if (element.else) {
				          processElse(element, currentParent);
				        } else {
				          currentParent.children.push(element);
				          element.parent = currentParent;
				        }
				      }
				      if (!unary) {
				        currentParent = element;
				        stack.push(element);
				      }
				      // apply post-transforms
				      for (var i$2 = 0; i$2 < postTransforms.length; i$2++) {
				        postTransforms[i$2](element, options);
				      }
				    },

				    end: function end () {
				      // remove trailing whitespace
				      var element = stack[stack.length - 1];
				      var lastNode = element.children[element.children.length - 1];
				      if (lastNode && lastNode.type === 3 && lastNode.text === ' ') {
				        element.children.pop();
				      }
				      // pop stack
				      stack.length -= 1;
				      currentParent = stack[stack.length - 1];
				      // check pre state
				      if (element.pre) {
				        inVPre = false;
				      }
				      if (platformIsPreTag(element.tag)) {
				        inPre = false;
				      }
				    },

				    chars: function chars (text) {
				      if (!currentParent) {
				        if ("development" !== 'production' && !warned && text === template) {
				          warned = true;
				          warn$1(
				            'Component template requires a root element, rather than just text:\n\n' + template
				          );
				        }
				        return
				      }
				      text = inPre || text.trim()
				        ? decodeHTMLCached(text)
				        // only preserve whitespace if its not right after a starting tag
				        : preserveWhitespace && currentParent.children.length ? ' ' : '';
				      if (text) {
				        var expression;
				        if (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {
				          currentParent.children.push({
				            type: 2,
				            expression: expression,
				            text: text
				          });
				        } else {
				          // #3895 special character
				          text = text.replace(specialNewlineRE, '');
				          currentParent.children.push({
				            type: 3,
				            text: text
				          });
				        }
				      }
				    }
				  });
				  return root
				}

				function processPre (el) {
				  if (getAndRemoveAttr(el, 'v-pre') != null) {
				    el.pre = true;
				  }
				}

				function processRawAttrs (el) {
				  var l = el.attrsList.length;
				  if (l) {
				    var attrs = el.attrs = new Array(l);
				    for (var i = 0; i < l; i++) {
				      attrs[i] = {
				        name: el.attrsList[i].name,
				        value: JSON.stringify(el.attrsList[i].value)
				      };
				    }
				  } else if (!el.pre) {
				    // non root node in pre blocks with no attributes
				    el.plain = true;
				  }
				}

				function processKey (el) {
				  var exp = getBindingAttr(el, 'key');
				  if (exp) {
				    if ("development" !== 'production' && el.tag === 'template') {
				      warn$1("<template> cannot be keyed. Place the key on real elements instead.");
				    }
				    el.key = exp;
				  }
				}

				function processRef (el) {
				  var ref = getBindingAttr(el, 'ref');
				  if (ref) {
				    el.ref = ref;
				    el.refInFor = checkInFor(el);
				  }
				}

				function processFor (el) {
				  var exp;
				  if ((exp = getAndRemoveAttr(el, 'v-for'))) {
				    var inMatch = exp.match(forAliasRE);
				    if (!inMatch) {
				      "development" !== 'production' && warn$1(
				        ("Invalid v-for expression: " + exp)
				      );
				      return
				    }
				    el.for = inMatch[2].trim();
				    var alias = inMatch[1].trim();
				    var iteratorMatch = alias.match(forIteratorRE);
				    if (iteratorMatch) {
				      el.alias = iteratorMatch[1].trim();
				      el.iterator1 = iteratorMatch[2].trim();
				      if (iteratorMatch[3]) {
				        el.iterator2 = iteratorMatch[3].trim();
				      }
				    } else {
				      el.alias = alias;
				    }
				  }
				}

				function processIf (el) {
				  var exp = getAndRemoveAttr(el, 'v-if');
				  if (exp) {
				    el.if = exp;
				  }
				  if (getAndRemoveAttr(el, 'v-else') != null) {
				    el.else = true;
				  }
				}

				function processElse (el, parent) {
				  var prev = findPrevElement(parent.children);
				  if (prev && prev.if) {
				    prev.elseBlock = el;
				  } else {
				    warn$1(
				      ("v-else used on element <" + (el.tag) + "> without corresponding v-if.")
				    );
				  }
				}

				function processOnce (el) {
				  var once = getAndRemoveAttr(el, 'v-once');
				  if (once != null) {
				    el.once = true;
				  }
				}

				function processSlot (el) {
				  if (el.tag === 'slot') {
				    el.slotName = getBindingAttr(el, 'name');
				  } else {
				    var slotTarget = getBindingAttr(el, 'slot');
				    if (slotTarget) {
				      el.slotTarget = slotTarget;
				    }
				  }
				}

				function processComponent (el) {
				  var binding;
				  if ((binding = getBindingAttr(el, 'is'))) {
				    el.component = binding;
				  }
				  if (getAndRemoveAttr(el, 'inline-template') != null) {
				    el.inlineTemplate = true;
				  }
				}

				function processAttrs (el) {
				  var list = el.attrsList;
				  var i, l, name, rawName, value, arg, modifiers, isProp;
				  for (i = 0, l = list.length; i < l; i++) {
				    name = rawName = list[i].name;
				    value = list[i].value;
				    if (dirRE.test(name)) {
				      // mark element as dynamic
				      el.hasBindings = true;
				      // modifiers
				      modifiers = parseModifiers(name);
				      if (modifiers) {
				        name = name.replace(modifierRE, '');
				      }
				      if (bindRE.test(name)) { // v-bind
				        name = name.replace(bindRE, '');
				        if (modifiers && modifiers.prop) {
				          isProp = true;
				          name = camelize(name);
				          if (name === 'innerHtml') { name = 'innerHTML'; }
				        }
				        if (isProp || platformMustUseProp(name)) {
				          addProp(el, name, value);
				        } else {
				          addAttr(el, name, value);
				        }
				      } else if (onRE.test(name)) { // v-on
				        name = name.replace(onRE, '');
				        addHandler(el, name, value, modifiers);
				      } else { // normal directives
				        name = name.replace(dirRE, '');
				        // parse arg
				        var argMatch = name.match(argRE);
				        if (argMatch && (arg = argMatch[1])) {
				          name = name.slice(0, -(arg.length + 1));
				        }
				        addDirective(el, name, rawName, value, arg, modifiers);
				        if ("development" !== 'production' && name === 'model') {
				          checkForAliasModel(el, value);
				        }
				      }
				    } else {
				      // literal attribute
				      {
				        var expression = parseText(value, delimiters);
				        if (expression) {
				          warn$1(
				            name + "=\"" + value + "\": " +
				            'Interpolation inside attributes has been removed. ' +
				            'Use v-bind or the colon shorthand instead. For example, ' +
				            'instead of <div id="{{ val }}">, use <div :id="val">.'
				          );
				        }
				      }
				      addAttr(el, name, JSON.stringify(value));
				    }
				  }
				}

				function checkInFor (el) {
				  var parent = el;
				  while (parent) {
				    if (parent.for !== undefined) {
				      return true
				    }
				    parent = parent.parent;
				  }
				  return false
				}

				function parseModifiers (name) {
				  var match = name.match(modifierRE);
				  if (match) {
				    var ret = {};
				    match.forEach(function (m) { ret[m.slice(1)] = true; });
				    return ret
				  }
				}

				function makeAttrsMap (attrs, isIE) {
				  var map = {};
				  for (var i = 0, l = attrs.length; i < l; i++) {
				    if ("development" !== 'production' && map[attrs[i].name] && !isIE) {
				      warn$1('duplicate attribute: ' + attrs[i].name);
				    }
				    map[attrs[i].name] = attrs[i].value;
				  }
				  return map
				}

				function findPrevElement (children) {
				  var i = children.length;
				  while (i--) {
				    if (children[i].tag) { return children[i] }
				  }
				}

				function isForbiddenTag (el) {
				  return (
				    el.tag === 'style' ||
				    (el.tag === 'script' && (
				      !el.attrsMap.type ||
				      el.attrsMap.type === 'text/javascript'
				    ))
				  )
				}

				var ieNSBug = /^xmlns:NS\d+/;
				var ieNSPrefix = /^NS\d+:/;

				/* istanbul ignore next */
				function guardIESVGBug (attrs) {
				  var res = [];
				  for (var i = 0; i < attrs.length; i++) {
				    var attr = attrs[i];
				    if (!ieNSBug.test(attr.name)) {
				      attr.name = attr.name.replace(ieNSPrefix, '');
				      res.push(attr);
				    }
				  }
				  return res
				}

				function checkForAliasModel (el, value) {
				  var _el = el;
				  while (_el) {
				    if (_el.for && _el.alias === value) {
				      warn$1(
				        "<" + (el.tag) + " v-model=\"" + value + "\">: " +
				        "You are binding v-model directly to a v-for iteration alias. " +
				        "This will not be able to modify the v-for source array because " +
				        "writing to the alias is like modifying a function local variable. " +
				        "Consider using an array of objects and use v-model on an object property instead."
				      );
				    }
				    _el = _el.parent;
				  }
				}

				/*  */

				var isStaticKey;
				var isPlatformReservedTag;

				var genStaticKeysCached = cached(genStaticKeys$1);

				/**
				 * Goal of the optimizer: walk the generated template AST tree
				 * and detect sub-trees that are purely static, i.e. parts of
				 * the DOM that never needs to change.
				 *
				 * Once we detect these sub-trees, we can:
				 *
				 * 1. Hoist them into constants, so that we no longer need to
				 *    create fresh nodes for them on each re-render;
				 * 2. Completely skip them in the patching process.
				 */
				function optimize (root, options) {
				  if (!root) { return }
				  isStaticKey = genStaticKeysCached(options.staticKeys || '');
				  isPlatformReservedTag = options.isReservedTag || (function () { return false; });
				  // first pass: mark all non-static nodes.
				  markStatic(root);
				  // second pass: mark static roots.
				  markStaticRoots(root, false);
				}

				function genStaticKeys$1 (keys) {
				  return makeMap(
				    'type,tag,attrsList,attrsMap,plain,parent,children,attrs' +
				    (keys ? ',' + keys : '')
				  )
				}

				function markStatic (node) {
				  node.static = isStatic(node);
				  if (node.type === 1) {
				    for (var i = 0, l = node.children.length; i < l; i++) {
				      var child = node.children[i];
				      markStatic(child);
				      if (!child.static) {
				        node.static = false;
				      }
				    }
				  }
				}

				function markStaticRoots (node, isInFor) {
				  if (node.type === 1) {
				    if (node.static || node.once) {
				      node.staticInFor = isInFor;
				    }
				    if (node.static) {
				      node.staticRoot = true;
				      return
				    }
				    if (node.children) {
				      for (var i = 0, l = node.children.length; i < l; i++) {
				        markStaticRoots(node.children[i], isInFor || !!node.for);
				      }
				    }
				  }
				}

				function isStatic (node) {
				  if (node.type === 2) { // expression
				    return false
				  }
				  if (node.type === 3) { // text
				    return true
				  }
				  return !!(node.pre || (
				    !node.hasBindings && // no dynamic bindings
				    !node.if && !node.for && // not v-if or v-for or v-else
				    !isBuiltInTag(node.tag) && // not a built-in
				    isPlatformReservedTag(node.tag) && // not a component
				    !isDirectChildOfTemplateFor(node) &&
				    Object.keys(node).every(isStaticKey)
				  ))
				}

				function isDirectChildOfTemplateFor (node) {
				  while (node.parent) {
				    node = node.parent;
				    if (node.tag !== 'template') {
				      return false
				    }
				    if (node.for) {
				      return true
				    }
				  }
				  return false
				}

				/*  */

				var simplePathRE = /^\s*[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['.*?']|\[".*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*\s*$/;

				// keyCode aliases
				var keyCodes = {
				  esc: 27,
				  tab: 9,
				  enter: 13,
				  space: 32,
				  up: 38,
				  left: 37,
				  right: 39,
				  down: 40,
				  'delete': [8, 46]
				};

				var modifierCode = {
				  stop: '$event.stopPropagation();',
				  prevent: '$event.preventDefault();',
				  self: 'if($event.target !== $event.currentTarget)return;'
				};

				function genHandlers (events, native) {
				  var res = native ? 'nativeOn:{' : 'on:{';
				  for (var name in events) {
				    res += "\"" + name + "\":" + (genHandler(events[name])) + ",";
				  }
				  return res.slice(0, -1) + '}'
				}

				function genHandler (
				  handler
				) {
				  if (!handler) {
				    return 'function(){}'
				  } else if (Array.isArray(handler)) {
				    return ("[" + (handler.map(genHandler).join(',')) + "]")
				  } else if (!handler.modifiers) {
				    return simplePathRE.test(handler.value)
				      ? handler.value
				      : ("function($event){" + (handler.value) + "}")
				  } else {
				    var code = '';
				    var keys = [];
				    for (var key in handler.modifiers) {
				      if (modifierCode[key]) {
				        code += modifierCode[key];
				      } else {
				        keys.push(key);
				      }
				    }
				    if (keys.length) {
				      code = genKeyFilter(keys) + code;
				    }
				    var handlerCode = simplePathRE.test(handler.value)
				      ? handler.value + '($event)'
				      : handler.value;
				    return 'function($event){' + code + handlerCode + '}'
				  }
				}

				function genKeyFilter (keys) {
				  var code = keys.length === 1
				    ? normalizeKeyCode(keys[0])
				    : Array.prototype.concat.apply([], keys.map(normalizeKeyCode));
				  if (Array.isArray(code)) {
				    return ("if(" + (code.map(function (c) { return ("$event.keyCode!==" + c); }).join('&&')) + ")return;")
				  } else {
				    return ("if($event.keyCode!==" + code + ")return;")
				  }
				}

				function normalizeKeyCode (key) {
				  return (
				    parseInt(key, 10) || // number keyCode
				    keyCodes[key] || // built-in alias
				    ("_k(" + (JSON.stringify(key)) + ")") // custom alias
				  )
				}

				/*  */

				function bind$2 (el, dir) {
				  el.wrapData = function (code) {
				    return ("_b(" + code + "," + (dir.value) + (dir.modifiers && dir.modifiers.prop ? ',true' : '') + ")")
				  };
				}

				var baseDirectives = {
				  bind: bind$2,
				  cloak: noop
				};

				/*  */

				// configurable state
				var warn$2;
				var transforms$1;
				var dataGenFns;
				var platformDirectives$1;
				var staticRenderFns;
				var onceCount;
				var currentOptions;

				function generate (
				  ast,
				  options
				) {
				  // save previous staticRenderFns so generate calls can be nested
				  var prevStaticRenderFns = staticRenderFns;
				  var currentStaticRenderFns = staticRenderFns = [];
				  var prevOnceCount = onceCount;
				  onceCount = 0;
				  currentOptions = options;
				  warn$2 = options.warn || baseWarn;
				  transforms$1 = pluckModuleFunction(options.modules, 'transformCode');
				  dataGenFns = pluckModuleFunction(options.modules, 'genData');
				  platformDirectives$1 = options.directives || {};
				  var code = ast ? genElement(ast) : '_h("div")';
				  staticRenderFns = prevStaticRenderFns;
				  onceCount = prevOnceCount;
				  return {
				    render: ("with(this){return " + code + "}"),
				    staticRenderFns: currentStaticRenderFns
				  }
				}

				function genElement (el) {
				  if (el.staticRoot && !el.staticProcessed) {
				    return genStatic(el)
				  } else if (el.once && !el.onceProcessed) {
				    return genOnce(el)
				  } else if (el.for && !el.forProcessed) {
				    return genFor(el)
				  } else if (el.if && !el.ifProcessed) {
				    return genIf(el)
				  } else if (el.tag === 'template' && !el.slotTarget) {
				    return genChildren(el) || 'void 0'
				  } else if (el.tag === 'slot') {
				    return genSlot(el)
				  } else {
				    // component or element
				    var code;
				    if (el.component) {
				      code = genComponent(el.component, el);
				    } else {
				      var data = el.plain ? undefined : genData(el);

				      var children = el.inlineTemplate ? null : genChildren(el);
				      code = "_h('" + (el.tag) + "'" + (data ? ("," + data) : '') + (children ? ("," + children) : '') + ")";
				    }
				    // module transforms
				    for (var i = 0; i < transforms$1.length; i++) {
				      code = transforms$1[i](el, code);
				    }
				    return code
				  }
				}

				// hoist static sub-trees out
				function genStatic (el) {
				  el.staticProcessed = true;
				  staticRenderFns.push(("with(this){return " + (genElement(el)) + "}"));
				  return ("_m(" + (staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + ")")
				}

				// v-once
				function genOnce (el) {
				  el.onceProcessed = true;
				  if (el.staticInFor) {
				    var key = '';
				    var parent = el.parent;
				    while (parent) {
				      if (parent.for) {
				        key = parent.key;
				        break
				      }
				      parent = parent.parent;
				    }
				    if (!key) {
				      "development" !== 'production' && warn$2(
				        "v-once can only be used inside v-for that is keyed. "
				      );
				      return genElement(el)
				    }
				    return ("_o(" + (genElement(el)) + "," + (onceCount++) + (key ? ("," + key) : "") + ")")
				  } else {
				    return genStatic(el)
				  }
				}

				function genIf (el) {
				  var exp = el.if;
				  el.ifProcessed = true; // avoid recursion
				  return ("(" + exp + ")?" + (genElement(el)) + ":" + (genElse(el)))
				}

				function genElse (el) {
				  return el.elseBlock
				    ? genElement(el.elseBlock)
				    : '_e()'
				}

				function genFor (el) {
				  var exp = el.for;
				  var alias = el.alias;
				  var iterator1 = el.iterator1 ? ("," + (el.iterator1)) : '';
				  var iterator2 = el.iterator2 ? ("," + (el.iterator2)) : '';
				  el.forProcessed = true; // avoid recursion
				  return "_l((" + exp + ")," +
				    "function(" + alias + iterator1 + iterator2 + "){" +
				      "return " + (genElement(el)) +
				    '})'
				}

				function genData (el) {
				  var data = '{';

				  // directives first.
				  // directives may mutate the el's other properties before they are generated.
				  var dirs = genDirectives(el);
				  if (dirs) { data += dirs + ','; }

				  // key
				  if (el.key) {
				    data += "key:" + (el.key) + ",";
				  }
				  // ref
				  if (el.ref) {
				    data += "ref:" + (el.ref) + ",";
				  }
				  if (el.refInFor) {
				    data += "refInFor:true,";
				  }
				  // record original tag name for components using "is" attribute
				  if (el.component) {
				    data += "tag:\"" + (el.tag) + "\",";
				  }
				  // slot target
				  if (el.slotTarget) {
				    data += "slot:" + (el.slotTarget) + ",";
				  }
				  // module data generation functions
				  for (var i = 0; i < dataGenFns.length; i++) {
				    data += dataGenFns[i](el);
				  }
				  // attributes
				  if (el.attrs) {
				    data += "attrs:{" + (genProps(el.attrs)) + "},";
				  }
				  // DOM props
				  if (el.props) {
				    data += "domProps:{" + (genProps(el.props)) + "},";
				  }
				  // event handlers
				  if (el.events) {
				    data += (genHandlers(el.events)) + ",";
				  }
				  if (el.nativeEvents) {
				    data += (genHandlers(el.nativeEvents, true)) + ",";
				  }
				  // inline-template
				  if (el.inlineTemplate) {
				    var ast = el.children[0];
				    if ("development" !== 'production' && (
				      el.children.length > 1 || ast.type !== 1
				    )) {
				      warn$2('Inline-template components must have exactly one child element.');
				    }
				    if (ast.type === 1) {
				      var inlineRenderFns = generate(ast, currentOptions);
				      data += "inlineTemplate:{render:function(){" + (inlineRenderFns.render) + "},staticRenderFns:[" + (inlineRenderFns.staticRenderFns.map(function (code) { return ("function(){" + code + "}"); }).join(',')) + "]}";
				    }
				  }
				  data = data.replace(/,$/, '') + '}';
				  // v-bind data wrap
				  if (el.wrapData) {
				    data = el.wrapData(data);
				  }
				  return data
				}

				function genDirectives (el) {
				  var dirs = el.directives;
				  if (!dirs) { return }
				  var res = 'directives:[';
				  var hasRuntime = false;
				  var i, l, dir, needRuntime;
				  for (i = 0, l = dirs.length; i < l; i++) {
				    dir = dirs[i];
				    needRuntime = true;
				    var gen = platformDirectives$1[dir.name] || baseDirectives[dir.name];
				    if (gen) {
				      // compile-time directive that manipulates AST.
				      // returns true if it also needs a runtime counterpart.
				      needRuntime = !!gen(el, dir, warn$2);
				    }
				    if (needRuntime) {
				      hasRuntime = true;
				      res += "{name:\"" + (dir.name) + "\",rawName:\"" + (dir.rawName) + "\"" + (dir.value ? (",value:(" + (dir.value) + "),expression:" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (",arg:\"" + (dir.arg) + "\"") : '') + (dir.modifiers ? (",modifiers:" + (JSON.stringify(dir.modifiers))) : '') + "},";
				    }
				  }
				  if (hasRuntime) {
				    return res.slice(0, -1) + ']'
				  }
				}

				function genChildren (el) {
				  if (el.children.length) {
				    return '[' + el.children.map(genNode).join(',') + ']'
				  }
				}

				function genNode (node) {
				  if (node.type === 1) {
				    return genElement(node)
				  } else {
				    return genText(node)
				  }
				}

				function genText (text) {
				  return text.type === 2
				    ? text.expression // no need for () because already wrapped in _s()
				    : JSON.stringify(text.text)
				}

				function genSlot (el) {
				  var slotName = el.slotName || '"default"';
				  var children = genChildren(el);
				  return ("_t(" + slotName + (children ? ("," + children) : '') + ")")
				}

				// componentName is el.component, take it as argument to shun flow's pessimistic refinement
				function genComponent (componentName, el) {
				  var children = el.inlineTemplate ? null : genChildren(el);
				  return ("_h(" + componentName + "," + (genData(el)) + (children ? ("," + children) : '') + ")")
				}

				function genProps (props) {
				  var res = '';
				  for (var i = 0; i < props.length; i++) {
				    var prop = props[i];
				    res += "\"" + (prop.name) + "\":" + (prop.value) + ",";
				  }
				  return res.slice(0, -1)
				}

				/*  */

				/**
				 * Compile a template.
				 */
				function compile$1 (
				  template,
				  options
				) {
				  var ast = parse(template.trim(), options);
				  optimize(ast, options);
				  var code = generate(ast, options);
				  return {
				    ast: ast,
				    render: code.render,
				    staticRenderFns: code.staticRenderFns
				  }
				}

				/*  */

				// operators like typeof, instanceof and in are allowed
				var prohibitedKeywordRE = new RegExp('\\b' + (
				  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +
				  'super,throw,while,yield,delete,export,import,return,switch,default,' +
				  'extends,finally,continue,debugger,function,arguments'
				).split(',').join('\\b|\\b') + '\\b');
				// check valid identifier for v-for
				var identRE = /[A-Za-z_$][\w$]*/;
				// strip strings in expressions
				var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;

				// detect problematic expressions in a template
				function detectErrors (ast) {
				  var errors = [];
				  if (ast) {
				    checkNode(ast, errors);
				  }
				  return errors
				}

				function checkNode (node, errors) {
				  if (node.type === 1) {
				    for (var name in node.attrsMap) {
				      if (dirRE.test(name)) {
				        var value = node.attrsMap[name];
				        if (value) {
				          if (name === 'v-for') {
				            checkFor(node, ("v-for=\"" + value + "\""), errors);
				          } else {
				            checkExpression(value, (name + "=\"" + value + "\""), errors);
				          }
				        }
				      }
				    }
				    if (node.children) {
				      for (var i = 0; i < node.children.length; i++) {
				        checkNode(node.children[i], errors);
				      }
				    }
				  } else if (node.type === 2) {
				    checkExpression(node.expression, node.text, errors);
				  }
				}

				function checkFor (node, text, errors) {
				  checkExpression(node.for || '', text, errors);
				  checkIdentifier(node.alias, 'v-for alias', text, errors);
				  checkIdentifier(node.iterator1, 'v-for iterator', text, errors);
				  checkIdentifier(node.iterator2, 'v-for iterator', text, errors);
				}

				function checkIdentifier (ident, type, text, errors) {
				  if (typeof ident === 'string' && !identRE.test(ident)) {
				    errors.push(("- invalid " + type + " \"" + ident + "\" in expression: " + text));
				  }
				}

				function checkExpression (exp, text, errors) {
				  try {
				    new Function(("return " + exp));
				  } catch (e) {
				    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);
				    if (keywordMatch) {
				      errors.push(
				        "- avoid using JavaScript keyword as property name: " +
				        "\"" + (keywordMatch[0]) + "\" in expression " + text
				      );
				    } else {
				      errors.push(("- invalid expression: " + text));
				    }
				  }
				}

				/*  */

				function transformNode (el, options) {
				  var warn = options.warn || baseWarn;
				  var staticClass = getAndRemoveAttr(el, 'class');
				  if ("development" !== 'production' && staticClass) {
				    var expression = parseText(staticClass, options.delimiters);
				    if (expression) {
				      warn(
				        "class=\"" + staticClass + "\": " +
				        'Interpolation inside attributes has been removed. ' +
				        'Use v-bind or the colon shorthand instead. For example, ' +
				        'instead of <div class="{{ val }}">, use <div :class="val">.'
				      );
				    }
				  }
				  if (staticClass) {
				    el.staticClass = JSON.stringify(staticClass);
				  }
				  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);
				  if (classBinding) {
				    el.classBinding = classBinding;
				  }
				}

				function genData$1 (el) {
				  var data = '';
				  if (el.staticClass) {
				    data += "staticClass:" + (el.staticClass) + ",";
				  }
				  if (el.classBinding) {
				    data += "class:" + (el.classBinding) + ",";
				  }
				  return data
				}

				var klass$1 = {
				  staticKeys: ['staticClass'],
				  transformNode: transformNode,
				  genData: genData$1
				};

				/*  */

				function transformNode$1 (el) {
				  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);
				  if (styleBinding) {
				    el.styleBinding = styleBinding;
				  }
				}

				function genData$2 (el) {
				  return el.styleBinding
				    ? ("style:(" + (el.styleBinding) + "),")
				    : ''
				}

				var style$1 = {
				  transformNode: transformNode$1,
				  genData: genData$2
				};

				var modules$1 = [
				  klass$1,
				  style$1
				];

				/*  */

				var len;
				var str;
				var chr;
				var index$1;
				var expressionPos;
				var expressionEndPos;

				/**
				 * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)
				 *
				 * for loop possible cases:
				 *
				 * - test
				 * - test[idx]
				 * - test[test1[idx]]
				 * - test["a"][idx]
				 * - xxx.test[a[a].test1[idx]]
				 * - test.xxx.a["asa"][test1[idx]]
				 *
				 */

				function parseModel (val) {
				  str = val;
				  len = str.length;
				  index$1 = expressionPos = expressionEndPos = 0;

				  if (val.indexOf('[') < 0) {
				    return {
				      exp: val,
				      idx: null
				    }
				  }

				  while (!eof()) {
				    chr = next();
				    /* istanbul ignore if */
				    if (isStringStart(chr)) {
				      parseString(chr);
				    } else if (chr === 0x5B) {
				      parseBracket(chr);
				    }
				  }

				  return {
				    exp: val.substring(0, expressionPos),
				    idx: val.substring(expressionPos + 1, expressionEndPos)
				  }
				}

				function next () {
				  return str.charCodeAt(++index$1)
				}

				function eof () {
				  return index$1 >= len
				}

				function isStringStart (chr) {
				  return chr === 0x22 || chr === 0x27
				}

				function parseBracket (chr) {
				  var inBracket = 1;
				  expressionPos = index$1;
				  while (!eof()) {
				    chr = next();
				    if (isStringStart(chr)) {
				      parseString(chr);
				      continue
				    }
				    if (chr === 0x5B) { inBracket++; }
				    if (chr === 0x5D) { inBracket--; }
				    if (inBracket === 0) {
				      expressionEndPos = index$1;
				      break
				    }
				  }
				}

				function parseString (chr) {
				  var stringQuote = chr;
				  while (!eof()) {
				    chr = next();
				    if (chr === stringQuote) {
				      break
				    }
				  }
				}

				/*  */

				var warn$3;

				function model$1 (
				  el,
				  dir,
				  _warn
				) {
				  warn$3 = _warn;
				  var value = dir.value;
				  var modifiers = dir.modifiers;
				  var tag = el.tag;
				  var type = el.attrsMap.type;
				  {
				    var dynamicType = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];
				    if (tag === 'input' && dynamicType) {
				      warn$3(
				        "<input :type=\"" + dynamicType + "\" v-model=\"" + value + "\">:\n" +
				        "v-model does not support dynamic input types. Use v-if branches instead."
				      );
				    }
				  }
				  if (tag === 'select') {
				    genSelect(el, value, modifiers);
				  } else if (tag === 'input' && type === 'checkbox') {
				    genCheckboxModel(el, value, modifiers);
				  } else if (tag === 'input' && type === 'radio') {
				    genRadioModel(el, value, modifiers);
				  } else {
				    genDefaultModel(el, value, modifiers);
				  }
				  // ensure runtime directive metadata
				  return true
				}

				function genCheckboxModel (
				  el,
				  value,
				  modifiers
				) {
				  if ("development" !== 'production' &&
				    el.attrsMap.checked != null) {
				    warn$3(
				      "<" + (el.tag) + " v-model=\"" + value + "\" checked>:\n" +
				      "inline checked attributes will be ignored when using v-model. " +
				      'Declare initial values in the component\'s data option instead.'
				    );
				  }
				  var number = modifiers && modifiers.number;
				  var valueBinding = getBindingAttr(el, 'value') || 'null';
				  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';
				  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';
				  addProp(el, 'checked',
				    "Array.isArray(" + value + ")" +
				      "?_i(" + value + "," + valueBinding + ")>-1" +
				      ":_q(" + value + "," + trueValueBinding + ")"
				  );
				  addHandler(el, 'change',
				    "var $$a=" + value + "," +
				        '$$el=$event.target,' +
				        "$$c=$$el.checked?(" + trueValueBinding + "):(" + falseValueBinding + ");" +
				    'if(Array.isArray($$a)){' +
				      "var $$v=" + (number ? '_n(' + valueBinding + ')' : valueBinding) + "," +
				          '$$i=_i($$a,$$v);' +
				      "if($$c){$$i<0&&(" + value + "=$$a.concat($$v))}" +
				      "else{$$i>-1&&(" + value + "=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}" +
				    "}else{" + value + "=$$c}",
				    null, true
				  );
				}

				function genRadioModel (
				    el,
				    value,
				    modifiers
				) {
				  if ("development" !== 'production' &&
				    el.attrsMap.checked != null) {
				    warn$3(
				      "<" + (el.tag) + " v-model=\"" + value + "\" checked>:\n" +
				      "inline checked attributes will be ignored when using v-model. " +
				      'Declare initial values in the component\'s data option instead.'
				    );
				  }
				  var number = modifiers && modifiers.number;
				  var valueBinding = getBindingAttr(el, 'value') || 'null';
				  valueBinding = number ? ("_n(" + valueBinding + ")") : valueBinding;
				  addProp(el, 'checked', ("_q(" + value + "," + valueBinding + ")"));
				  addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);
				}

				function genDefaultModel (
				  el,
				  value,
				  modifiers
				) {
				  {
				    if (el.tag === 'input' && el.attrsMap.value) {
				      warn$3(
				        "<" + (el.tag) + " v-model=\"" + value + "\" value=\"" + (el.attrsMap.value) + "\">:\n" +
				        'inline value attributes will be ignored when using v-model. ' +
				        'Declare initial values in the component\'s data option instead.'
				      );
				    }
				    if (el.tag === 'textarea' && el.children.length) {
				      warn$3(
				        "<textarea v-model=\"" + value + "\">:\n" +
				        'inline content inside <textarea> will be ignored when using v-model. ' +
				        'Declare initial values in the component\'s data option instead.'
				      );
				    }
				  }

				  var type = el.attrsMap.type;
				  var ref = modifiers || {};
				  var lazy = ref.lazy;
				  var number = ref.number;
				  var trim = ref.trim;
				  var event = lazy || (isIE && type === 'range') ? 'change' : 'input';
				  var needCompositionGuard = !lazy && type !== 'range';
				  var isNative = el.tag === 'input' || el.tag === 'textarea';

				  var valueExpression = isNative
				    ? ("$event.target.value" + (trim ? '.trim()' : ''))
				    : "$event";
				  valueExpression = number || type === 'number'
				    ? ("_n(" + valueExpression + ")")
				    : valueExpression;
				  var code = genAssignmentCode(value, valueExpression);
				  if (isNative && needCompositionGuard) {
				    code = "if($event.target.composing)return;" + code;
				  }
				  // inputs with type="file" are read only and setting the input's
				  // value will throw an error.
				  if ("development" !== 'production' &&
				      type === 'file') {
				    warn$3(
				      "<" + (el.tag) + " v-model=\"" + value + "\" type=\"file\">:\n" +
				      "File inputs are read only. Use a v-on:change listener instead."
				    );
				  }
				  addProp(el, 'value', isNative ? ("_s(" + value + ")") : ("(" + value + ")"));
				  addHandler(el, event, code, null, true);
				}

				function genSelect (
				    el,
				    value,
				    modifiers
				) {
				  {
				    el.children.some(checkOptionWarning);
				  }

				  var number = modifiers && modifiers.number;
				  var assignment = "Array.prototype.filter" +
				    ".call($event.target.options,function(o){return o.selected})" +
				    ".map(function(o){var val = \"_value\" in o ? o._value : o.value;" +
				    "return " + (number ? '_n(val)' : 'val') + "})" +
				    (el.attrsMap.multiple == null ? '[0]' : '');

				  var code = genAssignmentCode(value, assignment);
				  addHandler(el, 'change', code, null, true);
				}

				function checkOptionWarning (option) {
				  if (option.type === 1 &&
				    option.tag === 'option' &&
				    option.attrsMap.selected != null) {
				    warn$3(
				      "<select v-model=\"" + (option.parent.attrsMap['v-model']) + "\">:\n" +
				      'inline selected attributes on <option> will be ignored when using v-model. ' +
				      'Declare initial values in the component\'s data option instead.'
				    );
				    return true
				  }
				  return false
				}

				function genAssignmentCode (value, assignment) {
				  var modelRs = parseModel(value);
				  if (modelRs.idx === null) {
				    return (value + "=" + assignment)
				  } else {
				    return "var $$exp = " + (modelRs.exp) + ", $$idx = " + (modelRs.idx) + ";" +
				      "if (!Array.isArray($$exp)){" +
				        value + "=" + assignment + "}" +
				      "else{$$exp.splice($$idx, 1, " + assignment + ")}"
				  }
				}

				/*  */

				function text (el, dir) {
				  if (dir.value) {
				    addProp(el, 'textContent', ("_s(" + (dir.value) + ")"));
				  }
				}

				/*  */

				function html (el, dir) {
				  if (dir.value) {
				    addProp(el, 'innerHTML', ("_s(" + (dir.value) + ")"));
				  }
				}

				var directives$1 = {
				  model: model$1,
				  text: text,
				  html: html
				};

				/*  */

				var cache = Object.create(null);

				var baseOptions = {
				  isIE: isIE,
				  expectHTML: true,
				  modules: modules$1,
				  staticKeys: genStaticKeys(modules$1),
				  directives: directives$1,
				  isReservedTag: isReservedTag,
				  isUnaryTag: isUnaryTag,
				  mustUseProp: mustUseProp,
				  getTagNamespace: getTagNamespace,
				  isPreTag: isPreTag
				};

				function compile$$1 (
				  template,
				  options
				) {
				  options = options
				    ? extend(extend({}, baseOptions), options)
				    : baseOptions;
				  return compile$1(template, options)
				}

				function compileToFunctions (
				  template,
				  options,
				  vm
				) {
				  var _warn = (options && options.warn) || warn;
				  // detect possible CSP restriction
				  /* istanbul ignore if */
				  {
				    try {
				      new Function('return 1');
				    } catch (e) {
				      if (e.toString().match(/unsafe-eval|CSP/)) {
				        _warn(
				          'It seems you are using the standalone build of Vue.js in an ' +
				          'environment with Content Security Policy that prohibits unsafe-eval. ' +
				          'The template compiler cannot work in this environment. Consider ' +
				          'relaxing the policy to allow unsafe-eval or pre-compiling your ' +
				          'templates into render functions.'
				        );
				      }
				    }
				  }
				  var key = options && options.delimiters
				    ? String(options.delimiters) + template
				    : template;
				  if (cache[key]) {
				    return cache[key]
				  }
				  var res = {};
				  var compiled = compile$$1(template, options);
				  res.render = makeFunction(compiled.render);
				  var l = compiled.staticRenderFns.length;
				  res.staticRenderFns = new Array(l);
				  for (var i = 0; i < l; i++) {
				    res.staticRenderFns[i] = makeFunction(compiled.staticRenderFns[i]);
				  }
				  {
				    if (res.render === noop || res.staticRenderFns.some(function (fn) { return fn === noop; })) {
				      _warn(
				        "failed to compile template:\n\n" + template + "\n\n" +
				        detectErrors(compiled.ast).join('\n') +
				        '\n\n',
				        vm
				      );
				    }
				  }
				  return (cache[key] = res)
				}

				function makeFunction (code) {
				  try {
				    return new Function(code)
				  } catch (e) {
				    return noop
				  }
				}

				/*  */

				var idToTemplate = cached(function (id) {
				  var el = query(id);
				  return el && el.innerHTML
				});

				var mount = Vue$2.prototype.$mount;
				Vue$2.prototype.$mount = function (
				  el,
				  hydrating
				) {
				  el = el && query(el);

				  /* istanbul ignore if */
				  if (el === document.body || el === document.documentElement) {
				    "development" !== 'production' && warn(
				      "Do not mount Vue to <html> or <body> - mount to normal elements instead."
				    );
				    return this
				  }

				  var options = this.$options;
				  // resolve template/el and convert to render function
				  if (!options.render) {
				    var template = options.template;
				    if (template) {
				      if (typeof template === 'string') {
				        if (template.charAt(0) === '#') {
				          template = idToTemplate(template);
				        }
				      } else if (template.nodeType) {
				        template = template.innerHTML;
				      } else {
				        {
				          warn('invalid template option:' + template, this);
				        }
				        return this
				      }
				    } else if (el) {
				      template = getOuterHTML(el);
				    }
				    if (template) {
				      var ref = compileToFunctions(template, {
				        warn: warn,
				        shouldDecodeNewlines: shouldDecodeNewlines,
				        delimiters: options.delimiters
				      }, this);
				      var render = ref.render;
				      var staticRenderFns = ref.staticRenderFns;
				      options.render = render;
				      options.staticRenderFns = staticRenderFns;
				    }
				  }
				  return mount.call(this, el, hydrating)
				};

				/**
				 * Get outerHTML of elements, taking care
				 * of SVG elements in IE as well.
				 */
				function getOuterHTML (el) {
				  if (el.outerHTML) {
				    return el.outerHTML
				  } else {
				    var container = document.createElement('div');
				    container.appendChild(el.cloneNode(true));
				    return container.innerHTML
				  }
				}

				Vue$2.compile = compileToFunctions;

				return Vue$2;

				})));


			/***/ },
			/* 3 */
			/***/ function(module, exports, __webpack_require__) {

				var Vue = __webpack_require__(2);
				new Vue({
				    el: '#gamearea',
				    data: {
				        length: 6,
				        message: 'Hello Vue!',
				        items: [
				            { name: 'vedge vedgeAnim edge' },
				            { name: 'vedge vedgeAnim edge' }
				        ]
				    }
				})

			/***/ },
			/* 4 */
			/***/ function(module, exports, __webpack_require__) {

				var $ = __webpack_require__(5);
				// Global variables
				var boardSize = 6;
				var tunnelLength = 12;
				var maxTunnelLength;
				var numProbes = 0;
				var probesList = [];
				var tunnel = new Tunnel();
				var finalTunnelGuess = [];
				var gameMode = -1;
				// 0 = Regular
				// 1 = Easy Mode
				var player1Name = "";
				var player2Name = "";
				var player1Score = 0;
				var player2Score = 0;
				var round = 1;
				var winningScore = 0;
				var winningPlayer = "";
				var computer = -1;
				// 0 = Humans
				// 1 = AI
				var gameState = -1;
				// 0 = badGuy placing tunnels
				// 1 = detector placing 1st hour probes
				// 2 = detector placing 2nd hour probes
				// 3 = detector placing 3rd hour probes
				// 4 = detector detecting


				// Clear the board before a new game
				var clearBoard = function () {
				    $(".animate").filter(function() {
				        $(this).removeClass("animate");
				    });
				    $(".final").filter(function() {
				        $(this).removeClass("final");
				    });
				    $(".detectedEdge").filter(function() {
				        $(this).removeClass("detectedEdge");
				    });
				    $(".reveal").filter(function() {
				        $(this).removeClass("reveal");
				    });
				}

				function Node(id) {
				    this.edges = [];
				    this.id = id;

				    this.addEdge = function(e0) {
				        this.edges.push(e0);
				    };

				    this.removeEdge = function(e0) {
				        var index = this.edges.indexOf(e0);
				        this.edges.splice(index, 1);
				    }
				}

				Node.prototype.toString = function nodeToString() {
				    var ret = this.id + ": ";
				    for (var i = 0; i < this.edges.length; i++) {
				        ret += (this.edges[i].id + " ");
				    }
				    return ret;
				}

				function Edge(n1, n2, id) {
				    this.n1 = n1;
				    this.n2 = n2;
				    this.id = id;
				    this.allNodes = [];
				}

				Edge.prototype.toString = function edgeToString() {
				    var ret = this.id + ": ";
				    console.log(ret)
				    for (var i = 0; i < this.allNodes.length; i++) {
				        ret += (this.allNodes[i].id + " ");
				    }
				    return ret;
				}

				function Tunnel() {
				    this.edges = {};
				    this.nodes = {};

				    this.addNode = function(node) {
				        var nodeId = node.id;
				        this.nodes[nodeId] = node;
				    };

				    this.removeNode = function(node) {
				        var nodeId = node.id;
				        delete this.nodes[nodeId];
				    };

				    this.addEdge = function(edge) {
				        var edgeId = edge.id;
				        this.edges[edgeId] = edge;
				    };

				    this.removeEdge = function(edge1) {
				        var edgeId = edge1.id;
				        delete this.edges[edgeId];
				    };

				    this.getStartNode = function() {
				        // Get all nodes that are touching the top row
				        var starts = [];
				        for (var nodeId in this.nodes) {
				            if (!this.nodes.hasOwnProperty(nodeId)) {
				                //not direct property of nodes
				                continue;
				            }

				            node = this.nodes[nodeId];
				            if (Number(node.id) < (boardSize + 1)) {
				                starts.push(node);
				            }
				        }

				        // Out of all nodes on top row, get all that have just one edge
				        var validStarts = [];
				        for (var i = 0; i < starts.length; i++) {
				            if (starts[i].edges.length == 1) {
				                validStarts.push(starts[i]);
				                console.log("valid starts: ", validStarts);
				            }
				        }

				        // If there is just one such node, it's our start
				        // Else there isn't a valid start node and tunnel is invalid
				        console.log("length of validStarts: ", validStarts.length);
				        if (validStarts.length == 1) {
				            console.log("validStarts[0] is ", validStarts[0]);
				            return validStarts[0];
				        }
				        else {
				            return null;
				        }
				    };

				    this.getEndNode = function() {
				        // Get all nodes that are touching the bottom row
				        var ends = [];
				        for (var nodeId in this.nodes) {
				            if (!this.nodes.hasOwnProperty(nodeId)) {
				                // Not direct property of nodes
				                continue;
				            }

				            node = this.nodes[nodeId];
				            if (Number(node.id) >= (boardSize * (boardSize + 1))) {
				                ends.push(node);
				            }
				        }

				        // Out of all nodes on top row, get all that have just one edge
				        var validEnds = [];
				        for (var i = 0; i < ends.length; i++) {
				            if (ends[i].edges.length == 1) {
				                validEnds.push(ends[i]);
				            }
				        }

				        // If there is just one such node, it's our start
				        // Else there isn't a valid start node and tunnel is invalid
				        if (validEnds.length == 1) {
				            return validEnds[0];
				        }
				        else {
				            return null;
				        }
				    };

				    this.validTunnel = function() {
				        console.log("EDGE INFO ", this.edges);
				        console.log("NODES ", this.nodes);
				        //duplicate nodes and edges
				        var allEdgeIds = [];
				        for (var item in this.edges) {
				            allEdgeIds.push(item);
				        }
				        console.log("All edge ids: ", allEdgeIds);
				        var allNodeIds = [];
				        for (var item in this.nodes) {
				            allNodeIds.push(item);
				        }
				        console.log("All nodes: ", allNodeIds);

				        var currNode = this.getStartNode();
				        console.log("Start node: ", currNode);

				        //if there is no start node, tunnel is invalid
				        if (currNode == null) {
				            return false;
				        }

				        //if there is no end node, tunnel is invalid
				        if (this.getEndNode() == null) {
				            return false;
				        }
				        console.log("end node: ", this.getEndNode());

				        //remove start node and it's only edge from total
				        allEdgeIds.splice(allEdgeIds.indexOf(currNode.edges[0].id), 1);

				        //get 2nd node
				        if(currNode.edges[0].n1 != currNode) {
				            currNode = currNode.edges[0].n1;
				        }
				        else {
				            currNode = currNode.edges[0].n2;
				        }

				        while (true) {
				            console.log("beg of loop", currNode.id);

				            //end conditions
				            if (currNode == this.getEndNode()) {
				                console.log("Reached end node");
				                //if we've removed all the edges we're good
				                if (allEdgeIds.length == 0) {
				                    return true;
				                }
				                else {
				                    console.log("AllEdgeIds does NOT == 0");
				                    return false;
				                }
				            }

				            //check that each node we reach only has 2 edges
				            if(currNode.edges.length != 2) {
				                console.log(currNode, "doesn't have 2 edges");
				                return false;
				            }

				            //check that one of the two edges is still alive
				            var nextEdge = null;
				            console.log("curr node edges:", currNode.edges);
				            console.log("All edge Ids: ", allEdgeIds);
				            for (var i = 0; i < currNode.edges.length; i++) {
				                console.log("currNode.edges[i].id ", currNode.edges[i].id);
				                if (allEdgeIds.indexOf(currNode.edges[i].id) > -1) {
				                    nextEdge = this.edges[currNode.edges[i].id];
				                }
				            }

				            //neither edge still in total list, tunnel invalid
				            if (nextEdge == null) {
				                console.log(nextEdge, "neither edge still in total list");
				                return false;
				            }

				            //clean up - remove curr node and curr edge
				            allEdgeIds.splice(allEdgeIds.indexOf(nextEdge.id), 1);

				            //get the next node
				            if(nextEdge.n1 != currNode) {
				                currNode = nextEdge.n1;
				            }
				            else {
				                currNode = nextEdge.n2;
				            }
				        }

				    };

				    this.clearTunnel = function() {
				        this.edges = {};
				        this.nodes = {};
				    }
				}

				Tunnel.prototype.toString = function tunnelToString() {
				    var ret = "tunnel: \n";
				    ret += "nodes: ";
				    for (var n in this.nodes) {
				        ret += (this.nodes[n].id + " ");
				    }
				    ret += "\nedges: ";
				    for (var e in this.edges) {
				        ret += (this.edges[e].id + " ");
				    }
				    ret += "\n";
				    return ret;
				}

				// Determine if was clicked before or not and add/remove edge from tunnel class
				var edges = document.getElementsByClassName("edge");

				var edgeClicked = function() {
				    var edgeId = this.getAttribute('x');
				    console.log(edgeId)
				    if (gameState == 0) {
				        $(this).toggleClass("animate");
				        if (edgeId in tunnel.edges) {
				            // Get nodes
				            tunnelLength++;
				            var n1 = tunnel.edges[edgeId].n1;
				            var n2 = tunnel.edges[edgeId].n2;
				            // Remove this edge from each node's edge list
				            n1.removeEdge(tunnel.edges[edgeId]);
				            n2.removeEdge(tunnel.edges[edgeId]);
				            if (n1.edges.length == 0) {
				                tunnel.removeNode(n1);
				            }
				            if (n2.edges.length == 0) {
				                tunnel.removeNode(n2);
				            }
				            tunnel.removeEdge(tunnel.edges[edgeId]);
				        } else {
				            // Check if there are no pieces
				            if (tunnelLength <= 0) {
				                remainingPieces.innerHTML = "There are no remaining edges! Please remove an edge to continue building.";
				                return;
				            }
				            tunnelLength--;
				            if (edgeId[0] == "h") {
				                console.log("slice: ", edgeId.slice(1));
				                var rNum = Math.floor(edgeId.slice(1) / boardSize);
				                console.log("rNum: ", rNum);
				                var n1Id = Number(edgeId.slice(1)) + rNum;
				                var n2Id = (n1Id + 1).toString();
				                console.log("n1Id: ", n1Id);
				                console.log("n2Id: ", n2Id);
				                var n1;
				                var n2;

				                if (n1Id in tunnel.nodes) {
				                    n1 = tunnel.nodes[n1Id];
				                } else {
				                    n1 = new Node(n1Id);
				                    tunnel.addNode(n1);
				                }

				                if (n2Id in tunnel.nodes) {
				                    n2 = tunnel.nodes[n2Id];
				                } else {
				                    n2 = new Node(n2Id);
				                    tunnel.addNode(n2);
				                }

				                var newEdge = new Edge(n1, n2, edgeId);
				                tunnel.addEdge(newEdge);
				                n1.addEdge(newEdge);
				                n2.addEdge(newEdge);
				            } else {
				                var n1Id = edgeId.slice(1);
				                var n2Id = (Number(edgeId.slice(1)) + boardSize + 1).toString();
				                console.log("n1Id: ", n1Id);
				                console.log("n2Id: ", n2Id);
				                var n1;
				                var n2;

				                if (n1Id in tunnel.nodes) {
				                    n1 = tunnel.nodes[n1Id];
				                } else {
				                    n1 = new Node(n1Id);
				                    tunnel.addNode(n1);
				                }

				                if (n2Id in tunnel.nodes) {
				                    n2 = tunnel.nodes[n2Id];
				                } else {
				                    n2 = new Node(n2Id);
				                    tunnel.addNode(n2);
				                }

				                var newEdge = new Edge(n1, n2, edgeId);
				                tunnel.addEdge(newEdge);
				                n1.addEdge(newEdge);
				                n2.addEdge(newEdge);
				            }
				        }

				        // this.style.background = this.style.background=='yellow'? '#63f9ff':'yellow';
				        remainingPieces.innerHTML = "Edges left: " + tunnelLength;
				        console.log(tunnel.edges);
				        console.log("Tunnel nodes: ", tunnel.nodes);
				    } else if (gameState == 4) {
				        if (finalTunnelGuess.indexOf(edgeId) > -1) {
				            finalTunnelGuess.splice(finalTunnelGuess.indexOf(edgeId), 1);
				        } else {
				            finalTunnelGuess.push(edgeId);
				        }
				        $(this).toggleClass("final");
				    }
				};

				for(var i = 0; i < edges.length; i++){
				    edges[i].addEventListener('click', edgeClicked, false);
				}

				// Get probes and add event listener to each one
				var probes = document.getElementsByClassName("probe");

				var probeClicked = function() {
				    if (gameState == 1 || gameState == 2 || gameState == 3) {
				        $(this).toggleClass("animate");
				        probeId = this.id;
				        console.log("Probe id: ", probeId);
				        index = probesList.indexOf(probeId);
				        console.log("Numprobes: " + numProbes);
				        console.log("Index: " + index);
				        if (index < 0) {
				            probesList.push(probeId.slice(1));
				            numProbes++;
				        } else {
				            probesList.splice(index, 1);
				            numProbes--;
				        }
				        // this.style.background = this.style.background == 'red' ? 'blue' : 'red';
				    }
				};

				for(var i=0;i<probes.length;i++){
				    probes[i].addEventListener('click', probeClicked, false);
				}

				var startGameInRegularMode = function () {
				    clearBoard();
				    gameMode = 0;
				    alert("Detector, please look away while Badguy builds a tunnel.");
				    startGame();
				}

				var startGameInEasyMode = function () {
				    clearBoard();
				    gameMode = 1;
				    alert("Detector, please look away while Badguy builds a tunnel.");
				    startGame();
				}

				var startGameAI = function () {
				    computer = 1;
				    gameMode = 0;
				    gameState = 0;
				    console.log("GAME STATE IN START AI ", gameState);
				    tunnel = createAITunnel();
				    startGame();
				}

				var startGameEasyAI = function () {
				    computer = 1;
				    gameMode = 1;
				    gameState = 0;
				    tunnel = createAITunnel();
				    startGame();
				}

				var startGame = function () {
				    clearBoard();
				    if (round == 1) {
				        tunnelLength = Math.floor(Math.random() * 13) + 8;
				        maxTunnelLength = tunnelLength;
				        alert("Maximum tunnel length is " + tunnelLength + ".");
				    } else {
				        tunnelLength = maxTunnelLength;
				    }
				    gameState++;
				    console.log("GAME STATE IS ", gameState);
				    document.getElementById('start').style.display = 'none';
				    document.getElementById('startEasy').style.display = 'none';
				    document.getElementById('startAI').style.display = 'none';
				    document.getElementById('startEasyAI').style.display = 'none';
				    document.getElementById('submitGuess').style.display = 'none';
				    if (gameState == 0) {
				        tunnelInfo.innerHTML = "Tunnel can be up to " + tunnelLength + " edges long.";
				        remainingPieces.innerHTML = "Edges left: " + tunnelLength;
				        document.getElementById('tunnelDone').style.display = 'block';
				    } else if (gameState == 1) {
				        message.innerHTML = "Computer opponent has constructed a tunnel. Detector, begin placing probes.";
				        document.getElementById('probesPlaced1').style.display = 'block';
				    }
				};

				var doneAddingTunnels = function () {
				    var valid = tunnel.validTunnel();
				    console.log(valid);

				    // If the tunnel isn't valid, don't let the game keep going
				    if(!valid) {
				        alert("Your tunnel is invalid. It must start on the top edge, end on the bottom edge, and be a single simple path.");
				        return;
				    }

				    document.getElementById('tunnelDone').style.display = 'none';
				    document.getElementById('probesPlaced1').style.display = 'block';
				    tunnelInfo.innerHTML = "";
				    remainingPieces.innerHTML = "";
				    currentTunnel.innerHTML = "";
				    message.innerHTML = "Done adding tunnels. Time for Detector to place first round of probes.";
				    for (var e in tunnel.edges) {
				        console.log("TRYING TO UNHIGHLIGHT");
				        console.log("tunnel.edges[e].id is ", tunnel.edges[e].id);
				        $("#" + tunnel.edges[e].id).toggleClass("animate");
				    }

				    // tunnelLength = 12;
				    // tunnel = createAITunnel();

				    console.log("final final tunnel:");
				    console.log("nodes");
				    for (var n in tunnel.nodes) {
				        console.log(tunnel.nodes[n] + "");
				    }
				    console.log("edges: ");
				    for (var e in tunnel.edges) {
				        console.log(tunnel.edges[e] + "");
				    }

				    gameState++;
				};

				var doneAddingProbes = function () {
				    message.innerHTML = "Done adding probes. Let's see how you did.";
				    for (var i = 0; i < probesList.length; i++) {
				        console.log("probesList[i] is ", probesList[i]);
				        if (probesList[i] in tunnel.nodes) {
				            console.log("we got in the if statement");
				            for (var j = 0; j < tunnel.nodes[probesList[i]].edges.length; j++) {
				                console.log("Found edge ", tunnel.nodes[probesList[i]].edges[j].id);
				                if (gameMode == 1) {
				                    $("#" + tunnel.nodes[probesList[i]].edges[j].id).addClass("animate");
				                }
				            }
				            $("#p" + probesList[i]).removeClass("animate");
				            $("#p" + probesList[i]).addClass("detectedEdge");
				        }
				    }

				    if (gameState == 1 || gameState == 2) {
				        //update score
				        if (computer == 1) {
				            //only need to update player1 score
				            player1Score += probesList.length;
				        } else {
				            if (round == 1) {
				                player1Score += probesList.length;
				            } else {
				                player2Score += probesList.length;
				            }
				        }

				        console.log("done with probe placement in round " + round);
				        console.log("player 1 score: " + player1Score);
				        console.log("player 2 score: " + player2Score);

				        probesList = [];
				        message.innerHTML = "Detector, please place another round of probes.";
				        document.getElementById('probesPlaced1').style.display = 'none';
				        document.getElementById('probesPlaced2').style.display = 'block';

				        gameState++;

				    } else if (gameState == 3) {
				        // Update score
				        if (computer == 1) {
				            // Only need to update player1 score
				            player1Score += probesList.length;
				        } else {
				            if (round == 1) {
				                player1Score += probesList.length;
				            } else {
				                player2Score += probesList.length;
				            }
				        }

				        console.log("done with probe placement in round " + round);
				        console.log("player 1 score: " + player1Score);
				        console.log("player 2 score: " + player2Score);

				        document.getElementById('probesPlaced2').style.display = 'none';
				        document.getElementById('submitGuess').style.display = 'block';
				        message.innerHTML = "Now, select all edges in the tunnel to submit your final guess.";
				        gameState++;
				    }

				    console.log("probes list after done ", probesList);
				};

				function restartGame() {
				    message.innerHTML = "";
				    round++;
				    if (computer == 1) {
				        if (gameMode == 0) { //regular ai
				            numProbes = 0;
				            probesList = [];
				            tunnel = new Tunnel();
				            finalTunnelGuess = [];
				            gameMode = -1;
				            computer = -1;
				            gameState = -1;
				            startGameAI();
				        } else {
				            numProbes = 0;
				            probesList = [];
				            tunnel = new Tunnel();
				            finalTunnelGuess = [];
				            gameMode = -1;
				            computer = -1;
				            gameState = -1;
				            startGameEasyAI();
				        }
				    } else {
				        if (gameMode == 0) {
				            numProbes = 0;
				            probesList = [];
				            tunnel = new Tunnel();
				            finalTunnelGuess = [];
				            gameMode = -1;
				            computer = -1;
				            gameState = -1;
				            startGameInRegularMode();
				        } else {
				            numProbes = 0;
				            probesList = [];
				            tunnel = new Tunnel();
				            finalTunnelGuess = [];
				            gameMode = -1;
				            computer = -1;
				            gameState = -1;
				            startGameInEasyMode();
				        }
				    }
				}

				var revealTunnel = function () {
				    for (var e in tunnel.edges) {
				        console.log("REVEALING TUNNEL");
				        console.log("tunnel.edges[e].id is ", tunnel.edges[e].id);
				        $("#" + tunnel.edges[e].id).removeClass("final");
				        $("#" + tunnel.edges[e].id).removeClass("animate");
				        $("#" + tunnel.edges[e].id).addClass("reveal");
				    }
				}

				var submitGuess = function () {
				    console.log("Final tunnel guess: ", finalTunnelGuess);
				    console.log("The actual tunnel: ", tunnel.edges);
				    console.log("Final tunnel guess LENGTH: ", finalTunnelGuess.length);
				    console.log("Tunnel length: ", Object.keys(tunnel.edges).length);
				    var clone = finalTunnelGuess.slice(0);
				    if (finalTunnelGuess.length != Object.keys(tunnel.edges).length) {
				        console.log("Tunnel length not the same");
				        if (round == 1) {
				            player1Score = 10000;
				            revealTunnel();
				            alert("You are a horrible Detector. Keep your day job. Your score is infinity.");
				        } else {
				            player2Score = 10000;
				            revealTunnel();
				            alert("You are a horrible Detector. Keep your day job. Your score is infinity.");
				        }
				    } else {
				        console.log("Tunnel length is good");
				        for (var i = 0; i < finalTunnelGuess.length; i++) {
				            console.log("Final tunnel guess: iteration ",i, finalTunnelGuess);
				            if (finalTunnelGuess[i] in tunnel.edges) {
				                console.log("Found match: " + finalTunnelGuess[i]);
				                clone.splice(clone.indexOf(finalTunnelGuess[i]), 1);
				                console.log("Clone: " + clone)
				            }
				        }
				        console.log("clone length ", clone.length);
				        if (!clone.length) {
				            if (round == 1) {
				                alert("Good job. Your score is " + player1Score + ".");
				            } else {
				                alert("Good job. Your score is " + player2Score + ".");
				            }
				        } else {
				            if (round == 1) {
				                player1Score = 10000;
				                revealTunnel();
				                alert("You are a horrible Detector. Keep your day job. Your score is infinity.");
				            } else {
				                player2Score = 10000;
				                revealTunnel();
				                alert("You are a horrible Detector. Keep your day job. Your score is infinity.");
				            }
				        }
				    }

				    if (round == 1 && computer != 1) {
				        // Popup that they need to switch roles
				        alert("Round 1 over. Now switch roles. The game will restart when you click OK.");
				        restartGame();
				    } else if (computer == 1) {
				        alert("Game over. You may submit your score.");
				        document.getElementById('submitGuess').style.display = 'none';
				        message.innerHTML = "";
				        document.getElementById("score").style.display="inline-block";
				    } else {
				        if (player1Score < player2Score ) {
				            winningScore = player1Score;
				            winningPlayer = player1Name;
				        } else {
				            winningScore = player2Score;
				            winningPlayer = player2Name;
				        }
				        if(computer != 1) {
				            if (player1Score < player2Score) {
				                alert("The game is over. Player 1 won with a score of " + player1Score + ". Player 1 can save their score.");
				            } else {
				                alert("The game is over. Player 2 won with a score of " + player2Score + ". Player 2 can save their score.");
				            }
				        } else {
				            alert("The game is over. Your score is " + player1Score + ". You can save your score.");
				            document.getElementById('submitGuess').style.display = 'none';
				            message.innerHTML = "";
				        }
				        document.getElementById('submitGuess').style.display = 'none';
				        message.innerHTML = "";
				        document.getElementById("score").style.display="inline-block";
				    }
				};


				// AI tunnel stuff
				function createAITunnel() {
				    var aiTunnel = new Tunnel();
				    var graph = new Graph();
				    graph.createGraph();
				    var currentTunnelLength = 0;

				    var start = Math.floor(Math.random() * (boardSize+1));
				    var currNodeFromGraph = graph.nodes[start];
				    var currNode = new Node(start);

				    var counter = 0;

				    while(true) {
				        console.log("curr node: " + currNode);

				        // Check if on end and if yes break
				        if (Math.floor(currNode.id / (boardSize+1)) == boardSize) {
				            console.log("on end!")
				            console.log("final tunnel: " + aiTunnel);
				            aiTunnel.addNode(currNode);
				            break;
				        }

				        // Pick an edge from the current nodes edges that's not the incoming edge
				        var potentialEdge = getRandomEdge(currNodeFromGraph, aiTunnel);
				        console.log("first potential edge: " + potentialEdge);

				        // See if adding that edge leaves enough pipes to get to the end
				        while (!potentialEdgeValid(potentialEdge, currNode, aiTunnel)) {
				            //while(false) {
				            potentialEdge = getRandomEdge(currNodeFromGraph, aiTunnel);
				            console.log("edge was invalid, got new one: " + potentialEdge);
				            //sleepFor(1000);
				        }

				        // Now we have a good edge, update it's n1
				        potentialEdge.n1 = currNode;

				        // Add the edge to currNode
				        currNode.addEdge(potentialEdge);

				        // Add them both to the tunnel
				        aiTunnel.addNode(currNode);
				        aiTunnel.addEdge(potentialEdge);

				        // Get the next node
				        var currNodeId = currNode.id;
				        var newNodeId = null;
				        // console.log("curr node id: " + currNodeId);
				        for (var i = 0; i < potentialEdge.allNodes.length; i++) {
				            // console.log("potentialEdge.allNodes[i].id: " + potentialEdge.allNodes[i].id );
				            if (potentialEdge.allNodes[i].id != currNodeId) {
				                newNodeId = potentialEdge.allNodes[i].id;
				            }
				        }
				        // console.log("new node id: " + newNodeId);

				        currNodeFromGraph = graph.nodes[newNodeId];
				        currNode = new Node(newNodeId);
				        currNode.addEdge(potentialEdge);
				        potentialEdge.n2 = currNode;
				        counter++;

				        console.log("tunnel: " + aiTunnel);

				    }

				    return aiTunnel;
				}

				function potentialEdgeValid(potentialEdge, currNode, tunnel) {

				    if(potentialEdge.id in tunnel.edges) {
				        console.log("edge exists, not valid");
				        return false;
				    }

				    tunnel.addEdge(potentialEdge);
				    tunnel.addNode(currNode);

				    var tunnelLengthSoFar = Object.keys(tunnel.edges).length;
				    var edgesLeft = tunnelLength - tunnelLengthSoFar;
				    var rowNum = getRowNum(potentialEdge);


				    console.log();
				    console.log("======= starting validation ========")
				    console.log("checking if edge " + potentialEdge.id + " is valid to add to tunnel: ");
				    console.log(tunnel + "");
				    console.log("tunnel len so far: " + tunnelLengthSoFar);
				    console.log("edges left so far: " + edgesLeft);
				    console.log("row num of edge: " + rowNum);

				    // Check that the other end of the new edge isn't already in the tunnel
				    // (This means we created a loop)
				    var currNodeId = currNode.id;
				    var newNodeId = null;
				    console.log("curr node id: " + currNodeId);
				    for (var i = 0; i < potentialEdge.allNodes.length; i++) {
				        //console.log("potentialEdge.allNodes[i].id: " + potentialEdge.allNodes[i].id );
				        if (potentialEdge.allNodes[i].id != currNodeId) {
				            newNodeId = potentialEdge.allNodes[i].id;
				        }
				    }
				    console.log("new node id: " + newNodeId);

				    if (newNodeId in tunnel.nodes) {
				        console.log("we created a loop, not valid");
				        tunnel.removeEdge(potentialEdge);
				        tunnel.removeNode(currNode);
				        return false;
				    }


				    // If the edge is horizontal then need (remaining pieces - (boardSize - rowNum)) >= 0
				    // Check if have enough nodes to end
				    var neededToEnd = -1;
				    if (potentialEdge.id[0] == "h") {
				        console.log("edge is horiz");
				        // Check if h edge below is already in tunnel
				        var edgeBelowId = Number(potentialEdge.id.slice(1)) + boardSize;
				        var edgeBelow = "h" + edgeBelowId;
				        if (edgeBelow in tunnel.edges) {
				            console.log("can't add this horiz edge because will cause box");
				            tunnel.removeEdge(potentialEdge);
				            tunnel.removeNode(currNode);
				            return false;
				        }
				        neededToEnd = boardSize - rowNum;
				    } else {
				        if (newNodeId > currNodeId) { //edge is going down
				            console.log("edge is v going down")
				            neededToEnd = (boardSize - rowNum) - 1;
				        } else {
				            console.log("edge is v going up");
				            // console.log("so for now returning false");
				            // return false;
				            // can't go up on the edges
				            var potEdgeIdNum = Number(potentialEdge.id.slice(1));
				            if(potEdgeIdNum % (boardSize + 1) == 0 || potEdgeIdNum % (boardSize + 1) == boardSize) {
				                console.log("can't go up on an outside edge");
				                tunnel.removeEdge(potentialEdge);
				                tunnel.removeNode(currNode);
				                return false;
				            }

				            neededToEnd = (boardSize - rowNum) + 1;
				        }
				    }
				    console.log("needed to end: " + neededToEnd);
				    console.log("======== done with check =========");
				    console.log();
				    tunnel.removeEdge(potentialEdge);
				    tunnel.removeNode(currNode);
				    return ((edgesLeft - neededToEnd) >= 0);

				    //if edge is vertical
				    //if edge is downward need (remaining pieces - (boardSize - rownum) - 1) >= 0
				    //else if upward need (remaining pieces - (boardSize - rownum) + 1) >= 0
				}

				function getRowNum(edge) {
				    var edgeId = Number(edge.id.slice(1));
				    if(edge.id[0] == "h") {
				        return Math.floor(edgeId / (boardSize));
				    } else {
				        return Math.floor(edgeId / (boardSize + 1));
				    }
				}

				function getRandomEdge(node, tunnel) {
				    // Given the tunnel and the current node
				    var nodeId = node.id;

				    var existingEdgeId;
				    if (nodeId in tunnel.nodes) {
				        var nodeFromTunnel = tunnel.nodes[nodeId];
				        existingEdgeId = nodeFromTunnel.edges[0];
				    } else {
				        existingEdgeId = "bad"
				    }

				    var potentialEdges = [];

				    for (var i = 0; i < node.edges.length; i++) {
				        if (node.edges[i].id != existingEdgeId) {
				            potentialEdges.push(node.edges[i]);
				        }
				    }

				    console.log("list of potential edge candidates for node " + nodeId);
				    for(var i = 0; i < potentialEdges.length; i++) {
				        console.log(potentialEdges[i].id);
				    }

				    var rand = potentialEdges[Math.floor(Math.random() * potentialEdges.length)];
				    return rand;
				}

				function Graph() {
				    this.nodes = {};
				    this.edges = {};
				    this.nodeIds = [];
				    this.edgeIds = [];

				    this.createGraph = function() {
				        console.log("!23")
				        for(var i = 0; i < ((boardSize+1)*(boardSize+1)); i++) {
				            var node = new Node(i);
				            this.nodes[i] = node;
				            this.nodeIds.push(i);
				            var horizontalEdgeIds = getHorizontalEdgesIds(i);
				            var verticalEdgeIds = getVerticalEdgesIds(i);

				            for(var j = 0; j < horizontalEdgeIds.length; j++) {
				                var edgeId = horizontalEdgeIds[j];
				                if (edgeId in this.edges) {
				                    // Add the node to the edge
				                    this.edges[edgeId].allNodes.push(node);
				                    node.addEdge(this.edges[edgeId]);
				                } else {
				                    // Create new edge and add it to edge object
				                    var edge = new Edge(null, null, edgeId);
				                    edge.allNodes.push(node);
				                    this.edges[edgeId] = edge;
				                    this.edgeIds.push(edgeId);
				                    node.addEdge(edge);
				                }
				            }

				            for (var j = 0; j < verticalEdgeIds.length; j++) {
				                var edgeId = verticalEdgeIds[j];
				                if (edgeId in this.edges) {
				                    // Add the node to it
				                    this.edges[edgeId].allNodes.push(node);
				                    node.addEdge(this.edges[edgeId]);
				                } else {
				                    // Create new edge
				                    var edge = new Edge(null, null, edgeId);
				                    edge.allNodes.push(node);
				                    this.edges[edgeId] = edge;
				                    this.edgeIds.push(edgeId);
				                    node.addEdge(this.edges[edgeId]);
				                }
				            }
				        }
				        console.log("nodes");
				        for (var n in this.nodes) {
				            console.log("" + this.nodes[n]);
				        }
				        console.log("edges");
				        for (var e in this.edges) {
				            console.log("" + this.edges[e]);
				        }
				    }
				}

				function getHorizontalEdgesIds(i) {
				    var horizontalEdgeIds = [];

				    // console.log("getting horizontal edges for node " + i);

				    // Create left and right edges
				    var rowNum = Math.floor(i / (boardSize + 1));
				    var leftEdge = i - (rowNum + 1);
				    var rightEdge = i - rowNum;
				    var leftEdgeId = "h" + leftEdge;
				    var rightEdgeId = "h" + rightEdge;

				    // console.log("row num: " + rowNum);
				    // console.log("left edge: " + leftEdge);
				    // console.log("right edge: " + rightEdge);

				    // If on left border, only has right edge
				    if (i % (boardSize + 1) == 0) {
				        // console.log("on left border");
				        leftEdgeId = null;
				    }

				    // If on right border only has left edge
				    if (i % (boardSize + 1) == 6) {
				        // console.log("on right border");
				        rightEdgeId = null;
				    }

				    // Add non null edges
				    if (leftEdgeId != null) {
				        horizontalEdgeIds.push(leftEdgeId);
				    }

				    if (rightEdgeId != null) {
				        horizontalEdgeIds.push(rightEdgeId);
				    }

				    // console.log("final result: " , horizontalEdgeIds);
				    return horizontalEdgeIds;
				}

				function getVerticalEdgesIds(i) {
				    var verticalEdgeIds = [];
				    // console.log("getting vertical edges for node " + i);

				    // If on the first row only has a down edge
				    if (i <= boardSize) {
				        // console.log("on first row");
				        var edgeId = "v" + i;
				        verticalEdgeIds.push(edgeId);
				        return verticalEdgeIds;
				    }

				    // If on the bottom row only has an up edge
				    if (i >= (boardSize * (boardSize + 1))) {
				        // console.log("on bottom row");
				        var upEdgeIdNum = i - (boardSize + 1);
				        var upEdgeId = "v" + upEdgeIdNum;
				        verticalEdgeIds.push(upEdgeId);
				        return verticalEdgeIds;
				    }

				    // Else has both edges
				    var downEdgeId = "v" + i;
				    var upEdgeIdNum = i - (boardSize + 1);
				    var upEdgeId = "v" + upEdgeIdNum;
				    verticalEdgeIds.push(downEdgeId);
				    verticalEdgeIds.push(upEdgeId);
				    // console.log("final result: ", verticalEdgeIds);
				    return verticalEdgeIds;
				}

				function edgeIsHorizontal(edge) {
				    var edgeId = edge.id;
				    var dir = edgeId.slice(0,1);
				    if (dir == "h") {
				        return true;
				    } else {
				        return false;
				    }
				}


				// Add button event listeners

				// Start game in normal mode
				document.getElementById('start').addEventListener('click', startGameInRegularMode, false);

				// Start game in easy mode
				document.getElementById('startEasy').addEventListener('click', startGameInEasyMode, false);

				// Start game with AI
				document.getElementById('startAI').addEventListener('click', startGameAI, false);

				// Start game with AI in easy mode
				document.getElementById('startEasyAI').addEventListener('click', startGameEasyAI, false);

				document.getElementById('tunnelDone').addEventListener('click', doneAddingTunnels, false);

				document.getElementById('probesPlaced1').addEventListener('click', doneAddingProbes, false);

				document.getElementById('probesPlaced2').addEventListener('click', doneAddingProbes, false);

				document.getElementById('submitGuess').addEventListener('click', submitGuess, false);



			/***/ },
			/* 5 */
			/***/ function(module, exports, __webpack_require__) {

				var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
				 * jQuery JavaScript Library v3.1.1
				 * https://jquery.com/
				 *
				 * Includes Sizzle.js
				 * https://sizzlejs.com/
				 *
				 * Copyright jQuery Foundation and other contributors
				 * Released under the MIT license
				 * https://jquery.org/license
				 *
				 * Date: 2016-09-22T22:30Z
				 */
				( function( global, factory ) {

					"use strict";

					if ( typeof module === "object" && typeof module.exports === "object" ) {

						// For CommonJS and CommonJS-like environments where a proper `window`
						// is present, execute the factory and get jQuery.
						// For environments that do not have a `window` with a `document`
						// (such as Node.js), expose a factory as module.exports.
						// This accentuates the need for the creation of a real `window`.
						// e.g. var jQuery = require("jquery")(window);
						// See ticket #14549 for more info.
						module.exports = global.document ?
							factory( global, true ) :
							function( w ) {
								if ( !w.document ) {
									throw new Error( "jQuery requires a window with a document" );
								}
								return factory( w );
							};
					} else {
						factory( global );
					}

				// Pass this if window is not defined yet
				} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

				// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
				// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
				// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
				// enough that all such attempts are guarded in a try block.
				"use strict";

				var arr = [];

				var document = window.document;

				var getProto = Object.getPrototypeOf;

				var slice = arr.slice;

				var concat = arr.concat;

				var push = arr.push;

				var indexOf = arr.indexOf;

				var class2type = {};

				var toString = class2type.toString;

				var hasOwn = class2type.hasOwnProperty;

				var fnToString = hasOwn.toString;

				var ObjectFunctionString = fnToString.call( Object );

				var support = {};



					function DOMEval( code, doc ) {
						doc = doc || document;

						var script = doc.createElement( "script" );

						script.text = code;
						doc.head.appendChild( script ).parentNode.removeChild( script );
					}
				/* global Symbol */
				// Defining this global in .eslintrc.json would create a danger of using the global
				// unguarded in another place, it seems safer to define global only for this module



				var
					version = "3.1.1",

					// Define a local copy of jQuery
					jQuery = function( selector, context ) {

						// The jQuery object is actually just the init constructor 'enhanced'
						// Need init if jQuery is called (just allow error to be thrown if not included)
						return new jQuery.fn.init( selector, context );
					},

					// Support: Android <=4.0 only
					// Make sure we trim BOM and NBSP
					rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

					// Matches dashed string for camelizing
					rmsPrefix = /^-ms-/,
					rdashAlpha = /-([a-z])/g,

					// Used by jQuery.camelCase as callback to replace()
					fcamelCase = function( all, letter ) {
						return letter.toUpperCase();
					};

				jQuery.fn = jQuery.prototype = {

					// The current version of jQuery being used
					jquery: version,

					constructor: jQuery,

					// The default length of a jQuery object is 0
					length: 0,

					toArray: function() {
						return slice.call( this );
					},

					// Get the Nth element in the matched element set OR
					// Get the whole matched element set as a clean array
					get: function( num ) {

						// Return all the elements in a clean array
						if ( num == null ) {
							return slice.call( this );
						}

						// Return just the one element from the set
						return num < 0 ? this[ num + this.length ] : this[ num ];
					},

					// Take an array of elements and push it onto the stack
					// (returning the new matched element set)
					pushStack: function( elems ) {

						// Build a new jQuery matched element set
						var ret = jQuery.merge( this.constructor(), elems );

						// Add the old object onto the stack (as a reference)
						ret.prevObject = this;

						// Return the newly-formed element set
						return ret;
					},

					// Execute a callback for every element in the matched set.
					each: function( callback ) {
						return jQuery.each( this, callback );
					},

					map: function( callback ) {
						return this.pushStack( jQuery.map( this, function( elem, i ) {
							return callback.call( elem, i, elem );
						} ) );
					},

					slice: function() {
						return this.pushStack( slice.apply( this, arguments ) );
					},

					first: function() {
						return this.eq( 0 );
					},

					last: function() {
						return this.eq( -1 );
					},

					eq: function( i ) {
						var len = this.length,
							j = +i + ( i < 0 ? len : 0 );
						return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
					},

					end: function() {
						return this.prevObject || this.constructor();
					},

					// For internal use only.
					// Behaves like an Array's method, not like a jQuery method.
					push: push,
					sort: arr.sort,
					splice: arr.splice
				};

				jQuery.extend = jQuery.fn.extend = function() {
					var options, name, src, copy, copyIsArray, clone,
						target = arguments[ 0 ] || {},
						i = 1,
						length = arguments.length,
						deep = false;

					// Handle a deep copy situation
					if ( typeof target === "boolean" ) {
						deep = target;

						// Skip the boolean and the target
						target = arguments[ i ] || {};
						i++;
					}

					// Handle case when target is a string or something (possible in deep copy)
					if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {
						target = {};
					}

					// Extend jQuery itself if only one argument is passed
					if ( i === length ) {
						target = this;
						i--;
					}

					for ( ; i < length; i++ ) {

						// Only deal with non-null/undefined values
						if ( ( options = arguments[ i ] ) != null ) {

							// Extend the base object
							for ( name in options ) {
								src = target[ name ];
								copy = options[ name ];

								// Prevent never-ending loop
								if ( target === copy ) {
									continue;
								}

								// Recurse if we're merging plain objects or arrays
								if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
									( copyIsArray = jQuery.isArray( copy ) ) ) ) {

									if ( copyIsArray ) {
										copyIsArray = false;
										clone = src && jQuery.isArray( src ) ? src : [];

									} else {
										clone = src && jQuery.isPlainObject( src ) ? src : {};
									}

									// Never move original objects, clone them
									target[ name ] = jQuery.extend( deep, clone, copy );

								// Don't bring in undefined values
								} else if ( copy !== undefined ) {
									target[ name ] = copy;
								}
							}
						}
					}

					// Return the modified object
					return target;
				};

				jQuery.extend( {

					// Unique for each copy of jQuery on the page
					expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

					// Assume jQuery is ready without the ready module
					isReady: true,

					error: function( msg ) {
						throw new Error( msg );
					},

					noop: function() {},

					isFunction: function( obj ) {
						return jQuery.type( obj ) === "function";
					},

					isArray: Array.isArray,

					isWindow: function( obj ) {
						return obj != null && obj === obj.window;
					},

					isNumeric: function( obj ) {

						// As of jQuery 3.0, isNumeric is limited to
						// strings and numbers (primitives or objects)
						// that can be coerced to finite numbers (gh-2662)
						var type = jQuery.type( obj );
						return ( type === "number" || type === "string" ) &&

							// parseFloat NaNs numeric-cast false positives ("")
							// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
							// subtraction forces infinities to NaN
							!isNaN( obj - parseFloat( obj ) );
					},

					isPlainObject: function( obj ) {
						var proto, Ctor;

						// Detect obvious negatives
						// Use toString instead of jQuery.type to catch host objects
						if ( !obj || toString.call( obj ) !== "[object Object]" ) {
							return false;
						}

						proto = getProto( obj );

						// Objects with no prototype (e.g., `Object.create( null )`) are plain
						if ( !proto ) {
							return true;
						}

						// Objects with prototype are plain iff they were constructed by a global Object function
						Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
						return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
					},

					isEmptyObject: function( obj ) {

						/* eslint-disable no-unused-vars */
						// See https://github.com/eslint/eslint/issues/6125
						var name;

						for ( name in obj ) {
							return false;
						}
						return true;
					},

					type: function( obj ) {
						if ( obj == null ) {
							return obj + "";
						}

						// Support: Android <=2.3 only (functionish RegExp)
						return typeof obj === "object" || typeof obj === "function" ?
							class2type[ toString.call( obj ) ] || "object" :
							typeof obj;
					},

					// Evaluates a script in a global context
					globalEval: function( code ) {
						DOMEval( code );
					},

					// Convert dashed to camelCase; used by the css and data modules
					// Support: IE <=9 - 11, Edge 12 - 13
					// Microsoft forgot to hump their vendor prefix (#9572)
					camelCase: function( string ) {
						return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
					},

					nodeName: function( elem, name ) {
						return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
					},

					each: function( obj, callback ) {
						var length, i = 0;

						if ( isArrayLike( obj ) ) {
							length = obj.length;
							for ( ; i < length; i++ ) {
								if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
									break;
								}
							}
						} else {
							for ( i in obj ) {
								if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
									break;
								}
							}
						}

						return obj;
					},

					// Support: Android <=4.0 only
					trim: function( text ) {
						return text == null ?
							"" :
							( text + "" ).replace( rtrim, "" );
					},

					// results is for internal usage only
					makeArray: function( arr, results ) {
						var ret = results || [];

						if ( arr != null ) {
							if ( isArrayLike( Object( arr ) ) ) {
								jQuery.merge( ret,
									typeof arr === "string" ?
									[ arr ] : arr
								);
							} else {
								push.call( ret, arr );
							}
						}

						return ret;
					},

					inArray: function( elem, arr, i ) {
						return arr == null ? -1 : indexOf.call( arr, elem, i );
					},

					// Support: Android <=4.0 only, PhantomJS 1 only
					// push.apply(_, arraylike) throws on ancient WebKit
					merge: function( first, second ) {
						var len = +second.length,
							j = 0,
							i = first.length;

						for ( ; j < len; j++ ) {
							first[ i++ ] = second[ j ];
						}

						first.length = i;

						return first;
					},

					grep: function( elems, callback, invert ) {
						var callbackInverse,
							matches = [],
							i = 0,
							length = elems.length,
							callbackExpect = !invert;

						// Go through the array, only saving the items
						// that pass the validator function
						for ( ; i < length; i++ ) {
							callbackInverse = !callback( elems[ i ], i );
							if ( callbackInverse !== callbackExpect ) {
								matches.push( elems[ i ] );
							}
						}

						return matches;
					},

					// arg is for internal usage only
					map: function( elems, callback, arg ) {
						var length, value,
							i = 0,
							ret = [];

						// Go through the array, translating each of the items to their new values
						if ( isArrayLike( elems ) ) {
							length = elems.length;
							for ( ; i < length; i++ ) {
								value = callback( elems[ i ], i, arg );

								if ( value != null ) {
									ret.push( value );
								}
							}

						// Go through every key on the object,
						} else {
							for ( i in elems ) {
								value = callback( elems[ i ], i, arg );

								if ( value != null ) {
									ret.push( value );
								}
							}
						}

						// Flatten any nested arrays
						return concat.apply( [], ret );
					},

					// A global GUID counter for objects
					guid: 1,

					// Bind a function to a context, optionally partially applying any
					// arguments.
					proxy: function( fn, context ) {
						var tmp, args, proxy;

						if ( typeof context === "string" ) {
							tmp = fn[ context ];
							context = fn;
							fn = tmp;
						}

						// Quick check to determine if target is callable, in the spec
						// this throws a TypeError, but we will just return undefined.
						if ( !jQuery.isFunction( fn ) ) {
							return undefined;
						}

						// Simulated bind
						args = slice.call( arguments, 2 );
						proxy = function() {
							return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
						};

						// Set the guid of unique handler to the same of original handler, so it can be removed
						proxy.guid = fn.guid = fn.guid || jQuery.guid++;

						return proxy;
					},

					now: Date.now,

					// jQuery.support is not used in Core but other projects attach their
					// properties to it so it needs to exist.
					support: support
				} );

				if ( typeof Symbol === "function" ) {
					jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
				}

				// Populate the class2type map
				jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
				function( i, name ) {
					class2type[ "[object " + name + "]" ] = name.toLowerCase();
				} );

				function isArrayLike( obj ) {

					// Support: real iOS 8.2 only (not reproducible in simulator)
					// `in` check used to prevent JIT error (gh-2145)
					// hasOwn isn't used here due to false negatives
					// regarding Nodelist length in IE
					var length = !!obj && "length" in obj && obj.length,
						type = jQuery.type( obj );

					if ( type === "function" || jQuery.isWindow( obj ) ) {
						return false;
					}

					return type === "array" || length === 0 ||
						typeof length === "number" && length > 0 && ( length - 1 ) in obj;
				}
				var Sizzle =
				/*!
				 * Sizzle CSS Selector Engine v2.3.3
				 * https://sizzlejs.com/
				 *
				 * Copyright jQuery Foundation and other contributors
				 * Released under the MIT license
				 * http://jquery.org/license
				 *
				 * Date: 2016-08-08
				 */
				(function( window ) {

				var i,
					support,
					Expr,
					getText,
					isXML,
					tokenize,
					compile,
					select,
					outermostContext,
					sortInput,
					hasDuplicate,

					// Local document vars
					setDocument,
					document,
					docElem,
					documentIsHTML,
					rbuggyQSA,
					rbuggyMatches,
					matches,
					contains,

					// Instance-specific data
					expando = "sizzle" + 1 * new Date(),
					preferredDoc = window.document,
					dirruns = 0,
					done = 0,
					classCache = createCache(),
					tokenCache = createCache(),
					compilerCache = createCache(),
					sortOrder = function( a, b ) {
						if ( a === b ) {
							hasDuplicate = true;
						}
						return 0;
					},

					// Instance methods
					hasOwn = ({}).hasOwnProperty,
					arr = [],
					pop = arr.pop,
					push_native = arr.push,
					push = arr.push,
					slice = arr.slice,
					// Use a stripped-down indexOf as it's faster than native
					// https://jsperf.com/thor-indexof-vs-for/5
					indexOf = function( list, elem ) {
						var i = 0,
							len = list.length;
						for ( ; i < len; i++ ) {
							if ( list[i] === elem ) {
								return i;
							}
						}
						return -1;
					},

					booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

					// Regular expressions

					// http://www.w3.org/TR/css3-selectors/#whitespace
					whitespace = "[\\x20\\t\\r\\n\\f]",

					// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
					identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

					// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
					attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
						// Operator (capture 2)
						"*([*^$|!~]?=)" + whitespace +
						// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
						"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
						"*\\]",

					pseudos = ":(" + identifier + ")(?:\\((" +
						// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
						// 1. quoted (capture 3; capture 4 or capture 5)
						"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
						// 2. simple (capture 6)
						"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
						// 3. anything else (capture 2)
						".*" +
						")\\)|)",

					// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
					rwhitespace = new RegExp( whitespace + "+", "g" ),
					rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

					rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
					rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

					rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

					rpseudo = new RegExp( pseudos ),
					ridentifier = new RegExp( "^" + identifier + "$" ),

					matchExpr = {
						"ID": new RegExp( "^#(" + identifier + ")" ),
						"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
						"TAG": new RegExp( "^(" + identifier + "|[*])" ),
						"ATTR": new RegExp( "^" + attributes ),
						"PSEUDO": new RegExp( "^" + pseudos ),
						"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
							"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
							"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
						"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
						// For use in libraries implementing .is()
						// We use this for POS matching in `select`
						"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
							whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
					},

					rinputs = /^(?:input|select|textarea|button)$/i,
					rheader = /^h\d$/i,

					rnative = /^[^{]+\{\s*\[native \w/,

					// Easily-parseable/retrievable ID or TAG or CLASS selectors
					rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

					rsibling = /[+~]/,

					// CSS escapes
					// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
					runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
					funescape = function( _, escaped, escapedWhitespace ) {
						var high = "0x" + escaped - 0x10000;
						// NaN means non-codepoint
						// Support: Firefox<24
						// Workaround erroneous numeric interpretation of +"0x"
						return high !== high || escapedWhitespace ?
							escaped :
							high < 0 ?
								// BMP codepoint
								String.fromCharCode( high + 0x10000 ) :
								// Supplemental Plane codepoint (surrogate pair)
								String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
					},

					// CSS string/identifier serialization
					// https://drafts.csswg.org/cssom/#common-serializing-idioms
					rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
					fcssescape = function( ch, asCodePoint ) {
						if ( asCodePoint ) {

							// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
							if ( ch === "\0" ) {
								return "\uFFFD";
							}

							// Control characters and (dependent upon position) numbers get escaped as code points
							return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
						}

						// Other potentially-special ASCII characters get backslash-escaped
						return "\\" + ch;
					},

					// Used for iframes
					// See setDocument()
					// Removing the function wrapper causes a "Permission Denied"
					// error in IE
					unloadHandler = function() {
						setDocument();
					},

					disabledAncestor = addCombinator(
						function( elem ) {
							return elem.disabled === true && ("form" in elem || "label" in elem);
						},
						{ dir: "parentNode", next: "legend" }
					);

				// Optimize for push.apply( _, NodeList )
				try {
					push.apply(
						(arr = slice.call( preferredDoc.childNodes )),
						preferredDoc.childNodes
					);
					// Support: Android<4.0
					// Detect silently failing push.apply
					arr[ preferredDoc.childNodes.length ].nodeType;
				} catch ( e ) {
					push = { apply: arr.length ?

						// Leverage slice if possible
						function( target, els ) {
							push_native.apply( target, slice.call(els) );
						} :

						// Support: IE<9
						// Otherwise append directly
						function( target, els ) {
							var j = target.length,
								i = 0;
							// Can't trust NodeList.length
							while ( (target[j++] = els[i++]) ) {}
							target.length = j - 1;
						}
					};
				}

				function Sizzle( selector, context, results, seed ) {
					var m, i, elem, nid, match, groups, newSelector,
						newContext = context && context.ownerDocument,

						// nodeType defaults to 9, since context defaults to document
						nodeType = context ? context.nodeType : 9;

					results = results || [];

					// Return early from calls with invalid selector or context
					if ( typeof selector !== "string" || !selector ||
						nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

						return results;
					}

					// Try to shortcut find operations (as opposed to filters) in HTML documents
					if ( !seed ) {

						if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
							setDocument( context );
						}
						context = context || document;

						if ( documentIsHTML ) {

							// If the selector is sufficiently simple, try using a "get*By*" DOM method
							// (excepting DocumentFragment context, where the methods don't exist)
							if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

								// ID selector
								if ( (m = match[1]) ) {

									// Document context
									if ( nodeType === 9 ) {
										if ( (elem = context.getElementById( m )) ) {

											// Support: IE, Opera, Webkit
											// TODO: identify versions
											// getElementById can match elements by name instead of ID
											if ( elem.id === m ) {
												results.push( elem );
												return results;
											}
										} else {
											return results;
										}

									// Element context
									} else {

										// Support: IE, Opera, Webkit
										// TODO: identify versions
										// getElementById can match elements by name instead of ID
										if ( newContext && (elem = newContext.getElementById( m )) &&
											contains( context, elem ) &&
											elem.id === m ) {

											results.push( elem );
											return results;
										}
									}

								// Type selector
								} else if ( match[2] ) {
									push.apply( results, context.getElementsByTagName( selector ) );
									return results;

								// Class selector
								} else if ( (m = match[3]) && support.getElementsByClassName &&
									context.getElementsByClassName ) {

									push.apply( results, context.getElementsByClassName( m ) );
									return results;
								}
							}

							// Take advantage of querySelectorAll
							if ( support.qsa &&
								!compilerCache[ selector + " " ] &&
								(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

								if ( nodeType !== 1 ) {
									newContext = context;
									newSelector = selector;

								// qSA looks outside Element context, which is not what we want
								// Thanks to Andrew Dupont for this workaround technique
								// Support: IE <=8
								// Exclude object elements
								} else if ( context.nodeName.toLowerCase() !== "object" ) {

									// Capture the context ID, setting it first if necessary
									if ( (nid = context.getAttribute( "id" )) ) {
										nid = nid.replace( rcssescape, fcssescape );
									} else {
										context.setAttribute( "id", (nid = expando) );
									}

									// Prefix every selector in the list
									groups = tokenize( selector );
									i = groups.length;
									while ( i-- ) {
										groups[i] = "#" + nid + " " + toSelector( groups[i] );
									}
									newSelector = groups.join( "," );

									// Expand context for sibling selectors
									newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
										context;
								}

								if ( newSelector ) {
									try {
										push.apply( results,
											newContext.querySelectorAll( newSelector )
										);
										return results;
									} catch ( qsaError ) {
									} finally {
										if ( nid === expando ) {
											context.removeAttribute( "id" );
										}
									}
								}
							}
						}
					}

					// All others
					return select( selector.replace( rtrim, "$1" ), context, results, seed );
				}

				/**
				 * Create key-value caches of limited size
				 * @returns {function(string, object)} Returns the Object data after storing it on itself with
				 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
				 *	deleting the oldest entry
				 */
				function createCache() {
					var keys = [];

					function cache( key, value ) {
						// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
						if ( keys.push( key + " " ) > Expr.cacheLength ) {
							// Only keep the most recent entries
							delete cache[ keys.shift() ];
						}
						return (cache[ key + " " ] = value);
					}
					return cache;
				}

				/**
				 * Mark a function for special use by Sizzle
				 * @param {Function} fn The function to mark
				 */
				function markFunction( fn ) {
					fn[ expando ] = true;
					return fn;
				}

				/**
				 * Support testing using an element
				 * @param {Function} fn Passed the created element and returns a boolean result
				 */
				function assert( fn ) {
					var el = document.createElement("fieldset");

					try {
						return !!fn( el );
					} catch (e) {
						return false;
					} finally {
						// Remove from its parent by default
						if ( el.parentNode ) {
							el.parentNode.removeChild( el );
						}
						// release memory in IE
						el = null;
					}
				}

				/**
				 * Adds the same handler for all of the specified attrs
				 * @param {String} attrs Pipe-separated list of attributes
				 * @param {Function} handler The method that will be applied
				 */
				function addHandle( attrs, handler ) {
					var arr = attrs.split("|"),
						i = arr.length;

					while ( i-- ) {
						Expr.attrHandle[ arr[i] ] = handler;
					}
				}

				/**
				 * Checks document order of two siblings
				 * @param {Element} a
				 * @param {Element} b
				 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
				 */
				function siblingCheck( a, b ) {
					var cur = b && a,
						diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
							a.sourceIndex - b.sourceIndex;

					// Use IE sourceIndex if available on both nodes
					if ( diff ) {
						return diff;
					}

					// Check if b follows a
					if ( cur ) {
						while ( (cur = cur.nextSibling) ) {
							if ( cur === b ) {
								return -1;
							}
						}
					}

					return a ? 1 : -1;
				}

				/**
				 * Returns a function to use in pseudos for input types
				 * @param {String} type
				 */
				function createInputPseudo( type ) {
					return function( elem ) {
						var name = elem.nodeName.toLowerCase();
						return name === "input" && elem.type === type;
					};
				}

				/**
				 * Returns a function to use in pseudos for buttons
				 * @param {String} type
				 */
				function createButtonPseudo( type ) {
					return function( elem ) {
						var name = elem.nodeName.toLowerCase();
						return (name === "input" || name === "button") && elem.type === type;
					};
				}

				/**
				 * Returns a function to use in pseudos for :enabled/:disabled
				 * @param {Boolean} disabled true for :disabled; false for :enabled
				 */
				function createDisabledPseudo( disabled ) {

					// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
					return function( elem ) {

						// Only certain elements can match :enabled or :disabled
						// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
						// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
						if ( "form" in elem ) {

							// Check for inherited disabledness on relevant non-disabled elements:
							// * listed form-associated elements in a disabled fieldset
							//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
							//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
							// * option elements in a disabled optgroup
							//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
							// All such elements have a "form" property.
							if ( elem.parentNode && elem.disabled === false ) {

								// Option elements defer to a parent optgroup if present
								if ( "label" in elem ) {
									if ( "label" in elem.parentNode ) {
										return elem.parentNode.disabled === disabled;
									} else {
										return elem.disabled === disabled;
									}
								}

								// Support: IE 6 - 11
								// Use the isDisabled shortcut property to check for disabled fieldset ancestors
								return elem.isDisabled === disabled ||

									// Where there is no isDisabled, check manually
									/* jshint -W018 */
									elem.isDisabled !== !disabled &&
										disabledAncestor( elem ) === disabled;
							}

							return elem.disabled === disabled;

						// Try to winnow out elements that can't be disabled before trusting the disabled property.
						// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
						// even exist on them, let alone have a boolean value.
						} else if ( "label" in elem ) {
							return elem.disabled === disabled;
						}

						// Remaining elements are neither :enabled nor :disabled
						return false;
					};
				}

				/**
				 * Returns a function to use in pseudos for positionals
				 * @param {Function} fn
				 */
				function createPositionalPseudo( fn ) {
					return markFunction(function( argument ) {
						argument = +argument;
						return markFunction(function( seed, matches ) {
							var j,
								matchIndexes = fn( [], seed.length, argument ),
								i = matchIndexes.length;

							// Match elements found at the specified indexes
							while ( i-- ) {
								if ( seed[ (j = matchIndexes[i]) ] ) {
									seed[j] = !(matches[j] = seed[j]);
								}
							}
						});
					});
				}

				/**
				 * Checks a node for validity as a Sizzle context
				 * @param {Element|Object=} context
				 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
				 */
				function testContext( context ) {
					return context && typeof context.getElementsByTagName !== "undefined" && context;
				}

				// Expose support vars for convenience
				support = Sizzle.support = {};

				/**
				 * Detects XML nodes
				 * @param {Element|Object} elem An element or a document
				 * @returns {Boolean} True iff elem is a non-HTML XML node
				 */
				isXML = Sizzle.isXML = function( elem ) {
					// documentElement is verified for cases where it doesn't yet exist
					// (such as loading iframes in IE - #4833)
					var documentElement = elem && (elem.ownerDocument || elem).documentElement;
					return documentElement ? documentElement.nodeName !== "HTML" : false;
				};

				/**
				 * Sets document-related variables once based on the current document
				 * @param {Element|Object} [doc] An element or document object to use to set the document
				 * @returns {Object} Returns the current document
				 */
				setDocument = Sizzle.setDocument = function( node ) {
					var hasCompare, subWindow,
						doc = node ? node.ownerDocument || node : preferredDoc;

					// Return early if doc is invalid or already selected
					if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
						return document;
					}

					// Update global variables
					document = doc;
					docElem = document.documentElement;
					documentIsHTML = !isXML( document );

					// Support: IE 9-11, Edge
					// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
					if ( preferredDoc !== document &&
						(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

						// Support: IE 11, Edge
						if ( subWindow.addEventListener ) {
							subWindow.addEventListener( "unload", unloadHandler, false );

						// Support: IE 9 - 10 only
						} else if ( subWindow.attachEvent ) {
							subWindow.attachEvent( "onunload", unloadHandler );
						}
					}

					/* Attributes
					---------------------------------------------------------------------- */

					// Support: IE<8
					// Verify that getAttribute really returns attributes and not properties
					// (excepting IE8 booleans)
					support.attributes = assert(function( el ) {
						el.className = "i";
						return !el.getAttribute("className");
					});

					/* getElement(s)By*
					---------------------------------------------------------------------- */

					// Check if getElementsByTagName("*") returns only elements
					support.getElementsByTagName = assert(function( el ) {
						el.appendChild( document.createComment("") );
						return !el.getElementsByTagName("*").length;
					});

					// Support: IE<9
					support.getElementsByClassName = rnative.test( document.getElementsByClassName );

					// Support: IE<10
					// Check if getElementById returns elements by name
					// The broken getElementById methods don't pick up programmatically-set names,
					// so use a roundabout getElementsByName test
					support.getById = assert(function( el ) {
						docElem.appendChild( el ).id = expando;
						return !document.getElementsByName || !document.getElementsByName( expando ).length;
					});

					// ID filter and find
					if ( support.getById ) {
						Expr.filter["ID"] = function( id ) {
							var attrId = id.replace( runescape, funescape );
							return function( elem ) {
								return elem.getAttribute("id") === attrId;
							};
						};
						Expr.find["ID"] = function( id, context ) {
							if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
								var elem = context.getElementById( id );
								return elem ? [ elem ] : [];
							}
						};
					} else {
						Expr.filter["ID"] =  function( id ) {
							var attrId = id.replace( runescape, funescape );
							return function( elem ) {
								var node = typeof elem.getAttributeNode !== "undefined" &&
									elem.getAttributeNode("id");
								return node && node.value === attrId;
							};
						};

						// Support: IE 6 - 7 only
						// getElementById is not reliable as a find shortcut
						Expr.find["ID"] = function( id, context ) {
							if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
								var node, i, elems,
									elem = context.getElementById( id );

								if ( elem ) {

									// Verify the id attribute
									node = elem.getAttributeNode("id");
									if ( node && node.value === id ) {
										return [ elem ];
									}

									// Fall back on getElementsByName
									elems = context.getElementsByName( id );
									i = 0;
									while ( (elem = elems[i++]) ) {
										node = elem.getAttributeNode("id");
										if ( node && node.value === id ) {
											return [ elem ];
										}
									}
								}

								return [];
							}
						};
					}

					// Tag
					Expr.find["TAG"] = support.getElementsByTagName ?
						function( tag, context ) {
							if ( typeof context.getElementsByTagName !== "undefined" ) {
								return context.getElementsByTagName( tag );

							// DocumentFragment nodes don't have gEBTN
							} else if ( support.qsa ) {
								return context.querySelectorAll( tag );
							}
						} :

						function( tag, context ) {
							var elem,
								tmp = [],
								i = 0,
								// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
								results = context.getElementsByTagName( tag );

							// Filter out possible comments
							if ( tag === "*" ) {
								while ( (elem = results[i++]) ) {
									if ( elem.nodeType === 1 ) {
										tmp.push( elem );
									}
								}

								return tmp;
							}
							return results;
						};

					// Class
					Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
						if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
							return context.getElementsByClassName( className );
						}
					};

					/* QSA/matchesSelector
					---------------------------------------------------------------------- */

					// QSA and matchesSelector support

					// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
					rbuggyMatches = [];

					// qSa(:focus) reports false when true (Chrome 21)
					// We allow this because of a bug in IE8/9 that throws an error
					// whenever `document.activeElement` is accessed on an iframe
					// So, we allow :focus to pass through QSA all the time to avoid the IE error
					// See https://bugs.jquery.com/ticket/13378
					rbuggyQSA = [];

					if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
						// Build QSA regex
						// Regex strategy adopted from Diego Perini
						assert(function( el ) {
							// Select is set to empty string on purpose
							// This is to test IE's treatment of not explicitly
							// setting a boolean content attribute,
							// since its presence should be enough
							// https://bugs.jquery.com/ticket/12359
							docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
								"<select id='" + expando + "-\r\\' msallowcapture=''>" +
								"<option selected=''></option></select>";

							// Support: IE8, Opera 11-12.16
							// Nothing should be selected when empty strings follow ^= or $= or *=
							// The test attribute must be unknown in Opera but "safe" for WinRT
							// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
							if ( el.querySelectorAll("[msallowcapture^='']").length ) {
								rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
							}

							// Support: IE8
							// Boolean attributes and "value" are not treated correctly
							if ( !el.querySelectorAll("[selected]").length ) {
								rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
							}

							// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
							if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
								rbuggyQSA.push("~=");
							}

							// Webkit/Opera - :checked should return selected option elements
							// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
							// IE8 throws error here and will not see later tests
							if ( !el.querySelectorAll(":checked").length ) {
								rbuggyQSA.push(":checked");
							}

							// Support: Safari 8+, iOS 8+
							// https://bugs.webkit.org/show_bug.cgi?id=136851
							// In-page `selector#id sibling-combinator selector` fails
							if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
								rbuggyQSA.push(".#.+[+~]");
							}
						});

						assert(function( el ) {
							el.innerHTML = "<a href='' disabled='disabled'></a>" +
								"<select disabled='disabled'><option/></select>";

							// Support: Windows 8 Native Apps
							// The type and name attributes are restricted during .innerHTML assignment
							var input = document.createElement("input");
							input.setAttribute( "type", "hidden" );
							el.appendChild( input ).setAttribute( "name", "D" );

							// Support: IE8
							// Enforce case-sensitivity of name attribute
							if ( el.querySelectorAll("[name=d]").length ) {
								rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
							}

							// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
							// IE8 throws error here and will not see later tests
							if ( el.querySelectorAll(":enabled").length !== 2 ) {
								rbuggyQSA.push( ":enabled", ":disabled" );
							}

							// Support: IE9-11+
							// IE's :disabled selector does not pick up the children of disabled fieldsets
							docElem.appendChild( el ).disabled = true;
							if ( el.querySelectorAll(":disabled").length !== 2 ) {
								rbuggyQSA.push( ":enabled", ":disabled" );
							}

							// Opera 10-11 does not throw on post-comma invalid pseudos
							el.querySelectorAll("*,:x");
							rbuggyQSA.push(",.*:");
						});
					}

					if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
						docElem.webkitMatchesSelector ||
						docElem.mozMatchesSelector ||
						docElem.oMatchesSelector ||
						docElem.msMatchesSelector) )) ) {

						assert(function( el ) {
							// Check to see if it's possible to do matchesSelector
							// on a disconnected node (IE 9)
							support.disconnectedMatch = matches.call( el, "*" );

							// This should fail with an exception
							// Gecko does not error, returns false instead
							matches.call( el, "[s!='']:x" );
							rbuggyMatches.push( "!=", pseudos );
						});
					}

					rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
					rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

					/* Contains
					---------------------------------------------------------------------- */
					hasCompare = rnative.test( docElem.compareDocumentPosition );

					// Element contains another
					// Purposefully self-exclusive
					// As in, an element does not contain itself
					contains = hasCompare || rnative.test( docElem.contains ) ?
						function( a, b ) {
							var adown = a.nodeType === 9 ? a.documentElement : a,
								bup = b && b.parentNode;
							return a === bup || !!( bup && bup.nodeType === 1 && (
								adown.contains ?
									adown.contains( bup ) :
									a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
							));
						} :
						function( a, b ) {
							if ( b ) {
								while ( (b = b.parentNode) ) {
									if ( b === a ) {
										return true;
									}
								}
							}
							return false;
						};

					/* Sorting
					---------------------------------------------------------------------- */

					// Document order sorting
					sortOrder = hasCompare ?
					function( a, b ) {

						// Flag for duplicate removal
						if ( a === b ) {
							hasDuplicate = true;
							return 0;
						}

						// Sort on method existence if only one input has compareDocumentPosition
						var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
						if ( compare ) {
							return compare;
						}

						// Calculate position if both inputs belong to the same document
						compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
							a.compareDocumentPosition( b ) :

							// Otherwise we know they are disconnected
							1;

						// Disconnected nodes
						if ( compare & 1 ||
							(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

							// Choose the first element that is related to our preferred document
							if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
								return -1;
							}
							if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
								return 1;
							}

							// Maintain original order
							return sortInput ?
								( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
								0;
						}

						return compare & 4 ? -1 : 1;
					} :
					function( a, b ) {
						// Exit early if the nodes are identical
						if ( a === b ) {
							hasDuplicate = true;
							return 0;
						}

						var cur,
							i = 0,
							aup = a.parentNode,
							bup = b.parentNode,
							ap = [ a ],
							bp = [ b ];

						// Parentless nodes are either documents or disconnected
						if ( !aup || !bup ) {
							return a === document ? -1 :
								b === document ? 1 :
								aup ? -1 :
								bup ? 1 :
								sortInput ?
								( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
								0;

						// If the nodes are siblings, we can do a quick check
						} else if ( aup === bup ) {
							return siblingCheck( a, b );
						}

						// Otherwise we need full lists of their ancestors for comparison
						cur = a;
						while ( (cur = cur.parentNode) ) {
							ap.unshift( cur );
						}
						cur = b;
						while ( (cur = cur.parentNode) ) {
							bp.unshift( cur );
						}

						// Walk down the tree looking for a discrepancy
						while ( ap[i] === bp[i] ) {
							i++;
						}

						return i ?
							// Do a sibling check if the nodes have a common ancestor
							siblingCheck( ap[i], bp[i] ) :

							// Otherwise nodes in our document sort first
							ap[i] === preferredDoc ? -1 :
							bp[i] === preferredDoc ? 1 :
							0;
					};

					return document;
				};

				Sizzle.matches = function( expr, elements ) {
					return Sizzle( expr, null, null, elements );
				};

				Sizzle.matchesSelector = function( elem, expr ) {
					// Set document vars if needed
					if ( ( elem.ownerDocument || elem ) !== document ) {
						setDocument( elem );
					}

					// Make sure that attribute selectors are quoted
					expr = expr.replace( rattributeQuotes, "='$1']" );

					if ( support.matchesSelector && documentIsHTML &&
						!compilerCache[ expr + " " ] &&
						( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
						( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

						try {
							var ret = matches.call( elem, expr );

							// IE 9's matchesSelector returns false on disconnected nodes
							if ( ret || support.disconnectedMatch ||
									// As well, disconnected nodes are said to be in a document
									// fragment in IE 9
									elem.document && elem.document.nodeType !== 11 ) {
								return ret;
							}
						} catch (e) {}
					}

					return Sizzle( expr, document, null, [ elem ] ).length > 0;
				};

				Sizzle.contains = function( context, elem ) {
					// Set document vars if needed
					if ( ( context.ownerDocument || context ) !== document ) {
						setDocument( context );
					}
					return contains( context, elem );
				};

				Sizzle.attr = function( elem, name ) {
					// Set document vars if needed
					if ( ( elem.ownerDocument || elem ) !== document ) {
						setDocument( elem );
					}

					var fn = Expr.attrHandle[ name.toLowerCase() ],
						// Don't get fooled by Object.prototype properties (jQuery #13807)
						val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
							fn( elem, name, !documentIsHTML ) :
							undefined;

					return val !== undefined ?
						val :
						support.attributes || !documentIsHTML ?
							elem.getAttribute( name ) :
							(val = elem.getAttributeNode(name)) && val.specified ?
								val.value :
								null;
				};

				Sizzle.escape = function( sel ) {
					return (sel + "").replace( rcssescape, fcssescape );
				};

				Sizzle.error = function( msg ) {
					throw new Error( "Syntax error, unrecognized expression: " + msg );
				};

				/**
				 * Document sorting and removing duplicates
				 * @param {ArrayLike} results
				 */
				Sizzle.uniqueSort = function( results ) {
					var elem,
						duplicates = [],
						j = 0,
						i = 0;

					// Unless we *know* we can detect duplicates, assume their presence
					hasDuplicate = !support.detectDuplicates;
					sortInput = !support.sortStable && results.slice( 0 );
					results.sort( sortOrder );

					if ( hasDuplicate ) {
						while ( (elem = results[i++]) ) {
							if ( elem === results[ i ] ) {
								j = duplicates.push( i );
							}
						}
						while ( j-- ) {
							results.splice( duplicates[ j ], 1 );
						}
					}

					// Clear input after sorting to release objects
					// See https://github.com/jquery/sizzle/pull/225
					sortInput = null;

					return results;
				};

				/**
				 * Utility function for retrieving the text value of an array of DOM nodes
				 * @param {Array|Element} elem
				 */
				getText = Sizzle.getText = function( elem ) {
					var node,
						ret = "",
						i = 0,
						nodeType = elem.nodeType;

					if ( !nodeType ) {
						// If no nodeType, this is expected to be an array
						while ( (node = elem[i++]) ) {
							// Do not traverse comment nodes
							ret += getText( node );
						}
					} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
						// Use textContent for elements
						// innerText usage removed for consistency of new lines (jQuery #11153)
						if ( typeof elem.textContent === "string" ) {
							return elem.textContent;
						} else {
							// Traverse its children
							for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
								ret += getText( elem );
							}
						}
					} else if ( nodeType === 3 || nodeType === 4 ) {
						return elem.nodeValue;
					}
					// Do not include comment or processing instruction nodes

					return ret;
				};

				Expr = Sizzle.selectors = {

					// Can be adjusted by the user
					cacheLength: 50,

					createPseudo: markFunction,

					match: matchExpr,

					attrHandle: {},

					find: {},

					relative: {
						">": { dir: "parentNode", first: true },
						" ": { dir: "parentNode" },
						"+": { dir: "previousSibling", first: true },
						"~": { dir: "previousSibling" }
					},

					preFilter: {
						"ATTR": function( match ) {
							match[1] = match[1].replace( runescape, funescape );

							// Move the given value to match[3] whether quoted or unquoted
							match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

							if ( match[2] === "~=" ) {
								match[3] = " " + match[3] + " ";
							}

							return match.slice( 0, 4 );
						},

						"CHILD": function( match ) {
							/* matches from matchExpr["CHILD"]
								1 type (only|nth|...)
								2 what (child|of-type)
								3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
								4 xn-component of xn+y argument ([+-]?\d*n|)
								5 sign of xn-component
								6 x of xn-component
								7 sign of y-component
								8 y of y-component
							*/
							match[1] = match[1].toLowerCase();

							if ( match[1].slice( 0, 3 ) === "nth" ) {
								// nth-* requires argument
								if ( !match[3] ) {
									Sizzle.error( match[0] );
								}

								// numeric x and y parameters for Expr.filter.CHILD
								// remember that false/true cast respectively to 0/1
								match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
								match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

							// other types prohibit arguments
							} else if ( match[3] ) {
								Sizzle.error( match[0] );
							}

							return match;
						},

						"PSEUDO": function( match ) {
							var excess,
								unquoted = !match[6] && match[2];

							if ( matchExpr["CHILD"].test( match[0] ) ) {
								return null;
							}

							// Accept quoted arguments as-is
							if ( match[3] ) {
								match[2] = match[4] || match[5] || "";

							// Strip excess characters from unquoted arguments
							} else if ( unquoted && rpseudo.test( unquoted ) &&
								// Get excess from tokenize (recursively)
								(excess = tokenize( unquoted, true )) &&
								// advance to the next closing parenthesis
								(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

								// excess is a negative index
								match[0] = match[0].slice( 0, excess );
								match[2] = unquoted.slice( 0, excess );
							}

							// Return only captures needed by the pseudo filter method (type and argument)
							return match.slice( 0, 3 );
						}
					},

					filter: {

						"TAG": function( nodeNameSelector ) {
							var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
							return nodeNameSelector === "*" ?
								function() { return true; } :
								function( elem ) {
									return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
								};
						},

						"CLASS": function( className ) {
							var pattern = classCache[ className + " " ];

							return pattern ||
								(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
								classCache( className, function( elem ) {
									return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
								});
						},

						"ATTR": function( name, operator, check ) {
							return function( elem ) {
								var result = Sizzle.attr( elem, name );

								if ( result == null ) {
									return operator === "!=";
								}
								if ( !operator ) {
									return true;
								}

								result += "";

								return operator === "=" ? result === check :
									operator === "!=" ? result !== check :
									operator === "^=" ? check && result.indexOf( check ) === 0 :
									operator === "*=" ? check && result.indexOf( check ) > -1 :
									operator === "$=" ? check && result.slice( -check.length ) === check :
									operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
									operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
									false;
							};
						},

						"CHILD": function( type, what, argument, first, last ) {
							var simple = type.slice( 0, 3 ) !== "nth",
								forward = type.slice( -4 ) !== "last",
								ofType = what === "of-type";

							return first === 1 && last === 0 ?

								// Shortcut for :nth-*(n)
								function( elem ) {
									return !!elem.parentNode;
								} :

								function( elem, context, xml ) {
									var cache, uniqueCache, outerCache, node, nodeIndex, start,
										dir = simple !== forward ? "nextSibling" : "previousSibling",
										parent = elem.parentNode,
										name = ofType && elem.nodeName.toLowerCase(),
										useCache = !xml && !ofType,
										diff = false;

									if ( parent ) {

										// :(first|last|only)-(child|of-type)
										if ( simple ) {
											while ( dir ) {
												node = elem;
												while ( (node = node[ dir ]) ) {
													if ( ofType ?
														node.nodeName.toLowerCase() === name :
														node.nodeType === 1 ) {

														return false;
													}
												}
												// Reverse direction for :only-* (if we haven't yet done so)
												start = dir = type === "only" && !start && "nextSibling";
											}
											return true;
										}

										start = [ forward ? parent.firstChild : parent.lastChild ];

										// non-xml :nth-child(...) stores cache data on `parent`
										if ( forward && useCache ) {

											// Seek `elem` from a previously-cached index

											// ...in a gzip-friendly way
											node = parent;
											outerCache = node[ expando ] || (node[ expando ] = {});

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												(outerCache[ node.uniqueID ] = {});

											cache = uniqueCache[ type ] || [];
											nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
											diff = nodeIndex && cache[ 2 ];
											node = nodeIndex && parent.childNodes[ nodeIndex ];

											while ( (node = ++nodeIndex && node && node[ dir ] ||

												// Fallback to seeking `elem` from the start
												(diff = nodeIndex = 0) || start.pop()) ) {

												// When found, cache indexes on `parent` and break
												if ( node.nodeType === 1 && ++diff && node === elem ) {
													uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
													break;
												}
											}

										} else {
											// Use previously-cached element index if available
											if ( useCache ) {
												// ...in a gzip-friendly way
												node = elem;
												outerCache = node[ expando ] || (node[ expando ] = {});

												// Support: IE <9 only
												// Defend against cloned attroperties (jQuery gh-1709)
												uniqueCache = outerCache[ node.uniqueID ] ||
													(outerCache[ node.uniqueID ] = {});

												cache = uniqueCache[ type ] || [];
												nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
												diff = nodeIndex;
											}

											// xml :nth-child(...)
											// or :nth-last-child(...) or :nth(-last)?-of-type(...)
											if ( diff === false ) {
												// Use the same loop as above to seek `elem` from the start
												while ( (node = ++nodeIndex && node && node[ dir ] ||
													(diff = nodeIndex = 0) || start.pop()) ) {

													if ( ( ofType ?
														node.nodeName.toLowerCase() === name :
														node.nodeType === 1 ) &&
														++diff ) {

														// Cache the index of each encountered element
														if ( useCache ) {
															outerCache = node[ expando ] || (node[ expando ] = {});

															// Support: IE <9 only
															// Defend against cloned attroperties (jQuery gh-1709)
															uniqueCache = outerCache[ node.uniqueID ] ||
																(outerCache[ node.uniqueID ] = {});

															uniqueCache[ type ] = [ dirruns, diff ];
														}

														if ( node === elem ) {
															break;
														}
													}
												}
											}
										}

										// Incorporate the offset, then check against cycle size
										diff -= last;
										return diff === first || ( diff % first === 0 && diff / first >= 0 );
									}
								};
						},

						"PSEUDO": function( pseudo, argument ) {
							// pseudo-class names are case-insensitive
							// http://www.w3.org/TR/selectors/#pseudo-classes
							// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
							// Remember that setFilters inherits from pseudos
							var args,
								fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
									Sizzle.error( "unsupported pseudo: " + pseudo );

							// The user may use createPseudo to indicate that
							// arguments are needed to create the filter function
							// just as Sizzle does
							if ( fn[ expando ] ) {
								return fn( argument );
							}

							// But maintain support for old signatures
							if ( fn.length > 1 ) {
								args = [ pseudo, pseudo, "", argument ];
								return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
									markFunction(function( seed, matches ) {
										var idx,
											matched = fn( seed, argument ),
											i = matched.length;
										while ( i-- ) {
											idx = indexOf( seed, matched[i] );
											seed[ idx ] = !( matches[ idx ] = matched[i] );
										}
									}) :
									function( elem ) {
										return fn( elem, 0, args );
									};
							}

							return fn;
						}
					},

					pseudos: {
						// Potentially complex pseudos
						"not": markFunction(function( selector ) {
							// Trim the selector passed to compile
							// to avoid treating leading and trailing
							// spaces as combinators
							var input = [],
								results = [],
								matcher = compile( selector.replace( rtrim, "$1" ) );

							return matcher[ expando ] ?
								markFunction(function( seed, matches, context, xml ) {
									var elem,
										unmatched = matcher( seed, null, xml, [] ),
										i = seed.length;

									// Match elements unmatched by `matcher`
									while ( i-- ) {
										if ( (elem = unmatched[i]) ) {
											seed[i] = !(matches[i] = elem);
										}
									}
								}) :
								function( elem, context, xml ) {
									input[0] = elem;
									matcher( input, null, xml, results );
									// Don't keep the element (issue #299)
									input[0] = null;
									return !results.pop();
								};
						}),

						"has": markFunction(function( selector ) {
							return function( elem ) {
								return Sizzle( selector, elem ).length > 0;
							};
						}),

						"contains": markFunction(function( text ) {
							text = text.replace( runescape, funescape );
							return function( elem ) {
								return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
							};
						}),

						// "Whether an element is represented by a :lang() selector
						// is based solely on the element's language value
						// being equal to the identifier C,
						// or beginning with the identifier C immediately followed by "-".
						// The matching of C against the element's language value is performed case-insensitively.
						// The identifier C does not have to be a valid language name."
						// http://www.w3.org/TR/selectors/#lang-pseudo
						"lang": markFunction( function( lang ) {
							// lang value must be a valid identifier
							if ( !ridentifier.test(lang || "") ) {
								Sizzle.error( "unsupported lang: " + lang );
							}
							lang = lang.replace( runescape, funescape ).toLowerCase();
							return function( elem ) {
								var elemLang;
								do {
									if ( (elemLang = documentIsHTML ?
										elem.lang :
										elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

										elemLang = elemLang.toLowerCase();
										return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
									}
								} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
								return false;
							};
						}),

						// Miscellaneous
						"target": function( elem ) {
							var hash = window.location && window.location.hash;
							return hash && hash.slice( 1 ) === elem.id;
						},

						"root": function( elem ) {
							return elem === docElem;
						},

						"focus": function( elem ) {
							return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
						},

						// Boolean properties
						"enabled": createDisabledPseudo( false ),
						"disabled": createDisabledPseudo( true ),

						"checked": function( elem ) {
							// In CSS3, :checked should return both checked and selected elements
							// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
							var nodeName = elem.nodeName.toLowerCase();
							return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
						},

						"selected": function( elem ) {
							// Accessing this property makes selected-by-default
							// options in Safari work properly
							if ( elem.parentNode ) {
								elem.parentNode.selectedIndex;
							}

							return elem.selected === true;
						},

						// Contents
						"empty": function( elem ) {
							// http://www.w3.org/TR/selectors/#empty-pseudo
							// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
							//   but not by others (comment: 8; processing instruction: 7; etc.)
							// nodeType < 6 works because attributes (2) do not appear as children
							for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
								if ( elem.nodeType < 6 ) {
									return false;
								}
							}
							return true;
						},

						"parent": function( elem ) {
							return !Expr.pseudos["empty"]( elem );
						},

						// Element/input types
						"header": function( elem ) {
							return rheader.test( elem.nodeName );
						},

						"input": function( elem ) {
							return rinputs.test( elem.nodeName );
						},

						"button": function( elem ) {
							var name = elem.nodeName.toLowerCase();
							return name === "input" && elem.type === "button" || name === "button";
						},

						"text": function( elem ) {
							var attr;
							return elem.nodeName.toLowerCase() === "input" &&
								elem.type === "text" &&

								// Support: IE<8
								// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
								( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
						},

						// Position-in-collection
						"first": createPositionalPseudo(function() {
							return [ 0 ];
						}),

						"last": createPositionalPseudo(function( matchIndexes, length ) {
							return [ length - 1 ];
						}),

						"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
							return [ argument < 0 ? argument + length : argument ];
						}),

						"even": createPositionalPseudo(function( matchIndexes, length ) {
							var i = 0;
							for ( ; i < length; i += 2 ) {
								matchIndexes.push( i );
							}
							return matchIndexes;
						}),

						"odd": createPositionalPseudo(function( matchIndexes, length ) {
							var i = 1;
							for ( ; i < length; i += 2 ) {
								matchIndexes.push( i );
							}
							return matchIndexes;
						}),

						"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
							var i = argument < 0 ? argument + length : argument;
							for ( ; --i >= 0; ) {
								matchIndexes.push( i );
							}
							return matchIndexes;
						}),

						"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
							var i = argument < 0 ? argument + length : argument;
							for ( ; ++i < length; ) {
								matchIndexes.push( i );
							}
							return matchIndexes;
						})
					}
				};

				Expr.pseudos["nth"] = Expr.pseudos["eq"];

				// Add button/input type pseudos
				for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
					Expr.pseudos[ i ] = createInputPseudo( i );
				}
				for ( i in { submit: true, reset: true } ) {
					Expr.pseudos[ i ] = createButtonPseudo( i );
				}

				// Easy API for creating new setFilters
				function setFilters() {}
				setFilters.prototype = Expr.filters = Expr.pseudos;
				Expr.setFilters = new setFilters();

				tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
					var matched, match, tokens, type,
						soFar, groups, preFilters,
						cached = tokenCache[ selector + " " ];

					if ( cached ) {
						return parseOnly ? 0 : cached.slice( 0 );
					}

					soFar = selector;
					groups = [];
					preFilters = Expr.preFilter;

					while ( soFar ) {

						// Comma and first run
						if ( !matched || (match = rcomma.exec( soFar )) ) {
							if ( match ) {
								// Don't consume trailing commas as valid
								soFar = soFar.slice( match[0].length ) || soFar;
							}
							groups.push( (tokens = []) );
						}

						matched = false;

						// Combinators
						if ( (match = rcombinators.exec( soFar )) ) {
							matched = match.shift();
							tokens.push({
								value: matched,
								// Cast descendant combinators to space
								type: match[0].replace( rtrim, " " )
							});
							soFar = soFar.slice( matched.length );
						}

						// Filters
						for ( type in Expr.filter ) {
							if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
								(match = preFilters[ type ]( match ))) ) {
								matched = match.shift();
								tokens.push({
									value: matched,
									type: type,
									matches: match
								});
								soFar = soFar.slice( matched.length );
							}
						}

						if ( !matched ) {
							break;
						}
					}

					// Return the length of the invalid excess
					// if we're just parsing
					// Otherwise, throw an error or return tokens
					return parseOnly ?
						soFar.length :
						soFar ?
							Sizzle.error( selector ) :
							// Cache the tokens
							tokenCache( selector, groups ).slice( 0 );
				};

				function toSelector( tokens ) {
					var i = 0,
						len = tokens.length,
						selector = "";
					for ( ; i < len; i++ ) {
						selector += tokens[i].value;
					}
					return selector;
				}

				function addCombinator( matcher, combinator, base ) {
					var dir = combinator.dir,
						skip = combinator.next,
						key = skip || dir,
						checkNonElements = base && key === "parentNode",
						doneName = done++;

					return combinator.first ?
						// Check against closest ancestor/preceding element
						function( elem, context, xml ) {
							while ( (elem = elem[ dir ]) ) {
								if ( elem.nodeType === 1 || checkNonElements ) {
									return matcher( elem, context, xml );
								}
							}
							return false;
						} :

						// Check against all ancestor/preceding elements
						function( elem, context, xml ) {
							var oldCache, uniqueCache, outerCache,
								newCache = [ dirruns, doneName ];

							// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
							if ( xml ) {
								while ( (elem = elem[ dir ]) ) {
									if ( elem.nodeType === 1 || checkNonElements ) {
										if ( matcher( elem, context, xml ) ) {
											return true;
										}
									}
								}
							} else {
								while ( (elem = elem[ dir ]) ) {
									if ( elem.nodeType === 1 || checkNonElements ) {
										outerCache = elem[ expando ] || (elem[ expando ] = {});

										// Support: IE <9 only
										// Defend against cloned attroperties (jQuery gh-1709)
										uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

										if ( skip && skip === elem.nodeName.toLowerCase() ) {
											elem = elem[ dir ] || elem;
										} else if ( (oldCache = uniqueCache[ key ]) &&
											oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

											// Assign to newCache so results back-propagate to previous elements
											return (newCache[ 2 ] = oldCache[ 2 ]);
										} else {
											// Reuse newcache so results back-propagate to previous elements
											uniqueCache[ key ] = newCache;

											// A match means we're done; a fail means we have to keep checking
											if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
												return true;
											}
										}
									}
								}
							}
							return false;
						};
				}

				function elementMatcher( matchers ) {
					return matchers.length > 1 ?
						function( elem, context, xml ) {
							var i = matchers.length;
							while ( i-- ) {
								if ( !matchers[i]( elem, context, xml ) ) {
									return false;
								}
							}
							return true;
						} :
						matchers[0];
				}

				function multipleContexts( selector, contexts, results ) {
					var i = 0,
						len = contexts.length;
					for ( ; i < len; i++ ) {
						Sizzle( selector, contexts[i], results );
					}
					return results;
				}

				function condense( unmatched, map, filter, context, xml ) {
					var elem,
						newUnmatched = [],
						i = 0,
						len = unmatched.length,
						mapped = map != null;

					for ( ; i < len; i++ ) {
						if ( (elem = unmatched[i]) ) {
							if ( !filter || filter( elem, context, xml ) ) {
								newUnmatched.push( elem );
								if ( mapped ) {
									map.push( i );
								}
							}
						}
					}

					return newUnmatched;
				}

				function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
					if ( postFilter && !postFilter[ expando ] ) {
						postFilter = setMatcher( postFilter );
					}
					if ( postFinder && !postFinder[ expando ] ) {
						postFinder = setMatcher( postFinder, postSelector );
					}
					return markFunction(function( seed, results, context, xml ) {
						var temp, i, elem,
							preMap = [],
							postMap = [],
							preexisting = results.length,

							// Get initial elements from seed or context
							elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

							// Prefilter to get matcher input, preserving a map for seed-results synchronization
							matcherIn = preFilter && ( seed || !selector ) ?
								condense( elems, preMap, preFilter, context, xml ) :
								elems,

							matcherOut = matcher ?
								// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
								postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

									// ...intermediate processing is necessary
									[] :

									// ...otherwise use results directly
									results :
								matcherIn;

						// Find primary matches
						if ( matcher ) {
							matcher( matcherIn, matcherOut, context, xml );
						}

						// Apply postFilter
						if ( postFilter ) {
							temp = condense( matcherOut, postMap );
							postFilter( temp, [], context, xml );

							// Un-match failing elements by moving them back to matcherIn
							i = temp.length;
							while ( i-- ) {
								if ( (elem = temp[i]) ) {
									matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
								}
							}
						}

						if ( seed ) {
							if ( postFinder || preFilter ) {
								if ( postFinder ) {
									// Get the final matcherOut by condensing this intermediate into postFinder contexts
									temp = [];
									i = matcherOut.length;
									while ( i-- ) {
										if ( (elem = matcherOut[i]) ) {
											// Restore matcherIn since elem is not yet a final match
											temp.push( (matcherIn[i] = elem) );
										}
									}
									postFinder( null, (matcherOut = []), temp, xml );
								}

								// Move matched elements from seed to results to keep them synchronized
								i = matcherOut.length;
								while ( i-- ) {
									if ( (elem = matcherOut[i]) &&
										(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

										seed[temp] = !(results[temp] = elem);
									}
								}
							}

						// Add elements to results, through postFinder if defined
						} else {
							matcherOut = condense(
								matcherOut === results ?
									matcherOut.splice( preexisting, matcherOut.length ) :
									matcherOut
							);
							if ( postFinder ) {
								postFinder( null, results, matcherOut, xml );
							} else {
								push.apply( results, matcherOut );
							}
						}
					});
				}

				function matcherFromTokens( tokens ) {
					var checkContext, matcher, j,
						len = tokens.length,
						leadingRelative = Expr.relative[ tokens[0].type ],
						implicitRelative = leadingRelative || Expr.relative[" "],
						i = leadingRelative ? 1 : 0,

						// The foundational matcher ensures that elements are reachable from top-level context(s)
						matchContext = addCombinator( function( elem ) {
							return elem === checkContext;
						}, implicitRelative, true ),
						matchAnyContext = addCombinator( function( elem ) {
							return indexOf( checkContext, elem ) > -1;
						}, implicitRelative, true ),
						matchers = [ function( elem, context, xml ) {
							var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
								(checkContext = context).nodeType ?
									matchContext( elem, context, xml ) :
									matchAnyContext( elem, context, xml ) );
							// Avoid hanging onto element (issue #299)
							checkContext = null;
							return ret;
						} ];

					for ( ; i < len; i++ ) {
						if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
							matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
						} else {
							matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

							// Return special upon seeing a positional matcher
							if ( matcher[ expando ] ) {
								// Find the next relative operator (if any) for proper handling
								j = ++i;
								for ( ; j < len; j++ ) {
									if ( Expr.relative[ tokens[j].type ] ) {
										break;
									}
								}
								return setMatcher(
									i > 1 && elementMatcher( matchers ),
									i > 1 && toSelector(
										// If the preceding token was a descendant combinator, insert an implicit any-element `*`
										tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
									).replace( rtrim, "$1" ),
									matcher,
									i < j && matcherFromTokens( tokens.slice( i, j ) ),
									j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
									j < len && toSelector( tokens )
								);
							}
							matchers.push( matcher );
						}
					}

					return elementMatcher( matchers );
				}

				function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
					var bySet = setMatchers.length > 0,
						byElement = elementMatchers.length > 0,
						superMatcher = function( seed, context, xml, results, outermost ) {
							var elem, j, matcher,
								matchedCount = 0,
								i = "0",
								unmatched = seed && [],
								setMatched = [],
								contextBackup = outermostContext,
								// We must always have either seed elements or outermost context
								elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
								// Use integer dirruns iff this is the outermost matcher
								dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
								len = elems.length;

							if ( outermost ) {
								outermostContext = context === document || context || outermost;
							}

							// Add elements passing elementMatchers directly to results
							// Support: IE<9, Safari
							// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
							for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
								if ( byElement && elem ) {
									j = 0;
									if ( !context && elem.ownerDocument !== document ) {
										setDocument( elem );
										xml = !documentIsHTML;
									}
									while ( (matcher = elementMatchers[j++]) ) {
										if ( matcher( elem, context || document, xml) ) {
											results.push( elem );
											break;
										}
									}
									if ( outermost ) {
										dirruns = dirrunsUnique;
									}
								}

								// Track unmatched elements for set filters
								if ( bySet ) {
									// They will have gone through all possible matchers
									if ( (elem = !matcher && elem) ) {
										matchedCount--;
									}

									// Lengthen the array for every element, matched or not
									if ( seed ) {
										unmatched.push( elem );
									}
								}
							}

							// `i` is now the count of elements visited above, and adding it to `matchedCount`
							// makes the latter nonnegative.
							matchedCount += i;

							// Apply set filters to unmatched elements
							// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
							// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
							// no element matchers and no seed.
							// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
							// case, which will result in a "00" `matchedCount` that differs from `i` but is also
							// numerically zero.
							if ( bySet && i !== matchedCount ) {
								j = 0;
								while ( (matcher = setMatchers[j++]) ) {
									matcher( unmatched, setMatched, context, xml );
								}

								if ( seed ) {
									// Reintegrate element matches to eliminate the need for sorting
									if ( matchedCount > 0 ) {
										while ( i-- ) {
											if ( !(unmatched[i] || setMatched[i]) ) {
												setMatched[i] = pop.call( results );
											}
										}
									}

									// Discard index placeholder values to get only actual matches
									setMatched = condense( setMatched );
								}

								// Add matches to results
								push.apply( results, setMatched );

								// Seedless set matches succeeding multiple successful matchers stipulate sorting
								if ( outermost && !seed && setMatched.length > 0 &&
									( matchedCount + setMatchers.length ) > 1 ) {

									Sizzle.uniqueSort( results );
								}
							}

							// Override manipulation of globals by nested matchers
							if ( outermost ) {
								dirruns = dirrunsUnique;
								outermostContext = contextBackup;
							}

							return unmatched;
						};

					return bySet ?
						markFunction( superMatcher ) :
						superMatcher;
				}

				compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
					var i,
						setMatchers = [],
						elementMatchers = [],
						cached = compilerCache[ selector + " " ];

					if ( !cached ) {
						// Generate a function of recursive functions that can be used to check each element
						if ( !match ) {
							match = tokenize( selector );
						}
						i = match.length;
						while ( i-- ) {
							cached = matcherFromTokens( match[i] );
							if ( cached[ expando ] ) {
								setMatchers.push( cached );
							} else {
								elementMatchers.push( cached );
							}
						}

						// Cache the compiled function
						cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

						// Save selector and tokenization
						cached.selector = selector;
					}
					return cached;
				};

				/**
				 * A low-level selection function that works with Sizzle's compiled
				 *  selector functions
				 * @param {String|Function} selector A selector or a pre-compiled
				 *  selector function built with Sizzle.compile
				 * @param {Element} context
				 * @param {Array} [results]
				 * @param {Array} [seed] A set of elements to match against
				 */
				select = Sizzle.select = function( selector, context, results, seed ) {
					var i, tokens, token, type, find,
						compiled = typeof selector === "function" && selector,
						match = !seed && tokenize( (selector = compiled.selector || selector) );

					results = results || [];

					// Try to minimize operations if there is only one selector in the list and no seed
					// (the latter of which guarantees us context)
					if ( match.length === 1 ) {

						// Reduce context if the leading compound selector is an ID
						tokens = match[0] = match[0].slice( 0 );
						if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
								context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {

							context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
							if ( !context ) {
								return results;

							// Precompiled matchers will still verify ancestry, so step up a level
							} else if ( compiled ) {
								context = context.parentNode;
							}

							selector = selector.slice( tokens.shift().value.length );
						}

						// Fetch a seed set for right-to-left matching
						i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
						while ( i-- ) {
							token = tokens[i];

							// Abort if we hit a combinator
							if ( Expr.relative[ (type = token.type) ] ) {
								break;
							}
							if ( (find = Expr.find[ type ]) ) {
								// Search, expanding context for leading sibling combinators
								if ( (seed = find(
									token.matches[0].replace( runescape, funescape ),
									rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
								)) ) {

									// If seed is empty or no tokens remain, we can return early
									tokens.splice( i, 1 );
									selector = seed.length && toSelector( tokens );
									if ( !selector ) {
										push.apply( results, seed );
										return results;
									}

									break;
								}
							}
						}
					}

					// Compile and execute a filtering function if one is not provided
					// Provide `match` to avoid retokenization if we modified the selector above
					( compiled || compile( selector, match ) )(
						seed,
						context,
						!documentIsHTML,
						results,
						!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
					);
					return results;
				};

				// One-time assignments

				// Sort stability
				support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

				// Support: Chrome 14-35+
				// Always assume duplicates if they aren't passed to the comparison function
				support.detectDuplicates = !!hasDuplicate;

				// Initialize against the default document
				setDocument();

				// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
				// Detached nodes confoundingly follow *each other*
				support.sortDetached = assert(function( el ) {
					// Should return 1, but returns 4 (following)
					return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
				});

				// Support: IE<8
				// Prevent attribute/property "interpolation"
				// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
				if ( !assert(function( el ) {
					el.innerHTML = "<a href='#'></a>";
					return el.firstChild.getAttribute("href") === "#" ;
				}) ) {
					addHandle( "type|href|height|width", function( elem, name, isXML ) {
						if ( !isXML ) {
							return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
						}
					});
				}

				// Support: IE<9
				// Use defaultValue in place of getAttribute("value")
				if ( !support.attributes || !assert(function( el ) {
					el.innerHTML = "<input/>";
					el.firstChild.setAttribute( "value", "" );
					return el.firstChild.getAttribute( "value" ) === "";
				}) ) {
					addHandle( "value", function( elem, name, isXML ) {
						if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
							return elem.defaultValue;
						}
					});
				}

				// Support: IE<9
				// Use getAttributeNode to fetch booleans when getAttribute lies
				if ( !assert(function( el ) {
					return el.getAttribute("disabled") == null;
				}) ) {
					addHandle( booleans, function( elem, name, isXML ) {
						var val;
						if ( !isXML ) {
							return elem[ name ] === true ? name.toLowerCase() :
									(val = elem.getAttributeNode( name )) && val.specified ?
									val.value :
								null;
						}
					});
				}

				return Sizzle;

				})( window );



				jQuery.find = Sizzle;
				jQuery.expr = Sizzle.selectors;

				// Deprecated
				jQuery.expr[ ":" ] = jQuery.expr.pseudos;
				jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
				jQuery.text = Sizzle.getText;
				jQuery.isXMLDoc = Sizzle.isXML;
				jQuery.contains = Sizzle.contains;
				jQuery.escapeSelector = Sizzle.escape;




				var dir = function( elem, dir, until ) {
					var matched = [],
						truncate = until !== undefined;

					while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
						if ( elem.nodeType === 1 ) {
							if ( truncate && jQuery( elem ).is( until ) ) {
								break;
							}
							matched.push( elem );
						}
					}
					return matched;
				};


				var siblings = function( n, elem ) {
					var matched = [];

					for ( ; n; n = n.nextSibling ) {
						if ( n.nodeType === 1 && n !== elem ) {
							matched.push( n );
						}
					}

					return matched;
				};


				var rneedsContext = jQuery.expr.match.needsContext;

				var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



				var risSimple = /^.[^:#\[\.,]*$/;

				// Implement the identical functionality for filter and not
				function winnow( elements, qualifier, not ) {
					if ( jQuery.isFunction( qualifier ) ) {
						return jQuery.grep( elements, function( elem, i ) {
							return !!qualifier.call( elem, i, elem ) !== not;
						} );
					}

					// Single element
					if ( qualifier.nodeType ) {
						return jQuery.grep( elements, function( elem ) {
							return ( elem === qualifier ) !== not;
						} );
					}

					// Arraylike of elements (jQuery, arguments, Array)
					if ( typeof qualifier !== "string" ) {
						return jQuery.grep( elements, function( elem ) {
							return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
						} );
					}

					// Simple selector that can be filtered directly, removing non-Elements
					if ( risSimple.test( qualifier ) ) {
						return jQuery.filter( qualifier, elements, not );
					}

					// Complex selector, compare the two sets, removing non-Elements
					qualifier = jQuery.filter( qualifier, elements );
					return jQuery.grep( elements, function( elem ) {
						return ( indexOf.call( qualifier, elem ) > -1 ) !== not && elem.nodeType === 1;
					} );
				}

				jQuery.filter = function( expr, elems, not ) {
					var elem = elems[ 0 ];

					if ( not ) {
						expr = ":not(" + expr + ")";
					}

					if ( elems.length === 1 && elem.nodeType === 1 ) {
						return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
					}

					return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
						return elem.nodeType === 1;
					} ) );
				};

				jQuery.fn.extend( {
					find: function( selector ) {
						var i, ret,
							len = this.length,
							self = this;

						if ( typeof selector !== "string" ) {
							return this.pushStack( jQuery( selector ).filter( function() {
								for ( i = 0; i < len; i++ ) {
									if ( jQuery.contains( self[ i ], this ) ) {
										return true;
									}
								}
							} ) );
						}

						ret = this.pushStack( [] );

						for ( i = 0; i < len; i++ ) {
							jQuery.find( selector, self[ i ], ret );
						}

						return len > 1 ? jQuery.uniqueSort( ret ) : ret;
					},
					filter: function( selector ) {
						return this.pushStack( winnow( this, selector || [], false ) );
					},
					not: function( selector ) {
						return this.pushStack( winnow( this, selector || [], true ) );
					},
					is: function( selector ) {
						return !!winnow(
							this,

							// If this is a positional/relative selector, check membership in the returned set
							// so $("p:first").is("p:last") won't return true for a doc with two "p".
							typeof selector === "string" && rneedsContext.test( selector ) ?
								jQuery( selector ) :
								selector || [],
							false
						).length;
					}
				} );


				// Initialize a jQuery object


				// A central reference to the root jQuery(document)
				var rootjQuery,

					// A simple way to check for HTML strings
					// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
					// Strict HTML recognition (#11290: must start with <)
					// Shortcut simple #id case for speed
					rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

					init = jQuery.fn.init = function( selector, context, root ) {
						var match, elem;

						// HANDLE: $(""), $(null), $(undefined), $(false)
						if ( !selector ) {
							return this;
						}

						// Method init() accepts an alternate rootjQuery
						// so migrate can support jQuery.sub (gh-2101)
						root = root || rootjQuery;

						// Handle HTML strings
						if ( typeof selector === "string" ) {
							if ( selector[ 0 ] === "<" &&
								selector[ selector.length - 1 ] === ">" &&
								selector.length >= 3 ) {

								// Assume that strings that start and end with <> are HTML and skip the regex check
								match = [ null, selector, null ];

							} else {
								match = rquickExpr.exec( selector );
							}

							// Match html or make sure no context is specified for #id
							if ( match && ( match[ 1 ] || !context ) ) {

								// HANDLE: $(html) -> $(array)
								if ( match[ 1 ] ) {
									context = context instanceof jQuery ? context[ 0 ] : context;

									// Option to run scripts is true for back-compat
									// Intentionally let the error be thrown if parseHTML is not present
									jQuery.merge( this, jQuery.parseHTML(
										match[ 1 ],
										context && context.nodeType ? context.ownerDocument || context : document,
										true
									) );

									// HANDLE: $(html, props)
									if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
										for ( match in context ) {

											// Properties of context are called as methods if possible
											if ( jQuery.isFunction( this[ match ] ) ) {
												this[ match ]( context[ match ] );

											// ...and otherwise set as attributes
											} else {
												this.attr( match, context[ match ] );
											}
										}
									}

									return this;

								// HANDLE: $(#id)
								} else {
									elem = document.getElementById( match[ 2 ] );

									if ( elem ) {

										// Inject the element directly into the jQuery object
										this[ 0 ] = elem;
										this.length = 1;
									}
									return this;
								}

							// HANDLE: $(expr, $(...))
							} else if ( !context || context.jquery ) {
								return ( context || root ).find( selector );

							// HANDLE: $(expr, context)
							// (which is just equivalent to: $(context).find(expr)
							} else {
								return this.constructor( context ).find( selector );
							}

						// HANDLE: $(DOMElement)
						} else if ( selector.nodeType ) {
							this[ 0 ] = selector;
							this.length = 1;
							return this;

						// HANDLE: $(function)
						// Shortcut for document ready
						} else if ( jQuery.isFunction( selector ) ) {
							return root.ready !== undefined ?
								root.ready( selector ) :

								// Execute immediately if ready is not present
								selector( jQuery );
						}

						return jQuery.makeArray( selector, this );
					};

				// Give the init function the jQuery prototype for later instantiation
				init.prototype = jQuery.fn;

				// Initialize central reference
				rootjQuery = jQuery( document );


				var rparentsprev = /^(?:parents|prev(?:Until|All))/,

					// Methods guaranteed to produce a unique set when starting from a unique set
					guaranteedUnique = {
						children: true,
						contents: true,
						next: true,
						prev: true
					};

				jQuery.fn.extend( {
					has: function( target ) {
						var targets = jQuery( target, this ),
							l = targets.length;

						return this.filter( function() {
							var i = 0;
							for ( ; i < l; i++ ) {
								if ( jQuery.contains( this, targets[ i ] ) ) {
									return true;
								}
							}
						} );
					},

					closest: function( selectors, context ) {
						var cur,
							i = 0,
							l = this.length,
							matched = [],
							targets = typeof selectors !== "string" && jQuery( selectors );

						// Positional selectors never match, since there's no _selection_ context
						if ( !rneedsContext.test( selectors ) ) {
							for ( ; i < l; i++ ) {
								for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

									// Always skip document fragments
									if ( cur.nodeType < 11 && ( targets ?
										targets.index( cur ) > -1 :

										// Don't pass non-elements to Sizzle
										cur.nodeType === 1 &&
											jQuery.find.matchesSelector( cur, selectors ) ) ) {

										matched.push( cur );
										break;
									}
								}
							}
						}

						return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
					},

					// Determine the position of an element within the set
					index: function( elem ) {

						// No argument, return index in parent
						if ( !elem ) {
							return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
						}

						// Index in selector
						if ( typeof elem === "string" ) {
							return indexOf.call( jQuery( elem ), this[ 0 ] );
						}

						// Locate the position of the desired element
						return indexOf.call( this,

							// If it receives a jQuery object, the first element is used
							elem.jquery ? elem[ 0 ] : elem
						);
					},

					add: function( selector, context ) {
						return this.pushStack(
							jQuery.uniqueSort(
								jQuery.merge( this.get(), jQuery( selector, context ) )
							)
						);
					},

					addBack: function( selector ) {
						return this.add( selector == null ?
							this.prevObject : this.prevObject.filter( selector )
						);
					}
				} );

				function sibling( cur, dir ) {
					while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
					return cur;
				}

				jQuery.each( {
					parent: function( elem ) {
						var parent = elem.parentNode;
						return parent && parent.nodeType !== 11 ? parent : null;
					},
					parents: function( elem ) {
						return dir( elem, "parentNode" );
					},
					parentsUntil: function( elem, i, until ) {
						return dir( elem, "parentNode", until );
					},
					next: function( elem ) {
						return sibling( elem, "nextSibling" );
					},
					prev: function( elem ) {
						return sibling( elem, "previousSibling" );
					},
					nextAll: function( elem ) {
						return dir( elem, "nextSibling" );
					},
					prevAll: function( elem ) {
						return dir( elem, "previousSibling" );
					},
					nextUntil: function( elem, i, until ) {
						return dir( elem, "nextSibling", until );
					},
					prevUntil: function( elem, i, until ) {
						return dir( elem, "previousSibling", until );
					},
					siblings: function( elem ) {
						return siblings( ( elem.parentNode || {} ).firstChild, elem );
					},
					children: function( elem ) {
						return siblings( elem.firstChild );
					},
					contents: function( elem ) {
						return elem.contentDocument || jQuery.merge( [], elem.childNodes );
					}
				}, function( name, fn ) {
					jQuery.fn[ name ] = function( until, selector ) {
						var matched = jQuery.map( this, fn, until );

						if ( name.slice( -5 ) !== "Until" ) {
							selector = until;
						}

						if ( selector && typeof selector === "string" ) {
							matched = jQuery.filter( selector, matched );
						}

						if ( this.length > 1 ) {

							// Remove duplicates
							if ( !guaranteedUnique[ name ] ) {
								jQuery.uniqueSort( matched );
							}

							// Reverse order for parents* and prev-derivatives
							if ( rparentsprev.test( name ) ) {
								matched.reverse();
							}
						}

						return this.pushStack( matched );
					};
				} );
				var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



				// Convert String-formatted options into Object-formatted ones
				function createOptions( options ) {
					var object = {};
					jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
						object[ flag ] = true;
					} );
					return object;
				}

				/*
				 * Create a callback list using the following parameters:
				 *
				 *	options: an optional list of space-separated options that will change how
				 *			the callback list behaves or a more traditional option object
				 *
				 * By default a callback list will act like an event callback list and can be
				 * "fired" multiple times.
				 *
				 * Possible options:
				 *
				 *	once:			will ensure the callback list can only be fired once (like a Deferred)
				 *
				 *	memory:			will keep track of previous values and will call any callback added
				 *					after the list has been fired right away with the latest "memorized"
				 *					values (like a Deferred)
				 *
				 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
				 *
				 *	stopOnFalse:	interrupt callings when a callback returns false
				 *
				 */
				jQuery.Callbacks = function( options ) {

					// Convert options from String-formatted to Object-formatted if needed
					// (we check in cache first)
					options = typeof options === "string" ?
						createOptions( options ) :
						jQuery.extend( {}, options );

					var // Flag to know if list is currently firing
						firing,

						// Last fire value for non-forgettable lists
						memory,

						// Flag to know if list was already fired
						fired,

						// Flag to prevent firing
						locked,

						// Actual callback list
						list = [],

						// Queue of execution data for repeatable lists
						queue = [],

						// Index of currently firing callback (modified by add/remove as needed)
						firingIndex = -1,

						// Fire callbacks
						fire = function() {

							// Enforce single-firing
							locked = options.once;

							// Execute callbacks for all pending executions,
							// respecting firingIndex overrides and runtime changes
							fired = firing = true;
							for ( ; queue.length; firingIndex = -1 ) {
								memory = queue.shift();
								while ( ++firingIndex < list.length ) {

									// Run callback and check for early termination
									if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
										options.stopOnFalse ) {

										// Jump to end and forget the data so .add doesn't re-fire
										firingIndex = list.length;
										memory = false;
									}
								}
							}

							// Forget the data if we're done with it
							if ( !options.memory ) {
								memory = false;
							}

							firing = false;

							// Clean up if we're done firing for good
							if ( locked ) {

								// Keep an empty list if we have data for future add calls
								if ( memory ) {
									list = [];

								// Otherwise, this object is spent
								} else {
									list = "";
								}
							}
						},

						// Actual Callbacks object
						self = {

							// Add a callback or a collection of callbacks to the list
							add: function() {
								if ( list ) {

									// If we have memory from a past run, we should fire after adding
									if ( memory && !firing ) {
										firingIndex = list.length - 1;
										queue.push( memory );
									}

									( function add( args ) {
										jQuery.each( args, function( _, arg ) {
											if ( jQuery.isFunction( arg ) ) {
												if ( !options.unique || !self.has( arg ) ) {
													list.push( arg );
												}
											} else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {

												// Inspect recursively
												add( arg );
											}
										} );
									} )( arguments );

									if ( memory && !firing ) {
										fire();
									}
								}
								return this;
							},

							// Remove a callback from the list
							remove: function() {
								jQuery.each( arguments, function( _, arg ) {
									var index;
									while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
										list.splice( index, 1 );

										// Handle firing indexes
										if ( index <= firingIndex ) {
											firingIndex--;
										}
									}
								} );
								return this;
							},

							// Check if a given callback is in the list.
							// If no argument is given, return whether or not list has callbacks attached.
							has: function( fn ) {
								return fn ?
									jQuery.inArray( fn, list ) > -1 :
									list.length > 0;
							},

							// Remove all callbacks from the list
							empty: function() {
								if ( list ) {
									list = [];
								}
								return this;
							},

							// Disable .fire and .add
							// Abort any current/pending executions
							// Clear all callbacks and values
							disable: function() {
								locked = queue = [];
								list = memory = "";
								return this;
							},
							disabled: function() {
								return !list;
							},

							// Disable .fire
							// Also disable .add unless we have memory (since it would have no effect)
							// Abort any pending executions
							lock: function() {
								locked = queue = [];
								if ( !memory && !firing ) {
									list = memory = "";
								}
								return this;
							},
							locked: function() {
								return !!locked;
							},

							// Call all callbacks with the given context and arguments
							fireWith: function( context, args ) {
								if ( !locked ) {
									args = args || [];
									args = [ context, args.slice ? args.slice() : args ];
									queue.push( args );
									if ( !firing ) {
										fire();
									}
								}
								return this;
							},

							// Call all the callbacks with the given arguments
							fire: function() {
								self.fireWith( this, arguments );
								return this;
							},

							// To know if the callbacks have already been called at least once
							fired: function() {
								return !!fired;
							}
						};

					return self;
				};


				function Identity( v ) {
					return v;
				}
				function Thrower( ex ) {
					throw ex;
				}

				function adoptValue( value, resolve, reject ) {
					var method;

					try {

						// Check for promise aspect first to privilege synchronous behavior
						if ( value && jQuery.isFunction( ( method = value.promise ) ) ) {
							method.call( value ).done( resolve ).fail( reject );

						// Other thenables
						} else if ( value && jQuery.isFunction( ( method = value.then ) ) ) {
							method.call( value, resolve, reject );

						// Other non-thenables
						} else {

							// Support: Android 4.0 only
							// Strict mode functions invoked without .call/.apply get global-object context
							resolve.call( undefined, value );
						}

					// For Promises/A+, convert exceptions into rejections
					// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
					// Deferred#then to conditionally suppress rejection.
					} catch ( value ) {

						// Support: Android 4.0 only
						// Strict mode functions invoked without .call/.apply get global-object context
						reject.call( undefined, value );
					}
				}

				jQuery.extend( {

					Deferred: function( func ) {
						var tuples = [

								// action, add listener, callbacks,
								// ... .then handlers, argument index, [final state]
								[ "notify", "progress", jQuery.Callbacks( "memory" ),
									jQuery.Callbacks( "memory" ), 2 ],
								[ "resolve", "done", jQuery.Callbacks( "once memory" ),
									jQuery.Callbacks( "once memory" ), 0, "resolved" ],
								[ "reject", "fail", jQuery.Callbacks( "once memory" ),
									jQuery.Callbacks( "once memory" ), 1, "rejected" ]
							],
							state = "pending",
							promise = {
								state: function() {
									return state;
								},
								always: function() {
									deferred.done( arguments ).fail( arguments );
									return this;
								},
								"catch": function( fn ) {
									return promise.then( null, fn );
								},

								// Keep pipe for back-compat
								pipe: function( /* fnDone, fnFail, fnProgress */ ) {
									var fns = arguments;

									return jQuery.Deferred( function( newDefer ) {
										jQuery.each( tuples, function( i, tuple ) {

											// Map tuples (progress, done, fail) to arguments (done, fail, progress)
											var fn = jQuery.isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

											// deferred.progress(function() { bind to newDefer or newDefer.notify })
											// deferred.done(function() { bind to newDefer or newDefer.resolve })
											// deferred.fail(function() { bind to newDefer or newDefer.reject })
											deferred[ tuple[ 1 ] ]( function() {
												var returned = fn && fn.apply( this, arguments );
												if ( returned && jQuery.isFunction( returned.promise ) ) {
													returned.promise()
														.progress( newDefer.notify )
														.done( newDefer.resolve )
														.fail( newDefer.reject );
												} else {
													newDefer[ tuple[ 0 ] + "With" ](
														this,
														fn ? [ returned ] : arguments
													);
												}
											} );
										} );
										fns = null;
									} ).promise();
								},
								then: function( onFulfilled, onRejected, onProgress ) {
									var maxDepth = 0;
									function resolve( depth, deferred, handler, special ) {
										return function() {
											var that = this,
												args = arguments,
												mightThrow = function() {
													var returned, then;

													// Support: Promises/A+ section 2.3.3.3.3
													// https://promisesaplus.com/#point-59
													// Ignore double-resolution attempts
													if ( depth < maxDepth ) {
														return;
													}

													returned = handler.apply( that, args );

													// Support: Promises/A+ section 2.3.1
													// https://promisesaplus.com/#point-48
													if ( returned === deferred.promise() ) {
														throw new TypeError( "Thenable self-resolution" );
													}

													// Support: Promises/A+ sections 2.3.3.1, 3.5
													// https://promisesaplus.com/#point-54
													// https://promisesaplus.com/#point-75
													// Retrieve `then` only once
													then = returned &&

														// Support: Promises/A+ section 2.3.4
														// https://promisesaplus.com/#point-64
														// Only check objects and functions for thenability
														( typeof returned === "object" ||
															typeof returned === "function" ) &&
														returned.then;

													// Handle a returned thenable
													if ( jQuery.isFunction( then ) ) {

														// Special processors (notify) just wait for resolution
														if ( special ) {
															then.call(
																returned,
																resolve( maxDepth, deferred, Identity, special ),
																resolve( maxDepth, deferred, Thrower, special )
															);

														// Normal processors (resolve) also hook into progress
														} else {

															// ...and disregard older resolution values
															maxDepth++;

															then.call(
																returned,
																resolve( maxDepth, deferred, Identity, special ),
																resolve( maxDepth, deferred, Thrower, special ),
																resolve( maxDepth, deferred, Identity,
																	deferred.notifyWith )
															);
														}

													// Handle all other returned values
													} else {

														// Only substitute handlers pass on context
														// and multiple values (non-spec behavior)
														if ( handler !== Identity ) {
															that = undefined;
															args = [ returned ];
														}

														// Process the value(s)
														// Default process is resolve
														( special || deferred.resolveWith )( that, args );
													}
												},

												// Only normal processors (resolve) catch and reject exceptions
												process = special ?
													mightThrow :
													function() {
														try {
															mightThrow();
														} catch ( e ) {

															if ( jQuery.Deferred.exceptionHook ) {
																jQuery.Deferred.exceptionHook( e,
																	process.stackTrace );
															}

															// Support: Promises/A+ section 2.3.3.3.4.1
															// https://promisesaplus.com/#point-61
															// Ignore post-resolution exceptions
															if ( depth + 1 >= maxDepth ) {

																// Only substitute handlers pass on context
																// and multiple values (non-spec behavior)
																if ( handler !== Thrower ) {
																	that = undefined;
																	args = [ e ];
																}

																deferred.rejectWith( that, args );
															}
														}
													};

											// Support: Promises/A+ section 2.3.3.3.1
											// https://promisesaplus.com/#point-57
											// Re-resolve promises immediately to dodge false rejection from
											// subsequent errors
											if ( depth ) {
												process();
											} else {

												// Call an optional hook to record the stack, in case of exception
												// since it's otherwise lost when execution goes async
												if ( jQuery.Deferred.getStackHook ) {
													process.stackTrace = jQuery.Deferred.getStackHook();
												}
												window.setTimeout( process );
											}
										};
									}

									return jQuery.Deferred( function( newDefer ) {

										// progress_handlers.add( ... )
										tuples[ 0 ][ 3 ].add(
											resolve(
												0,
												newDefer,
												jQuery.isFunction( onProgress ) ?
													onProgress :
													Identity,
												newDefer.notifyWith
											)
										);

										// fulfilled_handlers.add( ... )
										tuples[ 1 ][ 3 ].add(
											resolve(
												0,
												newDefer,
												jQuery.isFunction( onFulfilled ) ?
													onFulfilled :
													Identity
											)
										);

										// rejected_handlers.add( ... )
										tuples[ 2 ][ 3 ].add(
											resolve(
												0,
												newDefer,
												jQuery.isFunction( onRejected ) ?
													onRejected :
													Thrower
											)
										);
									} ).promise();
								},

								// Get a promise for this deferred
								// If obj is provided, the promise aspect is added to the object
								promise: function( obj ) {
									return obj != null ? jQuery.extend( obj, promise ) : promise;
								}
							},
							deferred = {};

						// Add list-specific methods
						jQuery.each( tuples, function( i, tuple ) {
							var list = tuple[ 2 ],
								stateString = tuple[ 5 ];

							// promise.progress = list.add
							// promise.done = list.add
							// promise.fail = list.add
							promise[ tuple[ 1 ] ] = list.add;

							// Handle state
							if ( stateString ) {
								list.add(
									function() {

										// state = "resolved" (i.e., fulfilled)
										// state = "rejected"
										state = stateString;
									},

									// rejected_callbacks.disable
									// fulfilled_callbacks.disable
									tuples[ 3 - i ][ 2 ].disable,

									// progress_callbacks.lock
									tuples[ 0 ][ 2 ].lock
								);
							}

							// progress_handlers.fire
							// fulfilled_handlers.fire
							// rejected_handlers.fire
							list.add( tuple[ 3 ].fire );

							// deferred.notify = function() { deferred.notifyWith(...) }
							// deferred.resolve = function() { deferred.resolveWith(...) }
							// deferred.reject = function() { deferred.rejectWith(...) }
							deferred[ tuple[ 0 ] ] = function() {
								deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
								return this;
							};

							// deferred.notifyWith = list.fireWith
							// deferred.resolveWith = list.fireWith
							// deferred.rejectWith = list.fireWith
							deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
						} );

						// Make the deferred a promise
						promise.promise( deferred );

						// Call given func if any
						if ( func ) {
							func.call( deferred, deferred );
						}

						// All done!
						return deferred;
					},

					// Deferred helper
					when: function( singleValue ) {
						var

							// count of uncompleted subordinates
							remaining = arguments.length,

							// count of unprocessed arguments
							i = remaining,

							// subordinate fulfillment data
							resolveContexts = Array( i ),
							resolveValues = slice.call( arguments ),

							// the master Deferred
							master = jQuery.Deferred(),

							// subordinate callback factory
							updateFunc = function( i ) {
								return function( value ) {
									resolveContexts[ i ] = this;
									resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
									if ( !( --remaining ) ) {
										master.resolveWith( resolveContexts, resolveValues );
									}
								};
							};

						// Single- and empty arguments are adopted like Promise.resolve
						if ( remaining <= 1 ) {
							adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject );

							// Use .then() to unwrap secondary thenables (cf. gh-3000)
							if ( master.state() === "pending" ||
								jQuery.isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

								return master.then();
							}
						}

						// Multiple arguments are aggregated like Promise.all array elements
						while ( i-- ) {
							adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
						}

						return master.promise();
					}
				} );


				// These usually indicate a programmer mistake during development,
				// warn about them ASAP rather than swallowing them by default.
				var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

				jQuery.Deferred.exceptionHook = function( error, stack ) {

					// Support: IE 8 - 9 only
					// Console exists when dev tools are open, which can happen at any time
					if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
						window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
					}
				};




				jQuery.readyException = function( error ) {
					window.setTimeout( function() {
						throw error;
					} );
				};




				// The deferred used on DOM ready
				var readyList = jQuery.Deferred();

				jQuery.fn.ready = function( fn ) {

					readyList
						.then( fn )

						// Wrap jQuery.readyException in a function so that the lookup
						// happens at the time of error handling instead of callback
						// registration.
						.catch( function( error ) {
							jQuery.readyException( error );
						} );

					return this;
				};

				jQuery.extend( {

					// Is the DOM ready to be used? Set to true once it occurs.
					isReady: false,

					// A counter to track how many items to wait for before
					// the ready event fires. See #6781
					readyWait: 1,

					// Hold (or release) the ready event
					holdReady: function( hold ) {
						if ( hold ) {
							jQuery.readyWait++;
						} else {
							jQuery.ready( true );
						}
					},

					// Handle when the DOM is ready
					ready: function( wait ) {

						// Abort if there are pending holds or we're already ready
						if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
							return;
						}

						// Remember that the DOM is ready
						jQuery.isReady = true;

						// If a normal DOM Ready event fired, decrement, and wait if need be
						if ( wait !== true && --jQuery.readyWait > 0 ) {
							return;
						}

						// If there are functions bound, to execute
						readyList.resolveWith( document, [ jQuery ] );
					}
				} );

				jQuery.ready.then = readyList.then;

				// The ready event handler and self cleanup method
				function completed() {
					document.removeEventListener( "DOMContentLoaded", completed );
					window.removeEventListener( "load", completed );
					jQuery.ready();
				}

				// Catch cases where $(document).ready() is called
				// after the browser event has already occurred.
				// Support: IE <=9 - 10 only
				// Older IE sometimes signals "interactive" too soon
				if ( document.readyState === "complete" ||
					( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

					// Handle it asynchronously to allow scripts the opportunity to delay ready
					window.setTimeout( jQuery.ready );

				} else {

					// Use the handy event callback
					document.addEventListener( "DOMContentLoaded", completed );

					// A fallback to window.onload, that will always work
					window.addEventListener( "load", completed );
				}




				// Multifunctional method to get and set values of a collection
				// The value/s can optionally be executed if it's a function
				var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
					var i = 0,
						len = elems.length,
						bulk = key == null;

					// Sets many values
					if ( jQuery.type( key ) === "object" ) {
						chainable = true;
						for ( i in key ) {
							access( elems, fn, i, key[ i ], true, emptyGet, raw );
						}

					// Sets one value
					} else if ( value !== undefined ) {
						chainable = true;

						if ( !jQuery.isFunction( value ) ) {
							raw = true;
						}

						if ( bulk ) {

							// Bulk operations run against the entire set
							if ( raw ) {
								fn.call( elems, value );
								fn = null;

							// ...except when executing function values
							} else {
								bulk = fn;
								fn = function( elem, key, value ) {
									return bulk.call( jQuery( elem ), value );
								};
							}
						}

						if ( fn ) {
							for ( ; i < len; i++ ) {
								fn(
									elems[ i ], key, raw ?
									value :
									value.call( elems[ i ], i, fn( elems[ i ], key ) )
								);
							}
						}
					}

					if ( chainable ) {
						return elems;
					}

					// Gets
					if ( bulk ) {
						return fn.call( elems );
					}

					return len ? fn( elems[ 0 ], key ) : emptyGet;
				};
				var acceptData = function( owner ) {

					// Accepts only:
					//  - Node
					//    - Node.ELEMENT_NODE
					//    - Node.DOCUMENT_NODE
					//  - Object
					//    - Any
					return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
				};




				function Data() {
					this.expando = jQuery.expando + Data.uid++;
				}

				Data.uid = 1;

				Data.prototype = {

					cache: function( owner ) {

						// Check if the owner object already has a cache
						var value = owner[ this.expando ];

						// If not, create one
						if ( !value ) {
							value = {};

							// We can accept data for non-element nodes in modern browsers,
							// but we should not, see #8335.
							// Always return an empty object.
							if ( acceptData( owner ) ) {

								// If it is a node unlikely to be stringify-ed or looped over
								// use plain assignment
								if ( owner.nodeType ) {
									owner[ this.expando ] = value;

								// Otherwise secure it in a non-enumerable property
								// configurable must be true to allow the property to be
								// deleted when data is removed
								} else {
									Object.defineProperty( owner, this.expando, {
										value: value,
										configurable: true
									} );
								}
							}
						}

						return value;
					},
					set: function( owner, data, value ) {
						var prop,
							cache = this.cache( owner );

						// Handle: [ owner, key, value ] args
						// Always use camelCase key (gh-2257)
						if ( typeof data === "string" ) {
							cache[ jQuery.camelCase( data ) ] = value;

						// Handle: [ owner, { properties } ] args
						} else {

							// Copy the properties one-by-one to the cache object
							for ( prop in data ) {
								cache[ jQuery.camelCase( prop ) ] = data[ prop ];
							}
						}
						return cache;
					},
					get: function( owner, key ) {
						return key === undefined ?
							this.cache( owner ) :

							// Always use camelCase key (gh-2257)
							owner[ this.expando ] && owner[ this.expando ][ jQuery.camelCase( key ) ];
					},
					access: function( owner, key, value ) {

						// In cases where either:
						//
						//   1. No key was specified
						//   2. A string key was specified, but no value provided
						//
						// Take the "read" path and allow the get method to determine
						// which value to return, respectively either:
						//
						//   1. The entire cache object
						//   2. The data stored at the key
						//
						if ( key === undefined ||
								( ( key && typeof key === "string" ) && value === undefined ) ) {

							return this.get( owner, key );
						}

						// When the key is not a string, or both a key and value
						// are specified, set or extend (existing objects) with either:
						//
						//   1. An object of properties
						//   2. A key and value
						//
						this.set( owner, key, value );

						// Since the "set" path can have two possible entry points
						// return the expected data based on which path was taken[*]
						return value !== undefined ? value : key;
					},
					remove: function( owner, key ) {
						var i,
							cache = owner[ this.expando ];

						if ( cache === undefined ) {
							return;
						}

						if ( key !== undefined ) {

							// Support array or space separated string of keys
							if ( jQuery.isArray( key ) ) {

								// If key is an array of keys...
								// We always set camelCase keys, so remove that.
								key = key.map( jQuery.camelCase );
							} else {
								key = jQuery.camelCase( key );

								// If a key with the spaces exists, use it.
								// Otherwise, create an array by matching non-whitespace
								key = key in cache ?
									[ key ] :
									( key.match( rnothtmlwhite ) || [] );
							}

							i = key.length;

							while ( i-- ) {
								delete cache[ key[ i ] ];
							}
						}

						// Remove the expando if there's no more data
						if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

							// Support: Chrome <=35 - 45
							// Webkit & Blink performance suffers when deleting properties
							// from DOM nodes, so set to undefined instead
							// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
							if ( owner.nodeType ) {
								owner[ this.expando ] = undefined;
							} else {
								delete owner[ this.expando ];
							}
						}
					},
					hasData: function( owner ) {
						var cache = owner[ this.expando ];
						return cache !== undefined && !jQuery.isEmptyObject( cache );
					}
				};
				var dataPriv = new Data();

				var dataUser = new Data();



				//	Implementation Summary
				//
				//	1. Enforce API surface and semantic compatibility with 1.9.x branch
				//	2. Improve the module's maintainability by reducing the storage
				//		paths to a single mechanism.
				//	3. Use the same single mechanism to support "private" and "user" data.
				//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
				//	5. Avoid exposing implementation details on user objects (eg. expando properties)
				//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

				var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
					rmultiDash = /[A-Z]/g;

				function getData( data ) {
					if ( data === "true" ) {
						return true;
					}

					if ( data === "false" ) {
						return false;
					}

					if ( data === "null" ) {
						return null;
					}

					// Only convert to a number if it doesn't change the string
					if ( data === +data + "" ) {
						return +data;
					}

					if ( rbrace.test( data ) ) {
						return JSON.parse( data );
					}

					return data;
				}

				function dataAttr( elem, key, data ) {
					var name;

					// If nothing was found internally, try to fetch any
					// data from the HTML5 data-* attribute
					if ( data === undefined && elem.nodeType === 1 ) {
						name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
						data = elem.getAttribute( name );

						if ( typeof data === "string" ) {
							try {
								data = getData( data );
							} catch ( e ) {}

							// Make sure we set the data so it isn't changed later
							dataUser.set( elem, key, data );
						} else {
							data = undefined;
						}
					}
					return data;
				}

				jQuery.extend( {
					hasData: function( elem ) {
						return dataUser.hasData( elem ) || dataPriv.hasData( elem );
					},

					data: function( elem, name, data ) {
						return dataUser.access( elem, name, data );
					},

					removeData: function( elem, name ) {
						dataUser.remove( elem, name );
					},

					// TODO: Now that all calls to _data and _removeData have been replaced
					// with direct calls to dataPriv methods, these can be deprecated.
					_data: function( elem, name, data ) {
						return dataPriv.access( elem, name, data );
					},

					_removeData: function( elem, name ) {
						dataPriv.remove( elem, name );
					}
				} );

				jQuery.fn.extend( {
					data: function( key, value ) {
						var i, name, data,
							elem = this[ 0 ],
							attrs = elem && elem.attributes;

						// Gets all values
						if ( key === undefined ) {
							if ( this.length ) {
								data = dataUser.get( elem );

								if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
									i = attrs.length;
									while ( i-- ) {

										// Support: IE 11 only
										// The attrs elements can be null (#14894)
										if ( attrs[ i ] ) {
											name = attrs[ i ].name;
											if ( name.indexOf( "data-" ) === 0 ) {
												name = jQuery.camelCase( name.slice( 5 ) );
												dataAttr( elem, name, data[ name ] );
											}
										}
									}
									dataPriv.set( elem, "hasDataAttrs", true );
								}
							}

							return data;
						}

						// Sets multiple values
						if ( typeof key === "object" ) {
							return this.each( function() {
								dataUser.set( this, key );
							} );
						}

						return access( this, function( value ) {
							var data;

							// The calling jQuery object (element matches) is not empty
							// (and therefore has an element appears at this[ 0 ]) and the
							// `value` parameter was not undefined. An empty jQuery object
							// will result in `undefined` for elem = this[ 0 ] which will
							// throw an exception if an attempt to read a data cache is made.
							if ( elem && value === undefined ) {

								// Attempt to get data from the cache
								// The key will always be camelCased in Data
								data = dataUser.get( elem, key );
								if ( data !== undefined ) {
									return data;
								}

								// Attempt to "discover" the data in
								// HTML5 custom data-* attrs
								data = dataAttr( elem, key );
								if ( data !== undefined ) {
									return data;
								}

								// We tried really hard, but the data doesn't exist.
								return;
							}

							// Set the data...
							this.each( function() {

								// We always store the camelCased key
								dataUser.set( this, key, value );
							} );
						}, null, value, arguments.length > 1, null, true );
					},

					removeData: function( key ) {
						return this.each( function() {
							dataUser.remove( this, key );
						} );
					}
				} );


				jQuery.extend( {
					queue: function( elem, type, data ) {
						var queue;

						if ( elem ) {
							type = ( type || "fx" ) + "queue";
							queue = dataPriv.get( elem, type );

							// Speed up dequeue by getting out quickly if this is just a lookup
							if ( data ) {
								if ( !queue || jQuery.isArray( data ) ) {
									queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
								} else {
									queue.push( data );
								}
							}
							return queue || [];
						}
					},

					dequeue: function( elem, type ) {
						type = type || "fx";

						var queue = jQuery.queue( elem, type ),
							startLength = queue.length,
							fn = queue.shift(),
							hooks = jQuery._queueHooks( elem, type ),
							next = function() {
								jQuery.dequeue( elem, type );
							};

						// If the fx queue is dequeued, always remove the progress sentinel
						if ( fn === "inprogress" ) {
							fn = queue.shift();
							startLength--;
						}

						if ( fn ) {

							// Add a progress sentinel to prevent the fx queue from being
							// automatically dequeued
							if ( type === "fx" ) {
								queue.unshift( "inprogress" );
							}

							// Clear up the last queue stop function
							delete hooks.stop;
							fn.call( elem, next, hooks );
						}

						if ( !startLength && hooks ) {
							hooks.empty.fire();
						}
					},

					// Not public - generate a queueHooks object, or return the current one
					_queueHooks: function( elem, type ) {
						var key = type + "queueHooks";
						return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
							empty: jQuery.Callbacks( "once memory" ).add( function() {
								dataPriv.remove( elem, [ type + "queue", key ] );
							} )
						} );
					}
				} );

				jQuery.fn.extend( {
					queue: function( type, data ) {
						var setter = 2;

						if ( typeof type !== "string" ) {
							data = type;
							type = "fx";
							setter--;
						}

						if ( arguments.length < setter ) {
							return jQuery.queue( this[ 0 ], type );
						}

						return data === undefined ?
							this :
							this.each( function() {
								var queue = jQuery.queue( this, type, data );

								// Ensure a hooks for this queue
								jQuery._queueHooks( this, type );

								if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
									jQuery.dequeue( this, type );
								}
							} );
					},
					dequeue: function( type ) {
						return this.each( function() {
							jQuery.dequeue( this, type );
						} );
					},
					clearQueue: function( type ) {
						return this.queue( type || "fx", [] );
					},

					// Get a promise resolved when queues of a certain type
					// are emptied (fx is the type by default)
					promise: function( type, obj ) {
						var tmp,
							count = 1,
							defer = jQuery.Deferred(),
							elements = this,
							i = this.length,
							resolve = function() {
								if ( !( --count ) ) {
									defer.resolveWith( elements, [ elements ] );
								}
							};

						if ( typeof type !== "string" ) {
							obj = type;
							type = undefined;
						}
						type = type || "fx";

						while ( i-- ) {
							tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
							if ( tmp && tmp.empty ) {
								count++;
								tmp.empty.add( resolve );
							}
						}
						resolve();
						return defer.promise( obj );
					}
				} );
				var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

				var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


				var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

				var isHiddenWithinTree = function( elem, el ) {

						// isHiddenWithinTree might be called from jQuery#filter function;
						// in that case, element will be second argument
						elem = el || elem;

						// Inline style trumps all
						return elem.style.display === "none" ||
							elem.style.display === "" &&

							// Otherwise, check computed style
							// Support: Firefox <=43 - 45
							// Disconnected elements can have computed display: none, so first confirm that elem is
							// in the document.
							jQuery.contains( elem.ownerDocument, elem ) &&

							jQuery.css( elem, "display" ) === "none";
					};

				var swap = function( elem, options, callback, args ) {
					var ret, name,
						old = {};

					// Remember the old values, and insert the new ones
					for ( name in options ) {
						old[ name ] = elem.style[ name ];
						elem.style[ name ] = options[ name ];
					}

					ret = callback.apply( elem, args || [] );

					// Revert the old values
					for ( name in options ) {
						elem.style[ name ] = old[ name ];
					}

					return ret;
				};




				function adjustCSS( elem, prop, valueParts, tween ) {
					var adjusted,
						scale = 1,
						maxIterations = 20,
						currentValue = tween ?
							function() {
								return tween.cur();
							} :
							function() {
								return jQuery.css( elem, prop, "" );
							},
						initial = currentValue(),
						unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

						// Starting value computation is required for potential unit mismatches
						initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
							rcssNum.exec( jQuery.css( elem, prop ) );

					if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

						// Trust units reported by jQuery.css
						unit = unit || initialInUnit[ 3 ];

						// Make sure we update the tween properties later on
						valueParts = valueParts || [];

						// Iteratively approximate from a nonzero starting point
						initialInUnit = +initial || 1;

						do {

							// If previous iteration zeroed out, double until we get *something*.
							// Use string for doubling so we don't accidentally see scale as unchanged below
							scale = scale || ".5";

							// Adjust and apply
							initialInUnit = initialInUnit / scale;
							jQuery.style( elem, prop, initialInUnit + unit );

						// Update scale, tolerating zero or NaN from tween.cur()
						// Break the loop if scale is unchanged or perfect, or if we've just had enough.
						} while (
							scale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations
						);
					}

					if ( valueParts ) {
						initialInUnit = +initialInUnit || +initial || 0;

						// Apply relative offset (+=/-=) if specified
						adjusted = valueParts[ 1 ] ?
							initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
							+valueParts[ 2 ];
						if ( tween ) {
							tween.unit = unit;
							tween.start = initialInUnit;
							tween.end = adjusted;
						}
					}
					return adjusted;
				}


				var defaultDisplayMap = {};

				function getDefaultDisplay( elem ) {
					var temp,
						doc = elem.ownerDocument,
						nodeName = elem.nodeName,
						display = defaultDisplayMap[ nodeName ];

					if ( display ) {
						return display;
					}

					temp = doc.body.appendChild( doc.createElement( nodeName ) );
					display = jQuery.css( temp, "display" );

					temp.parentNode.removeChild( temp );

					if ( display === "none" ) {
						display = "block";
					}
					defaultDisplayMap[ nodeName ] = display;

					return display;
				}

				function showHide( elements, show ) {
					var display, elem,
						values = [],
						index = 0,
						length = elements.length;

					// Determine new display value for elements that need to change
					for ( ; index < length; index++ ) {
						elem = elements[ index ];
						if ( !elem.style ) {
							continue;
						}

						display = elem.style.display;
						if ( show ) {

							// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
							// check is required in this first loop unless we have a nonempty display value (either
							// inline or about-to-be-restored)
							if ( display === "none" ) {
								values[ index ] = dataPriv.get( elem, "display" ) || null;
								if ( !values[ index ] ) {
									elem.style.display = "";
								}
							}
							if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
								values[ index ] = getDefaultDisplay( elem );
							}
						} else {
							if ( display !== "none" ) {
								values[ index ] = "none";

								// Remember what we're overwriting
								dataPriv.set( elem, "display", display );
							}
						}
					}

					// Set the display of the elements in a second loop to avoid constant reflow
					for ( index = 0; index < length; index++ ) {
						if ( values[ index ] != null ) {
							elements[ index ].style.display = values[ index ];
						}
					}

					return elements;
				}

				jQuery.fn.extend( {
					show: function() {
						return showHide( this, true );
					},
					hide: function() {
						return showHide( this );
					},
					toggle: function( state ) {
						if ( typeof state === "boolean" ) {
							return state ? this.show() : this.hide();
						}

						return this.each( function() {
							if ( isHiddenWithinTree( this ) ) {
								jQuery( this ).show();
							} else {
								jQuery( this ).hide();
							}
						} );
					}
				} );
				var rcheckableType = ( /^(?:checkbox|radio)$/i );

				var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]+)/i );

				var rscriptType = ( /^$|\/(?:java|ecma)script/i );



				// We have to close these tags to support XHTML (#13200)
				var wrapMap = {

					// Support: IE <=9 only
					option: [ 1, "<select multiple='multiple'>", "</select>" ],

					// XHTML parsers do not magically insert elements in the
					// same way that tag soup parsers do. So we cannot shorten
					// this by omitting <tbody> or other required elements.
					thead: [ 1, "<table>", "</table>" ],
					col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
					tr: [ 2, "<table><tbody>", "</tbody></table>" ],
					td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

					_default: [ 0, "", "" ]
				};

				// Support: IE <=9 only
				wrapMap.optgroup = wrapMap.option;

				wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
				wrapMap.th = wrapMap.td;


				function getAll( context, tag ) {

					// Support: IE <=9 - 11 only
					// Use typeof to avoid zero-argument method invocation on host objects (#15151)
					var ret;

					if ( typeof context.getElementsByTagName !== "undefined" ) {
						ret = context.getElementsByTagName( tag || "*" );

					} else if ( typeof context.querySelectorAll !== "undefined" ) {
						ret = context.querySelectorAll( tag || "*" );

					} else {
						ret = [];
					}

					if ( tag === undefined || tag && jQuery.nodeName( context, tag ) ) {
						return jQuery.merge( [ context ], ret );
					}

					return ret;
				}


				// Mark scripts as having already been evaluated
				function setGlobalEval( elems, refElements ) {
					var i = 0,
						l = elems.length;

					for ( ; i < l; i++ ) {
						dataPriv.set(
							elems[ i ],
							"globalEval",
							!refElements || dataPriv.get( refElements[ i ], "globalEval" )
						);
					}
				}


				var rhtml = /<|&#?\w+;/;

				function buildFragment( elems, context, scripts, selection, ignored ) {
					var elem, tmp, tag, wrap, contains, j,
						fragment = context.createDocumentFragment(),
						nodes = [],
						i = 0,
						l = elems.length;

					for ( ; i < l; i++ ) {
						elem = elems[ i ];

						if ( elem || elem === 0 ) {

							// Add nodes directly
							if ( jQuery.type( elem ) === "object" ) {

								// Support: Android <=4.0 only, PhantomJS 1 only
								// push.apply(_, arraylike) throws on ancient WebKit
								jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

							// Convert non-html into a text node
							} else if ( !rhtml.test( elem ) ) {
								nodes.push( context.createTextNode( elem ) );

							// Convert html into DOM nodes
							} else {
								tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

								// Deserialize a standard representation
								tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
								wrap = wrapMap[ tag ] || wrapMap._default;
								tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

								// Descend through wrappers to the right content
								j = wrap[ 0 ];
								while ( j-- ) {
									tmp = tmp.lastChild;
								}

								// Support: Android <=4.0 only, PhantomJS 1 only
								// push.apply(_, arraylike) throws on ancient WebKit
								jQuery.merge( nodes, tmp.childNodes );

								// Remember the top-level container
								tmp = fragment.firstChild;

								// Ensure the created nodes are orphaned (#12392)
								tmp.textContent = "";
							}
						}
					}

					// Remove wrapper from fragment
					fragment.textContent = "";

					i = 0;
					while ( ( elem = nodes[ i++ ] ) ) {

						// Skip elements already in the context collection (trac-4087)
						if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
							if ( ignored ) {
								ignored.push( elem );
							}
							continue;
						}

						contains = jQuery.contains( elem.ownerDocument, elem );

						// Append to fragment
						tmp = getAll( fragment.appendChild( elem ), "script" );

						// Preserve script evaluation history
						if ( contains ) {
							setGlobalEval( tmp );
						}

						// Capture executables
						if ( scripts ) {
							j = 0;
							while ( ( elem = tmp[ j++ ] ) ) {
								if ( rscriptType.test( elem.type || "" ) ) {
									scripts.push( elem );
								}
							}
						}
					}

					return fragment;
				}


				( function() {
					var fragment = document.createDocumentFragment(),
						div = fragment.appendChild( document.createElement( "div" ) ),
						input = document.createElement( "input" );

					// Support: Android 4.0 - 4.3 only
					// Check state lost if the name is set (#11217)
					// Support: Windows Web Apps (WWA)
					// `name` and `type` must use .setAttribute for WWA (#14901)
					input.setAttribute( "type", "radio" );
					input.setAttribute( "checked", "checked" );
					input.setAttribute( "name", "t" );

					div.appendChild( input );

					// Support: Android <=4.1 only
					// Older WebKit doesn't clone checked state correctly in fragments
					support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

					// Support: IE <=11 only
					// Make sure textarea (and checkbox) defaultValue is properly cloned
					div.innerHTML = "<textarea>x</textarea>";
					support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
				} )();
				var documentElement = document.documentElement;



				var
					rkeyEvent = /^key/,
					rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
					rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

				function returnTrue() {
					return true;
				}

				function returnFalse() {
					return false;
				}

				// Support: IE <=9 only
				// See #13393 for more info
				function safeActiveElement() {
					try {
						return document.activeElement;
					} catch ( err ) { }
				}

				function on( elem, types, selector, data, fn, one ) {
					var origFn, type;

					// Types can be a map of types/handlers
					if ( typeof types === "object" ) {

						// ( types-Object, selector, data )
						if ( typeof selector !== "string" ) {

							// ( types-Object, data )
							data = data || selector;
							selector = undefined;
						}
						for ( type in types ) {
							on( elem, type, selector, data, types[ type ], one );
						}
						return elem;
					}

					if ( data == null && fn == null ) {

						// ( types, fn )
						fn = selector;
						data = selector = undefined;
					} else if ( fn == null ) {
						if ( typeof selector === "string" ) {

							// ( types, selector, fn )
							fn = data;
							data = undefined;
						} else {

							// ( types, data, fn )
							fn = data;
							data = selector;
							selector = undefined;
						}
					}
					if ( fn === false ) {
						fn = returnFalse;
					} else if ( !fn ) {
						return elem;
					}

					if ( one === 1 ) {
						origFn = fn;
						fn = function( event ) {

							// Can use an empty set, since event contains the info
							jQuery().off( event );
							return origFn.apply( this, arguments );
						};

						// Use same guid so caller can remove using origFn
						fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
					}
					return elem.each( function() {
						jQuery.event.add( this, types, fn, data, selector );
					} );
				}

				/*
				 * Helper functions for managing events -- not part of the public interface.
				 * Props to Dean Edwards' addEvent library for many of the ideas.
				 */
				jQuery.event = {

					global: {},

					add: function( elem, types, handler, data, selector ) {

						var handleObjIn, eventHandle, tmp,
							events, t, handleObj,
							special, handlers, type, namespaces, origType,
							elemData = dataPriv.get( elem );

						// Don't attach events to noData or text/comment nodes (but allow plain objects)
						if ( !elemData ) {
							return;
						}

						// Caller can pass in an object of custom data in lieu of the handler
						if ( handler.handler ) {
							handleObjIn = handler;
							handler = handleObjIn.handler;
							selector = handleObjIn.selector;
						}

						// Ensure that invalid selectors throw exceptions at attach time
						// Evaluate against documentElement in case elem is a non-element node (e.g., document)
						if ( selector ) {
							jQuery.find.matchesSelector( documentElement, selector );
						}

						// Make sure that the handler has a unique ID, used to find/remove it later
						if ( !handler.guid ) {
							handler.guid = jQuery.guid++;
						}

						// Init the element's event structure and main handler, if this is the first
						if ( !( events = elemData.events ) ) {
							events = elemData.events = {};
						}
						if ( !( eventHandle = elemData.handle ) ) {
							eventHandle = elemData.handle = function( e ) {

								// Discard the second event of a jQuery.event.trigger() and
								// when an event is called after a page has unloaded
								return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
									jQuery.event.dispatch.apply( elem, arguments ) : undefined;
							};
						}

						// Handle multiple events separated by a space
						types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
						t = types.length;
						while ( t-- ) {
							tmp = rtypenamespace.exec( types[ t ] ) || [];
							type = origType = tmp[ 1 ];
							namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

							// There *must* be a type, no attaching namespace-only handlers
							if ( !type ) {
								continue;
							}

							// If event changes its type, use the special event handlers for the changed type
							special = jQuery.event.special[ type ] || {};

							// If selector defined, determine special event api type, otherwise given type
							type = ( selector ? special.delegateType : special.bindType ) || type;

							// Update special based on newly reset type
							special = jQuery.event.special[ type ] || {};

							// handleObj is passed to all event handlers
							handleObj = jQuery.extend( {
								type: type,
								origType: origType,
								data: data,
								handler: handler,
								guid: handler.guid,
								selector: selector,
								needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
								namespace: namespaces.join( "." )
							}, handleObjIn );

							// Init the event handler queue if we're the first
							if ( !( handlers = events[ type ] ) ) {
								handlers = events[ type ] = [];
								handlers.delegateCount = 0;

								// Only use addEventListener if the special events handler returns false
								if ( !special.setup ||
									special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

									if ( elem.addEventListener ) {
										elem.addEventListener( type, eventHandle );
									}
								}
							}

							if ( special.add ) {
								special.add.call( elem, handleObj );

								if ( !handleObj.handler.guid ) {
									handleObj.handler.guid = handler.guid;
								}
							}

							// Add to the element's handler list, delegates in front
							if ( selector ) {
								handlers.splice( handlers.delegateCount++, 0, handleObj );
							} else {
								handlers.push( handleObj );
							}

							// Keep track of which events have ever been used, for event optimization
							jQuery.event.global[ type ] = true;
						}

					},

					// Detach an event or set of events from an element
					remove: function( elem, types, handler, selector, mappedTypes ) {

						var j, origCount, tmp,
							events, t, handleObj,
							special, handlers, type, namespaces, origType,
							elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

						if ( !elemData || !( events = elemData.events ) ) {
							return;
						}

						// Once for each type.namespace in types; type may be omitted
						types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
						t = types.length;
						while ( t-- ) {
							tmp = rtypenamespace.exec( types[ t ] ) || [];
							type = origType = tmp[ 1 ];
							namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

							// Unbind all events (on this namespace, if provided) for the element
							if ( !type ) {
								for ( type in events ) {
									jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
								}
								continue;
							}

							special = jQuery.event.special[ type ] || {};
							type = ( selector ? special.delegateType : special.bindType ) || type;
							handlers = events[ type ] || [];
							tmp = tmp[ 2 ] &&
								new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

							// Remove matching events
							origCount = j = handlers.length;
							while ( j-- ) {
								handleObj = handlers[ j ];

								if ( ( mappedTypes || origType === handleObj.origType ) &&
									( !handler || handler.guid === handleObj.guid ) &&
									( !tmp || tmp.test( handleObj.namespace ) ) &&
									( !selector || selector === handleObj.selector ||
										selector === "**" && handleObj.selector ) ) {
									handlers.splice( j, 1 );

									if ( handleObj.selector ) {
										handlers.delegateCount--;
									}
									if ( special.remove ) {
										special.remove.call( elem, handleObj );
									}
								}
							}

							// Remove generic event handler if we removed something and no more handlers exist
							// (avoids potential for endless recursion during removal of special event handlers)
							if ( origCount && !handlers.length ) {
								if ( !special.teardown ||
									special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

									jQuery.removeEvent( elem, type, elemData.handle );
								}

								delete events[ type ];
							}
						}

						// Remove data and the expando if it's no longer used
						if ( jQuery.isEmptyObject( events ) ) {
							dataPriv.remove( elem, "handle events" );
						}
					},

					dispatch: function( nativeEvent ) {

						// Make a writable jQuery.Event from the native event object
						var event = jQuery.event.fix( nativeEvent );

						var i, j, ret, matched, handleObj, handlerQueue,
							args = new Array( arguments.length ),
							handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
							special = jQuery.event.special[ event.type ] || {};

						// Use the fix-ed jQuery.Event rather than the (read-only) native event
						args[ 0 ] = event;

						for ( i = 1; i < arguments.length; i++ ) {
							args[ i ] = arguments[ i ];
						}

						event.delegateTarget = this;

						// Call the preDispatch hook for the mapped type, and let it bail if desired
						if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
							return;
						}

						// Determine handlers
						handlerQueue = jQuery.event.handlers.call( this, event, handlers );

						// Run delegates first; they may want to stop propagation beneath us
						i = 0;
						while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
							event.currentTarget = matched.elem;

							j = 0;
							while ( ( handleObj = matched.handlers[ j++ ] ) &&
								!event.isImmediatePropagationStopped() ) {

								// Triggered event must either 1) have no namespace, or 2) have namespace(s)
								// a subset or equal to those in the bound event (both can have no namespace).
								if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

									event.handleObj = handleObj;
									event.data = handleObj.data;

									ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
										handleObj.handler ).apply( matched.elem, args );

									if ( ret !== undefined ) {
										if ( ( event.result = ret ) === false ) {
											event.preventDefault();
											event.stopPropagation();
										}
									}
								}
							}
						}

						// Call the postDispatch hook for the mapped type
						if ( special.postDispatch ) {
							special.postDispatch.call( this, event );
						}

						return event.result;
					},

					handlers: function( event, handlers ) {
						var i, handleObj, sel, matchedHandlers, matchedSelectors,
							handlerQueue = [],
							delegateCount = handlers.delegateCount,
							cur = event.target;

						// Find delegate handlers
						if ( delegateCount &&

							// Support: IE <=9
							// Black-hole SVG <use> instance trees (trac-13180)
							cur.nodeType &&

							// Support: Firefox <=42
							// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
							// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
							// Support: IE 11 only
							// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
							!( event.type === "click" && event.button >= 1 ) ) {

							for ( ; cur !== this; cur = cur.parentNode || this ) {

								// Don't check non-elements (#13208)
								// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
								if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
									matchedHandlers = [];
									matchedSelectors = {};
									for ( i = 0; i < delegateCount; i++ ) {
										handleObj = handlers[ i ];

										// Don't conflict with Object.prototype properties (#13203)
										sel = handleObj.selector + " ";

										if ( matchedSelectors[ sel ] === undefined ) {
											matchedSelectors[ sel ] = handleObj.needsContext ?
												jQuery( sel, this ).index( cur ) > -1 :
												jQuery.find( sel, this, null, [ cur ] ).length;
										}
										if ( matchedSelectors[ sel ] ) {
											matchedHandlers.push( handleObj );
										}
									}
									if ( matchedHandlers.length ) {
										handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
									}
								}
							}
						}

						// Add the remaining (directly-bound) handlers
						cur = this;
						if ( delegateCount < handlers.length ) {
							handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
						}

						return handlerQueue;
					},

					addProp: function( name, hook ) {
						Object.defineProperty( jQuery.Event.prototype, name, {
							enumerable: true,
							configurable: true,

							get: jQuery.isFunction( hook ) ?
								function() {
									if ( this.originalEvent ) {
											return hook( this.originalEvent );
									}
								} :
								function() {
									if ( this.originalEvent ) {
											return this.originalEvent[ name ];
									}
								},

							set: function( value ) {
								Object.defineProperty( this, name, {
									enumerable: true,
									configurable: true,
									writable: true,
									value: value
								} );
							}
						} );
					},

					fix: function( originalEvent ) {
						return originalEvent[ jQuery.expando ] ?
							originalEvent :
							new jQuery.Event( originalEvent );
					},

					special: {
						load: {

							// Prevent triggered image.load events from bubbling to window.load
							noBubble: true
						},
						focus: {

							// Fire native event if possible so blur/focus sequence is correct
							trigger: function() {
								if ( this !== safeActiveElement() && this.focus ) {
									this.focus();
									return false;
								}
							},
							delegateType: "focusin"
						},
						blur: {
							trigger: function() {
								if ( this === safeActiveElement() && this.blur ) {
									this.blur();
									return false;
								}
							},
							delegateType: "focusout"
						},
						click: {

							// For checkbox, fire native event so checked state will be right
							trigger: function() {
								if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
									this.click();
									return false;
								}
							},

							// For cross-browser consistency, don't fire native .click() on links
							_default: function( event ) {
								return jQuery.nodeName( event.target, "a" );
							}
						},

						beforeunload: {
							postDispatch: function( event ) {

								// Support: Firefox 20+
								// Firefox doesn't alert if the returnValue field is not set.
								if ( event.result !== undefined && event.originalEvent ) {
									event.originalEvent.returnValue = event.result;
								}
							}
						}
					}
				};

				jQuery.removeEvent = function( elem, type, handle ) {

					// This "if" is needed for plain objects
					if ( elem.removeEventListener ) {
						elem.removeEventListener( type, handle );
					}
				};

				jQuery.Event = function( src, props ) {

					// Allow instantiation without the 'new' keyword
					if ( !( this instanceof jQuery.Event ) ) {
						return new jQuery.Event( src, props );
					}

					// Event object
					if ( src && src.type ) {
						this.originalEvent = src;
						this.type = src.type;

						// Events bubbling up the document may have been marked as prevented
						// by a handler lower down the tree; reflect the correct value.
						this.isDefaultPrevented = src.defaultPrevented ||
								src.defaultPrevented === undefined &&

								// Support: Android <=2.3 only
								src.returnValue === false ?
							returnTrue :
							returnFalse;

						// Create target properties
						// Support: Safari <=6 - 7 only
						// Target should not be a text node (#504, #13143)
						this.target = ( src.target && src.target.nodeType === 3 ) ?
							src.target.parentNode :
							src.target;

						this.currentTarget = src.currentTarget;
						this.relatedTarget = src.relatedTarget;

					// Event type
					} else {
						this.type = src;
					}

					// Put explicitly provided properties onto the event object
					if ( props ) {
						jQuery.extend( this, props );
					}

					// Create a timestamp if incoming event doesn't have one
					this.timeStamp = src && src.timeStamp || jQuery.now();

					// Mark it as fixed
					this[ jQuery.expando ] = true;
				};

				// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
				// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
				jQuery.Event.prototype = {
					constructor: jQuery.Event,
					isDefaultPrevented: returnFalse,
					isPropagationStopped: returnFalse,
					isImmediatePropagationStopped: returnFalse,
					isSimulated: false,

					preventDefault: function() {
						var e = this.originalEvent;

						this.isDefaultPrevented = returnTrue;

						if ( e && !this.isSimulated ) {
							e.preventDefault();
						}
					},
					stopPropagation: function() {
						var e = this.originalEvent;

						this.isPropagationStopped = returnTrue;

						if ( e && !this.isSimulated ) {
							e.stopPropagation();
						}
					},
					stopImmediatePropagation: function() {
						var e = this.originalEvent;

						this.isImmediatePropagationStopped = returnTrue;

						if ( e && !this.isSimulated ) {
							e.stopImmediatePropagation();
						}

						this.stopPropagation();
					}
				};

				// Includes all common event props including KeyEvent and MouseEvent specific props
				jQuery.each( {
					altKey: true,
					bubbles: true,
					cancelable: true,
					changedTouches: true,
					ctrlKey: true,
					detail: true,
					eventPhase: true,
					metaKey: true,
					pageX: true,
					pageY: true,
					shiftKey: true,
					view: true,
					"char": true,
					charCode: true,
					key: true,
					keyCode: true,
					button: true,
					buttons: true,
					clientX: true,
					clientY: true,
					offsetX: true,
					offsetY: true,
					pointerId: true,
					pointerType: true,
					screenX: true,
					screenY: true,
					targetTouches: true,
					toElement: true,
					touches: true,

					which: function( event ) {
						var button = event.button;

						// Add which for key events
						if ( event.which == null && rkeyEvent.test( event.type ) ) {
							return event.charCode != null ? event.charCode : event.keyCode;
						}

						// Add which for click: 1 === left; 2 === middle; 3 === right
						if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
							if ( button & 1 ) {
								return 1;
							}

							if ( button & 2 ) {
								return 3;
							}

							if ( button & 4 ) {
								return 2;
							}

							return 0;
						}

						return event.which;
					}
				}, jQuery.event.addProp );

				// Create mouseenter/leave events using mouseover/out and event-time checks
				// so that event delegation works in jQuery.
				// Do the same for pointerenter/pointerleave and pointerover/pointerout
				//
				// Support: Safari 7 only
				// Safari sends mouseenter too often; see:
				// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
				// for the description of the bug (it existed in older Chrome versions as well).
				jQuery.each( {
					mouseenter: "mouseover",
					mouseleave: "mouseout",
					pointerenter: "pointerover",
					pointerleave: "pointerout"
				}, function( orig, fix ) {
					jQuery.event.special[ orig ] = {
						delegateType: fix,
						bindType: fix,

						handle: function( event ) {
							var ret,
								target = this,
								related = event.relatedTarget,
								handleObj = event.handleObj;

							// For mouseenter/leave call the handler if related is outside the target.
							// NB: No relatedTarget if the mouse left/entered the browser window
							if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
								event.type = handleObj.origType;
								ret = handleObj.handler.apply( this, arguments );
								event.type = fix;
							}
							return ret;
						}
					};
				} );

				jQuery.fn.extend( {

					on: function( types, selector, data, fn ) {
						return on( this, types, selector, data, fn );
					},
					one: function( types, selector, data, fn ) {
						return on( this, types, selector, data, fn, 1 );
					},
					off: function( types, selector, fn ) {
						var handleObj, type;
						if ( types && types.preventDefault && types.handleObj ) {

							// ( event )  dispatched jQuery.Event
							handleObj = types.handleObj;
							jQuery( types.delegateTarget ).off(
								handleObj.namespace ?
									handleObj.origType + "." + handleObj.namespace :
									handleObj.origType,
								handleObj.selector,
								handleObj.handler
							);
							return this;
						}
						if ( typeof types === "object" ) {

							// ( types-object [, selector] )
							for ( type in types ) {
								this.off( type, selector, types[ type ] );
							}
							return this;
						}
						if ( selector === false || typeof selector === "function" ) {

							// ( types [, fn] )
							fn = selector;
							selector = undefined;
						}
						if ( fn === false ) {
							fn = returnFalse;
						}
						return this.each( function() {
							jQuery.event.remove( this, types, fn, selector );
						} );
					}
				} );


				var

					/* eslint-disable max-len */

					// See https://github.com/eslint/eslint/issues/3229
					rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

					/* eslint-enable */

					// Support: IE <=10 - 11, Edge 12 - 13
					// In IE/Edge using regex groups here causes severe slowdowns.
					// See https://connect.microsoft.com/IE/feedback/details/1736512/
					rnoInnerhtml = /<script|<style|<link/i,

					// checked="checked" or checked
					rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
					rscriptTypeMasked = /^true\/(.*)/,
					rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

				function manipulationTarget( elem, content ) {
					if ( jQuery.nodeName( elem, "table" ) &&
						jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

						return elem.getElementsByTagName( "tbody" )[ 0 ] || elem;
					}

					return elem;
				}

				// Replace/restore the type attribute of script elements for safe DOM manipulation
				function disableScript( elem ) {
					elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
					return elem;
				}
				function restoreScript( elem ) {
					var match = rscriptTypeMasked.exec( elem.type );

					if ( match ) {
						elem.type = match[ 1 ];
					} else {
						elem.removeAttribute( "type" );
					}

					return elem;
				}

				function cloneCopyEvent( src, dest ) {
					var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

					if ( dest.nodeType !== 1 ) {
						return;
					}

					// 1. Copy private data: events, handlers, etc.
					if ( dataPriv.hasData( src ) ) {
						pdataOld = dataPriv.access( src );
						pdataCur = dataPriv.set( dest, pdataOld );
						events = pdataOld.events;

						if ( events ) {
							delete pdataCur.handle;
							pdataCur.events = {};

							for ( type in events ) {
								for ( i = 0, l = events[ type ].length; i < l; i++ ) {
									jQuery.event.add( dest, type, events[ type ][ i ] );
								}
							}
						}
					}

					// 2. Copy user data
					if ( dataUser.hasData( src ) ) {
						udataOld = dataUser.access( src );
						udataCur = jQuery.extend( {}, udataOld );

						dataUser.set( dest, udataCur );
					}
				}

				// Fix IE bugs, see support tests
				function fixInput( src, dest ) {
					var nodeName = dest.nodeName.toLowerCase();

					// Fails to persist the checked state of a cloned checkbox or radio button.
					if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
						dest.checked = src.checked;

					// Fails to return the selected option to the default selected state when cloning options
					} else if ( nodeName === "input" || nodeName === "textarea" ) {
						dest.defaultValue = src.defaultValue;
					}
				}

				function domManip( collection, args, callback, ignored ) {

					// Flatten any nested arrays
					args = concat.apply( [], args );

					var fragment, first, scripts, hasScripts, node, doc,
						i = 0,
						l = collection.length,
						iNoClone = l - 1,
						value = args[ 0 ],
						isFunction = jQuery.isFunction( value );

					// We can't cloneNode fragments that contain checked, in WebKit
					if ( isFunction ||
							( l > 1 && typeof value === "string" &&
								!support.checkClone && rchecked.test( value ) ) ) {
						return collection.each( function( index ) {
							var self = collection.eq( index );
							if ( isFunction ) {
								args[ 0 ] = value.call( this, index, self.html() );
							}
							domManip( self, args, callback, ignored );
						} );
					}

					if ( l ) {
						fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
						first = fragment.firstChild;

						if ( fragment.childNodes.length === 1 ) {
							fragment = first;
						}

						// Require either new content or an interest in ignored elements to invoke the callback
						if ( first || ignored ) {
							scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
							hasScripts = scripts.length;

							// Use the original fragment for the last item
							// instead of the first because it can end up
							// being emptied incorrectly in certain situations (#8070).
							for ( ; i < l; i++ ) {
								node = fragment;

								if ( i !== iNoClone ) {
									node = jQuery.clone( node, true, true );

									// Keep references to cloned scripts for later restoration
									if ( hasScripts ) {

										// Support: Android <=4.0 only, PhantomJS 1 only
										// push.apply(_, arraylike) throws on ancient WebKit
										jQuery.merge( scripts, getAll( node, "script" ) );
									}
								}

								callback.call( collection[ i ], node, i );
							}

							if ( hasScripts ) {
								doc = scripts[ scripts.length - 1 ].ownerDocument;

								// Reenable scripts
								jQuery.map( scripts, restoreScript );

								// Evaluate executable scripts on first document insertion
								for ( i = 0; i < hasScripts; i++ ) {
									node = scripts[ i ];
									if ( rscriptType.test( node.type || "" ) &&
										!dataPriv.access( node, "globalEval" ) &&
										jQuery.contains( doc, node ) ) {

										if ( node.src ) {

											// Optional AJAX dependency, but won't run scripts if not present
											if ( jQuery._evalUrl ) {
												jQuery._evalUrl( node.src );
											}
										} else {
											DOMEval( node.textContent.replace( rcleanScript, "" ), doc );
										}
									}
								}
							}
						}
					}

					return collection;
				}

				function remove( elem, selector, keepData ) {
					var node,
						nodes = selector ? jQuery.filter( selector, elem ) : elem,
						i = 0;

					for ( ; ( node = nodes[ i ] ) != null; i++ ) {
						if ( !keepData && node.nodeType === 1 ) {
							jQuery.cleanData( getAll( node ) );
						}

						if ( node.parentNode ) {
							if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
								setGlobalEval( getAll( node, "script" ) );
							}
							node.parentNode.removeChild( node );
						}
					}

					return elem;
				}

				jQuery.extend( {
					htmlPrefilter: function( html ) {
						return html.replace( rxhtmlTag, "<$1></$2>" );
					},

					clone: function( elem, dataAndEvents, deepDataAndEvents ) {
						var i, l, srcElements, destElements,
							clone = elem.cloneNode( true ),
							inPage = jQuery.contains( elem.ownerDocument, elem );

						// Fix IE cloning issues
						if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
								!jQuery.isXMLDoc( elem ) ) {

							// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
							destElements = getAll( clone );
							srcElements = getAll( elem );

							for ( i = 0, l = srcElements.length; i < l; i++ ) {
								fixInput( srcElements[ i ], destElements[ i ] );
							}
						}

						// Copy the events from the original to the clone
						if ( dataAndEvents ) {
							if ( deepDataAndEvents ) {
								srcElements = srcElements || getAll( elem );
								destElements = destElements || getAll( clone );

								for ( i = 0, l = srcElements.length; i < l; i++ ) {
									cloneCopyEvent( srcElements[ i ], destElements[ i ] );
								}
							} else {
								cloneCopyEvent( elem, clone );
							}
						}

						// Preserve script evaluation history
						destElements = getAll( clone, "script" );
						if ( destElements.length > 0 ) {
							setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
						}

						// Return the cloned set
						return clone;
					},

					cleanData: function( elems ) {
						var data, elem, type,
							special = jQuery.event.special,
							i = 0;

						for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
							if ( acceptData( elem ) ) {
								if ( ( data = elem[ dataPriv.expando ] ) ) {
									if ( data.events ) {
										for ( type in data.events ) {
											if ( special[ type ] ) {
												jQuery.event.remove( elem, type );

											// This is a shortcut to avoid jQuery.event.remove's overhead
											} else {
												jQuery.removeEvent( elem, type, data.handle );
											}
										}
									}

									// Support: Chrome <=35 - 45+
									// Assign undefined instead of using delete, see Data#remove
									elem[ dataPriv.expando ] = undefined;
								}
								if ( elem[ dataUser.expando ] ) {

									// Support: Chrome <=35 - 45+
									// Assign undefined instead of using delete, see Data#remove
									elem[ dataUser.expando ] = undefined;
								}
							}
						}
					}
				} );

				jQuery.fn.extend( {
					detach: function( selector ) {
						return remove( this, selector, true );
					},

					remove: function( selector ) {
						return remove( this, selector );
					},

					text: function( value ) {
						return access( this, function( value ) {
							return value === undefined ?
								jQuery.text( this ) :
								this.empty().each( function() {
									if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
										this.textContent = value;
									}
								} );
						}, null, value, arguments.length );
					},

					append: function() {
						return domManip( this, arguments, function( elem ) {
							if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
								var target = manipulationTarget( this, elem );
								target.appendChild( elem );
							}
						} );
					},

					prepend: function() {
						return domManip( this, arguments, function( elem ) {
							if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
								var target = manipulationTarget( this, elem );
								target.insertBefore( elem, target.firstChild );
							}
						} );
					},

					before: function() {
						return domManip( this, arguments, function( elem ) {
							if ( this.parentNode ) {
								this.parentNode.insertBefore( elem, this );
							}
						} );
					},

					after: function() {
						return domManip( this, arguments, function( elem ) {
							if ( this.parentNode ) {
								this.parentNode.insertBefore( elem, this.nextSibling );
							}
						} );
					},

					empty: function() {
						var elem,
							i = 0;

						for ( ; ( elem = this[ i ] ) != null; i++ ) {
							if ( elem.nodeType === 1 ) {

								// Prevent memory leaks
								jQuery.cleanData( getAll( elem, false ) );

								// Remove any remaining nodes
								elem.textContent = "";
							}
						}

						return this;
					},

					clone: function( dataAndEvents, deepDataAndEvents ) {
						dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
						deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

						return this.map( function() {
							return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
						} );
					},

					html: function( value ) {
						return access( this, function( value ) {
							var elem = this[ 0 ] || {},
								i = 0,
								l = this.length;

							if ( value === undefined && elem.nodeType === 1 ) {
								return elem.innerHTML;
							}

							// See if we can take a shortcut and just use innerHTML
							if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
								!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

								value = jQuery.htmlPrefilter( value );

								try {
									for ( ; i < l; i++ ) {
										elem = this[ i ] || {};

										// Remove element nodes and prevent memory leaks
										if ( elem.nodeType === 1 ) {
											jQuery.cleanData( getAll( elem, false ) );
											elem.innerHTML = value;
										}
									}

									elem = 0;

								// If using innerHTML throws an exception, use the fallback method
								} catch ( e ) {}
							}

							if ( elem ) {
								this.empty().append( value );
							}
						}, null, value, arguments.length );
					},

					replaceWith: function() {
						var ignored = [];

						// Make the changes, replacing each non-ignored context element with the new content
						return domManip( this, arguments, function( elem ) {
							var parent = this.parentNode;

							if ( jQuery.inArray( this, ignored ) < 0 ) {
								jQuery.cleanData( getAll( this ) );
								if ( parent ) {
									parent.replaceChild( elem, this );
								}
							}

						// Force callback invocation
						}, ignored );
					}
				} );

				jQuery.each( {
					appendTo: "append",
					prependTo: "prepend",
					insertBefore: "before",
					insertAfter: "after",
					replaceAll: "replaceWith"
				}, function( name, original ) {
					jQuery.fn[ name ] = function( selector ) {
						var elems,
							ret = [],
							insert = jQuery( selector ),
							last = insert.length - 1,
							i = 0;

						for ( ; i <= last; i++ ) {
							elems = i === last ? this : this.clone( true );
							jQuery( insert[ i ] )[ original ]( elems );

							// Support: Android <=4.0 only, PhantomJS 1 only
							// .get() because push.apply(_, arraylike) throws on ancient WebKit
							push.apply( ret, elems.get() );
						}

						return this.pushStack( ret );
					};
				} );
				var rmargin = ( /^margin/ );

				var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

				var getStyles = function( elem ) {

						// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
						// IE throws on elements created in popups
						// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
						var view = elem.ownerDocument.defaultView;

						if ( !view || !view.opener ) {
							view = window;
						}

						return view.getComputedStyle( elem );
					};



				( function() {

					// Executing both pixelPosition & boxSizingReliable tests require only one layout
					// so they're executed at the same time to save the second computation.
					function computeStyleTests() {

						// This is a singleton, we need to execute it only once
						if ( !div ) {
							return;
						}

						div.style.cssText =
							"box-sizing:border-box;" +
							"position:relative;display:block;" +
							"margin:auto;border:1px;padding:1px;" +
							"top:1%;width:50%";
						div.innerHTML = "";
						documentElement.appendChild( container );

						var divStyle = window.getComputedStyle( div );
						pixelPositionVal = divStyle.top !== "1%";

						// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
						reliableMarginLeftVal = divStyle.marginLeft === "2px";
						boxSizingReliableVal = divStyle.width === "4px";

						// Support: Android 4.0 - 4.3 only
						// Some styles come back with percentage values, even though they shouldn't
						div.style.marginRight = "50%";
						pixelMarginRightVal = divStyle.marginRight === "4px";

						documentElement.removeChild( container );

						// Nullify the div so it wouldn't be stored in the memory and
						// it will also be a sign that checks already performed
						div = null;
					}

					var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,
						container = document.createElement( "div" ),
						div = document.createElement( "div" );

					// Finish early in limited (non-browser) environments
					if ( !div.style ) {
						return;
					}

					// Support: IE <=9 - 11 only
					// Style of cloned element affects source element cloned (#8908)
					div.style.backgroundClip = "content-box";
					div.cloneNode( true ).style.backgroundClip = "";
					support.clearCloneStyle = div.style.backgroundClip === "content-box";

					container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
						"padding:0;margin-top:1px;position:absolute";
					container.appendChild( div );

					jQuery.extend( support, {
						pixelPosition: function() {
							computeStyleTests();
							return pixelPositionVal;
						},
						boxSizingReliable: function() {
							computeStyleTests();
							return boxSizingReliableVal;
						},
						pixelMarginRight: function() {
							computeStyleTests();
							return pixelMarginRightVal;
						},
						reliableMarginLeft: function() {
							computeStyleTests();
							return reliableMarginLeftVal;
						}
					} );
				} )();


				function curCSS( elem, name, computed ) {
					var width, minWidth, maxWidth, ret,
						style = elem.style;

					computed = computed || getStyles( elem );

					// Support: IE <=9 only
					// getPropertyValue is only needed for .css('filter') (#12537)
					if ( computed ) {
						ret = computed.getPropertyValue( name ) || computed[ name ];

						if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
							ret = jQuery.style( elem, name );
						}

						// A tribute to the "awesome hack by Dean Edwards"
						// Android Browser returns percentage for some values,
						// but width seems to be reliably pixels.
						// This is against the CSSOM draft spec:
						// https://drafts.csswg.org/cssom/#resolved-values
						if ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {

							// Remember the original values
							width = style.width;
							minWidth = style.minWidth;
							maxWidth = style.maxWidth;

							// Put in the new values to get a computed value out
							style.minWidth = style.maxWidth = style.width = ret;
							ret = computed.width;

							// Revert the changed values
							style.width = width;
							style.minWidth = minWidth;
							style.maxWidth = maxWidth;
						}
					}

					return ret !== undefined ?

						// Support: IE <=9 - 11 only
						// IE returns zIndex value as an integer.
						ret + "" :
						ret;
				}


				function addGetHookIf( conditionFn, hookFn ) {

					// Define the hook, we'll check on the first run if it's really needed.
					return {
						get: function() {
							if ( conditionFn() ) {

								// Hook not needed (or it's not possible to use it due
								// to missing dependency), remove it.
								delete this.get;
								return;
							}

							// Hook needed; redefine it so that the support test is not executed again.
							return ( this.get = hookFn ).apply( this, arguments );
						}
					};
				}


				var

					// Swappable if display is none or starts with table
					// except "table", "table-cell", or "table-caption"
					// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
					rdisplayswap = /^(none|table(?!-c[ea]).+)/,
					cssShow = { position: "absolute", visibility: "hidden", display: "block" },
					cssNormalTransform = {
						letterSpacing: "0",
						fontWeight: "400"
					},

					cssPrefixes = [ "Webkit", "Moz", "ms" ],
					emptyStyle = document.createElement( "div" ).style;

				// Return a css property mapped to a potentially vendor prefixed property
				function vendorPropName( name ) {

					// Shortcut for names that are not vendor prefixed
					if ( name in emptyStyle ) {
						return name;
					}

					// Check for vendor prefixed names
					var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
						i = cssPrefixes.length;

					while ( i-- ) {
						name = cssPrefixes[ i ] + capName;
						if ( name in emptyStyle ) {
							return name;
						}
					}
				}

				function setPositiveNumber( elem, value, subtract ) {

					// Any relative (+/-) values have already been
					// normalized at this point
					var matches = rcssNum.exec( value );
					return matches ?

						// Guard against undefined "subtract", e.g., when used as in cssHooks
						Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
						value;
				}

				function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
					var i,
						val = 0;

					// If we already have the right measurement, avoid augmentation
					if ( extra === ( isBorderBox ? "border" : "content" ) ) {
						i = 4;

					// Otherwise initialize for horizontal or vertical properties
					} else {
						i = name === "width" ? 1 : 0;
					}

					for ( ; i < 4; i += 2 ) {

						// Both box models exclude margin, so add it if we want it
						if ( extra === "margin" ) {
							val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
						}

						if ( isBorderBox ) {

							// border-box includes padding, so remove it if we want content
							if ( extra === "content" ) {
								val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
							}

							// At this point, extra isn't border nor margin, so remove border
							if ( extra !== "margin" ) {
								val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
							}
						} else {

							// At this point, extra isn't content, so add padding
							val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

							// At this point, extra isn't content nor padding, so add border
							if ( extra !== "padding" ) {
								val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
							}
						}
					}

					return val;
				}

				function getWidthOrHeight( elem, name, extra ) {

					// Start with offset property, which is equivalent to the border-box value
					var val,
						valueIsBorderBox = true,
						styles = getStyles( elem ),
						isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					if ( elem.getClientRects().length ) {
						val = elem.getBoundingClientRect()[ name ];
					}

					// Some non-html elements return undefined for offsetWidth, so check for null/undefined
					// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
					// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
					if ( val <= 0 || val == null ) {

						// Fall back to computed then uncomputed css if necessary
						val = curCSS( elem, name, styles );
						if ( val < 0 || val == null ) {
							val = elem.style[ name ];
						}

						// Computed unit is not pixels. Stop here and return.
						if ( rnumnonpx.test( val ) ) {
							return val;
						}

						// Check for style in case a browser which returns unreliable values
						// for getComputedStyle silently falls back to the reliable elem.style
						valueIsBorderBox = isBorderBox &&
							( support.boxSizingReliable() || val === elem.style[ name ] );

						// Normalize "", auto, and prepare for extra
						val = parseFloat( val ) || 0;
					}

					// Use the active box-sizing model to add/subtract irrelevant styles
					return ( val +
						augmentWidthOrHeight(
							elem,
							name,
							extra || ( isBorderBox ? "border" : "content" ),
							valueIsBorderBox,
							styles
						)
					) + "px";
				}

				jQuery.extend( {

					// Add in style property hooks for overriding the default
					// behavior of getting and setting a style property
					cssHooks: {
						opacity: {
							get: function( elem, computed ) {
								if ( computed ) {

									// We should always get a number back from opacity
									var ret = curCSS( elem, "opacity" );
									return ret === "" ? "1" : ret;
								}
							}
						}
					},

					// Don't automatically add "px" to these possibly-unitless properties
					cssNumber: {
						"animationIterationCount": true,
						"columnCount": true,
						"fillOpacity": true,
						"flexGrow": true,
						"flexShrink": true,
						"fontWeight": true,
						"lineHeight": true,
						"opacity": true,
						"order": true,
						"orphans": true,
						"widows": true,
						"zIndex": true,
						"zoom": true
					},

					// Add in properties whose names you wish to fix before
					// setting or getting the value
					cssProps: {
						"float": "cssFloat"
					},

					// Get and set the style property on a DOM Node
					style: function( elem, name, value, extra ) {

						// Don't set styles on text and comment nodes
						if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
							return;
						}

						// Make sure that we're working with the right name
						var ret, type, hooks,
							origName = jQuery.camelCase( name ),
							style = elem.style;

						name = jQuery.cssProps[ origName ] ||
							( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

						// Gets hook for the prefixed version, then unprefixed version
						hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

						// Check if we're setting a value
						if ( value !== undefined ) {
							type = typeof value;

							// Convert "+=" or "-=" to relative numbers (#7345)
							if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
								value = adjustCSS( elem, name, ret );

								// Fixes bug #9237
								type = "number";
							}

							// Make sure that null and NaN values aren't set (#7116)
							if ( value == null || value !== value ) {
								return;
							}

							// If a number was passed in, add the unit (except for certain CSS properties)
							if ( type === "number" ) {
								value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
							}

							// background-* props affect original clone's values
							if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
								style[ name ] = "inherit";
							}

							// If a hook was provided, use that value, otherwise just set the specified value
							if ( !hooks || !( "set" in hooks ) ||
								( value = hooks.set( elem, value, extra ) ) !== undefined ) {

								style[ name ] = value;
							}

						} else {

							// If a hook was provided get the non-computed value from there
							if ( hooks && "get" in hooks &&
								( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

								return ret;
							}

							// Otherwise just get the value from the style object
							return style[ name ];
						}
					},

					css: function( elem, name, extra, styles ) {
						var val, num, hooks,
							origName = jQuery.camelCase( name );

						// Make sure that we're working with the right name
						name = jQuery.cssProps[ origName ] ||
							( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

						// Try prefixed name followed by the unprefixed name
						hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

						// If a hook was provided get the computed value from there
						if ( hooks && "get" in hooks ) {
							val = hooks.get( elem, true, extra );
						}

						// Otherwise, if a way to get the computed value exists, use that
						if ( val === undefined ) {
							val = curCSS( elem, name, styles );
						}

						// Convert "normal" to computed value
						if ( val === "normal" && name in cssNormalTransform ) {
							val = cssNormalTransform[ name ];
						}

						// Make numeric if forced or a qualifier was provided and val looks numeric
						if ( extra === "" || extra ) {
							num = parseFloat( val );
							return extra === true || isFinite( num ) ? num || 0 : val;
						}
						return val;
					}
				} );

				jQuery.each( [ "height", "width" ], function( i, name ) {
					jQuery.cssHooks[ name ] = {
						get: function( elem, computed, extra ) {
							if ( computed ) {

								// Certain elements can have dimension info if we invisibly show them
								// but it must have a current display style that would benefit
								return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

									// Support: Safari 8+
									// Table columns in Safari have non-zero offsetWidth & zero
									// getBoundingClientRect().width unless display is changed.
									// Support: IE <=11 only
									// Running getBoundingClientRect on a disconnected node
									// in IE throws an error.
									( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
										swap( elem, cssShow, function() {
											return getWidthOrHeight( elem, name, extra );
										} ) :
										getWidthOrHeight( elem, name, extra );
							}
						},

						set: function( elem, value, extra ) {
							var matches,
								styles = extra && getStyles( elem ),
								subtract = extra && augmentWidthOrHeight(
									elem,
									name,
									extra,
									jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
									styles
								);

							// Convert to pixels if value adjustment is needed
							if ( subtract && ( matches = rcssNum.exec( value ) ) &&
								( matches[ 3 ] || "px" ) !== "px" ) {

								elem.style[ name ] = value;
								value = jQuery.css( elem, name );
							}

							return setPositiveNumber( elem, value, subtract );
						}
					};
				} );

				jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
					function( elem, computed ) {
						if ( computed ) {
							return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
								elem.getBoundingClientRect().left -
									swap( elem, { marginLeft: 0 }, function() {
										return elem.getBoundingClientRect().left;
									} )
								) + "px";
						}
					}
				);

				// These hooks are used by animate to expand properties
				jQuery.each( {
					margin: "",
					padding: "",
					border: "Width"
				}, function( prefix, suffix ) {
					jQuery.cssHooks[ prefix + suffix ] = {
						expand: function( value ) {
							var i = 0,
								expanded = {},

								// Assumes a single number if not a string
								parts = typeof value === "string" ? value.split( " " ) : [ value ];

							for ( ; i < 4; i++ ) {
								expanded[ prefix + cssExpand[ i ] + suffix ] =
									parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
							}

							return expanded;
						}
					};

					if ( !rmargin.test( prefix ) ) {
						jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
					}
				} );

				jQuery.fn.extend( {
					css: function( name, value ) {
						return access( this, function( elem, name, value ) {
							var styles, len,
								map = {},
								i = 0;

							if ( jQuery.isArray( name ) ) {
								styles = getStyles( elem );
								len = name.length;

								for ( ; i < len; i++ ) {
									map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
								}

								return map;
							}

							return value !== undefined ?
								jQuery.style( elem, name, value ) :
								jQuery.css( elem, name );
						}, name, value, arguments.length > 1 );
					}
				} );


				function Tween( elem, options, prop, end, easing ) {
					return new Tween.prototype.init( elem, options, prop, end, easing );
				}
				jQuery.Tween = Tween;

				Tween.prototype = {
					constructor: Tween,
					init: function( elem, options, prop, end, easing, unit ) {
						this.elem = elem;
						this.prop = prop;
						this.easing = easing || jQuery.easing._default;
						this.options = options;
						this.start = this.now = this.cur();
						this.end = end;
						this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
					},
					cur: function() {
						var hooks = Tween.propHooks[ this.prop ];

						return hooks && hooks.get ?
							hooks.get( this ) :
							Tween.propHooks._default.get( this );
					},
					run: function( percent ) {
						var eased,
							hooks = Tween.propHooks[ this.prop ];

						if ( this.options.duration ) {
							this.pos = eased = jQuery.easing[ this.easing ](
								percent, this.options.duration * percent, 0, 1, this.options.duration
							);
						} else {
							this.pos = eased = percent;
						}
						this.now = ( this.end - this.start ) * eased + this.start;

						if ( this.options.step ) {
							this.options.step.call( this.elem, this.now, this );
						}

						if ( hooks && hooks.set ) {
							hooks.set( this );
						} else {
							Tween.propHooks._default.set( this );
						}
						return this;
					}
				};

				Tween.prototype.init.prototype = Tween.prototype;

				Tween.propHooks = {
					_default: {
						get: function( tween ) {
							var result;

							// Use a property on the element directly when it is not a DOM element,
							// or when there is no matching style property that exists.
							if ( tween.elem.nodeType !== 1 ||
								tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
								return tween.elem[ tween.prop ];
							}

							// Passing an empty string as a 3rd parameter to .css will automatically
							// attempt a parseFloat and fallback to a string if the parse fails.
							// Simple values such as "10px" are parsed to Float;
							// complex values such as "rotate(1rad)" are returned as-is.
							result = jQuery.css( tween.elem, tween.prop, "" );

							// Empty strings, null, undefined and "auto" are converted to 0.
							return !result || result === "auto" ? 0 : result;
						},
						set: function( tween ) {

							// Use step hook for back compat.
							// Use cssHook if its there.
							// Use .style if available and use plain properties where available.
							if ( jQuery.fx.step[ tween.prop ] ) {
								jQuery.fx.step[ tween.prop ]( tween );
							} else if ( tween.elem.nodeType === 1 &&
								( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
									jQuery.cssHooks[ tween.prop ] ) ) {
								jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
							} else {
								tween.elem[ tween.prop ] = tween.now;
							}
						}
					}
				};

				// Support: IE <=9 only
				// Panic based approach to setting things on disconnected nodes
				Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
					set: function( tween ) {
						if ( tween.elem.nodeType && tween.elem.parentNode ) {
							tween.elem[ tween.prop ] = tween.now;
						}
					}
				};

				jQuery.easing = {
					linear: function( p ) {
						return p;
					},
					swing: function( p ) {
						return 0.5 - Math.cos( p * Math.PI ) / 2;
					},
					_default: "swing"
				};

				jQuery.fx = Tween.prototype.init;

				// Back compat <1.8 extension point
				jQuery.fx.step = {};




				var
					fxNow, timerId,
					rfxtypes = /^(?:toggle|show|hide)$/,
					rrun = /queueHooks$/;

				function raf() {
					if ( timerId ) {
						window.requestAnimationFrame( raf );
						jQuery.fx.tick();
					}
				}

				// Animations created synchronously will run synchronously
				function createFxNow() {
					window.setTimeout( function() {
						fxNow = undefined;
					} );
					return ( fxNow = jQuery.now() );
				}

				// Generate parameters to create a standard animation
				function genFx( type, includeWidth ) {
					var which,
						i = 0,
						attrs = { height: type };

					// If we include width, step value is 1 to do all cssExpand values,
					// otherwise step value is 2 to skip over Left and Right
					includeWidth = includeWidth ? 1 : 0;
					for ( ; i < 4; i += 2 - includeWidth ) {
						which = cssExpand[ i ];
						attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
					}

					if ( includeWidth ) {
						attrs.opacity = attrs.width = type;
					}

					return attrs;
				}

				function createTween( value, prop, animation ) {
					var tween,
						collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
						index = 0,
						length = collection.length;
					for ( ; index < length; index++ ) {
						if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

							// We're done with this property
							return tween;
						}
					}
				}

				function defaultPrefilter( elem, props, opts ) {
					var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
						isBox = "width" in props || "height" in props,
						anim = this,
						orig = {},
						style = elem.style,
						hidden = elem.nodeType && isHiddenWithinTree( elem ),
						dataShow = dataPriv.get( elem, "fxshow" );

					// Queue-skipping animations hijack the fx hooks
					if ( !opts.queue ) {
						hooks = jQuery._queueHooks( elem, "fx" );
						if ( hooks.unqueued == null ) {
							hooks.unqueued = 0;
							oldfire = hooks.empty.fire;
							hooks.empty.fire = function() {
								if ( !hooks.unqueued ) {
									oldfire();
								}
							};
						}
						hooks.unqueued++;

						anim.always( function() {

							// Ensure the complete handler is called before this completes
							anim.always( function() {
								hooks.unqueued--;
								if ( !jQuery.queue( elem, "fx" ).length ) {
									hooks.empty.fire();
								}
							} );
						} );
					}

					// Detect show/hide animations
					for ( prop in props ) {
						value = props[ prop ];
						if ( rfxtypes.test( value ) ) {
							delete props[ prop ];
							toggle = toggle || value === "toggle";
							if ( value === ( hidden ? "hide" : "show" ) ) {

								// Pretend to be hidden if this is a "show" and
								// there is still data from a stopped show/hide
								if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
									hidden = true;

								// Ignore all other no-op show/hide data
								} else {
									continue;
								}
							}
							orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
						}
					}

					// Bail out if this is a no-op like .hide().hide()
					propTween = !jQuery.isEmptyObject( props );
					if ( !propTween && jQuery.isEmptyObject( orig ) ) {
						return;
					}

					// Restrict "overflow" and "display" styles during box animations
					if ( isBox && elem.nodeType === 1 ) {

						// Support: IE <=9 - 11, Edge 12 - 13
						// Record all 3 overflow attributes because IE does not infer the shorthand
						// from identically-valued overflowX and overflowY
						opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

						// Identify a display type, preferring old show/hide data over the CSS cascade
						restoreDisplay = dataShow && dataShow.display;
						if ( restoreDisplay == null ) {
							restoreDisplay = dataPriv.get( elem, "display" );
						}
						display = jQuery.css( elem, "display" );
						if ( display === "none" ) {
							if ( restoreDisplay ) {
								display = restoreDisplay;
							} else {

								// Get nonempty value(s) by temporarily forcing visibility
								showHide( [ elem ], true );
								restoreDisplay = elem.style.display || restoreDisplay;
								display = jQuery.css( elem, "display" );
								showHide( [ elem ] );
							}
						}

						// Animate inline elements as inline-block
						if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
							if ( jQuery.css( elem, "float" ) === "none" ) {

								// Restore the original display value at the end of pure show/hide animations
								if ( !propTween ) {
									anim.done( function() {
										style.display = restoreDisplay;
									} );
									if ( restoreDisplay == null ) {
										display = style.display;
										restoreDisplay = display === "none" ? "" : display;
									}
								}
								style.display = "inline-block";
							}
						}
					}

					if ( opts.overflow ) {
						style.overflow = "hidden";
						anim.always( function() {
							style.overflow = opts.overflow[ 0 ];
							style.overflowX = opts.overflow[ 1 ];
							style.overflowY = opts.overflow[ 2 ];
						} );
					}

					// Implement show/hide animations
					propTween = false;
					for ( prop in orig ) {

						// General show/hide setup for this element animation
						if ( !propTween ) {
							if ( dataShow ) {
								if ( "hidden" in dataShow ) {
									hidden = dataShow.hidden;
								}
							} else {
								dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
							}

							// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
							if ( toggle ) {
								dataShow.hidden = !hidden;
							}

							// Show elements before animating them
							if ( hidden ) {
								showHide( [ elem ], true );
							}

							/* eslint-disable no-loop-func */

							anim.done( function() {

							/* eslint-enable no-loop-func */

								// The final step of a "hide" animation is actually hiding the element
								if ( !hidden ) {
									showHide( [ elem ] );
								}
								dataPriv.remove( elem, "fxshow" );
								for ( prop in orig ) {
									jQuery.style( elem, prop, orig[ prop ] );
								}
							} );
						}

						// Per-property setup
						propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
						if ( !( prop in dataShow ) ) {
							dataShow[ prop ] = propTween.start;
							if ( hidden ) {
								propTween.end = propTween.start;
								propTween.start = 0;
							}
						}
					}
				}

				function propFilter( props, specialEasing ) {
					var index, name, easing, value, hooks;

					// camelCase, specialEasing and expand cssHook pass
					for ( index in props ) {
						name = jQuery.camelCase( index );
						easing = specialEasing[ name ];
						value = props[ index ];
						if ( jQuery.isArray( value ) ) {
							easing = value[ 1 ];
							value = props[ index ] = value[ 0 ];
						}

						if ( index !== name ) {
							props[ name ] = value;
							delete props[ index ];
						}

						hooks = jQuery.cssHooks[ name ];
						if ( hooks && "expand" in hooks ) {
							value = hooks.expand( value );
							delete props[ name ];

							// Not quite $.extend, this won't overwrite existing keys.
							// Reusing 'index' because we have the correct "name"
							for ( index in value ) {
								if ( !( index in props ) ) {
									props[ index ] = value[ index ];
									specialEasing[ index ] = easing;
								}
							}
						} else {
							specialEasing[ name ] = easing;
						}
					}
				}

				function Animation( elem, properties, options ) {
					var result,
						stopped,
						index = 0,
						length = Animation.prefilters.length,
						deferred = jQuery.Deferred().always( function() {

							// Don't match elem in the :animated selector
							delete tick.elem;
						} ),
						tick = function() {
							if ( stopped ) {
								return false;
							}
							var currentTime = fxNow || createFxNow(),
								remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

								// Support: Android 2.3 only
								// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
								temp = remaining / animation.duration || 0,
								percent = 1 - temp,
								index = 0,
								length = animation.tweens.length;

							for ( ; index < length; index++ ) {
								animation.tweens[ index ].run( percent );
							}

							deferred.notifyWith( elem, [ animation, percent, remaining ] );

							if ( percent < 1 && length ) {
								return remaining;
							} else {
								deferred.resolveWith( elem, [ animation ] );
								return false;
							}
						},
						animation = deferred.promise( {
							elem: elem,
							props: jQuery.extend( {}, properties ),
							opts: jQuery.extend( true, {
								specialEasing: {},
								easing: jQuery.easing._default
							}, options ),
							originalProperties: properties,
							originalOptions: options,
							startTime: fxNow || createFxNow(),
							duration: options.duration,
							tweens: [],
							createTween: function( prop, end ) {
								var tween = jQuery.Tween( elem, animation.opts, prop, end,
										animation.opts.specialEasing[ prop ] || animation.opts.easing );
								animation.tweens.push( tween );
								return tween;
							},
							stop: function( gotoEnd ) {
								var index = 0,

									// If we are going to the end, we want to run all the tweens
									// otherwise we skip this part
									length = gotoEnd ? animation.tweens.length : 0;
								if ( stopped ) {
									return this;
								}
								stopped = true;
								for ( ; index < length; index++ ) {
									animation.tweens[ index ].run( 1 );
								}

								// Resolve when we played the last frame; otherwise, reject
								if ( gotoEnd ) {
									deferred.notifyWith( elem, [ animation, 1, 0 ] );
									deferred.resolveWith( elem, [ animation, gotoEnd ] );
								} else {
									deferred.rejectWith( elem, [ animation, gotoEnd ] );
								}
								return this;
							}
						} ),
						props = animation.props;

					propFilter( props, animation.opts.specialEasing );

					for ( ; index < length; index++ ) {
						result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
						if ( result ) {
							if ( jQuery.isFunction( result.stop ) ) {
								jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
									jQuery.proxy( result.stop, result );
							}
							return result;
						}
					}

					jQuery.map( props, createTween, animation );

					if ( jQuery.isFunction( animation.opts.start ) ) {
						animation.opts.start.call( elem, animation );
					}

					jQuery.fx.timer(
						jQuery.extend( tick, {
							elem: elem,
							anim: animation,
							queue: animation.opts.queue
						} )
					);

					// attach callbacks from options
					return animation.progress( animation.opts.progress )
						.done( animation.opts.done, animation.opts.complete )
						.fail( animation.opts.fail )
						.always( animation.opts.always );
				}

				jQuery.Animation = jQuery.extend( Animation, {

					tweeners: {
						"*": [ function( prop, value ) {
							var tween = this.createTween( prop, value );
							adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
							return tween;
						} ]
					},

					tweener: function( props, callback ) {
						if ( jQuery.isFunction( props ) ) {
							callback = props;
							props = [ "*" ];
						} else {
							props = props.match( rnothtmlwhite );
						}

						var prop,
							index = 0,
							length = props.length;

						for ( ; index < length; index++ ) {
							prop = props[ index ];
							Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
							Animation.tweeners[ prop ].unshift( callback );
						}
					},

					prefilters: [ defaultPrefilter ],

					prefilter: function( callback, prepend ) {
						if ( prepend ) {
							Animation.prefilters.unshift( callback );
						} else {
							Animation.prefilters.push( callback );
						}
					}
				} );

				jQuery.speed = function( speed, easing, fn ) {
					var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
						complete: fn || !fn && easing ||
							jQuery.isFunction( speed ) && speed,
						duration: speed,
						easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
					};

					// Go to the end state if fx are off or if document is hidden
					if ( jQuery.fx.off || document.hidden ) {
						opt.duration = 0;

					} else {
						if ( typeof opt.duration !== "number" ) {
							if ( opt.duration in jQuery.fx.speeds ) {
								opt.duration = jQuery.fx.speeds[ opt.duration ];

							} else {
								opt.duration = jQuery.fx.speeds._default;
							}
						}
					}

					// Normalize opt.queue - true/undefined/null -> "fx"
					if ( opt.queue == null || opt.queue === true ) {
						opt.queue = "fx";
					}

					// Queueing
					opt.old = opt.complete;

					opt.complete = function() {
						if ( jQuery.isFunction( opt.old ) ) {
							opt.old.call( this );
						}

						if ( opt.queue ) {
							jQuery.dequeue( this, opt.queue );
						}
					};

					return opt;
				};

				jQuery.fn.extend( {
					fadeTo: function( speed, to, easing, callback ) {

						// Show any hidden elements after setting opacity to 0
						return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

							// Animate to the value specified
							.end().animate( { opacity: to }, speed, easing, callback );
					},
					animate: function( prop, speed, easing, callback ) {
						var empty = jQuery.isEmptyObject( prop ),
							optall = jQuery.speed( speed, easing, callback ),
							doAnimation = function() {

								// Operate on a copy of prop so per-property easing won't be lost
								var anim = Animation( this, jQuery.extend( {}, prop ), optall );

								// Empty animations, or finishing resolves immediately
								if ( empty || dataPriv.get( this, "finish" ) ) {
									anim.stop( true );
								}
							};
							doAnimation.finish = doAnimation;

						return empty || optall.queue === false ?
							this.each( doAnimation ) :
							this.queue( optall.queue, doAnimation );
					},
					stop: function( type, clearQueue, gotoEnd ) {
						var stopQueue = function( hooks ) {
							var stop = hooks.stop;
							delete hooks.stop;
							stop( gotoEnd );
						};

						if ( typeof type !== "string" ) {
							gotoEnd = clearQueue;
							clearQueue = type;
							type = undefined;
						}
						if ( clearQueue && type !== false ) {
							this.queue( type || "fx", [] );
						}

						return this.each( function() {
							var dequeue = true,
								index = type != null && type + "queueHooks",
								timers = jQuery.timers,
								data = dataPriv.get( this );

							if ( index ) {
								if ( data[ index ] && data[ index ].stop ) {
									stopQueue( data[ index ] );
								}
							} else {
								for ( index in data ) {
									if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
										stopQueue( data[ index ] );
									}
								}
							}

							for ( index = timers.length; index--; ) {
								if ( timers[ index ].elem === this &&
									( type == null || timers[ index ].queue === type ) ) {

									timers[ index ].anim.stop( gotoEnd );
									dequeue = false;
									timers.splice( index, 1 );
								}
							}

							// Start the next in the queue if the last step wasn't forced.
							// Timers currently will call their complete callbacks, which
							// will dequeue but only if they were gotoEnd.
							if ( dequeue || !gotoEnd ) {
								jQuery.dequeue( this, type );
							}
						} );
					},
					finish: function( type ) {
						if ( type !== false ) {
							type = type || "fx";
						}
						return this.each( function() {
							var index,
								data = dataPriv.get( this ),
								queue = data[ type + "queue" ],
								hooks = data[ type + "queueHooks" ],
								timers = jQuery.timers,
								length = queue ? queue.length : 0;

							// Enable finishing flag on private data
							data.finish = true;

							// Empty the queue first
							jQuery.queue( this, type, [] );

							if ( hooks && hooks.stop ) {
								hooks.stop.call( this, true );
							}

							// Look for any active animations, and finish them
							for ( index = timers.length; index--; ) {
								if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
									timers[ index ].anim.stop( true );
									timers.splice( index, 1 );
								}
							}

							// Look for any animations in the old queue and finish them
							for ( index = 0; index < length; index++ ) {
								if ( queue[ index ] && queue[ index ].finish ) {
									queue[ index ].finish.call( this );
								}
							}

							// Turn off finishing flag
							delete data.finish;
						} );
					}
				} );

				jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
					var cssFn = jQuery.fn[ name ];
					jQuery.fn[ name ] = function( speed, easing, callback ) {
						return speed == null || typeof speed === "boolean" ?
							cssFn.apply( this, arguments ) :
							this.animate( genFx( name, true ), speed, easing, callback );
					};
				} );

				// Generate shortcuts for custom animations
				jQuery.each( {
					slideDown: genFx( "show" ),
					slideUp: genFx( "hide" ),
					slideToggle: genFx( "toggle" ),
					fadeIn: { opacity: "show" },
					fadeOut: { opacity: "hide" },
					fadeToggle: { opacity: "toggle" }
				}, function( name, props ) {
					jQuery.fn[ name ] = function( speed, easing, callback ) {
						return this.animate( props, speed, easing, callback );
					};
				} );

				jQuery.timers = [];
				jQuery.fx.tick = function() {
					var timer,
						i = 0,
						timers = jQuery.timers;

					fxNow = jQuery.now();

					for ( ; i < timers.length; i++ ) {
						timer = timers[ i ];

						// Checks the timer has not already been removed
						if ( !timer() && timers[ i ] === timer ) {
							timers.splice( i--, 1 );
						}
					}

					if ( !timers.length ) {
						jQuery.fx.stop();
					}
					fxNow = undefined;
				};

				jQuery.fx.timer = function( timer ) {
					jQuery.timers.push( timer );
					if ( timer() ) {
						jQuery.fx.start();
					} else {
						jQuery.timers.pop();
					}
				};

				jQuery.fx.interval = 13;
				jQuery.fx.start = function() {
					if ( !timerId ) {
						timerId = window.requestAnimationFrame ?
							window.requestAnimationFrame( raf ) :
							window.setInterval( jQuery.fx.tick, jQuery.fx.interval );
					}
				};

				jQuery.fx.stop = function() {
					if ( window.cancelAnimationFrame ) {
						window.cancelAnimationFrame( timerId );
					} else {
						window.clearInterval( timerId );
					}

					timerId = null;
				};

				jQuery.fx.speeds = {
					slow: 600,
					fast: 200,

					// Default speed
					_default: 400
				};


				// Based off of the plugin by Clint Helfers, with permission.
				// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
				jQuery.fn.delay = function( time, type ) {
					time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
					type = type || "fx";

					return this.queue( type, function( next, hooks ) {
						var timeout = window.setTimeout( next, time );
						hooks.stop = function() {
							window.clearTimeout( timeout );
						};
					} );
				};


				( function() {
					var input = document.createElement( "input" ),
						select = document.createElement( "select" ),
						opt = select.appendChild( document.createElement( "option" ) );

					input.type = "checkbox";

					// Support: Android <=4.3 only
					// Default value for a checkbox should be "on"
					support.checkOn = input.value !== "";

					// Support: IE <=11 only
					// Must access selectedIndex to make default options select
					support.optSelected = opt.selected;

					// Support: IE <=11 only
					// An input loses its value after becoming a radio
					input = document.createElement( "input" );
					input.value = "t";
					input.type = "radio";
					support.radioValue = input.value === "t";
				} )();


				var boolHook,
					attrHandle = jQuery.expr.attrHandle;

				jQuery.fn.extend( {
					attr: function( name, value ) {
						return access( this, jQuery.attr, name, value, arguments.length > 1 );
					},

					removeAttr: function( name ) {
						return this.each( function() {
							jQuery.removeAttr( this, name );
						} );
					}
				} );

				jQuery.extend( {
					attr: function( elem, name, value ) {
						var ret, hooks,
							nType = elem.nodeType;

						// Don't get/set attributes on text, comment and attribute nodes
						if ( nType === 3 || nType === 8 || nType === 2 ) {
							return;
						}

						// Fallback to prop when attributes are not supported
						if ( typeof elem.getAttribute === "undefined" ) {
							return jQuery.prop( elem, name, value );
						}

						// Attribute hooks are determined by the lowercase version
						// Grab necessary hook if one is defined
						if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
							hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
								( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
						}

						if ( value !== undefined ) {
							if ( value === null ) {
								jQuery.removeAttr( elem, name );
								return;
							}

							if ( hooks && "set" in hooks &&
								( ret = hooks.set( elem, value, name ) ) !== undefined ) {
								return ret;
							}

							elem.setAttribute( name, value + "" );
							return value;
						}

						if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
							return ret;
						}

						ret = jQuery.find.attr( elem, name );

						// Non-existent attributes return null, we normalize to undefined
						return ret == null ? undefined : ret;
					},

					attrHooks: {
						type: {
							set: function( elem, value ) {
								if ( !support.radioValue && value === "radio" &&
									jQuery.nodeName( elem, "input" ) ) {
									var val = elem.value;
									elem.setAttribute( "type", value );
									if ( val ) {
										elem.value = val;
									}
									return value;
								}
							}
						}
					},

					removeAttr: function( elem, value ) {
						var name,
							i = 0,

							// Attribute names can contain non-HTML whitespace characters
							// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
							attrNames = value && value.match( rnothtmlwhite );

						if ( attrNames && elem.nodeType === 1 ) {
							while ( ( name = attrNames[ i++ ] ) ) {
								elem.removeAttribute( name );
							}
						}
					}
				} );

				// Hooks for boolean attributes
				boolHook = {
					set: function( elem, value, name ) {
						if ( value === false ) {

							// Remove boolean attributes when set to false
							jQuery.removeAttr( elem, name );
						} else {
							elem.setAttribute( name, name );
						}
						return name;
					}
				};

				jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
					var getter = attrHandle[ name ] || jQuery.find.attr;

					attrHandle[ name ] = function( elem, name, isXML ) {
						var ret, handle,
							lowercaseName = name.toLowerCase();

						if ( !isXML ) {

							// Avoid an infinite loop by temporarily removing this function from the getter
							handle = attrHandle[ lowercaseName ];
							attrHandle[ lowercaseName ] = ret;
							ret = getter( elem, name, isXML ) != null ?
								lowercaseName :
								null;
							attrHandle[ lowercaseName ] = handle;
						}
						return ret;
					};
				} );




				var rfocusable = /^(?:input|select|textarea|button)$/i,
					rclickable = /^(?:a|area)$/i;

				jQuery.fn.extend( {
					prop: function( name, value ) {
						return access( this, jQuery.prop, name, value, arguments.length > 1 );
					},

					removeProp: function( name ) {
						return this.each( function() {
							delete this[ jQuery.propFix[ name ] || name ];
						} );
					}
				} );

				jQuery.extend( {
					prop: function( elem, name, value ) {
						var ret, hooks,
							nType = elem.nodeType;

						// Don't get/set properties on text, comment and attribute nodes
						if ( nType === 3 || nType === 8 || nType === 2 ) {
							return;
						}

						if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

							// Fix name and attach hooks
							name = jQuery.propFix[ name ] || name;
							hooks = jQuery.propHooks[ name ];
						}

						if ( value !== undefined ) {
							if ( hooks && "set" in hooks &&
								( ret = hooks.set( elem, value, name ) ) !== undefined ) {
								return ret;
							}

							return ( elem[ name ] = value );
						}

						if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
							return ret;
						}

						return elem[ name ];
					},

					propHooks: {
						tabIndex: {
							get: function( elem ) {

								// Support: IE <=9 - 11 only
								// elem.tabIndex doesn't always return the
								// correct value when it hasn't been explicitly set
								// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
								// Use proper attribute retrieval(#12072)
								var tabindex = jQuery.find.attr( elem, "tabindex" );

								if ( tabindex ) {
									return parseInt( tabindex, 10 );
								}

								if (
									rfocusable.test( elem.nodeName ) ||
									rclickable.test( elem.nodeName ) &&
									elem.href
								) {
									return 0;
								}

								return -1;
							}
						}
					},

					propFix: {
						"for": "htmlFor",
						"class": "className"
					}
				} );

				// Support: IE <=11 only
				// Accessing the selectedIndex property
				// forces the browser to respect setting selected
				// on the option
				// The getter ensures a default option is selected
				// when in an optgroup
				// eslint rule "no-unused-expressions" is disabled for this code
				// since it considers such accessions noop
				if ( !support.optSelected ) {
					jQuery.propHooks.selected = {
						get: function( elem ) {

							/* eslint no-unused-expressions: "off" */

							var parent = elem.parentNode;
							if ( parent && parent.parentNode ) {
								parent.parentNode.selectedIndex;
							}
							return null;
						},
						set: function( elem ) {

							/* eslint no-unused-expressions: "off" */

							var parent = elem.parentNode;
							if ( parent ) {
								parent.selectedIndex;

								if ( parent.parentNode ) {
									parent.parentNode.selectedIndex;
								}
							}
						}
					};
				}

				jQuery.each( [
					"tabIndex",
					"readOnly",
					"maxLength",
					"cellSpacing",
					"cellPadding",
					"rowSpan",
					"colSpan",
					"useMap",
					"frameBorder",
					"contentEditable"
				], function() {
					jQuery.propFix[ this.toLowerCase() ] = this;
				} );




					// Strip and collapse whitespace according to HTML spec
					// https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace
					function stripAndCollapse( value ) {
						var tokens = value.match( rnothtmlwhite ) || [];
						return tokens.join( " " );
					}


				function getClass( elem ) {
					return elem.getAttribute && elem.getAttribute( "class" ) || "";
				}

				jQuery.fn.extend( {
					addClass: function( value ) {
						var classes, elem, cur, curValue, clazz, j, finalValue,
							i = 0;

						if ( jQuery.isFunction( value ) ) {
							return this.each( function( j ) {
								jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
							} );
						}

						if ( typeof value === "string" && value ) {
							classes = value.match( rnothtmlwhite ) || [];

							while ( ( elem = this[ i++ ] ) ) {
								curValue = getClass( elem );
								cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

								if ( cur ) {
									j = 0;
									while ( ( clazz = classes[ j++ ] ) ) {
										if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
											cur += clazz + " ";
										}
									}

									// Only assign if different to avoid unneeded rendering.
									finalValue = stripAndCollapse( cur );
									if ( curValue !== finalValue ) {
										elem.setAttribute( "class", finalValue );
									}
								}
							}
						}

						return this;
					},

					removeClass: function( value ) {
						var classes, elem, cur, curValue, clazz, j, finalValue,
							i = 0;

						if ( jQuery.isFunction( value ) ) {
							return this.each( function( j ) {
								jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
							} );
						}

						if ( !arguments.length ) {
							return this.attr( "class", "" );
						}

						if ( typeof value === "string" && value ) {
							classes = value.match( rnothtmlwhite ) || [];

							while ( ( elem = this[ i++ ] ) ) {
								curValue = getClass( elem );

								// This expression is here for better compressibility (see addClass)
								cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

								if ( cur ) {
									j = 0;
									while ( ( clazz = classes[ j++ ] ) ) {

										// Remove *all* instances
										while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
											cur = cur.replace( " " + clazz + " ", " " );
										}
									}

									// Only assign if different to avoid unneeded rendering.
									finalValue = stripAndCollapse( cur );
									if ( curValue !== finalValue ) {
										elem.setAttribute( "class", finalValue );
									}
								}
							}
						}

						return this;
					},

					toggleClass: function( value, stateVal ) {
						var type = typeof value;

						if ( typeof stateVal === "boolean" && type === "string" ) {
							return stateVal ? this.addClass( value ) : this.removeClass( value );
						}

						if ( jQuery.isFunction( value ) ) {
							return this.each( function( i ) {
								jQuery( this ).toggleClass(
									value.call( this, i, getClass( this ), stateVal ),
									stateVal
								);
							} );
						}

						return this.each( function() {
							var className, i, self, classNames;

							if ( type === "string" ) {

								// Toggle individual class names
								i = 0;
								self = jQuery( this );
								classNames = value.match( rnothtmlwhite ) || [];

								while ( ( className = classNames[ i++ ] ) ) {

									// Check each className given, space separated list
									if ( self.hasClass( className ) ) {
										self.removeClass( className );
									} else {
										self.addClass( className );
									}
								}

							// Toggle whole class name
							} else if ( value === undefined || type === "boolean" ) {
								className = getClass( this );
								if ( className ) {

									// Store className if set
									dataPriv.set( this, "__className__", className );
								}

								// If the element has a class name or if we're passed `false`,
								// then remove the whole classname (if there was one, the above saved it).
								// Otherwise bring back whatever was previously saved (if anything),
								// falling back to the empty string if nothing was stored.
								if ( this.setAttribute ) {
									this.setAttribute( "class",
										className || value === false ?
										"" :
										dataPriv.get( this, "__className__" ) || ""
									);
								}
							}
						} );
					},

					hasClass: function( selector ) {
						var className, elem,
							i = 0;

						className = " " + selector + " ";
						while ( ( elem = this[ i++ ] ) ) {
							if ( elem.nodeType === 1 &&
								( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
									return true;
							}
						}

						return false;
					}
				} );




				var rreturn = /\r/g;

				jQuery.fn.extend( {
					val: function( value ) {
						var hooks, ret, isFunction,
							elem = this[ 0 ];

						if ( !arguments.length ) {
							if ( elem ) {
								hooks = jQuery.valHooks[ elem.type ] ||
									jQuery.valHooks[ elem.nodeName.toLowerCase() ];

								if ( hooks &&
									"get" in hooks &&
									( ret = hooks.get( elem, "value" ) ) !== undefined
								) {
									return ret;
								}

								ret = elem.value;

								// Handle most common string cases
								if ( typeof ret === "string" ) {
									return ret.replace( rreturn, "" );
								}

								// Handle cases where value is null/undef or number
								return ret == null ? "" : ret;
							}

							return;
						}

						isFunction = jQuery.isFunction( value );

						return this.each( function( i ) {
							var val;

							if ( this.nodeType !== 1 ) {
								return;
							}

							if ( isFunction ) {
								val = value.call( this, i, jQuery( this ).val() );
							} else {
								val = value;
							}

							// Treat null/undefined as ""; convert numbers to string
							if ( val == null ) {
								val = "";

							} else if ( typeof val === "number" ) {
								val += "";

							} else if ( jQuery.isArray( val ) ) {
								val = jQuery.map( val, function( value ) {
									return value == null ? "" : value + "";
								} );
							}

							hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

							// If set returns undefined, fall back to normal setting
							if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
								this.value = val;
							}
						} );
					}
				} );

				jQuery.extend( {
					valHooks: {
						option: {
							get: function( elem ) {

								var val = jQuery.find.attr( elem, "value" );
								return val != null ?
									val :

									// Support: IE <=10 - 11 only
									// option.text throws exceptions (#14686, #14858)
									// Strip and collapse whitespace
									// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
									stripAndCollapse( jQuery.text( elem ) );
							}
						},
						select: {
							get: function( elem ) {
								var value, option, i,
									options = elem.options,
									index = elem.selectedIndex,
									one = elem.type === "select-one",
									values = one ? null : [],
									max = one ? index + 1 : options.length;

								if ( index < 0 ) {
									i = max;

								} else {
									i = one ? index : 0;
								}

								// Loop through all the selected options
								for ( ; i < max; i++ ) {
									option = options[ i ];

									// Support: IE <=9 only
									// IE8-9 doesn't update selected after form reset (#2551)
									if ( ( option.selected || i === index ) &&

											// Don't return options that are disabled or in a disabled optgroup
											!option.disabled &&
											( !option.parentNode.disabled ||
												!jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

										// Get the specific value for the option
										value = jQuery( option ).val();

										// We don't need an array for one selects
										if ( one ) {
											return value;
										}

										// Multi-Selects return an array
										values.push( value );
									}
								}

								return values;
							},

							set: function( elem, value ) {
								var optionSet, option,
									options = elem.options,
									values = jQuery.makeArray( value ),
									i = options.length;

								while ( i-- ) {
									option = options[ i ];

									/* eslint-disable no-cond-assign */

									if ( option.selected =
										jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
									) {
										optionSet = true;
									}

									/* eslint-enable no-cond-assign */
								}

								// Force browsers to behave consistently when non-matching value is set
								if ( !optionSet ) {
									elem.selectedIndex = -1;
								}
								return values;
							}
						}
					}
				} );

				// Radios and checkboxes getter/setter
				jQuery.each( [ "radio", "checkbox" ], function() {
					jQuery.valHooks[ this ] = {
						set: function( elem, value ) {
							if ( jQuery.isArray( value ) ) {
								return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
							}
						}
					};
					if ( !support.checkOn ) {
						jQuery.valHooks[ this ].get = function( elem ) {
							return elem.getAttribute( "value" ) === null ? "on" : elem.value;
						};
					}
				} );




				// Return jQuery for attributes-only inclusion


				var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;

				jQuery.extend( jQuery.event, {

					trigger: function( event, data, elem, onlyHandlers ) {

						var i, cur, tmp, bubbleType, ontype, handle, special,
							eventPath = [ elem || document ],
							type = hasOwn.call( event, "type" ) ? event.type : event,
							namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

						cur = tmp = elem = elem || document;

						// Don't do events on text and comment nodes
						if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
							return;
						}

						// focus/blur morphs to focusin/out; ensure we're not firing them right now
						if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
							return;
						}

						if ( type.indexOf( "." ) > -1 ) {

							// Namespaced trigger; create a regexp to match event type in handle()
							namespaces = type.split( "." );
							type = namespaces.shift();
							namespaces.sort();
						}
						ontype = type.indexOf( ":" ) < 0 && "on" + type;

						// Caller can pass in a jQuery.Event object, Object, or just an event type string
						event = event[ jQuery.expando ] ?
							event :
							new jQuery.Event( type, typeof event === "object" && event );

						// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
						event.isTrigger = onlyHandlers ? 2 : 3;
						event.namespace = namespaces.join( "." );
						event.rnamespace = event.namespace ?
							new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
							null;

						// Clean up the event in case it is being reused
						event.result = undefined;
						if ( !event.target ) {
							event.target = elem;
						}

						// Clone any incoming data and prepend the event, creating the handler arg list
						data = data == null ?
							[ event ] :
							jQuery.makeArray( data, [ event ] );

						// Allow special events to draw outside the lines
						special = jQuery.event.special[ type ] || {};
						if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
							return;
						}

						// Determine event propagation path in advance, per W3C events spec (#9951)
						// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
						if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

							bubbleType = special.delegateType || type;
							if ( !rfocusMorph.test( bubbleType + type ) ) {
								cur = cur.parentNode;
							}
							for ( ; cur; cur = cur.parentNode ) {
								eventPath.push( cur );
								tmp = cur;
							}

							// Only add window if we got to document (e.g., not plain obj or detached DOM)
							if ( tmp === ( elem.ownerDocument || document ) ) {
								eventPath.push( tmp.defaultView || tmp.parentWindow || window );
							}
						}

						// Fire handlers on the event path
						i = 0;
						while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {

							event.type = i > 1 ?
								bubbleType :
								special.bindType || type;

							// jQuery handler
							handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
								dataPriv.get( cur, "handle" );
							if ( handle ) {
								handle.apply( cur, data );
							}

							// Native handler
							handle = ontype && cur[ ontype ];
							if ( handle && handle.apply && acceptData( cur ) ) {
								event.result = handle.apply( cur, data );
								if ( event.result === false ) {
									event.preventDefault();
								}
							}
						}
						event.type = type;

						// If nobody prevented the default action, do it now
						if ( !onlyHandlers && !event.isDefaultPrevented() ) {

							if ( ( !special._default ||
								special._default.apply( eventPath.pop(), data ) === false ) &&
								acceptData( elem ) ) {

								// Call a native DOM method on the target with the same name as the event.
								// Don't do default actions on window, that's where global variables be (#6170)
								if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

									// Don't re-trigger an onFOO event when we call its FOO() method
									tmp = elem[ ontype ];

									if ( tmp ) {
										elem[ ontype ] = null;
									}

									// Prevent re-triggering of the same event, since we already bubbled it above
									jQuery.event.triggered = type;
									elem[ type ]();
									jQuery.event.triggered = undefined;

									if ( tmp ) {
										elem[ ontype ] = tmp;
									}
								}
							}
						}

						return event.result;
					},

					// Piggyback on a donor event to simulate a different one
					// Used only for `focus(in | out)` events
					simulate: function( type, elem, event ) {
						var e = jQuery.extend(
							new jQuery.Event(),
							event,
							{
								type: type,
								isSimulated: true
							}
						);

						jQuery.event.trigger( e, null, elem );
					}

				} );

				jQuery.fn.extend( {

					trigger: function( type, data ) {
						return this.each( function() {
							jQuery.event.trigger( type, data, this );
						} );
					},
					triggerHandler: function( type, data ) {
						var elem = this[ 0 ];
						if ( elem ) {
							return jQuery.event.trigger( type, data, elem, true );
						}
					}
				} );


				jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
					"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
					"change select submit keydown keypress keyup contextmenu" ).split( " " ),
					function( i, name ) {

					// Handle event binding
					jQuery.fn[ name ] = function( data, fn ) {
						return arguments.length > 0 ?
							this.on( name, null, data, fn ) :
							this.trigger( name );
					};
				} );

				jQuery.fn.extend( {
					hover: function( fnOver, fnOut ) {
						return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
					}
				} );




				support.focusin = "onfocusin" in window;


				// Support: Firefox <=44
				// Firefox doesn't have focus(in | out) events
				// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
				//
				// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
				// focus(in | out) events fire after focus & blur events,
				// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
				// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
				if ( !support.focusin ) {
					jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

						// Attach a single capturing handler on the document while someone wants focusin/focusout
						var handler = function( event ) {
							jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
						};

						jQuery.event.special[ fix ] = {
							setup: function() {
								var doc = this.ownerDocument || this,
									attaches = dataPriv.access( doc, fix );

								if ( !attaches ) {
									doc.addEventListener( orig, handler, true );
								}
								dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
							},
							teardown: function() {
								var doc = this.ownerDocument || this,
									attaches = dataPriv.access( doc, fix ) - 1;

								if ( !attaches ) {
									doc.removeEventListener( orig, handler, true );
									dataPriv.remove( doc, fix );

								} else {
									dataPriv.access( doc, fix, attaches );
								}
							}
						};
					} );
				}
				var location = window.location;

				var nonce = jQuery.now();

				var rquery = ( /\?/ );



				// Cross-browser xml parsing
				jQuery.parseXML = function( data ) {
					var xml;
					if ( !data || typeof data !== "string" ) {
						return null;
					}

					// Support: IE 9 - 11 only
					// IE throws on parseFromString with invalid input.
					try {
						xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
					} catch ( e ) {
						xml = undefined;
					}

					if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
						jQuery.error( "Invalid XML: " + data );
					}
					return xml;
				};


				var
					rbracket = /\[\]$/,
					rCRLF = /\r?\n/g,
					rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
					rsubmittable = /^(?:input|select|textarea|keygen)/i;

				function buildParams( prefix, obj, traditional, add ) {
					var name;

					if ( jQuery.isArray( obj ) ) {

						// Serialize array item.
						jQuery.each( obj, function( i, v ) {
							if ( traditional || rbracket.test( prefix ) ) {

								// Treat each array item as a scalar.
								add( prefix, v );

							} else {

								// Item is non-scalar (array or object), encode its numeric index.
								buildParams(
									prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
									v,
									traditional,
									add
								);
							}
						} );

					} else if ( !traditional && jQuery.type( obj ) === "object" ) {

						// Serialize object item.
						for ( name in obj ) {
							buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
						}

					} else {

						// Serialize scalar item.
						add( prefix, obj );
					}
				}

				// Serialize an array of form elements or a set of
				// key/values into a query string
				jQuery.param = function( a, traditional ) {
					var prefix,
						s = [],
						add = function( key, valueOrFunction ) {

							// If value is a function, invoke it and use its return value
							var value = jQuery.isFunction( valueOrFunction ) ?
								valueOrFunction() :
								valueOrFunction;

							s[ s.length ] = encodeURIComponent( key ) + "=" +
								encodeURIComponent( value == null ? "" : value );
						};

					// If an array was passed in, assume that it is an array of form elements.
					if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

						// Serialize the form elements
						jQuery.each( a, function() {
							add( this.name, this.value );
						} );

					} else {

						// If traditional, encode the "old" way (the way 1.3.2 or older
						// did it), otherwise encode params recursively.
						for ( prefix in a ) {
							buildParams( prefix, a[ prefix ], traditional, add );
						}
					}

					// Return the resulting serialization
					return s.join( "&" );
				};

				jQuery.fn.extend( {
					serialize: function() {
						return jQuery.param( this.serializeArray() );
					},
					serializeArray: function() {
						return this.map( function() {

							// Can add propHook for "elements" to filter or add form elements
							var elements = jQuery.prop( this, "elements" );
							return elements ? jQuery.makeArray( elements ) : this;
						} )
						.filter( function() {
							var type = this.type;

							// Use .is( ":disabled" ) so that fieldset[disabled] works
							return this.name && !jQuery( this ).is( ":disabled" ) &&
								rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
								( this.checked || !rcheckableType.test( type ) );
						} )
						.map( function( i, elem ) {
							var val = jQuery( this ).val();

							if ( val == null ) {
								return null;
							}

							if ( jQuery.isArray( val ) ) {
								return jQuery.map( val, function( val ) {
									return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
								} );
							}

							return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
						} ).get();
					}
				} );


				var
					r20 = /%20/g,
					rhash = /#.*$/,
					rantiCache = /([?&])_=[^&]*/,
					rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

					// #7653, #8125, #8152: local protocol detection
					rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
					rnoContent = /^(?:GET|HEAD)$/,
					rprotocol = /^\/\//,

					/* Prefilters
					 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
					 * 2) These are called:
					 *    - BEFORE asking for a transport
					 *    - AFTER param serialization (s.data is a string if s.processData is true)
					 * 3) key is the dataType
					 * 4) the catchall symbol "*" can be used
					 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
					 */
					prefilters = {},

					/* Transports bindings
					 * 1) key is the dataType
					 * 2) the catchall symbol "*" can be used
					 * 3) selection will start with transport dataType and THEN go to "*" if needed
					 */
					transports = {},

					// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
					allTypes = "*/".concat( "*" ),

					// Anchor tag for parsing the document origin
					originAnchor = document.createElement( "a" );
					originAnchor.href = location.href;

				// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
				function addToPrefiltersOrTransports( structure ) {

					// dataTypeExpression is optional and defaults to "*"
					return function( dataTypeExpression, func ) {

						if ( typeof dataTypeExpression !== "string" ) {
							func = dataTypeExpression;
							dataTypeExpression = "*";
						}

						var dataType,
							i = 0,
							dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

						if ( jQuery.isFunction( func ) ) {

							// For each dataType in the dataTypeExpression
							while ( ( dataType = dataTypes[ i++ ] ) ) {

								// Prepend if requested
								if ( dataType[ 0 ] === "+" ) {
									dataType = dataType.slice( 1 ) || "*";
									( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

								// Otherwise append
								} else {
									( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
								}
							}
						}
					};
				}

				// Base inspection function for prefilters and transports
				function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

					var inspected = {},
						seekingTransport = ( structure === transports );

					function inspect( dataType ) {
						var selected;
						inspected[ dataType ] = true;
						jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
							var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
							if ( typeof dataTypeOrTransport === "string" &&
								!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

								options.dataTypes.unshift( dataTypeOrTransport );
								inspect( dataTypeOrTransport );
								return false;
							} else if ( seekingTransport ) {
								return !( selected = dataTypeOrTransport );
							}
						} );
						return selected;
					}

					return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
				}

				// A special extend for ajax options
				// that takes "flat" options (not to be deep extended)
				// Fixes #9887
				function ajaxExtend( target, src ) {
					var key, deep,
						flatOptions = jQuery.ajaxSettings.flatOptions || {};

					for ( key in src ) {
						if ( src[ key ] !== undefined ) {
							( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
						}
					}
					if ( deep ) {
						jQuery.extend( true, target, deep );
					}

					return target;
				}

				/* Handles responses to an ajax request:
				 * - finds the right dataType (mediates between content-type and expected dataType)
				 * - returns the corresponding response
				 */
				function ajaxHandleResponses( s, jqXHR, responses ) {

					var ct, type, finalDataType, firstDataType,
						contents = s.contents,
						dataTypes = s.dataTypes;

					// Remove auto dataType and get content-type in the process
					while ( dataTypes[ 0 ] === "*" ) {
						dataTypes.shift();
						if ( ct === undefined ) {
							ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
						}
					}

					// Check if we're dealing with a known content-type
					if ( ct ) {
						for ( type in contents ) {
							if ( contents[ type ] && contents[ type ].test( ct ) ) {
								dataTypes.unshift( type );
								break;
							}
						}
					}

					// Check to see if we have a response for the expected dataType
					if ( dataTypes[ 0 ] in responses ) {
						finalDataType = dataTypes[ 0 ];
					} else {

						// Try convertible dataTypes
						for ( type in responses ) {
							if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
								finalDataType = type;
								break;
							}
							if ( !firstDataType ) {
								firstDataType = type;
							}
						}

						// Or just use first one
						finalDataType = finalDataType || firstDataType;
					}

					// If we found a dataType
					// We add the dataType to the list if needed
					// and return the corresponding response
					if ( finalDataType ) {
						if ( finalDataType !== dataTypes[ 0 ] ) {
							dataTypes.unshift( finalDataType );
						}
						return responses[ finalDataType ];
					}
				}

				/* Chain conversions given the request and the original response
				 * Also sets the responseXXX fields on the jqXHR instance
				 */
				function ajaxConvert( s, response, jqXHR, isSuccess ) {
					var conv2, current, conv, tmp, prev,
						converters = {},

						// Work with a copy of dataTypes in case we need to modify it for conversion
						dataTypes = s.dataTypes.slice();

					// Create converters map with lowercased keys
					if ( dataTypes[ 1 ] ) {
						for ( conv in s.converters ) {
							converters[ conv.toLowerCase() ] = s.converters[ conv ];
						}
					}

					current = dataTypes.shift();

					// Convert to each sequential dataType
					while ( current ) {

						if ( s.responseFields[ current ] ) {
							jqXHR[ s.responseFields[ current ] ] = response;
						}

						// Apply the dataFilter if provided
						if ( !prev && isSuccess && s.dataFilter ) {
							response = s.dataFilter( response, s.dataType );
						}

						prev = current;
						current = dataTypes.shift();

						if ( current ) {

							// There's only work to do if current dataType is non-auto
							if ( current === "*" ) {

								current = prev;

							// Convert response if prev dataType is non-auto and differs from current
							} else if ( prev !== "*" && prev !== current ) {

								// Seek a direct converter
								conv = converters[ prev + " " + current ] || converters[ "* " + current ];

								// If none found, seek a pair
								if ( !conv ) {
									for ( conv2 in converters ) {

										// If conv2 outputs current
										tmp = conv2.split( " " );
										if ( tmp[ 1 ] === current ) {

											// If prev can be converted to accepted input
											conv = converters[ prev + " " + tmp[ 0 ] ] ||
												converters[ "* " + tmp[ 0 ] ];
											if ( conv ) {

												// Condense equivalence converters
												if ( conv === true ) {
													conv = converters[ conv2 ];

												// Otherwise, insert the intermediate dataType
												} else if ( converters[ conv2 ] !== true ) {
													current = tmp[ 0 ];
													dataTypes.unshift( tmp[ 1 ] );
												}
												break;
											}
										}
									}
								}

								// Apply converter (if not an equivalence)
								if ( conv !== true ) {

									// Unless errors are allowed to bubble, catch and return them
									if ( conv && s.throws ) {
										response = conv( response );
									} else {
										try {
											response = conv( response );
										} catch ( e ) {
											return {
												state: "parsererror",
												error: conv ? e : "No conversion from " + prev + " to " + current
											};
										}
									}
								}
							}
						}
					}

					return { state: "success", data: response };
				}

				jQuery.extend( {

					// Counter for holding the number of active queries
					active: 0,

					// Last-Modified header cache for next request
					lastModified: {},
					etag: {},

					ajaxSettings: {
						url: location.href,
						type: "GET",
						isLocal: rlocalProtocol.test( location.protocol ),
						global: true,
						processData: true,
						async: true,
						contentType: "application/x-www-form-urlencoded; charset=UTF-8",

						/*
						timeout: 0,
						data: null,
						dataType: null,
						username: null,
						password: null,
						cache: null,
						throws: false,
						traditional: false,
						headers: {},
						*/

						accepts: {
							"*": allTypes,
							text: "text/plain",
							html: "text/html",
							xml: "application/xml, text/xml",
							json: "application/json, text/javascript"
						},

						contents: {
							xml: /\bxml\b/,
							html: /\bhtml/,
							json: /\bjson\b/
						},

						responseFields: {
							xml: "responseXML",
							text: "responseText",
							json: "responseJSON"
						},

						// Data converters
						// Keys separate source (or catchall "*") and destination types with a single space
						converters: {

							// Convert anything to text
							"* text": String,

							// Text to html (true = no transformation)
							"text html": true,

							// Evaluate text as a json expression
							"text json": JSON.parse,

							// Parse text as xml
							"text xml": jQuery.parseXML
						},

						// For options that shouldn't be deep extended:
						// you can add your own custom options here if
						// and when you create one that shouldn't be
						// deep extended (see ajaxExtend)
						flatOptions: {
							url: true,
							context: true
						}
					},

					// Creates a full fledged settings object into target
					// with both ajaxSettings and settings fields.
					// If target is omitted, writes into ajaxSettings.
					ajaxSetup: function( target, settings ) {
						return settings ?

							// Building a settings object
							ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

							// Extending ajaxSettings
							ajaxExtend( jQuery.ajaxSettings, target );
					},

					ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
					ajaxTransport: addToPrefiltersOrTransports( transports ),

					// Main method
					ajax: function( url, options ) {

						// If url is an object, simulate pre-1.5 signature
						if ( typeof url === "object" ) {
							options = url;
							url = undefined;
						}

						// Force options to be an object
						options = options || {};

						var transport,

							// URL without anti-cache param
							cacheURL,

							// Response headers
							responseHeadersString,
							responseHeaders,

							// timeout handle
							timeoutTimer,

							// Url cleanup var
							urlAnchor,

							// Request state (becomes false upon send and true upon completion)
							completed,

							// To know if global events are to be dispatched
							fireGlobals,

							// Loop variable
							i,

							// uncached part of the url
							uncached,

							// Create the final options object
							s = jQuery.ajaxSetup( {}, options ),

							// Callbacks context
							callbackContext = s.context || s,

							// Context for global events is callbackContext if it is a DOM node or jQuery collection
							globalEventContext = s.context &&
								( callbackContext.nodeType || callbackContext.jquery ) ?
									jQuery( callbackContext ) :
									jQuery.event,

							// Deferreds
							deferred = jQuery.Deferred(),
							completeDeferred = jQuery.Callbacks( "once memory" ),

							// Status-dependent callbacks
							statusCode = s.statusCode || {},

							// Headers (they are sent all at once)
							requestHeaders = {},
							requestHeadersNames = {},

							// Default abort message
							strAbort = "canceled",

							// Fake xhr
							jqXHR = {
								readyState: 0,

								// Builds headers hashtable if needed
								getResponseHeader: function( key ) {
									var match;
									if ( completed ) {
										if ( !responseHeaders ) {
											responseHeaders = {};
											while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
												responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
											}
										}
										match = responseHeaders[ key.toLowerCase() ];
									}
									return match == null ? null : match;
								},

								// Raw string
								getAllResponseHeaders: function() {
									return completed ? responseHeadersString : null;
								},

								// Caches the header
								setRequestHeader: function( name, value ) {
									if ( completed == null ) {
										name = requestHeadersNames[ name.toLowerCase() ] =
											requestHeadersNames[ name.toLowerCase() ] || name;
										requestHeaders[ name ] = value;
									}
									return this;
								},

								// Overrides response content-type header
								overrideMimeType: function( type ) {
									if ( completed == null ) {
										s.mimeType = type;
									}
									return this;
								},

								// Status-dependent callbacks
								statusCode: function( map ) {
									var code;
									if ( map ) {
										if ( completed ) {

											// Execute the appropriate callbacks
											jqXHR.always( map[ jqXHR.status ] );
										} else {

											// Lazy-add the new callbacks in a way that preserves old ones
											for ( code in map ) {
												statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
											}
										}
									}
									return this;
								},

								// Cancel the request
								abort: function( statusText ) {
									var finalText = statusText || strAbort;
									if ( transport ) {
										transport.abort( finalText );
									}
									done( 0, finalText );
									return this;
								}
							};

						// Attach deferreds
						deferred.promise( jqXHR );

						// Add protocol if not provided (prefilters might expect it)
						// Handle falsy url in the settings object (#10093: consistency with old signature)
						// We also use the url parameter if available
						s.url = ( ( url || s.url || location.href ) + "" )
							.replace( rprotocol, location.protocol + "//" );

						// Alias method option to type as per ticket #12004
						s.type = options.method || options.type || s.method || s.type;

						// Extract dataTypes list
						s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

						// A cross-domain request is in order when the origin doesn't match the current origin.
						if ( s.crossDomain == null ) {
							urlAnchor = document.createElement( "a" );

							// Support: IE <=8 - 11, Edge 12 - 13
							// IE throws exception on accessing the href property if url is malformed,
							// e.g. http://example.com:80x/
							try {
								urlAnchor.href = s.url;

								// Support: IE <=8 - 11 only
								// Anchor's host property isn't correctly set when s.url is relative
								urlAnchor.href = urlAnchor.href;
								s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
									urlAnchor.protocol + "//" + urlAnchor.host;
							} catch ( e ) {

								// If there is an error parsing the URL, assume it is crossDomain,
								// it can be rejected by the transport if it is invalid
								s.crossDomain = true;
							}
						}

						// Convert data if not already a string
						if ( s.data && s.processData && typeof s.data !== "string" ) {
							s.data = jQuery.param( s.data, s.traditional );
						}

						// Apply prefilters
						inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

						// If request was aborted inside a prefilter, stop there
						if ( completed ) {
							return jqXHR;
						}

						// We can fire global events as of now if asked to
						// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
						fireGlobals = jQuery.event && s.global;

						// Watch for a new set of requests
						if ( fireGlobals && jQuery.active++ === 0 ) {
							jQuery.event.trigger( "ajaxStart" );
						}

						// Uppercase the type
						s.type = s.type.toUpperCase();

						// Determine if request has content
						s.hasContent = !rnoContent.test( s.type );

						// Save the URL in case we're toying with the If-Modified-Since
						// and/or If-None-Match header later on
						// Remove hash to simplify url manipulation
						cacheURL = s.url.replace( rhash, "" );

						// More options handling for requests with no content
						if ( !s.hasContent ) {

							// Remember the hash so we can put it back
							uncached = s.url.slice( cacheURL.length );

							// If data is available, append data to url
							if ( s.data ) {
								cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

								// #9682: remove data so that it's not used in an eventual retry
								delete s.data;
							}

							// Add or update anti-cache param if needed
							if ( s.cache === false ) {
								cacheURL = cacheURL.replace( rantiCache, "$1" );
								uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
							}

							// Put hash and anti-cache on the URL that will be requested (gh-1732)
							s.url = cacheURL + uncached;

						// Change '%20' to '+' if this is encoded form body content (gh-2658)
						} else if ( s.data && s.processData &&
							( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
							s.data = s.data.replace( r20, "+" );
						}

						// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
						if ( s.ifModified ) {
							if ( jQuery.lastModified[ cacheURL ] ) {
								jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
							}
							if ( jQuery.etag[ cacheURL ] ) {
								jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
							}
						}

						// Set the correct header, if data is being sent
						if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
							jqXHR.setRequestHeader( "Content-Type", s.contentType );
						}

						// Set the Accepts header for the server, depending on the dataType
						jqXHR.setRequestHeader(
							"Accept",
							s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
								s.accepts[ s.dataTypes[ 0 ] ] +
									( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
								s.accepts[ "*" ]
						);

						// Check for headers option
						for ( i in s.headers ) {
							jqXHR.setRequestHeader( i, s.headers[ i ] );
						}

						// Allow custom headers/mimetypes and early abort
						if ( s.beforeSend &&
							( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

							// Abort if not done already and return
							return jqXHR.abort();
						}

						// Aborting is no longer a cancellation
						strAbort = "abort";

						// Install callbacks on deferreds
						completeDeferred.add( s.complete );
						jqXHR.done( s.success );
						jqXHR.fail( s.error );

						// Get transport
						transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

						// If no transport, we auto-abort
						if ( !transport ) {
							done( -1, "No Transport" );
						} else {
							jqXHR.readyState = 1;

							// Send global event
							if ( fireGlobals ) {
								globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
							}

							// If request was aborted inside ajaxSend, stop there
							if ( completed ) {
								return jqXHR;
							}

							// Timeout
							if ( s.async && s.timeout > 0 ) {
								timeoutTimer = window.setTimeout( function() {
									jqXHR.abort( "timeout" );
								}, s.timeout );
							}

							try {
								completed = false;
								transport.send( requestHeaders, done );
							} catch ( e ) {

								// Rethrow post-completion exceptions
								if ( completed ) {
									throw e;
								}

								// Propagate others as results
								done( -1, e );
							}
						}

						// Callback for when everything is done
						function done( status, nativeStatusText, responses, headers ) {
							var isSuccess, success, error, response, modified,
								statusText = nativeStatusText;

							// Ignore repeat invocations
							if ( completed ) {
								return;
							}

							completed = true;

							// Clear timeout if it exists
							if ( timeoutTimer ) {
								window.clearTimeout( timeoutTimer );
							}

							// Dereference transport for early garbage collection
							// (no matter how long the jqXHR object will be used)
							transport = undefined;

							// Cache response headers
							responseHeadersString = headers || "";

							// Set readyState
							jqXHR.readyState = status > 0 ? 4 : 0;

							// Determine if successful
							isSuccess = status >= 200 && status < 300 || status === 304;

							// Get response data
							if ( responses ) {
								response = ajaxHandleResponses( s, jqXHR, responses );
							}

							// Convert no matter what (that way responseXXX fields are always set)
							response = ajaxConvert( s, response, jqXHR, isSuccess );

							// If successful, handle type chaining
							if ( isSuccess ) {

								// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
								if ( s.ifModified ) {
									modified = jqXHR.getResponseHeader( "Last-Modified" );
									if ( modified ) {
										jQuery.lastModified[ cacheURL ] = modified;
									}
									modified = jqXHR.getResponseHeader( "etag" );
									if ( modified ) {
										jQuery.etag[ cacheURL ] = modified;
									}
								}

								// if no content
								if ( status === 204 || s.type === "HEAD" ) {
									statusText = "nocontent";

								// if not modified
								} else if ( status === 304 ) {
									statusText = "notmodified";

								// If we have data, let's convert it
								} else {
									statusText = response.state;
									success = response.data;
									error = response.error;
									isSuccess = !error;
								}
							} else {

								// Extract error from statusText and normalize for non-aborts
								error = statusText;
								if ( status || !statusText ) {
									statusText = "error";
									if ( status < 0 ) {
										status = 0;
									}
								}
							}

							// Set data for the fake xhr object
							jqXHR.status = status;
							jqXHR.statusText = ( nativeStatusText || statusText ) + "";

							// Success/Error
							if ( isSuccess ) {
								deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
							} else {
								deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
							}

							// Status-dependent callbacks
							jqXHR.statusCode( statusCode );
							statusCode = undefined;

							if ( fireGlobals ) {
								globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
									[ jqXHR, s, isSuccess ? success : error ] );
							}

							// Complete
							completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

							if ( fireGlobals ) {
								globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

								// Handle the global AJAX counter
								if ( !( --jQuery.active ) ) {
									jQuery.event.trigger( "ajaxStop" );
								}
							}
						}

						return jqXHR;
					},

					getJSON: function( url, data, callback ) {
						return jQuery.get( url, data, callback, "json" );
					},

					getScript: function( url, callback ) {
						return jQuery.get( url, undefined, callback, "script" );
					}
				} );

				jQuery.each( [ "get", "post" ], function( i, method ) {
					jQuery[ method ] = function( url, data, callback, type ) {

						// Shift arguments if data argument was omitted
						if ( jQuery.isFunction( data ) ) {
							type = type || callback;
							callback = data;
							data = undefined;
						}

						// The url can be an options object (which then must have .url)
						return jQuery.ajax( jQuery.extend( {
							url: url,
							type: method,
							dataType: type,
							data: data,
							success: callback
						}, jQuery.isPlainObject( url ) && url ) );
					};
				} );


				jQuery._evalUrl = function( url ) {
					return jQuery.ajax( {
						url: url,

						// Make this explicit, since user can override this through ajaxSetup (#11264)
						type: "GET",
						dataType: "script",
						cache: true,
						async: false,
						global: false,
						"throws": true
					} );
				};


				jQuery.fn.extend( {
					wrapAll: function( html ) {
						var wrap;

						if ( this[ 0 ] ) {
							if ( jQuery.isFunction( html ) ) {
								html = html.call( this[ 0 ] );
							}

							// The elements to wrap the target around
							wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

							if ( this[ 0 ].parentNode ) {
								wrap.insertBefore( this[ 0 ] );
							}

							wrap.map( function() {
								var elem = this;

								while ( elem.firstElementChild ) {
									elem = elem.firstElementChild;
								}

								return elem;
							} ).append( this );
						}

						return this;
					},

					wrapInner: function( html ) {
						if ( jQuery.isFunction( html ) ) {
							return this.each( function( i ) {
								jQuery( this ).wrapInner( html.call( this, i ) );
							} );
						}

						return this.each( function() {
							var self = jQuery( this ),
								contents = self.contents();

							if ( contents.length ) {
								contents.wrapAll( html );

							} else {
								self.append( html );
							}
						} );
					},

					wrap: function( html ) {
						var isFunction = jQuery.isFunction( html );

						return this.each( function( i ) {
							jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );
						} );
					},

					unwrap: function( selector ) {
						this.parent( selector ).not( "body" ).each( function() {
							jQuery( this ).replaceWith( this.childNodes );
						} );
						return this;
					}
				} );


				jQuery.expr.pseudos.hidden = function( elem ) {
					return !jQuery.expr.pseudos.visible( elem );
				};
				jQuery.expr.pseudos.visible = function( elem ) {
					return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
				};




				jQuery.ajaxSettings.xhr = function() {
					try {
						return new window.XMLHttpRequest();
					} catch ( e ) {}
				};

				var xhrSuccessStatus = {

						// File protocol always yields status code 0, assume 200
						0: 200,

						// Support: IE <=9 only
						// #1450: sometimes IE returns 1223 when it should be 204
						1223: 204
					},
					xhrSupported = jQuery.ajaxSettings.xhr();

				support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
				support.ajax = xhrSupported = !!xhrSupported;

				jQuery.ajaxTransport( function( options ) {
					var callback, errorCallback;

					// Cross domain only allowed if supported through XMLHttpRequest
					if ( support.cors || xhrSupported && !options.crossDomain ) {
						return {
							send: function( headers, complete ) {
								var i,
									xhr = options.xhr();

								xhr.open(
									options.type,
									options.url,
									options.async,
									options.username,
									options.password
								);

								// Apply custom fields if provided
								if ( options.xhrFields ) {
									for ( i in options.xhrFields ) {
										xhr[ i ] = options.xhrFields[ i ];
									}
								}

								// Override mime type if needed
								if ( options.mimeType && xhr.overrideMimeType ) {
									xhr.overrideMimeType( options.mimeType );
								}

								// X-Requested-With header
								// For cross-domain requests, seeing as conditions for a preflight are
								// akin to a jigsaw puzzle, we simply never set it to be sure.
								// (it can always be set on a per-request basis or even using ajaxSetup)
								// For same-domain requests, won't change header if already provided.
								if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
									headers[ "X-Requested-With" ] = "XMLHttpRequest";
								}

								// Set headers
								for ( i in headers ) {
									xhr.setRequestHeader( i, headers[ i ] );
								}

								// Callback
								callback = function( type ) {
									return function() {
										if ( callback ) {
											callback = errorCallback = xhr.onload =
												xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;

											if ( type === "abort" ) {
												xhr.abort();
											} else if ( type === "error" ) {

												// Support: IE <=9 only
												// On a manual native abort, IE9 throws
												// errors on any property access that is not readyState
												if ( typeof xhr.status !== "number" ) {
													complete( 0, "error" );
												} else {
													complete(

														// File: protocol always yields status 0; see #8605, #14207
														xhr.status,
														xhr.statusText
													);
												}
											} else {
												complete(
													xhrSuccessStatus[ xhr.status ] || xhr.status,
													xhr.statusText,

													// Support: IE <=9 only
													// IE9 has no XHR2 but throws on binary (trac-11426)
													// For XHR2 non-text, let the caller handle it (gh-2498)
													( xhr.responseType || "text" ) !== "text"  ||
													typeof xhr.responseText !== "string" ?
														{ binary: xhr.response } :
														{ text: xhr.responseText },
													xhr.getAllResponseHeaders()
												);
											}
										}
									};
								};

								// Listen to events
								xhr.onload = callback();
								errorCallback = xhr.onerror = callback( "error" );

								// Support: IE 9 only
								// Use onreadystatechange to replace onabort
								// to handle uncaught aborts
								if ( xhr.onabort !== undefined ) {
									xhr.onabort = errorCallback;
								} else {
									xhr.onreadystatechange = function() {

										// Check readyState before timeout as it changes
										if ( xhr.readyState === 4 ) {

											// Allow onerror to be called first,
											// but that will not handle a native abort
											// Also, save errorCallback to a variable
											// as xhr.onerror cannot be accessed
											window.setTimeout( function() {
												if ( callback ) {
													errorCallback();
												}
											} );
										}
									};
								}

								// Create the abort callback
								callback = callback( "abort" );

								try {

									// Do send the request (this may raise an exception)
									xhr.send( options.hasContent && options.data || null );
								} catch ( e ) {

									// #14683: Only rethrow if this hasn't been notified as an error yet
									if ( callback ) {
										throw e;
									}
								}
							},

							abort: function() {
								if ( callback ) {
									callback();
								}
							}
						};
					}
				} );




				// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
				jQuery.ajaxPrefilter( function( s ) {
					if ( s.crossDomain ) {
						s.contents.script = false;
					}
				} );

				// Install script dataType
				jQuery.ajaxSetup( {
					accepts: {
						script: "text/javascript, application/javascript, " +
							"application/ecmascript, application/x-ecmascript"
					},
					contents: {
						script: /\b(?:java|ecma)script\b/
					},
					converters: {
						"text script": function( text ) {
							jQuery.globalEval( text );
							return text;
						}
					}
				} );

				// Handle cache's special case and crossDomain
				jQuery.ajaxPrefilter( "script", function( s ) {
					if ( s.cache === undefined ) {
						s.cache = false;
					}
					if ( s.crossDomain ) {
						s.type = "GET";
					}
				} );

				// Bind script tag hack transport
				jQuery.ajaxTransport( "script", function( s ) {

					// This transport only deals with cross domain requests
					if ( s.crossDomain ) {
						var script, callback;
						return {
							send: function( _, complete ) {
								script = jQuery( "<script>" ).prop( {
									charset: s.scriptCharset,
									src: s.url
								} ).on(
									"load error",
									callback = function( evt ) {
										script.remove();
										callback = null;
										if ( evt ) {
											complete( evt.type === "error" ? 404 : 200, evt.type );
										}
									}
								);

								// Use native DOM manipulation to avoid our domManip AJAX trickery
								document.head.appendChild( script[ 0 ] );
							},
							abort: function() {
								if ( callback ) {
									callback();
								}
							}
						};
					}
				} );




				var oldCallbacks = [],
					rjsonp = /(=)\?(?=&|$)|\?\?/;

				// Default jsonp settings
				jQuery.ajaxSetup( {
					jsonp: "callback",
					jsonpCallback: function() {
						var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
						this[ callback ] = true;
						return callback;
					}
				} );

				// Detect, normalize options and install callbacks for jsonp requests
				jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

					var callbackName, overwritten, responseContainer,
						jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
							"url" :
							typeof s.data === "string" &&
								( s.contentType || "" )
									.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
								rjsonp.test( s.data ) && "data"
						);

					// Handle iff the expected data type is "jsonp" or we have a parameter to set
					if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

						// Get callback name, remembering preexisting value associated with it
						callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
							s.jsonpCallback() :
							s.jsonpCallback;

						// Insert callback into url or form data
						if ( jsonProp ) {
							s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
						} else if ( s.jsonp !== false ) {
							s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
						}

						// Use data converter to retrieve json after script execution
						s.converters[ "script json" ] = function() {
							if ( !responseContainer ) {
								jQuery.error( callbackName + " was not called" );
							}
							return responseContainer[ 0 ];
						};

						// Force json dataType
						s.dataTypes[ 0 ] = "json";

						// Install callback
						overwritten = window[ callbackName ];
						window[ callbackName ] = function() {
							responseContainer = arguments;
						};

						// Clean-up function (fires after converters)
						jqXHR.always( function() {

							// If previous value didn't exist - remove it
							if ( overwritten === undefined ) {
								jQuery( window ).removeProp( callbackName );

							// Otherwise restore preexisting value
							} else {
								window[ callbackName ] = overwritten;
							}

							// Save back as free
							if ( s[ callbackName ] ) {

								// Make sure that re-using the options doesn't screw things around
								s.jsonpCallback = originalSettings.jsonpCallback;

								// Save the callback name for future use
								oldCallbacks.push( callbackName );
							}

							// Call if it was a function and we have a response
							if ( responseContainer && jQuery.isFunction( overwritten ) ) {
								overwritten( responseContainer[ 0 ] );
							}

							responseContainer = overwritten = undefined;
						} );

						// Delegate to script
						return "script";
					}
				} );




				// Support: Safari 8 only
				// In Safari 8 documents created via document.implementation.createHTMLDocument
				// collapse sibling forms: the second one becomes a child of the first one.
				// Because of that, this security measure has to be disabled in Safari 8.
				// https://bugs.webkit.org/show_bug.cgi?id=137337
				support.createHTMLDocument = ( function() {
					var body = document.implementation.createHTMLDocument( "" ).body;
					body.innerHTML = "<form></form><form></form>";
					return body.childNodes.length === 2;
				} )();


				// Argument "data" should be string of html
				// context (optional): If specified, the fragment will be created in this context,
				// defaults to document
				// keepScripts (optional): If true, will include scripts passed in the html string
				jQuery.parseHTML = function( data, context, keepScripts ) {
					if ( typeof data !== "string" ) {
						return [];
					}
					if ( typeof context === "boolean" ) {
						keepScripts = context;
						context = false;
					}

					var base, parsed, scripts;

					if ( !context ) {

						// Stop scripts or inline event handlers from being executed immediately
						// by using document.implementation
						if ( support.createHTMLDocument ) {
							context = document.implementation.createHTMLDocument( "" );

							// Set the base href for the created document
							// so any parsed elements with URLs
							// are based on the document's URL (gh-2965)
							base = context.createElement( "base" );
							base.href = document.location.href;
							context.head.appendChild( base );
						} else {
							context = document;
						}
					}

					parsed = rsingleTag.exec( data );
					scripts = !keepScripts && [];

					// Single tag
					if ( parsed ) {
						return [ context.createElement( parsed[ 1 ] ) ];
					}

					parsed = buildFragment( [ data ], context, scripts );

					if ( scripts && scripts.length ) {
						jQuery( scripts ).remove();
					}

					return jQuery.merge( [], parsed.childNodes );
				};


				/**
				 * Load a url into a page
				 */
				jQuery.fn.load = function( url, params, callback ) {
					var selector, type, response,
						self = this,
						off = url.indexOf( " " );

					if ( off > -1 ) {
						selector = stripAndCollapse( url.slice( off ) );
						url = url.slice( 0, off );
					}

					// If it's a function
					if ( jQuery.isFunction( params ) ) {

						// We assume that it's the callback
						callback = params;
						params = undefined;

					// Otherwise, build a param string
					} else if ( params && typeof params === "object" ) {
						type = "POST";
					}

					// If we have elements to modify, make the request
					if ( self.length > 0 ) {
						jQuery.ajax( {
							url: url,

							// If "type" variable is undefined, then "GET" method will be used.
							// Make value of this field explicit since
							// user can override it through ajaxSetup method
							type: type || "GET",
							dataType: "html",
							data: params
						} ).done( function( responseText ) {

							// Save response for use in complete callback
							response = arguments;

							self.html( selector ?

								// If a selector was specified, locate the right elements in a dummy div
								// Exclude scripts to avoid IE 'Permission Denied' errors
								jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

								// Otherwise use the full result
								responseText );

						// If the request succeeds, this function gets "data", "status", "jqXHR"
						// but they are ignored because response was set above.
						// If it fails, this function gets "jqXHR", "status", "error"
						} ).always( callback && function( jqXHR, status ) {
							self.each( function() {
								callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
							} );
						} );
					}

					return this;
				};




				// Attach a bunch of functions for handling common AJAX events
				jQuery.each( [
					"ajaxStart",
					"ajaxStop",
					"ajaxComplete",
					"ajaxError",
					"ajaxSuccess",
					"ajaxSend"
				], function( i, type ) {
					jQuery.fn[ type ] = function( fn ) {
						return this.on( type, fn );
					};
				} );




				jQuery.expr.pseudos.animated = function( elem ) {
					return jQuery.grep( jQuery.timers, function( fn ) {
						return elem === fn.elem;
					} ).length;
				};




				/**
				 * Gets a window from an element
				 */
				function getWindow( elem ) {
					return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
				}

				jQuery.offset = {
					setOffset: function( elem, options, i ) {
						var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
							position = jQuery.css( elem, "position" ),
							curElem = jQuery( elem ),
							props = {};

						// Set position first, in-case top/left are set even on static elem
						if ( position === "static" ) {
							elem.style.position = "relative";
						}

						curOffset = curElem.offset();
						curCSSTop = jQuery.css( elem, "top" );
						curCSSLeft = jQuery.css( elem, "left" );
						calculatePosition = ( position === "absolute" || position === "fixed" ) &&
							( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

						// Need to be able to calculate position if either
						// top or left is auto and position is either absolute or fixed
						if ( calculatePosition ) {
							curPosition = curElem.position();
							curTop = curPosition.top;
							curLeft = curPosition.left;

						} else {
							curTop = parseFloat( curCSSTop ) || 0;
							curLeft = parseFloat( curCSSLeft ) || 0;
						}

						if ( jQuery.isFunction( options ) ) {

							// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
							options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
						}

						if ( options.top != null ) {
							props.top = ( options.top - curOffset.top ) + curTop;
						}
						if ( options.left != null ) {
							props.left = ( options.left - curOffset.left ) + curLeft;
						}

						if ( "using" in options ) {
							options.using.call( elem, props );

						} else {
							curElem.css( props );
						}
					}
				};

				jQuery.fn.extend( {
					offset: function( options ) {

						// Preserve chaining for setter
						if ( arguments.length ) {
							return options === undefined ?
								this :
								this.each( function( i ) {
									jQuery.offset.setOffset( this, options, i );
								} );
						}

						var docElem, win, rect, doc,
							elem = this[ 0 ];

						if ( !elem ) {
							return;
						}

						// Support: IE <=11 only
						// Running getBoundingClientRect on a
						// disconnected node in IE throws an error
						if ( !elem.getClientRects().length ) {
							return { top: 0, left: 0 };
						}

						rect = elem.getBoundingClientRect();

						// Make sure element is not hidden (display: none)
						if ( rect.width || rect.height ) {
							doc = elem.ownerDocument;
							win = getWindow( doc );
							docElem = doc.documentElement;

							return {
								top: rect.top + win.pageYOffset - docElem.clientTop,
								left: rect.left + win.pageXOffset - docElem.clientLeft
							};
						}

						// Return zeros for disconnected and hidden elements (gh-2310)
						return rect;
					},

					position: function() {
						if ( !this[ 0 ] ) {
							return;
						}

						var offsetParent, offset,
							elem = this[ 0 ],
							parentOffset = { top: 0, left: 0 };

						// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
						// because it is its only offset parent
						if ( jQuery.css( elem, "position" ) === "fixed" ) {

							// Assume getBoundingClientRect is there when computed position is fixed
							offset = elem.getBoundingClientRect();

						} else {

							// Get *real* offsetParent
							offsetParent = this.offsetParent();

							// Get correct offsets
							offset = this.offset();
							if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
								parentOffset = offsetParent.offset();
							}

							// Add offsetParent borders
							parentOffset = {
								top: parentOffset.top + jQuery.css( offsetParent[ 0 ], "borderTopWidth", true ),
								left: parentOffset.left + jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true )
							};
						}

						// Subtract parent offsets and element margins
						return {
							top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
							left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
						};
					},

					// This method will return documentElement in the following cases:
					// 1) For the element inside the iframe without offsetParent, this method will return
					//    documentElement of the parent window
					// 2) For the hidden or detached element
					// 3) For body or html element, i.e. in case of the html node - it will return itself
					//
					// but those exceptions were never presented as a real life use-cases
					// and might be considered as more preferable results.
					//
					// This logic, however, is not guaranteed and can change at any point in the future
					offsetParent: function() {
						return this.map( function() {
							var offsetParent = this.offsetParent;

							while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
								offsetParent = offsetParent.offsetParent;
							}

							return offsetParent || documentElement;
						} );
					}
				} );

				// Create scrollLeft and scrollTop methods
				jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
					var top = "pageYOffset" === prop;

					jQuery.fn[ method ] = function( val ) {
						return access( this, function( elem, method, val ) {
							var win = getWindow( elem );

							if ( val === undefined ) {
								return win ? win[ prop ] : elem[ method ];
							}

							if ( win ) {
								win.scrollTo(
									!top ? val : win.pageXOffset,
									top ? val : win.pageYOffset
								);

							} else {
								elem[ method ] = val;
							}
						}, method, val, arguments.length );
					};
				} );

				// Support: Safari <=7 - 9.1, Chrome <=37 - 49
				// Add the top/left cssHooks using jQuery.fn.position
				// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
				// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
				// getComputedStyle returns percent when specified for top/left/bottom/right;
				// rather than make the css module depend on the offset module, just check for it here
				jQuery.each( [ "top", "left" ], function( i, prop ) {
					jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
						function( elem, computed ) {
							if ( computed ) {
								computed = curCSS( elem, prop );

								// If curCSS returns percentage, fallback to offset
								return rnumnonpx.test( computed ) ?
									jQuery( elem ).position()[ prop ] + "px" :
									computed;
							}
						}
					);
				} );


				// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
				jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
					jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
						function( defaultExtra, funcName ) {

						// Margin is only for outerHeight, outerWidth
						jQuery.fn[ funcName ] = function( margin, value ) {
							var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
								extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

							return access( this, function( elem, type, value ) {
								var doc;

								if ( jQuery.isWindow( elem ) ) {

									// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
									return funcName.indexOf( "outer" ) === 0 ?
										elem[ "inner" + name ] :
										elem.document.documentElement[ "client" + name ];
								}

								// Get document width or height
								if ( elem.nodeType === 9 ) {
									doc = elem.documentElement;

									// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
									// whichever is greatest
									return Math.max(
										elem.body[ "scroll" + name ], doc[ "scroll" + name ],
										elem.body[ "offset" + name ], doc[ "offset" + name ],
										doc[ "client" + name ]
									);
								}

								return value === undefined ?

									// Get width or height on the element, requesting but not forcing parseFloat
									jQuery.css( elem, type, extra ) :

									// Set width or height on the element
									jQuery.style( elem, type, value, extra );
							}, type, chainable ? margin : undefined, chainable );
						};
					} );
				} );


				jQuery.fn.extend( {

					bind: function( types, data, fn ) {
						return this.on( types, null, data, fn );
					},
					unbind: function( types, fn ) {
						return this.off( types, null, fn );
					},

					delegate: function( selector, types, data, fn ) {
						return this.on( types, selector, data, fn );
					},
					undelegate: function( selector, types, fn ) {

						// ( namespace ) or ( selector, types [, fn] )
						return arguments.length === 1 ?
							this.off( selector, "**" ) :
							this.off( types, selector || "**", fn );
					}
				} );

				jQuery.parseJSON = JSON.parse;




				// Register as a named AMD module, since jQuery can be concatenated with other
				// files that may use define, but not via a proper concatenation script that
				// understands anonymous AMD modules. A named AMD is safest and most robust
				// way to register. Lowercase jquery is used because AMD module names are
				// derived from file names, and jQuery is normally delivered in a lowercase
				// file name. Do this after creating the global so that if an AMD module wants
				// to call noConflict to hide this version of jQuery, it will work.

				// Note that for maximum portability, libraries that are not jQuery should
				// declare themselves as anonymous modules, and avoid setting a global if an
				// AMD loader is present. jQuery is a special case. For more information, see
				// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

				if ( true ) {
					!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
						return jQuery;
					}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
				}




				var

					// Map over jQuery in case of overwrite
					_jQuery = window.jQuery,

					// Map over the $ in case of overwrite
					_$ = window.$;

				jQuery.noConflict = function( deep ) {
					if ( window.$ === jQuery ) {
						window.$ = _$;
					}

					if ( deep && window.jQuery === jQuery ) {
						window.jQuery = _jQuery;
					}

					return jQuery;
				};

				// Expose jQuery and $ identifiers, even in AMD
				// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
				// and CommonJS for browser emulators (#13566)
				if ( !noGlobal ) {
					window.jQuery = window.$ = jQuery;
				}





				return jQuery;
				} );


			/***/ },
			/* 6 */
			/***/ function(module, exports) {

				/******/ (function(modules) { // webpackBootstrap
				/******/ 	// The module cache
				/******/ 	var installedModules = {};

				/******/ 	// The require function
				/******/ 	function __webpack_require__(moduleId) {

				/******/ 		// Check if module is in cache
				/******/ 		if(installedModules[moduleId])
				/******/ 			return installedModules[moduleId].exports;

				/******/ 		// Create a new module (and put it into the cache)
				/******/ 		var module = installedModules[moduleId] = {
				/******/ 			exports: {},
				/******/ 			id: moduleId,
				/******/ 			loaded: false
				/******/ 		};

				/******/ 		// Execute the module function
				/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

				/******/ 		// Flag the module as loaded
				/******/ 		module.loaded = true;

				/******/ 		// Return the exports of the module
				/******/ 		return module.exports;
				/******/ 	}


				/******/ 	// expose the modules object (__webpack_modules__)
				/******/ 	__webpack_require__.m = modules;

				/******/ 	// expose the module cache
				/******/ 	__webpack_require__.c = installedModules;

				/******/ 	// __webpack_public_path__
				/******/ 	__webpack_require__.p = "";

				/******/ 	// Load entry module and return exports
				/******/ 	return __webpack_require__(0);
				/******/ })
				/************************************************************************/
				/******/ ([
				/* 0 */
				/***/ function(module, exports, __webpack_require__) {

					var Vue = __webpack_require__(1);
					var app1 = __webpack_require__(2);
					var logic = __webpack_require__(3);

				/***/ },
				/* 1 */
				/***/ function(module, exports, __webpack_require__) {

					/*!
					 * Vue.js v2.0.5
					 * (c) 2014-2016 Evan You
					 * Released under the MIT License.
					 */
					(function (global, factory) {
					   true ? module.exports = factory() :
					  typeof define === 'function' && define.amd ? define(factory) :
					  (global.Vue = factory());
					}(this, (function () { 'use strict';

					/*  */

					/**
					 * Convert a value to a string that is actually rendered.
					 */
					function _toString (val) {
					  return val == null
					    ? ''
					    : typeof val === 'object'
					      ? JSON.stringify(val, null, 2)
					      : String(val)
					}

					/**
					 * Convert a input value to a number for persistence.
					 * If the conversion fails, return original string.
					 */
					function toNumber (val) {
					  var n = parseFloat(val, 10);
					  return (n || n === 0) ? n : val
					}

					/**
					 * Make a map and return a function for checking if a key
					 * is in that map.
					 */
					function makeMap (
					  str,
					  expectsLowerCase
					) {
					  var map = Object.create(null);
					  var list = str.split(',');
					  for (var i = 0; i < list.length; i++) {
					    map[list[i]] = true;
					  }
					  return expectsLowerCase
					    ? function (val) { return map[val.toLowerCase()]; }
					    : function (val) { return map[val]; }
					}

					/**
					 * Check if a tag is a built-in tag.
					 */
					var isBuiltInTag = makeMap('slot,component', true);

					/**
					 * Remove an item from an array
					 */
					function remove$1 (arr, item) {
					  if (arr.length) {
					    var index = arr.indexOf(item);
					    if (index > -1) {
					      return arr.splice(index, 1)
					    }
					  }
					}

					/**
					 * Check whether the object has the property.
					 */
					var hasOwnProperty = Object.prototype.hasOwnProperty;
					function hasOwn (obj, key) {
					  return hasOwnProperty.call(obj, key)
					}

					/**
					 * Check if value is primitive
					 */
					function isPrimitive (value) {
					  return typeof value === 'string' || typeof value === 'number'
					}

					/**
					 * Create a cached version of a pure function.
					 */
					function cached (fn) {
					  var cache = Object.create(null);
					  return function cachedFn (str) {
					    var hit = cache[str];
					    return hit || (cache[str] = fn(str))
					  }
					}

					/**
					 * Camelize a hyphen-delmited string.
					 */
					var camelizeRE = /-(\w)/g;
					var camelize = cached(function (str) {
					  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })
					});

					/**
					 * Capitalize a string.
					 */
					var capitalize = cached(function (str) {
					  return str.charAt(0).toUpperCase() + str.slice(1)
					});

					/**
					 * Hyphenate a camelCase string.
					 */
					var hyphenateRE = /([^-])([A-Z])/g;
					var hyphenate = cached(function (str) {
					  return str
					    .replace(hyphenateRE, '$1-$2')
					    .replace(hyphenateRE, '$1-$2')
					    .toLowerCase()
					});

					/**
					 * Simple bind, faster than native
					 */
					function bind$1 (fn, ctx) {
					  function boundFn (a) {
					    var l = arguments.length;
					    return l
					      ? l > 1
					        ? fn.apply(ctx, arguments)
					        : fn.call(ctx, a)
					      : fn.call(ctx)
					  }
					  // record original fn length
					  boundFn._length = fn.length;
					  return boundFn
					}

					/**
					 * Convert an Array-like object to a real Array.
					 */
					function toArray (list, start) {
					  start = start || 0;
					  var i = list.length - start;
					  var ret = new Array(i);
					  while (i--) {
					    ret[i] = list[i + start];
					  }
					  return ret
					}

					/**
					 * Mix properties into target object.
					 */
					function extend (to, _from) {
					  for (var key in _from) {
					    to[key] = _from[key];
					  }
					  return to
					}

					/**
					 * Quick object check - this is primarily used to tell
					 * Objects from primitive values when we know the value
					 * is a JSON-compliant type.
					 */
					function isObject (obj) {
					  return obj !== null && typeof obj === 'object'
					}

					/**
					 * Strict object type check. Only returns true
					 * for plain JavaScript objects.
					 */
					var toString = Object.prototype.toString;
					var OBJECT_STRING = '[object Object]';
					function isPlainObject (obj) {
					  return toString.call(obj) === OBJECT_STRING
					}

					/**
					 * Merge an Array of Objects into a single Object.
					 */
					function toObject (arr) {
					  var res = {};
					  for (var i = 0; i < arr.length; i++) {
					    if (arr[i]) {
					      extend(res, arr[i]);
					    }
					  }
					  return res
					}

					/**
					 * Perform no operation.
					 */
					function noop () {}

					/**
					 * Always return false.
					 */
					var no = function () { return false; };

					/**
					 * Generate a static keys string from compiler modules.
					 */
					function genStaticKeys (modules) {
					  return modules.reduce(function (keys, m) {
					    return keys.concat(m.staticKeys || [])
					  }, []).join(',')
					}

					/**
					 * Check if two values are loosely equal - that is,
					 * if they are plain objects, do they have the same shape?
					 */
					function looseEqual (a, b) {
					  /* eslint-disable eqeqeq */
					  return a == b || (
					    isObject(a) && isObject(b)
					      ? JSON.stringify(a) === JSON.stringify(b)
					      : false
					  )
					  /* eslint-enable eqeqeq */
					}

					function looseIndexOf (arr, val) {
					  for (var i = 0; i < arr.length; i++) {
					    if (looseEqual(arr[i], val)) { return i }
					  }
					  return -1
					}

					/*  */

					var config = {
					  /**
					   * Option merge strategies (used in core/util/options)
					   */
					  optionMergeStrategies: Object.create(null),

					  /**
					   * Whether to suppress warnings.
					   */
					  silent: false,

					  /**
					   * Whether to enable devtools
					   */
					  devtools: "development" !== 'production',

					  /**
					   * Error handler for watcher errors
					   */
					  errorHandler: null,

					  /**
					   * Ignore certain custom elements
					   */
					  ignoredElements: null,

					  /**
					   * Custom user key aliases for v-on
					   */
					  keyCodes: Object.create(null),

					  /**
					   * Check if a tag is reserved so that it cannot be registered as a
					   * component. This is platform-dependent and may be overwritten.
					   */
					  isReservedTag: no,

					  /**
					   * Check if a tag is an unknown element.
					   * Platform-dependent.
					   */
					  isUnknownElement: no,

					  /**
					   * Get the namespace of an element
					   */
					  getTagNamespace: noop,

					  /**
					   * Check if an attribute must be bound using property, e.g. value
					   * Platform-dependent.
					   */
					  mustUseProp: no,

					  /**
					   * List of asset types that a component can own.
					   */
					  _assetTypes: [
					    'component',
					    'directive',
					    'filter'
					  ],

					  /**
					   * List of lifecycle hooks.
					   */
					  _lifecycleHooks: [
					    'beforeCreate',
					    'created',
					    'beforeMount',
					    'mounted',
					    'beforeUpdate',
					    'updated',
					    'beforeDestroy',
					    'destroyed',
					    'activated',
					    'deactivated'
					  ],

					  /**
					   * Max circular updates allowed in a scheduler flush cycle.
					   */
					  _maxUpdateCount: 100,

					  /**
					   * Server rendering?
					   */
					  _isServer: "client" === 'server'
					};

					/*  */

					/**
					 * Check if a string starts with $ or _
					 */
					function isReserved (str) {
					  var c = (str + '').charCodeAt(0);
					  return c === 0x24 || c === 0x5F
					}

					/**
					 * Define a property.
					 */
					function def (obj, key, val, enumerable) {
					  Object.defineProperty(obj, key, {
					    value: val,
					    enumerable: !!enumerable,
					    writable: true,
					    configurable: true
					  });
					}

					/**
					 * Parse simple path.
					 */
					var bailRE = /[^\w.$]/;
					function parsePath (path) {
					  if (bailRE.test(path)) {
					    return
					  } else {
					    var segments = path.split('.');
					    return function (obj) {
					      for (var i = 0; i < segments.length; i++) {
					        if (!obj) { return }
					        obj = obj[segments[i]];
					      }
					      return obj
					    }
					  }
					}

					/*  */
					/* globals MutationObserver */

					// can we use __proto__?
					var hasProto = '__proto__' in {};

					// Browser environment sniffing
					var inBrowser =
					  typeof window !== 'undefined' &&
					  Object.prototype.toString.call(window) !== '[object Object]';

					var UA = inBrowser && window.navigator.userAgent.toLowerCase();
					var isIE = UA && /msie|trident/.test(UA);
					var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
					var isEdge = UA && UA.indexOf('edge/') > 0;
					var isAndroid = UA && UA.indexOf('android') > 0;
					var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);

					// detect devtools
					var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

					/* istanbul ignore next */
					function isNative (Ctor) {
					  return /native code/.test(Ctor.toString())
					}

					/**
					 * Defer a task to execute it asynchronously.
					 */
					var nextTick = (function () {
					  var callbacks = [];
					  var pending = false;
					  var timerFunc;

					  function nextTickHandler () {
					    pending = false;
					    var copies = callbacks.slice(0);
					    callbacks.length = 0;
					    for (var i = 0; i < copies.length; i++) {
					      copies[i]();
					    }
					  }

					  // the nextTick behavior leverages the microtask queue, which can be accessed
					  // via either native Promise.then or MutationObserver.
					  // MutationObserver has wider support, however it is seriously bugged in
					  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
					  // completely stops working after triggering a few times... so, if native
					  // Promise is available, we will use it:
					  /* istanbul ignore if */
					  if (typeof Promise !== 'undefined' && isNative(Promise)) {
					    var p = Promise.resolve();
					    timerFunc = function () {
					      p.then(nextTickHandler);
					      // in problematic UIWebViews, Promise.then doesn't completely break, but
					      // it can get stuck in a weird state where callbacks are pushed into the
					      // microtask queue but the queue isn't being flushed, until the browser
					      // needs to do some other work, e.g. handle a timer. Therefore we can
					      // "force" the microtask queue to be flushed by adding an empty timer.
					      if (isIOS) { setTimeout(noop); }
					    };
					  } else if (typeof MutationObserver !== 'undefined' && (
					    isNative(MutationObserver) ||
					    // PhantomJS and iOS 7.x
					    MutationObserver.toString() === '[object MutationObserverConstructor]'
					  )) {
					    // use MutationObserver where native Promise is not available,
					    // e.g. PhantomJS IE11, iOS7, Android 4.4
					    var counter = 1;
					    var observer = new MutationObserver(nextTickHandler);
					    var textNode = document.createTextNode(String(counter));
					    observer.observe(textNode, {
					      characterData: true
					    });
					    timerFunc = function () {
					      counter = (counter + 1) % 2;
					      textNode.data = String(counter);
					    };
					  } else {
					    // fallback to setTimeout
					    /* istanbul ignore next */
					    timerFunc = function () {
					      setTimeout(nextTickHandler, 0);
					    };
					  }

					  return function queueNextTick (cb, ctx) {
					    var func = ctx
					      ? function () { cb.call(ctx); }
					      : cb;
					    callbacks.push(func);
					    if (!pending) {
					      pending = true;
					      timerFunc();
					    }
					  }
					})();

					var _Set;
					/* istanbul ignore if */
					if (typeof Set !== 'undefined' && isNative(Set)) {
					  // use native Set when available.
					  _Set = Set;
					} else {
					  // a non-standard Set polyfill that only works with primitive keys.
					  _Set = (function () {
					    function Set () {
					      this.set = Object.create(null);
					    }
					    Set.prototype.has = function has (key) {
					      return this.set[key] !== undefined
					    };
					    Set.prototype.add = function add (key) {
					      this.set[key] = 1;
					    };
					    Set.prototype.clear = function clear () {
					      this.set = Object.create(null);
					    };

					    return Set;
					  }());
					}

					/* not type checking this file because flow doesn't play well with Proxy */

					var hasProxy;
					var proxyHandlers;
					var initProxy;

					{
					  var allowedGlobals = makeMap(
					    'Infinity,undefined,NaN,isFinite,isNaN,' +
					    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +
					    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +
					    'require' // for Webpack/Browserify
					  );

					  hasProxy =
					    typeof Proxy !== 'undefined' &&
					    Proxy.toString().match(/native code/);

					  proxyHandlers = {
					    has: function has (target, key) {
					      var has = key in target;
					      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';
					      if (!has && !isAllowed) {
					        warn(
					          "Property or method \"" + key + "\" is not defined on the instance but " +
					          "referenced during render. Make sure to declare reactive data " +
					          "properties in the data option.",
					          target
					        );
					      }
					      return has || !isAllowed
					    }
					  };

					  initProxy = function initProxy (vm) {
					    if (hasProxy) {
					      vm._renderProxy = new Proxy(vm, proxyHandlers);
					    } else {
					      vm._renderProxy = vm;
					    }
					  };
					}

					/*  */


					var uid$2 = 0;

					/**
					 * A dep is an observable that can have multiple
					 * directives subscribing to it.
					 */
					var Dep = function Dep () {
					  this.id = uid$2++;
					  this.subs = [];
					};

					Dep.prototype.addSub = function addSub (sub) {
					  this.subs.push(sub);
					};

					Dep.prototype.removeSub = function removeSub (sub) {
					  remove$1(this.subs, sub);
					};

					Dep.prototype.depend = function depend () {
					  if (Dep.target) {
					    Dep.target.addDep(this);
					  }
					};

					Dep.prototype.notify = function notify () {
					  // stablize the subscriber list first
					  var subs = this.subs.slice();
					  for (var i = 0, l = subs.length; i < l; i++) {
					    subs[i].update();
					  }
					};

					// the current target watcher being evaluated.
					// this is globally unique because there could be only one
					// watcher being evaluated at any time.
					Dep.target = null;
					var targetStack = [];

					function pushTarget (_target) {
					  if (Dep.target) { targetStack.push(Dep.target); }
					  Dep.target = _target;
					}

					function popTarget () {
					  Dep.target = targetStack.pop();
					}

					/*  */


					var queue = [];
					var has$1 = {};
					var circular = {};
					var waiting = false;
					var flushing = false;
					var index = 0;

					/**
					 * Reset the scheduler's state.
					 */
					function resetSchedulerState () {
					  queue.length = 0;
					  has$1 = {};
					  {
					    circular = {};
					  }
					  waiting = flushing = false;
					}

					/**
					 * Flush both queues and run the watchers.
					 */
					function flushSchedulerQueue () {
					  flushing = true;

					  // Sort queue before flush.
					  // This ensures that:
					  // 1. Components are updated from parent to child. (because parent is always
					  //    created before the child)
					  // 2. A component's user watchers are run before its render watcher (because
					  //    user watchers are created before the render watcher)
					  // 3. If a component is destroyed during a parent component's watcher run,
					  //    its watchers can be skipped.
					  queue.sort(function (a, b) { return a.id - b.id; });

					  // do not cache length because more watchers might be pushed
					  // as we run existing watchers
					  for (index = 0; index < queue.length; index++) {
					    var watcher = queue[index];
					    var id = watcher.id;
					    has$1[id] = null;
					    watcher.run();
					    // in dev build, check and stop circular updates.
					    if ("development" !== 'production' && has$1[id] != null) {
					      circular[id] = (circular[id] || 0) + 1;
					      if (circular[id] > config._maxUpdateCount) {
					        warn(
					          'You may have an infinite update loop ' + (
					            watcher.user
					              ? ("in watcher with expression \"" + (watcher.expression) + "\"")
					              : "in a component render function."
					          ),
					          watcher.vm
					        );
					        break
					      }
					    }
					  }

					  // devtool hook
					  /* istanbul ignore if */
					  if (devtools && config.devtools) {
					    devtools.emit('flush');
					  }

					  resetSchedulerState();
					}

					/**
					 * Push a watcher into the watcher queue.
					 * Jobs with duplicate IDs will be skipped unless it's
					 * pushed when the queue is being flushed.
					 */
					function queueWatcher (watcher) {
					  var id = watcher.id;
					  if (has$1[id] == null) {
					    has$1[id] = true;
					    if (!flushing) {
					      queue.push(watcher);
					    } else {
					      // if already flushing, splice the watcher based on its id
					      // if already past its id, it will be run next immediately.
					      var i = queue.length - 1;
					      while (i >= 0 && queue[i].id > watcher.id) {
					        i--;
					      }
					      queue.splice(Math.max(i, index) + 1, 0, watcher);
					    }
					    // queue the flush
					    if (!waiting) {
					      waiting = true;
					      nextTick(flushSchedulerQueue);
					    }
					  }
					}

					/*  */

					var uid$1 = 0;

					/**
					 * A watcher parses an expression, collects dependencies,
					 * and fires callback when the expression value changes.
					 * This is used for both the $watch() api and directives.
					 */
					var Watcher = function Watcher (
					  vm,
					  expOrFn,
					  cb,
					  options
					) {
					  if ( options === void 0 ) options = {};

					  this.vm = vm;
					  vm._watchers.push(this);
					  // options
					  this.deep = !!options.deep;
					  this.user = !!options.user;
					  this.lazy = !!options.lazy;
					  this.sync = !!options.sync;
					  this.expression = expOrFn.toString();
					  this.cb = cb;
					  this.id = ++uid$1; // uid for batching
					  this.active = true;
					  this.dirty = this.lazy; // for lazy watchers
					  this.deps = [];
					  this.newDeps = [];
					  this.depIds = new _Set();
					  this.newDepIds = new _Set();
					  // parse expression for getter
					  if (typeof expOrFn === 'function') {
					    this.getter = expOrFn;
					  } else {
					    this.getter = parsePath(expOrFn);
					    if (!this.getter) {
					      this.getter = function () {};
					      "development" !== 'production' && warn(
					        "Failed watching path: \"" + expOrFn + "\" " +
					        'Watcher only accepts simple dot-delimited paths. ' +
					        'For full control, use a function instead.',
					        vm
					      );
					    }
					  }
					  this.value = this.lazy
					    ? undefined
					    : this.get();
					};

					/**
					 * Evaluate the getter, and re-collect dependencies.
					 */
					Watcher.prototype.get = function get () {
					  pushTarget(this);
					  var value = this.getter.call(this.vm, this.vm);
					  // "touch" every property so they are all tracked as
					  // dependencies for deep watching
					  if (this.deep) {
					    traverse(value);
					  }
					  popTarget();
					  this.cleanupDeps();
					  return value
					};

					/**
					 * Add a dependency to this directive.
					 */
					Watcher.prototype.addDep = function addDep (dep) {
					  var id = dep.id;
					  if (!this.newDepIds.has(id)) {
					    this.newDepIds.add(id);
					    this.newDeps.push(dep);
					    if (!this.depIds.has(id)) {
					      dep.addSub(this);
					    }
					  }
					};

					/**
					 * Clean up for dependency collection.
					 */
					Watcher.prototype.cleanupDeps = function cleanupDeps () {
					    var this$1 = this;

					  var i = this.deps.length;
					  while (i--) {
					    var dep = this$1.deps[i];
					    if (!this$1.newDepIds.has(dep.id)) {
					      dep.removeSub(this$1);
					    }
					  }
					  var tmp = this.depIds;
					  this.depIds = this.newDepIds;
					  this.newDepIds = tmp;
					  this.newDepIds.clear();
					  tmp = this.deps;
					  this.deps = this.newDeps;
					  this.newDeps = tmp;
					  this.newDeps.length = 0;
					};

					/**
					 * Subscriber interface.
					 * Will be called when a dependency changes.
					 */
					Watcher.prototype.update = function update () {
					  /* istanbul ignore else */
					  if (this.lazy) {
					    this.dirty = true;
					  } else if (this.sync) {
					    this.run();
					  } else {
					    queueWatcher(this);
					  }
					};

					/**
					 * Scheduler job interface.
					 * Will be called by the scheduler.
					 */
					Watcher.prototype.run = function run () {
					  if (this.active) {
					    var value = this.get();
					      if (
					        value !== this.value ||
					      // Deep watchers and watchers on Object/Arrays should fire even
					      // when the value is the same, because the value may
					      // have mutated.
					      isObject(value) ||
					      this.deep
					    ) {
					      // set new value
					      var oldValue = this.value;
					      this.value = value;
					      if (this.user) {
					        try {
					          this.cb.call(this.vm, value, oldValue);
					        } catch (e) {
					          "development" !== 'production' && warn(
					            ("Error in watcher \"" + (this.expression) + "\""),
					            this.vm
					          );
					          /* istanbul ignore else */
					          if (config.errorHandler) {
					            config.errorHandler.call(null, e, this.vm);
					          } else {
					            throw e
					          }
					        }
					      } else {
					        this.cb.call(this.vm, value, oldValue);
					      }
					    }
					  }
					};

					/**
					 * Evaluate the value of the watcher.
					 * This only gets called for lazy watchers.
					 */
					Watcher.prototype.evaluate = function evaluate () {
					  this.value = this.get();
					  this.dirty = false;
					};

					/**
					 * Depend on all deps collected by this watcher.
					 */
					Watcher.prototype.depend = function depend () {
					    var this$1 = this;

					  var i = this.deps.length;
					  while (i--) {
					    this$1.deps[i].depend();
					  }
					};

					/**
					 * Remove self from all dependencies' subscriber list.
					 */
					Watcher.prototype.teardown = function teardown () {
					    var this$1 = this;

					  if (this.active) {
					    // remove self from vm's watcher list
					    // this is a somewhat expensive operation so we skip it
					    // if the vm is being destroyed or is performing a v-for
					    // re-render (the watcher list is then filtered by v-for).
					    if (!this.vm._isBeingDestroyed && !this.vm._vForRemoving) {
					      remove$1(this.vm._watchers, this);
					    }
					    var i = this.deps.length;
					    while (i--) {
					      this$1.deps[i].removeSub(this$1);
					    }
					    this.active = false;
					  }
					};

					/**
					 * Recursively traverse an object to evoke all converted
					 * getters, so that every nested property inside the object
					 * is collected as a "deep" dependency.
					 */
					var seenObjects = new _Set();
					function traverse (val) {
					  seenObjects.clear();
					  _traverse(val, seenObjects);
					}

					function _traverse (val, seen) {
					  var i, keys;
					  var isA = Array.isArray(val);
					  if ((!isA && !isObject(val)) || !Object.isExtensible(val)) {
					    return
					  }
					  if (val.__ob__) {
					    var depId = val.__ob__.dep.id;
					    if (seen.has(depId)) {
					      return
					    }
					    seen.add(depId);
					  }
					  if (isA) {
					    i = val.length;
					    while (i--) { _traverse(val[i], seen); }
					  } else {
					    keys = Object.keys(val);
					    i = keys.length;
					    while (i--) { _traverse(val[keys[i]], seen); }
					  }
					}

					/*
					 * not type checking this file because flow doesn't play well with
					 * dynamically accessing methods on Array prototype
					 */

					var arrayProto = Array.prototype;
					var arrayMethods = Object.create(arrayProto);[
					  'push',
					  'pop',
					  'shift',
					  'unshift',
					  'splice',
					  'sort',
					  'reverse'
					]
					.forEach(function (method) {
					  // cache original method
					  var original = arrayProto[method];
					  def(arrayMethods, method, function mutator () {
					    var arguments$1 = arguments;

					    // avoid leaking arguments:
					    // http://jsperf.com/closure-with-arguments
					    var i = arguments.length;
					    var args = new Array(i);
					    while (i--) {
					      args[i] = arguments$1[i];
					    }
					    var result = original.apply(this, args);
					    var ob = this.__ob__;
					    var inserted;
					    switch (method) {
					      case 'push':
					        inserted = args;
					        break
					      case 'unshift':
					        inserted = args;
					        break
					      case 'splice':
					        inserted = args.slice(2);
					        break
					    }
					    if (inserted) { ob.observeArray(inserted); }
					    // notify change
					    ob.dep.notify();
					    return result
					  });
					});

					/*  */

					var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

					/**
					 * By default, when a reactive property is set, the new value is
					 * also converted to become reactive. However when passing down props,
					 * we don't want to force conversion because the value may be a nested value
					 * under a frozen data structure. Converting it would defeat the optimization.
					 */
					var observerState = {
					  shouldConvert: true,
					  isSettingProps: false
					};

					/**
					 * Observer class that are attached to each observed
					 * object. Once attached, the observer converts target
					 * object's property keys into getter/setters that
					 * collect dependencies and dispatches updates.
					 */
					var Observer = function Observer (value) {
					  this.value = value;
					  this.dep = new Dep();
					  this.vmCount = 0;
					  def(value, '__ob__', this);
					  if (Array.isArray(value)) {
					    var augment = hasProto
					      ? protoAugment
					      : copyAugment;
					    augment(value, arrayMethods, arrayKeys);
					    this.observeArray(value);
					  } else {
					    this.walk(value);
					  }
					};

					/**
					 * Walk through each property and convert them into
					 * getter/setters. This method should only be called when
					 * value type is Object.
					 */
					Observer.prototype.walk = function walk (obj) {
					  var keys = Object.keys(obj);
					  for (var i = 0; i < keys.length; i++) {
					    defineReactive$$1(obj, keys[i], obj[keys[i]]);
					  }
					};

					/**
					 * Observe a list of Array items.
					 */
					Observer.prototype.observeArray = function observeArray (items) {
					  for (var i = 0, l = items.length; i < l; i++) {
					    observe(items[i]);
					  }
					};

					// helpers

					/**
					 * Augment an target Object or Array by intercepting
					 * the prototype chain using __proto__
					 */
					function protoAugment (target, src) {
					  /* eslint-disable no-proto */
					  target.__proto__ = src;
					  /* eslint-enable no-proto */
					}

					/**
					 * Augment an target Object or Array by defining
					 * hidden properties.
					 *
					 * istanbul ignore next
					 */
					function copyAugment (target, src, keys) {
					  for (var i = 0, l = keys.length; i < l; i++) {
					    var key = keys[i];
					    def(target, key, src[key]);
					  }
					}

					/**
					 * Attempt to create an observer instance for a value,
					 * returns the new observer if successfully observed,
					 * or the existing observer if the value already has one.
					 */
					function observe (value) {
					  if (!isObject(value)) {
					    return
					  }
					  var ob;
					  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
					    ob = value.__ob__;
					  } else if (
					    observerState.shouldConvert &&
					    !config._isServer &&
					    (Array.isArray(value) || isPlainObject(value)) &&
					    Object.isExtensible(value) &&
					    !value._isVue
					  ) {
					    ob = new Observer(value);
					  }
					  return ob
					}

					/**
					 * Define a reactive property on an Object.
					 */
					function defineReactive$$1 (
					  obj,
					  key,
					  val,
					  customSetter
					) {
					  var dep = new Dep();

					  var property = Object.getOwnPropertyDescriptor(obj, key);
					  if (property && property.configurable === false) {
					    return
					  }

					  // cater for pre-defined getter/setters
					  var getter = property && property.get;
					  var setter = property && property.set;

					  var childOb = observe(val);
					  Object.defineProperty(obj, key, {
					    enumerable: true,
					    configurable: true,
					    get: function reactiveGetter () {
					      var value = getter ? getter.call(obj) : val;
					      if (Dep.target) {
					        dep.depend();
					        if (childOb) {
					          childOb.dep.depend();
					        }
					        if (Array.isArray(value)) {
					          dependArray(value);
					        }
					      }
					      return value
					    },
					    set: function reactiveSetter (newVal) {
					      var value = getter ? getter.call(obj) : val;
					      if (newVal === value) {
					        return
					      }
					      if ("development" !== 'production' && customSetter) {
					        customSetter();
					      }
					      if (setter) {
					        setter.call(obj, newVal);
					      } else {
					        val = newVal;
					      }
					      childOb = observe(newVal);
					      dep.notify();
					    }
					  });
					}

					/**
					 * Set a property on an object. Adds the new property and
					 * triggers change notification if the property doesn't
					 * already exist.
					 */
					function set (obj, key, val) {
					  if (Array.isArray(obj)) {
					    obj.length = Math.max(obj.length, key);
					    obj.splice(key, 1, val);
					    return val
					  }
					  if (hasOwn(obj, key)) {
					    obj[key] = val;
					    return
					  }
					  var ob = obj.__ob__;
					  if (obj._isVue || (ob && ob.vmCount)) {
					    "development" !== 'production' && warn(
					      'Avoid adding reactive properties to a Vue instance or its root $data ' +
					      'at runtime - declare it upfront in the data option.'
					    );
					    return
					  }
					  if (!ob) {
					    obj[key] = val;
					    return
					  }
					  defineReactive$$1(ob.value, key, val);
					  ob.dep.notify();
					  return val
					}

					/**
					 * Delete a property and trigger change if necessary.
					 */
					function del (obj, key) {
					  var ob = obj.__ob__;
					  if (obj._isVue || (ob && ob.vmCount)) {
					    "development" !== 'production' && warn(
					      'Avoid deleting properties on a Vue instance or its root $data ' +
					      '- just set it to null.'
					    );
					    return
					  }
					  if (!hasOwn(obj, key)) {
					    return
					  }
					  delete obj[key];
					  if (!ob) {
					    return
					  }
					  ob.dep.notify();
					}

					/**
					 * Collect dependencies on array elements when the array is touched, since
					 * we cannot intercept array element access like property getters.
					 */
					function dependArray (value) {
					  for (var e = void 0, i = 0, l = value.length; i < l; i++) {
					    e = value[i];
					    e && e.__ob__ && e.__ob__.dep.depend();
					    if (Array.isArray(e)) {
					      dependArray(e);
					    }
					  }
					}

					/*  */

					function initState (vm) {
					  vm._watchers = [];
					  initProps(vm);
					  initData(vm);
					  initComputed(vm);
					  initMethods(vm);
					  initWatch(vm);
					}

					function initProps (vm) {
					  var props = vm.$options.props;
					  if (props) {
					    var propsData = vm.$options.propsData || {};
					    var keys = vm.$options._propKeys = Object.keys(props);
					    var isRoot = !vm.$parent;
					    // root instance props should be converted
					    observerState.shouldConvert = isRoot;
					    var loop = function ( i ) {
					      var key = keys[i];
					      /* istanbul ignore else */
					      {
					        defineReactive$$1(vm, key, validateProp(key, props, propsData, vm), function () {
					          if (vm.$parent && !observerState.isSettingProps) {
					            warn(
					              "Avoid mutating a prop directly since the value will be " +
					              "overwritten whenever the parent component re-renders. " +
					              "Instead, use a data or computed property based on the prop's " +
					              "value. Prop being mutated: \"" + key + "\"",
					              vm
					            );
					          }
					        });
					      }
					    };

					    for (var i = 0; i < keys.length; i++) loop( i );
					    observerState.shouldConvert = true;
					  }
					}

					function initData (vm) {
					  var data = vm.$options.data;
					  data = vm._data = typeof data === 'function'
					    ? data.call(vm)
					    : data || {};
					  if (!isPlainObject(data)) {
					    data = {};
					    "development" !== 'production' && warn(
					      'data functions should return an object.',
					      vm
					    );
					  }
					  // proxy data on instance
					  var keys = Object.keys(data);
					  var props = vm.$options.props;
					  var i = keys.length;
					  while (i--) {
					    if (props && hasOwn(props, keys[i])) {
					      "development" !== 'production' && warn(
					        "The data property \"" + (keys[i]) + "\" is already declared as a prop. " +
					        "Use prop default value instead.",
					        vm
					      );
					    } else {
					      proxy(vm, keys[i]);
					    }
					  }
					  // observe data
					  observe(data);
					  data.__ob__ && data.__ob__.vmCount++;
					}

					var computedSharedDefinition = {
					  enumerable: true,
					  configurable: true,
					  get: noop,
					  set: noop
					};

					function initComputed (vm) {
					  var computed = vm.$options.computed;
					  if (computed) {
					    for (var key in computed) {
					      var userDef = computed[key];
					      if (typeof userDef === 'function') {
					        computedSharedDefinition.get = makeComputedGetter(userDef, vm);
					        computedSharedDefinition.set = noop;
					      } else {
					        computedSharedDefinition.get = userDef.get
					          ? userDef.cache !== false
					            ? makeComputedGetter(userDef.get, vm)
					            : bind$1(userDef.get, vm)
					          : noop;
					        computedSharedDefinition.set = userDef.set
					          ? bind$1(userDef.set, vm)
					          : noop;
					      }
					      Object.defineProperty(vm, key, computedSharedDefinition);
					    }
					  }
					}

					function makeComputedGetter (getter, owner) {
					  var watcher = new Watcher(owner, getter, noop, {
					    lazy: true
					  });
					  return function computedGetter () {
					    if (watcher.dirty) {
					      watcher.evaluate();
					    }
					    if (Dep.target) {
					      watcher.depend();
					    }
					    return watcher.value
					  }
					}

					function initMethods (vm) {
					  var methods = vm.$options.methods;
					  if (methods) {
					    for (var key in methods) {
					      vm[key] = methods[key] == null ? noop : bind$1(methods[key], vm);
					      {
					        methods[key] == null && warn(
					          "method \"" + key + "\" has an undefined value in the component definition. " +
					          "Did you reference the function correctly?",
					          vm
					        );
					        hasOwn(Vue$2.prototype, key) && warn(
					          ("Avoid overriding Vue's internal method \"" + key + "\"."),
					          vm
					        );
					      }
					    }
					  }
					}

					function initWatch (vm) {
					  var watch = vm.$options.watch;
					  if (watch) {
					    for (var key in watch) {
					      var handler = watch[key];
					      if (Array.isArray(handler)) {
					        for (var i = 0; i < handler.length; i++) {
					          createWatcher(vm, key, handler[i]);
					        }
					      } else {
					        createWatcher(vm, key, handler);
					      }
					    }
					  }
					}

					function createWatcher (vm, key, handler) {
					  var options;
					  if (isPlainObject(handler)) {
					    options = handler;
					    handler = handler.handler;
					  }
					  if (typeof handler === 'string') {
					    handler = vm[handler];
					  }
					  vm.$watch(key, handler, options);
					}

					function stateMixin (Vue) {
					  // flow somehow has problems with directly declared definition object
					  // when using Object.defineProperty, so we have to procedurally build up
					  // the object here.
					  var dataDef = {};
					  dataDef.get = function () {
					    return this._data
					  };
					  {
					    dataDef.set = function (newData) {
					      warn(
					        'Avoid replacing instance root $data. ' +
					        'Use nested data properties instead.',
					        this
					      );
					    };
					  }
					  Object.defineProperty(Vue.prototype, '$data', dataDef);

					  Vue.prototype.$set = set;
					  Vue.prototype.$delete = del;

					  Vue.prototype.$watch = function (
					    expOrFn,
					    cb,
					    options
					  ) {
					    var vm = this;
					    options = options || {};
					    options.user = true;
					    var watcher = new Watcher(vm, expOrFn, cb, options);
					    if (options.immediate) {
					      cb.call(vm, watcher.value);
					    }
					    return function unwatchFn () {
					      watcher.teardown();
					    }
					  };
					}

					function proxy (vm, key) {
					  if (!isReserved(key)) {
					    Object.defineProperty(vm, key, {
					      configurable: true,
					      enumerable: true,
					      get: function proxyGetter () {
					        return vm._data[key]
					      },
					      set: function proxySetter (val) {
					        vm._data[key] = val;
					      }
					    });
					  }
					}

					/*  */

					var VNode = function VNode (
					  tag,
					  data,
					  children,
					  text,
					  elm,
					  ns,
					  context,
					  componentOptions
					) {
					  this.tag = tag;
					  this.data = data;
					  this.children = children;
					  this.text = text;
					  this.elm = elm;
					  this.ns = ns;
					  this.context = context;
					  this.functionalContext = undefined;
					  this.key = data && data.key;
					  this.componentOptions = componentOptions;
					  this.child = undefined;
					  this.parent = undefined;
					  this.raw = false;
					  this.isStatic = false;
					  this.isRootInsert = true;
					  this.isComment = false;
					  this.isCloned = false;
					  this.isOnce = false;
					};

					var emptyVNode = function () {
					  var node = new VNode();
					  node.text = '';
					  node.isComment = true;
					  return node
					};

					// optimized shallow clone
					// used for static nodes and slot nodes because they may be reused across
					// multiple renders, cloning them avoids errors when DOM manipulations rely
					// on their elm reference.
					function cloneVNode (vnode) {
					  var cloned = new VNode(
					    vnode.tag,
					    vnode.data,
					    vnode.children,
					    vnode.text,
					    vnode.elm,
					    vnode.ns,
					    vnode.context,
					    vnode.componentOptions
					  );
					  cloned.isStatic = vnode.isStatic;
					  cloned.key = vnode.key;
					  cloned.isCloned = true;
					  return cloned
					}

					function cloneVNodes (vnodes) {
					  var res = new Array(vnodes.length);
					  for (var i = 0; i < vnodes.length; i++) {
					    res[i] = cloneVNode(vnodes[i]);
					  }
					  return res
					}

					/*  */

					function mergeVNodeHook (def, hookKey, hook, key) {
					  key = key + hookKey;
					  var injectedHash = def.__injected || (def.__injected = {});
					  if (!injectedHash[key]) {
					    injectedHash[key] = true;
					    var oldHook = def[hookKey];
					    if (oldHook) {
					      def[hookKey] = function () {
					        oldHook.apply(this, arguments);
					        hook.apply(this, arguments);
					      };
					    } else {
					      def[hookKey] = hook;
					    }
					  }
					}

					/*  */

					function updateListeners (
					  on,
					  oldOn,
					  add,
					  remove$$1,
					  vm
					) {
					  var name, cur, old, fn, event, capture;
					  for (name in on) {
					    cur = on[name];
					    old = oldOn[name];
					    if (!cur) {
					      "development" !== 'production' && warn(
					        "Invalid handler for event \"" + name + "\": got " + String(cur),
					        vm
					      );
					    } else if (!old) {
					      capture = name.charAt(0) === '!';
					      event = capture ? name.slice(1) : name;
					      if (Array.isArray(cur)) {
					        add(event, (cur.invoker = arrInvoker(cur)), capture);
					      } else {
					        if (!cur.invoker) {
					          fn = cur;
					          cur = on[name] = {};
					          cur.fn = fn;
					          cur.invoker = fnInvoker(cur);
					        }
					        add(event, cur.invoker, capture);
					      }
					    } else if (cur !== old) {
					      if (Array.isArray(old)) {
					        old.length = cur.length;
					        for (var i = 0; i < old.length; i++) { old[i] = cur[i]; }
					        on[name] = old;
					      } else {
					        old.fn = cur;
					        on[name] = old;
					      }
					    }
					  }
					  for (name in oldOn) {
					    if (!on[name]) {
					      event = name.charAt(0) === '!' ? name.slice(1) : name;
					      remove$$1(event, oldOn[name].invoker);
					    }
					  }
					}

					function arrInvoker (arr) {
					  return function (ev) {
					    var arguments$1 = arguments;

					    var single = arguments.length === 1;
					    for (var i = 0; i < arr.length; i++) {
					      single ? arr[i](ev) : arr[i].apply(null, arguments$1);
					    }
					  }
					}

					function fnInvoker (o) {
					  return function (ev) {
					    var single = arguments.length === 1;
					    single ? o.fn(ev) : o.fn.apply(null, arguments);
					  }
					}

					/*  */

					function normalizeChildren (
					  children,
					  ns,
					  nestedIndex
					) {
					  if (isPrimitive(children)) {
					    return [createTextVNode(children)]
					  }
					  if (Array.isArray(children)) {
					    var res = [];
					    for (var i = 0, l = children.length; i < l; i++) {
					      var c = children[i];
					      var last = res[res.length - 1];
					      //  nested
					      if (Array.isArray(c)) {
					        res.push.apply(res, normalizeChildren(c, ns, ((nestedIndex || '') + "_" + i)));
					      } else if (isPrimitive(c)) {
					        if (last && last.text) {
					          last.text += String(c);
					        } else if (c !== '') {
					          // convert primitive to vnode
					          res.push(createTextVNode(c));
					        }
					      } else if (c instanceof VNode) {
					        if (c.text && last && last.text) {
					          last.text += c.text;
					        } else {
					          // inherit parent namespace
					          if (ns) {
					            applyNS(c, ns);
					          }
					          // default key for nested array children (likely generated by v-for)
					          if (c.tag && c.key == null && nestedIndex != null) {
					            c.key = "__vlist" + nestedIndex + "_" + i + "__";
					          }
					          res.push(c);
					        }
					      }
					    }
					    return res
					  }
					}

					function createTextVNode (val) {
					  return new VNode(undefined, undefined, undefined, String(val))
					}

					function applyNS (vnode, ns) {
					  if (vnode.tag && !vnode.ns) {
					    vnode.ns = ns;
					    if (vnode.children) {
					      for (var i = 0, l = vnode.children.length; i < l; i++) {
					        applyNS(vnode.children[i], ns);
					      }
					    }
					  }
					}

					/*  */

					function getFirstComponentChild (children) {
					  return children && children.filter(function (c) { return c && c.componentOptions; })[0]
					}

					/*  */

					var activeInstance = null;

					function initLifecycle (vm) {
					  var options = vm.$options;

					  // locate first non-abstract parent
					  var parent = options.parent;
					  if (parent && !options.abstract) {
					    while (parent.$options.abstract && parent.$parent) {
					      parent = parent.$parent;
					    }
					    parent.$children.push(vm);
					  }

					  vm.$parent = parent;
					  vm.$root = parent ? parent.$root : vm;

					  vm.$children = [];
					  vm.$refs = {};

					  vm._watcher = null;
					  vm._inactive = false;
					  vm._isMounted = false;
					  vm._isDestroyed = false;
					  vm._isBeingDestroyed = false;
					}

					function lifecycleMixin (Vue) {
					  Vue.prototype._mount = function (
					    el,
					    hydrating
					  ) {
					    var vm = this;
					    vm.$el = el;
					    if (!vm.$options.render) {
					      vm.$options.render = emptyVNode;
					      {
					        /* istanbul ignore if */
					        if (vm.$options.template) {
					          warn(
					            'You are using the runtime-only build of Vue where the template ' +
					            'option is not available. Either pre-compile the templates into ' +
					            'render functions, or use the compiler-included build.',
					            vm
					          );
					        } else {
					          warn(
					            'Failed to mount component: template or render function not defined.',
					            vm
					          );
					        }
					      }
					    }
					    callHook(vm, 'beforeMount');
					    vm._watcher = new Watcher(vm, function () {
					      vm._update(vm._render(), hydrating);
					    }, noop);
					    hydrating = false;
					    // manually mounted instance, call mounted on self
					    // mounted is called for render-created child components in its inserted hook
					    if (vm.$vnode == null) {
					      vm._isMounted = true;
					      callHook(vm, 'mounted');
					    }
					    return vm
					  };

					  Vue.prototype._update = function (vnode, hydrating) {
					    var vm = this;
					    if (vm._isMounted) {
					      callHook(vm, 'beforeUpdate');
					    }
					    var prevEl = vm.$el;
					    var prevActiveInstance = activeInstance;
					    activeInstance = vm;
					    var prevVnode = vm._vnode;
					    vm._vnode = vnode;
					    if (!prevVnode) {
					      // Vue.prototype.__patch__ is injected in entry points
					      // based on the rendering backend used.
					      vm.$el = vm.__patch__(vm.$el, vnode, hydrating);
					    } else {
					      vm.$el = vm.__patch__(prevVnode, vnode);
					    }
					    activeInstance = prevActiveInstance;
					    // update __vue__ reference
					    if (prevEl) {
					      prevEl.__vue__ = null;
					    }
					    if (vm.$el) {
					      vm.$el.__vue__ = vm;
					    }
					    // if parent is an HOC, update its $el as well
					    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
					      vm.$parent.$el = vm.$el;
					    }
					    if (vm._isMounted) {
					      callHook(vm, 'updated');
					    }
					  };

					  Vue.prototype._updateFromParent = function (
					    propsData,
					    listeners,
					    parentVnode,
					    renderChildren
					  ) {
					    var vm = this;
					    var hasChildren = !!(vm.$options._renderChildren || renderChildren);
					    vm.$options._parentVnode = parentVnode;
					    vm.$options._renderChildren = renderChildren;
					    // update props
					    if (propsData && vm.$options.props) {
					      observerState.shouldConvert = false;
					      {
					        observerState.isSettingProps = true;
					      }
					      var propKeys = vm.$options._propKeys || [];
					      for (var i = 0; i < propKeys.length; i++) {
					        var key = propKeys[i];
					        vm[key] = validateProp(key, vm.$options.props, propsData, vm);
					      }
					      observerState.shouldConvert = true;
					      {
					        observerState.isSettingProps = false;
					      }
					      vm.$options.propsData = propsData;
					    }
					    // update listeners
					    if (listeners) {
					      var oldListeners = vm.$options._parentListeners;
					      vm.$options._parentListeners = listeners;
					      vm._updateListeners(listeners, oldListeners);
					    }
					    // resolve slots + force update if has children
					    if (hasChildren) {
					      vm.$slots = resolveSlots(renderChildren, vm._renderContext);
					      vm.$forceUpdate();
					    }
					  };

					  Vue.prototype.$forceUpdate = function () {
					    var vm = this;
					    if (vm._watcher) {
					      vm._watcher.update();
					    }
					  };

					  Vue.prototype.$destroy = function () {
					    var vm = this;
					    if (vm._isBeingDestroyed) {
					      return
					    }
					    callHook(vm, 'beforeDestroy');
					    vm._isBeingDestroyed = true;
					    // remove self from parent
					    var parent = vm.$parent;
					    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
					      remove$1(parent.$children, vm);
					    }
					    // teardown watchers
					    if (vm._watcher) {
					      vm._watcher.teardown();
					    }
					    var i = vm._watchers.length;
					    while (i--) {
					      vm._watchers[i].teardown();
					    }
					    // remove reference from data ob
					    // frozen object may not have observer.
					    if (vm._data.__ob__) {
					      vm._data.__ob__.vmCount--;
					    }
					    // call the last hook...
					    vm._isDestroyed = true;
					    callHook(vm, 'destroyed');
					    // turn off all instance listeners.
					    vm.$off();
					    // remove __vue__ reference
					    if (vm.$el) {
					      vm.$el.__vue__ = null;
					    }
					    // invoke destroy hooks on current rendered tree
					    vm.__patch__(vm._vnode, null);
					  };
					}

					function callHook (vm, hook) {
					  var handlers = vm.$options[hook];
					  if (handlers) {
					    for (var i = 0, j = handlers.length; i < j; i++) {
					      handlers[i].call(vm);
					    }
					  }
					  vm.$emit('hook:' + hook);
					}

					/*  */

					var hooks = { init: init, prepatch: prepatch, insert: insert, destroy: destroy$1 };
					var hooksToMerge = Object.keys(hooks);

					function createComponent (
					  Ctor,
					  data,
					  context,
					  children,
					  tag
					) {
					  if (!Ctor) {
					    return
					  }

					  if (isObject(Ctor)) {
					    Ctor = Vue$2.extend(Ctor);
					  }

					  if (typeof Ctor !== 'function') {
					    {
					      warn(("Invalid Component definition: " + (String(Ctor))), context);
					    }
					    return
					  }

					  // resolve constructor options in case global mixins are applied after
					  // component constructor creation
					  resolveConstructorOptions(Ctor);

					  // async component
					  if (!Ctor.cid) {
					    if (Ctor.resolved) {
					      Ctor = Ctor.resolved;
					    } else {
					      Ctor = resolveAsyncComponent(Ctor, function () {
					        // it's ok to queue this on every render because
					        // $forceUpdate is buffered by the scheduler.
					        context.$forceUpdate();
					      });
					      if (!Ctor) {
					        // return nothing if this is indeed an async component
					        // wait for the callback to trigger parent update.
					        return
					      }
					    }
					  }

					  data = data || {};

					  // extract props
					  var propsData = extractProps(data, Ctor);

					  // functional component
					  if (Ctor.options.functional) {
					    return createFunctionalComponent(Ctor, propsData, data, context, children)
					  }

					  // extract listeners, since these needs to be treated as
					  // child component listeners instead of DOM listeners
					  var listeners = data.on;
					  // replace with listeners with .native modifier
					  data.on = data.nativeOn;

					  if (Ctor.options.abstract) {
					    // abstract components do not keep anything
					    // other than props & listeners
					    data = {};
					  }

					  // merge component management hooks onto the placeholder node
					  mergeHooks(data);

					  // return a placeholder vnode
					  var name = Ctor.options.name || tag;
					  var vnode = new VNode(
					    ("vue-component-" + (Ctor.cid) + (name ? ("-" + name) : '')),
					    data, undefined, undefined, undefined, undefined, context,
					    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }
					  );
					  return vnode
					}

					function createFunctionalComponent (
					  Ctor,
					  propsData,
					  data,
					  context,
					  children
					) {
					  var props = {};
					  var propOptions = Ctor.options.props;
					  if (propOptions) {
					    for (var key in propOptions) {
					      props[key] = validateProp(key, propOptions, propsData);
					    }
					  }
					  var vnode = Ctor.options.render.call(
					    null,
					    // ensure the createElement function in functional components
					    // gets a unique context - this is necessary for correct named slot check
					    bind$1(createElement, { _self: Object.create(context) }),
					    {
					      props: props,
					      data: data,
					      parent: context,
					      children: normalizeChildren(children),
					      slots: function () { return resolveSlots(children, context); }
					    }
					  );
					  if (vnode instanceof VNode) {
					    vnode.functionalContext = context;
					    if (data.slot) {
					      (vnode.data || (vnode.data = {})).slot = data.slot;
					    }
					  }
					  return vnode
					}

					function createComponentInstanceForVnode (
					  vnode, // we know it's MountedComponentVNode but flow doesn't
					  parent // activeInstance in lifecycle state
					) {
					  var vnodeComponentOptions = vnode.componentOptions;
					  var options = {
					    _isComponent: true,
					    parent: parent,
					    propsData: vnodeComponentOptions.propsData,
					    _componentTag: vnodeComponentOptions.tag,
					    _parentVnode: vnode,
					    _parentListeners: vnodeComponentOptions.listeners,
					    _renderChildren: vnodeComponentOptions.children
					  };
					  // check inline-template render functions
					  var inlineTemplate = vnode.data.inlineTemplate;
					  if (inlineTemplate) {
					    options.render = inlineTemplate.render;
					    options.staticRenderFns = inlineTemplate.staticRenderFns;
					  }
					  return new vnodeComponentOptions.Ctor(options)
					}

					function init (vnode, hydrating) {
					  if (!vnode.child || vnode.child._isDestroyed) {
					    var child = vnode.child = createComponentInstanceForVnode(vnode, activeInstance);
					    child.$mount(hydrating ? vnode.elm : undefined, hydrating);
					  }
					}

					function prepatch (
					  oldVnode,
					  vnode
					) {
					  var options = vnode.componentOptions;
					  var child = vnode.child = oldVnode.child;
					  child._updateFromParent(
					    options.propsData, // updated props
					    options.listeners, // updated listeners
					    vnode, // new parent vnode
					    options.children // new children
					  );
					}

					function insert (vnode) {
					  if (!vnode.child._isMounted) {
					    vnode.child._isMounted = true;
					    callHook(vnode.child, 'mounted');
					  }
					  if (vnode.data.keepAlive) {
					    vnode.child._inactive = false;
					    callHook(vnode.child, 'activated');
					  }
					}

					function destroy$1 (vnode) {
					  if (!vnode.child._isDestroyed) {
					    if (!vnode.data.keepAlive) {
					      vnode.child.$destroy();
					    } else {
					      vnode.child._inactive = true;
					      callHook(vnode.child, 'deactivated');
					    }
					  }
					}

					function resolveAsyncComponent (
					  factory,
					  cb
					) {
					  if (factory.requested) {
					    // pool callbacks
					    factory.pendingCallbacks.push(cb);
					  } else {
					    factory.requested = true;
					    var cbs = factory.pendingCallbacks = [cb];
					    var sync = true;

					    var resolve = function (res) {
					      if (isObject(res)) {
					        res = Vue$2.extend(res);
					      }
					      // cache resolved
					      factory.resolved = res;
					      // invoke callbacks only if this is not a synchronous resolve
					      // (async resolves are shimmed as synchronous during SSR)
					      if (!sync) {
					        for (var i = 0, l = cbs.length; i < l; i++) {
					          cbs[i](res);
					        }
					      }
					    };

					    var reject = function (reason) {
					      "development" !== 'production' && warn(
					        "Failed to resolve async component: " + (String(factory)) +
					        (reason ? ("\nReason: " + reason) : '')
					      );
					    };

					    var res = factory(resolve, reject);

					    // handle promise
					    if (res && typeof res.then === 'function' && !factory.resolved) {
					      res.then(resolve, reject);
					    }

					    sync = false;
					    // return in case resolved synchronously
					    return factory.resolved
					  }
					}

					function extractProps (data, Ctor) {
					  // we are only extracting raw values here.
					  // validation and default values are handled in the child
					  // component itself.
					  var propOptions = Ctor.options.props;
					  if (!propOptions) {
					    return
					  }
					  var res = {};
					  var attrs = data.attrs;
					  var props = data.props;
					  var domProps = data.domProps;
					  if (attrs || props || domProps) {
					    for (var key in propOptions) {
					      var altKey = hyphenate(key);
					      checkProp(res, props, key, altKey, true) ||
					      checkProp(res, attrs, key, altKey) ||
					      checkProp(res, domProps, key, altKey);
					    }
					  }
					  return res
					}

					function checkProp (
					  res,
					  hash,
					  key,
					  altKey,
					  preserve
					) {
					  if (hash) {
					    if (hasOwn(hash, key)) {
					      res[key] = hash[key];
					      if (!preserve) {
					        delete hash[key];
					      }
					      return true
					    } else if (hasOwn(hash, altKey)) {
					      res[key] = hash[altKey];
					      if (!preserve) {
					        delete hash[altKey];
					      }
					      return true
					    }
					  }
					  return false
					}

					function mergeHooks (data) {
					  if (!data.hook) {
					    data.hook = {};
					  }
					  for (var i = 0; i < hooksToMerge.length; i++) {
					    var key = hooksToMerge[i];
					    var fromParent = data.hook[key];
					    var ours = hooks[key];
					    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;
					  }
					}

					function mergeHook$1 (a, b) {
					  // since all hooks have at most two args, use fixed args
					  // to avoid having to use fn.apply().
					  return function (_, __) {
					    a(_, __);
					    b(_, __);
					  }
					}

					/*  */

					// wrapper function for providing a more flexible interface
					// without getting yelled at by flow
					function createElement (
					  tag,
					  data,
					  children
					) {
					  if (data && (Array.isArray(data) || typeof data !== 'object')) {
					    children = data;
					    data = undefined;
					  }
					  // make sure to use real instance instead of proxy as context
					  return _createElement(this._self, tag, data, children)
					}

					function _createElement (
					  context,
					  tag,
					  data,
					  children
					) {
					  if (data && data.__ob__) {
					    "development" !== 'production' && warn(
					      "Avoid using observed data object as vnode data: " + (JSON.stringify(data)) + "\n" +
					      'Always create fresh vnode data objects in each render!',
					      context
					    );
					    return
					  }
					  if (!tag) {
					    // in case of component :is set to falsy value
					    return emptyVNode()
					  }
					  if (typeof tag === 'string') {
					    var Ctor;
					    var ns = config.getTagNamespace(tag);
					    if (config.isReservedTag(tag)) {
					      // platform built-in elements
					      return new VNode(
					        tag, data, normalizeChildren(children, ns),
					        undefined, undefined, ns, context
					      )
					    } else if ((Ctor = resolveAsset(context.$options, 'components', tag))) {
					      // component
					      return createComponent(Ctor, data, context, children, tag)
					    } else {
					      // unknown or unlisted namespaced elements
					      // check at runtime because it may get assigned a namespace when its
					      // parent normalizes children
					      var childNs = tag === 'foreignObject' ? 'xhtml' : ns;
					      return new VNode(
					        tag, data, normalizeChildren(children, childNs),
					        undefined, undefined, ns, context
					      )
					    }
					  } else {
					    // direct component options / constructor
					    return createComponent(tag, data, context, children)
					  }
					}

					/*  */

					function initRender (vm) {
					  vm.$vnode = null; // the placeholder node in parent tree
					  vm._vnode = null; // the root of the child tree
					  vm._staticTrees = null;
					  vm._renderContext = vm.$options._parentVnode && vm.$options._parentVnode.context;
					  vm.$slots = resolveSlots(vm.$options._renderChildren, vm._renderContext);
					  // bind the public createElement fn to this instance
					  // so that we get proper render context inside it.
					  vm.$createElement = bind$1(createElement, vm);
					  if (vm.$options.el) {
					    vm.$mount(vm.$options.el);
					  }
					}

					function renderMixin (Vue) {
					  Vue.prototype.$nextTick = function (fn) {
					    nextTick(fn, this);
					  };

					  Vue.prototype._render = function () {
					    var vm = this;
					    var ref = vm.$options;
					    var render = ref.render;
					    var staticRenderFns = ref.staticRenderFns;
					    var _parentVnode = ref._parentVnode;

					    if (vm._isMounted) {
					      // clone slot nodes on re-renders
					      for (var key in vm.$slots) {
					        vm.$slots[key] = cloneVNodes(vm.$slots[key]);
					      }
					    }

					    if (staticRenderFns && !vm._staticTrees) {
					      vm._staticTrees = [];
					    }
					    // set parent vnode. this allows render functions to have access
					    // to the data on the placeholder node.
					    vm.$vnode = _parentVnode;
					    // render self
					    var vnode;
					    try {
					      vnode = render.call(vm._renderProxy, vm.$createElement);
					    } catch (e) {
					      {
					        warn(("Error when rendering " + (formatComponentName(vm)) + ":"));
					      }
					      /* istanbul ignore else */
					      if (config.errorHandler) {
					        config.errorHandler.call(null, e, vm);
					      } else {
					        if (config._isServer) {
					          throw e
					        } else {
					          console.error(e);
					        }
					      }
					      // return previous vnode to prevent render error causing blank component
					      vnode = vm._vnode;
					    }
					    // return empty vnode in case the render function errored out
					    if (!(vnode instanceof VNode)) {
					      if ("development" !== 'production' && Array.isArray(vnode)) {
					        warn(
					          'Multiple root nodes returned from render function. Render function ' +
					          'should return a single root node.',
					          vm
					        );
					      }
					      vnode = emptyVNode();
					    }
					    // set parent
					    vnode.parent = _parentVnode;
					    return vnode
					  };

					  // shorthands used in render functions
					  Vue.prototype._h = createElement;
					  // toString for mustaches
					  Vue.prototype._s = _toString;
					  // number conversion
					  Vue.prototype._n = toNumber;
					  // empty vnode
					  Vue.prototype._e = emptyVNode;
					  // loose equal
					  Vue.prototype._q = looseEqual;
					  // loose indexOf
					  Vue.prototype._i = looseIndexOf;

					  // render static tree by index
					  Vue.prototype._m = function renderStatic (
					    index,
					    isInFor
					  ) {
					    var tree = this._staticTrees[index];
					    // if has already-rendered static tree and not inside v-for,
					    // we can reuse the same tree by doing a shallow clone.
					    if (tree && !isInFor) {
					      return Array.isArray(tree)
					        ? cloneVNodes(tree)
					        : cloneVNode(tree)
					    }
					    // otherwise, render a fresh tree.
					    tree = this._staticTrees[index] = this.$options.staticRenderFns[index].call(this._renderProxy);
					    markStatic(tree, ("__static__" + index), false);
					    return tree
					  };

					  // mark node as static (v-once)
					  Vue.prototype._o = function markOnce (
					    tree,
					    index,
					    key
					  ) {
					    markStatic(tree, ("__once__" + index + (key ? ("_" + key) : "")), true);
					    return tree
					  };

					  function markStatic (tree, key, isOnce) {
					    if (Array.isArray(tree)) {
					      for (var i = 0; i < tree.length; i++) {
					        if (tree[i] && typeof tree[i] !== 'string') {
					          markStaticNode(tree[i], (key + "_" + i), isOnce);
					        }
					      }
					    } else {
					      markStaticNode(tree, key, isOnce);
					    }
					  }

					  function markStaticNode (node, key, isOnce) {
					    node.isStatic = true;
					    node.key = key;
					    node.isOnce = isOnce;
					  }

					  // filter resolution helper
					  var identity = function (_) { return _; };
					  Vue.prototype._f = function resolveFilter (id) {
					    return resolveAsset(this.$options, 'filters', id, true) || identity
					  };

					  // render v-for
					  Vue.prototype._l = function renderList (
					    val,
					    render
					  ) {
					    var ret, i, l, keys, key;
					    if (Array.isArray(val)) {
					      ret = new Array(val.length);
					      for (i = 0, l = val.length; i < l; i++) {
					        ret[i] = render(val[i], i);
					      }
					    } else if (typeof val === 'number') {
					      ret = new Array(val);
					      for (i = 0; i < val; i++) {
					        ret[i] = render(i + 1, i);
					      }
					    } else if (isObject(val)) {
					      keys = Object.keys(val);
					      ret = new Array(keys.length);
					      for (i = 0, l = keys.length; i < l; i++) {
					        key = keys[i];
					        ret[i] = render(val[key], key, i);
					      }
					    }
					    return ret
					  };

					  // renderSlot
					  Vue.prototype._t = function (
					    name,
					    fallback
					  ) {
					    var slotNodes = this.$slots[name];
					    // warn duplicate slot usage
					    if (slotNodes && "development" !== 'production') {
					      slotNodes._rendered && warn(
					        "Duplicate presence of slot \"" + name + "\" found in the same render tree " +
					        "- this will likely cause render errors.",
					        this
					      );
					      slotNodes._rendered = true;
					    }
					    return slotNodes || fallback
					  };

					  // apply v-bind object
					  Vue.prototype._b = function bindProps (
					    data,
					    value,
					    asProp
					  ) {
					    if (value) {
					      if (!isObject(value)) {
					        "development" !== 'production' && warn(
					          'v-bind without argument expects an Object or Array value',
					          this
					        );
					      } else {
					        if (Array.isArray(value)) {
					          value = toObject(value);
					        }
					        for (var key in value) {
					          if (key === 'class' || key === 'style') {
					            data[key] = value[key];
					          } else {
					            var hash = asProp || config.mustUseProp(key)
					              ? data.domProps || (data.domProps = {})
					              : data.attrs || (data.attrs = {});
					            hash[key] = value[key];
					          }
					        }
					      }
					    }
					    return data
					  };

					  // expose v-on keyCodes
					  Vue.prototype._k = function getKeyCodes (key) {
					    return config.keyCodes[key]
					  };
					}

					function resolveSlots (
					  renderChildren,
					  context
					) {
					  var slots = {};
					  if (!renderChildren) {
					    return slots
					  }
					  var children = normalizeChildren(renderChildren) || [];
					  var defaultSlot = [];
					  var name, child;
					  for (var i = 0, l = children.length; i < l; i++) {
					    child = children[i];
					    // named slots should only be respected if the vnode was rendered in the
					    // same context.
					    if ((child.context === context || child.functionalContext === context) &&
					        child.data && (name = child.data.slot)) {
					      var slot = (slots[name] || (slots[name] = []));
					      if (child.tag === 'template') {
					        slot.push.apply(slot, child.children);
					      } else {
					        slot.push(child);
					      }
					    } else {
					      defaultSlot.push(child);
					    }
					  }
					  // ignore single whitespace
					  if (defaultSlot.length && !(
					    defaultSlot.length === 1 &&
					    (defaultSlot[0].text === ' ' || defaultSlot[0].isComment)
					  )) {
					    slots.default = defaultSlot;
					  }
					  return slots
					}

					/*  */

					function initEvents (vm) {
					  vm._events = Object.create(null);
					  // init parent attached events
					  var listeners = vm.$options._parentListeners;
					  var on = bind$1(vm.$on, vm);
					  var off = bind$1(vm.$off, vm);
					  vm._updateListeners = function (listeners, oldListeners) {
					    updateListeners(listeners, oldListeners || {}, on, off, vm);
					  };
					  if (listeners) {
					    vm._updateListeners(listeners);
					  }
					}

					function eventsMixin (Vue) {
					  Vue.prototype.$on = function (event, fn) {
					    var vm = this;(vm._events[event] || (vm._events[event] = [])).push(fn);
					    return vm
					  };

					  Vue.prototype.$once = function (event, fn) {
					    var vm = this;
					    function on () {
					      vm.$off(event, on);
					      fn.apply(vm, arguments);
					    }
					    on.fn = fn;
					    vm.$on(event, on);
					    return vm
					  };

					  Vue.prototype.$off = function (event, fn) {
					    var vm = this;
					    // all
					    if (!arguments.length) {
					      vm._events = Object.create(null);
					      return vm
					    }
					    // specific event
					    var cbs = vm._events[event];
					    if (!cbs) {
					      return vm
					    }
					    if (arguments.length === 1) {
					      vm._events[event] = null;
					      return vm
					    }
					    // specific handler
					    var cb;
					    var i = cbs.length;
					    while (i--) {
					      cb = cbs[i];
					      if (cb === fn || cb.fn === fn) {
					        cbs.splice(i, 1);
					        break
					      }
					    }
					    return vm
					  };

					  Vue.prototype.$emit = function (event) {
					    var vm = this;
					    var cbs = vm._events[event];
					    if (cbs) {
					      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
					      var args = toArray(arguments, 1);
					      for (var i = 0, l = cbs.length; i < l; i++) {
					        cbs[i].apply(vm, args);
					      }
					    }
					    return vm
					  };
					}

					/*  */

					var uid = 0;

					function initMixin (Vue) {
					  Vue.prototype._init = function (options) {
					    var vm = this;
					    // a uid
					    vm._uid = uid++;
					    // a flag to avoid this being observed
					    vm._isVue = true;
					    // merge options
					    if (options && options._isComponent) {
					      // optimize internal component instantiation
					      // since dynamic options merging is pretty slow, and none of the
					      // internal component options needs special treatment.
					      initInternalComponent(vm, options);
					    } else {
					      vm.$options = mergeOptions(
					        resolveConstructorOptions(vm.constructor),
					        options || {},
					        vm
					      );
					    }
					    /* istanbul ignore else */
					    {
					      initProxy(vm);
					    }
					    // expose real self
					    vm._self = vm;
					    initLifecycle(vm);
					    initEvents(vm);
					    callHook(vm, 'beforeCreate');
					    initState(vm);
					    callHook(vm, 'created');
					    initRender(vm);
					  };
					}

					function initInternalComponent (vm, options) {
					  var opts = vm.$options = Object.create(vm.constructor.options);
					  // doing this because it's faster than dynamic enumeration.
					  opts.parent = options.parent;
					  opts.propsData = options.propsData;
					  opts._parentVnode = options._parentVnode;
					  opts._parentListeners = options._parentListeners;
					  opts._renderChildren = options._renderChildren;
					  opts._componentTag = options._componentTag;
					  if (options.render) {
					    opts.render = options.render;
					    opts.staticRenderFns = options.staticRenderFns;
					  }
					}

					function resolveConstructorOptions (Ctor) {
					  var options = Ctor.options;
					  if (Ctor.super) {
					    var superOptions = Ctor.super.options;
					    var cachedSuperOptions = Ctor.superOptions;
					    var extendOptions = Ctor.extendOptions;
					    if (superOptions !== cachedSuperOptions) {
					      // super option changed
					      Ctor.superOptions = superOptions;
					      extendOptions.render = options.render;
					      extendOptions.staticRenderFns = options.staticRenderFns;
					      options = Ctor.options = mergeOptions(superOptions, extendOptions);
					      if (options.name) {
					        options.components[options.name] = Ctor;
					      }
					    }
					  }
					  return options
					}

					function Vue$2 (options) {
					  if ("development" !== 'production' &&
					    !(this instanceof Vue$2)) {
					    warn('Vue is a constructor and should be called with the `new` keyword');
					  }
					  this._init(options);
					}

					initMixin(Vue$2);
					stateMixin(Vue$2);
					eventsMixin(Vue$2);
					lifecycleMixin(Vue$2);
					renderMixin(Vue$2);

					var warn = noop;
					var formatComponentName;

					{
					  var hasConsole = typeof console !== 'undefined';

					  warn = function (msg, vm) {
					    if (hasConsole && (!config.silent)) {
					      console.error("[Vue warn]: " + msg + " " + (
					        vm ? formatLocation(formatComponentName(vm)) : ''
					      ));
					    }
					  };

					  formatComponentName = function (vm) {
					    if (vm.$root === vm) {
					      return 'root instance'
					    }
					    var name = vm._isVue
					      ? vm.$options.name || vm.$options._componentTag
					      : vm.name;
					    return (
					      (name ? ("component <" + name + ">") : "anonymous component") +
					      (vm._isVue && vm.$options.__file ? (" at " + (vm.$options.__file)) : '')
					    )
					  };

					  var formatLocation = function (str) {
					    if (str === 'anonymous component') {
					      str += " - use the \"name\" option for better debugging messages.";
					    }
					    return ("\n(found in " + str + ")")
					  };
					}

					/*  */

					/**
					 * Option overwriting strategies are functions that handle
					 * how to merge a parent option value and a child option
					 * value into the final value.
					 */
					var strats = config.optionMergeStrategies;

					/**
					 * Options with restrictions
					 */
					{
					  strats.el = strats.propsData = function (parent, child, vm, key) {
					    if (!vm) {
					      warn(
					        "option \"" + key + "\" can only be used during instance " +
					        'creation with the `new` keyword.'
					      );
					    }
					    return defaultStrat(parent, child)
					  };
					}

					/**
					 * Helper that recursively merges two data objects together.
					 */
					function mergeData (to, from) {
					  var key, toVal, fromVal;
					  for (key in from) {
					    toVal = to[key];
					    fromVal = from[key];
					    if (!hasOwn(to, key)) {
					      set(to, key, fromVal);
					    } else if (isObject(toVal) && isObject(fromVal)) {
					      mergeData(toVal, fromVal);
					    }
					  }
					  return to
					}

					/**
					 * Data
					 */
					strats.data = function (
					  parentVal,
					  childVal,
					  vm
					) {
					  if (!vm) {
					    // in a Vue.extend merge, both should be functions
					    if (!childVal) {
					      return parentVal
					    }
					    if (typeof childVal !== 'function') {
					      "development" !== 'production' && warn(
					        'The "data" option should be a function ' +
					        'that returns a per-instance value in component ' +
					        'definitions.',
					        vm
					      );
					      return parentVal
					    }
					    if (!parentVal) {
					      return childVal
					    }
					    // when parentVal & childVal are both present,
					    // we need to return a function that returns the
					    // merged result of both functions... no need to
					    // check if parentVal is a function here because
					    // it has to be a function to pass previous merges.
					    return function mergedDataFn () {
					      return mergeData(
					        childVal.call(this),
					        parentVal.call(this)
					      )
					    }
					  } else if (parentVal || childVal) {
					    return function mergedInstanceDataFn () {
					      // instance merge
					      var instanceData = typeof childVal === 'function'
					        ? childVal.call(vm)
					        : childVal;
					      var defaultData = typeof parentVal === 'function'
					        ? parentVal.call(vm)
					        : undefined;
					      if (instanceData) {
					        return mergeData(instanceData, defaultData)
					      } else {
					        return defaultData
					      }
					    }
					  }
					};

					/**
					 * Hooks and param attributes are merged as arrays.
					 */
					function mergeHook (
					  parentVal,
					  childVal
					) {
					  return childVal
					    ? parentVal
					      ? parentVal.concat(childVal)
					      : Array.isArray(childVal)
					        ? childVal
					        : [childVal]
					    : parentVal
					}

					config._lifecycleHooks.forEach(function (hook) {
					  strats[hook] = mergeHook;
					});

					/**
					 * Assets
					 *
					 * When a vm is present (instance creation), we need to do
					 * a three-way merge between constructor options, instance
					 * options and parent options.
					 */
					function mergeAssets (parentVal, childVal) {
					  var res = Object.create(parentVal || null);
					  return childVal
					    ? extend(res, childVal)
					    : res
					}

					config._assetTypes.forEach(function (type) {
					  strats[type + 's'] = mergeAssets;
					});

					/**
					 * Watchers.
					 *
					 * Watchers hashes should not overwrite one
					 * another, so we merge them as arrays.
					 */
					strats.watch = function (parentVal, childVal) {
					  /* istanbul ignore if */
					  if (!childVal) { return parentVal }
					  if (!parentVal) { return childVal }
					  var ret = {};
					  extend(ret, parentVal);
					  for (var key in childVal) {
					    var parent = ret[key];
					    var child = childVal[key];
					    if (parent && !Array.isArray(parent)) {
					      parent = [parent];
					    }
					    ret[key] = parent
					      ? parent.concat(child)
					      : [child];
					  }
					  return ret
					};

					/**
					 * Other object hashes.
					 */
					strats.props =
					strats.methods =
					strats.computed = function (parentVal, childVal) {
					  if (!childVal) { return parentVal }
					  if (!parentVal) { return childVal }
					  var ret = Object.create(null);
					  extend(ret, parentVal);
					  extend(ret, childVal);
					  return ret
					};

					/**
					 * Default strategy.
					 */
					var defaultStrat = function (parentVal, childVal) {
					  return childVal === undefined
					    ? parentVal
					    : childVal
					};

					/**
					 * Validate component names
					 */
					function checkComponents (options) {
					  for (var key in options.components) {
					    var lower = key.toLowerCase();
					    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {
					      warn(
					        'Do not use built-in or reserved HTML elements as component ' +
					        'id: ' + key
					      );
					    }
					  }
					}

					/**
					 * Ensure all props option syntax are normalized into the
					 * Object-based format.
					 */
					function normalizeProps (options) {
					  var props = options.props;
					  if (!props) { return }
					  var res = {};
					  var i, val, name;
					  if (Array.isArray(props)) {
					    i = props.length;
					    while (i--) {
					      val = props[i];
					      if (typeof val === 'string') {
					        name = camelize(val);
					        res[name] = { type: null };
					      } else {
					        warn('props must be strings when using array syntax.');
					      }
					    }
					  } else if (isPlainObject(props)) {
					    for (var key in props) {
					      val = props[key];
					      name = camelize(key);
					      res[name] = isPlainObject(val)
					        ? val
					        : { type: val };
					    }
					  }
					  options.props = res;
					}

					/**
					 * Normalize raw function directives into object format.
					 */
					function normalizeDirectives (options) {
					  var dirs = options.directives;
					  if (dirs) {
					    for (var key in dirs) {
					      var def = dirs[key];
					      if (typeof def === 'function') {
					        dirs[key] = { bind: def, update: def };
					      }
					    }
					  }
					}

					/**
					 * Merge two option objects into a new one.
					 * Core utility used in both instantiation and inheritance.
					 */
					function mergeOptions (
					  parent,
					  child,
					  vm
					) {
					  {
					    checkComponents(child);
					  }
					  normalizeProps(child);
					  normalizeDirectives(child);
					  var extendsFrom = child.extends;
					  if (extendsFrom) {
					    parent = typeof extendsFrom === 'function'
					      ? mergeOptions(parent, extendsFrom.options, vm)
					      : mergeOptions(parent, extendsFrom, vm);
					  }
					  if (child.mixins) {
					    for (var i = 0, l = child.mixins.length; i < l; i++) {
					      var mixin = child.mixins[i];
					      if (mixin.prototype instanceof Vue$2) {
					        mixin = mixin.options;
					      }
					      parent = mergeOptions(parent, mixin, vm);
					    }
					  }
					  var options = {};
					  var key;
					  for (key in parent) {
					    mergeField(key);
					  }
					  for (key in child) {
					    if (!hasOwn(parent, key)) {
					      mergeField(key);
					    }
					  }
					  function mergeField (key) {
					    var strat = strats[key] || defaultStrat;
					    options[key] = strat(parent[key], child[key], vm, key);
					  }
					  return options
					}

					/**
					 * Resolve an asset.
					 * This function is used because child instances need access
					 * to assets defined in its ancestor chain.
					 */
					function resolveAsset (
					  options,
					  type,
					  id,
					  warnMissing
					) {
					  /* istanbul ignore if */
					  if (typeof id !== 'string') {
					    return
					  }
					  var assets = options[type];
					  var res = assets[id] ||
					    // camelCase ID
					    assets[camelize(id)] ||
					    // Pascal Case ID
					    assets[capitalize(camelize(id))];
					  if ("development" !== 'production' && warnMissing && !res) {
					    warn(
					      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,
					      options
					    );
					  }
					  return res
					}

					/*  */

					function validateProp (
					  key,
					  propOptions,
					  propsData,
					  vm
					) {
					  var prop = propOptions[key];
					  var absent = !hasOwn(propsData, key);
					  var value = propsData[key];
					  // handle boolean props
					  if (isBooleanType(prop.type)) {
					    if (absent && !hasOwn(prop, 'default')) {
					      value = false;
					    } else if (value === '' || value === hyphenate(key)) {
					      value = true;
					    }
					  }
					  // check default value
					  if (value === undefined) {
					    value = getPropDefaultValue(vm, prop, key);
					    // since the default value is a fresh copy,
					    // make sure to observe it.
					    var prevShouldConvert = observerState.shouldConvert;
					    observerState.shouldConvert = true;
					    observe(value);
					    observerState.shouldConvert = prevShouldConvert;
					  }
					  {
					    assertProp(prop, key, value, vm, absent);
					  }
					  return value
					}

					/**
					 * Get the default value of a prop.
					 */
					function getPropDefaultValue (vm, prop, key) {
					  // no default, return undefined
					  if (!hasOwn(prop, 'default')) {
					    return undefined
					  }
					  var def = prop.default;
					  // warn against non-factory defaults for Object & Array
					  if (isObject(def)) {
					    "development" !== 'production' && warn(
					      'Invalid default value for prop "' + key + '": ' +
					      'Props with type Object/Array must use a factory function ' +
					      'to return the default value.',
					      vm
					    );
					  }
					  // the raw prop value was also undefined from previous render,
					  // return previous default value to avoid unnecessary watcher trigger
					  if (vm && vm.$options.propsData &&
					    vm.$options.propsData[key] === undefined &&
					    vm[key] !== undefined) {
					    return vm[key]
					  }
					  // call factory function for non-Function types
					  return typeof def === 'function' && prop.type !== Function
					    ? def.call(vm)
					    : def
					}

					/**
					 * Assert whether a prop is valid.
					 */
					function assertProp (
					  prop,
					  name,
					  value,
					  vm,
					  absent
					) {
					  if (prop.required && absent) {
					    warn(
					      'Missing required prop: "' + name + '"',
					      vm
					    );
					    return
					  }
					  if (value == null && !prop.required) {
					    return
					  }
					  var type = prop.type;
					  var valid = !type || type === true;
					  var expectedTypes = [];
					  if (type) {
					    if (!Array.isArray(type)) {
					      type = [type];
					    }
					    for (var i = 0; i < type.length && !valid; i++) {
					      var assertedType = assertType(value, type[i]);
					      expectedTypes.push(assertedType.expectedType);
					      valid = assertedType.valid;
					    }
					  }
					  if (!valid) {
					    warn(
					      'Invalid prop: type check failed for prop "' + name + '".' +
					      ' Expected ' + expectedTypes.map(capitalize).join(', ') +
					      ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.',
					      vm
					    );
					    return
					  }
					  var validator = prop.validator;
					  if (validator) {
					    if (!validator(value)) {
					      warn(
					        'Invalid prop: custom validator check failed for prop "' + name + '".',
					        vm
					      );
					    }
					  }
					}

					/**
					 * Assert the type of a value
					 */
					function assertType (value, type) {
					  var valid;
					  var expectedType = getType(type);
					  if (expectedType === 'String') {
					    valid = typeof value === (expectedType = 'string');
					  } else if (expectedType === 'Number') {
					    valid = typeof value === (expectedType = 'number');
					  } else if (expectedType === 'Boolean') {
					    valid = typeof value === (expectedType = 'boolean');
					  } else if (expectedType === 'Function') {
					    valid = typeof value === (expectedType = 'function');
					  } else if (expectedType === 'Object') {
					    valid = isPlainObject(value);
					  } else if (expectedType === 'Array') {
					    valid = Array.isArray(value);
					  } else {
					    valid = value instanceof type;
					  }
					  return {
					    valid: valid,
					    expectedType: expectedType
					  }
					}

					/**
					 * Use function string name to check built-in types,
					 * because a simple equality check will fail when running
					 * across different vms / iframes.
					 */
					function getType (fn) {
					  var match = fn && fn.toString().match(/^\s*function (\w+)/);
					  return match && match[1]
					}

					function isBooleanType (fn) {
					  if (!Array.isArray(fn)) {
					    return getType(fn) === 'Boolean'
					  }
					  for (var i = 0, len = fn.length; i < len; i++) {
					    if (getType(fn[i]) === 'Boolean') {
					      return true
					    }
					  }
					  /* istanbul ignore next */
					  return false
					}



					var util = Object.freeze({
						defineReactive: defineReactive$$1,
						_toString: _toString,
						toNumber: toNumber,
						makeMap: makeMap,
						isBuiltInTag: isBuiltInTag,
						remove: remove$1,
						hasOwn: hasOwn,
						isPrimitive: isPrimitive,
						cached: cached,
						camelize: camelize,
						capitalize: capitalize,
						hyphenate: hyphenate,
						bind: bind$1,
						toArray: toArray,
						extend: extend,
						isObject: isObject,
						isPlainObject: isPlainObject,
						toObject: toObject,
						noop: noop,
						no: no,
						genStaticKeys: genStaticKeys,
						looseEqual: looseEqual,
						looseIndexOf: looseIndexOf,
						isReserved: isReserved,
						def: def,
						parsePath: parsePath,
						hasProto: hasProto,
						inBrowser: inBrowser,
						UA: UA,
						isIE: isIE,
						isIE9: isIE9,
						isEdge: isEdge,
						isAndroid: isAndroid,
						isIOS: isIOS,
						devtools: devtools,
						nextTick: nextTick,
						get _Set () { return _Set; },
						mergeOptions: mergeOptions,
						resolveAsset: resolveAsset,
						get warn () { return warn; },
						get formatComponentName () { return formatComponentName; },
						validateProp: validateProp
					});

					/*  */

					function initUse (Vue) {
					  Vue.use = function (plugin) {
					    /* istanbul ignore if */
					    if (plugin.installed) {
					      return
					    }
					    // additional parameters
					    var args = toArray(arguments, 1);
					    args.unshift(this);
					    if (typeof plugin.install === 'function') {
					      plugin.install.apply(plugin, args);
					    } else {
					      plugin.apply(null, args);
					    }
					    plugin.installed = true;
					    return this
					  };
					}

					/*  */

					function initMixin$1 (Vue) {
					  Vue.mixin = function (mixin) {
					    Vue.options = mergeOptions(Vue.options, mixin);
					  };
					}

					/*  */

					function initExtend (Vue) {
					  /**
					   * Each instance constructor, including Vue, has a unique
					   * cid. This enables us to create wrapped "child
					   * constructors" for prototypal inheritance and cache them.
					   */
					  Vue.cid = 0;
					  var cid = 1;

					  /**
					   * Class inheritance
					   */
					  Vue.extend = function (extendOptions) {
					    extendOptions = extendOptions || {};
					    var Super = this;
					    var isFirstExtend = Super.cid === 0;
					    if (isFirstExtend && extendOptions._Ctor) {
					      return extendOptions._Ctor
					    }
					    var name = extendOptions.name || Super.options.name;
					    {
					      if (!/^[a-zA-Z][\w-]*$/.test(name)) {
					        warn(
					          'Invalid component name: "' + name + '". Component names ' +
					          'can only contain alphanumeric characaters and the hyphen.'
					        );
					      }
					    }
					    var Sub = function VueComponent (options) {
					      this._init(options);
					    };
					    Sub.prototype = Object.create(Super.prototype);
					    Sub.prototype.constructor = Sub;
					    Sub.cid = cid++;
					    Sub.options = mergeOptions(
					      Super.options,
					      extendOptions
					    );
					    Sub['super'] = Super;
					    // allow further extension
					    Sub.extend = Super.extend;
					    // create asset registers, so extended classes
					    // can have their private assets too.
					    config._assetTypes.forEach(function (type) {
					      Sub[type] = Super[type];
					    });
					    // enable recursive self-lookup
					    if (name) {
					      Sub.options.components[name] = Sub;
					    }
					    // keep a reference to the super options at extension time.
					    // later at instantiation we can check if Super's options have
					    // been updated.
					    Sub.superOptions = Super.options;
					    Sub.extendOptions = extendOptions;
					    // cache constructor
					    if (isFirstExtend) {
					      extendOptions._Ctor = Sub;
					    }
					    return Sub
					  };
					}

					/*  */

					function initAssetRegisters (Vue) {
					  /**
					   * Create asset registration methods.
					   */
					  config._assetTypes.forEach(function (type) {
					    Vue[type] = function (
					      id,
					      definition
					    ) {
					      if (!definition) {
					        return this.options[type + 's'][id]
					      } else {
					        /* istanbul ignore if */
					        {
					          if (type === 'component' && config.isReservedTag(id)) {
					            warn(
					              'Do not use built-in or reserved HTML elements as component ' +
					              'id: ' + id
					            );
					          }
					        }
					        if (type === 'component' && isPlainObject(definition)) {
					          definition.name = definition.name || id;
					          definition = Vue.extend(definition);
					        }
					        if (type === 'directive' && typeof definition === 'function') {
					          definition = { bind: definition, update: definition };
					        }
					        this.options[type + 's'][id] = definition;
					        return definition
					      }
					    };
					  });
					}

					var KeepAlive = {
					  name: 'keep-alive',
					  abstract: true,
					  created: function created () {
					    this.cache = Object.create(null);
					  },
					  render: function render () {
					    var vnode = getFirstComponentChild(this.$slots.default);
					    if (vnode && vnode.componentOptions) {
					      var opts = vnode.componentOptions;
					      var key = vnode.key == null
					        // same constructor may get registered as different local components
					        // so cid alone is not enough (#3269)
					        ? opts.Ctor.cid + '::' + opts.tag
					        : vnode.key;
					      if (this.cache[key]) {
					        vnode.child = this.cache[key].child;
					      } else {
					        this.cache[key] = vnode;
					      }
					      vnode.data.keepAlive = true;
					    }
					    return vnode
					  },
					  destroyed: function destroyed () {
					    var this$1 = this;

					    for (var key in this.cache) {
					      var vnode = this$1.cache[key];
					      callHook(vnode.child, 'deactivated');
					      vnode.child.$destroy();
					    }
					  }
					};

					var builtInComponents = {
					  KeepAlive: KeepAlive
					};

					/*  */

					function initGlobalAPI (Vue) {
					  // config
					  var configDef = {};
					  configDef.get = function () { return config; };
					  {
					    configDef.set = function () {
					      warn(
					        'Do not replace the Vue.config object, set individual fields instead.'
					      );
					    };
					  }
					  Object.defineProperty(Vue, 'config', configDef);
					  Vue.util = util;
					  Vue.set = set;
					  Vue.delete = del;
					  Vue.nextTick = nextTick;

					  Vue.options = Object.create(null);
					  config._assetTypes.forEach(function (type) {
					    Vue.options[type + 's'] = Object.create(null);
					  });

					  extend(Vue.options.components, builtInComponents);

					  initUse(Vue);
					  initMixin$1(Vue);
					  initExtend(Vue);
					  initAssetRegisters(Vue);
					}

					initGlobalAPI(Vue$2);

					Object.defineProperty(Vue$2.prototype, '$isServer', {
					  get: function () { return config._isServer; }
					});

					Vue$2.version = '2.0.5';

					/*  */

					// attributes that should be using props for binding
					var mustUseProp = makeMap('value,selected,checked,muted');

					var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');

					var isBooleanAttr = makeMap(
					  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +
					  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +
					  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +
					  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +
					  'required,reversed,scoped,seamless,selected,sortable,translate,' +
					  'truespeed,typemustmatch,visible'
					);

					var isAttr = makeMap(
					  'accept,accept-charset,accesskey,action,align,alt,async,autocomplete,' +
					  'autofocus,autoplay,autosave,bgcolor,border,buffered,challenge,charset,' +
					  'checked,cite,class,code,codebase,color,cols,colspan,content,http-equiv,' +
					  'name,contenteditable,contextmenu,controls,coords,data,datetime,default,' +
					  'defer,dir,dirname,disabled,download,draggable,dropzone,enctype,method,for,' +
					  'form,formaction,headers,<th>,height,hidden,high,href,hreflang,http-equiv,' +
					  'icon,id,ismap,itemprop,keytype,kind,label,lang,language,list,loop,low,' +
					  'manifest,max,maxlength,media,method,GET,POST,min,multiple,email,file,' +
					  'muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,' +
					  'preload,radiogroup,readonly,rel,required,reversed,rows,rowspan,sandbox,' +
					  'scope,scoped,seamless,selected,shape,size,type,text,password,sizes,span,' +
					  'spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,' +
					  'target,title,type,usemap,value,width,wrap'
					);



					var xlinkNS = 'http://www.w3.org/1999/xlink';

					var isXlink = function (name) {
					  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'
					};

					var getXlinkProp = function (name) {
					  return isXlink(name) ? name.slice(6, name.length) : ''
					};

					var isFalsyAttrValue = function (val) {
					  return val == null || val === false
					};

					/*  */

					function genClassForVnode (vnode) {
					  var data = vnode.data;
					  var parentNode = vnode;
					  var childNode = vnode;
					  while (childNode.child) {
					    childNode = childNode.child._vnode;
					    if (childNode.data) {
					      data = mergeClassData(childNode.data, data);
					    }
					  }
					  while ((parentNode = parentNode.parent)) {
					    if (parentNode.data) {
					      data = mergeClassData(data, parentNode.data);
					    }
					  }
					  return genClassFromData(data)
					}

					function mergeClassData (child, parent) {
					  return {
					    staticClass: concat(child.staticClass, parent.staticClass),
					    class: child.class
					      ? [child.class, parent.class]
					      : parent.class
					  }
					}

					function genClassFromData (data) {
					  var dynamicClass = data.class;
					  var staticClass = data.staticClass;
					  if (staticClass || dynamicClass) {
					    return concat(staticClass, stringifyClass(dynamicClass))
					  }
					  /* istanbul ignore next */
					  return ''
					}

					function concat (a, b) {
					  return a ? b ? (a + ' ' + b) : a : (b || '')
					}

					function stringifyClass (value) {
					  var res = '';
					  if (!value) {
					    return res
					  }
					  if (typeof value === 'string') {
					    return value
					  }
					  if (Array.isArray(value)) {
					    var stringified;
					    for (var i = 0, l = value.length; i < l; i++) {
					      if (value[i]) {
					        if ((stringified = stringifyClass(value[i]))) {
					          res += stringified + ' ';
					        }
					      }
					    }
					    return res.slice(0, -1)
					  }
					  if (isObject(value)) {
					    for (var key in value) {
					      if (value[key]) { res += key + ' '; }
					    }
					    return res.slice(0, -1)
					  }
					  /* istanbul ignore next */
					  return res
					}

					/*  */

					var namespaceMap = {
					  svg: 'http://www.w3.org/2000/svg',
					  math: 'http://www.w3.org/1998/Math/MathML',
					  xhtml: 'http://www.w3.org/1999/xhtm'
					};

					var isHTMLTag = makeMap(
					  'html,body,base,head,link,meta,style,title,' +
					  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +
					  'div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,' +
					  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +
					  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +
					  'embed,object,param,source,canvas,script,noscript,del,ins,' +
					  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +
					  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +
					  'output,progress,select,textarea,' +
					  'details,dialog,menu,menuitem,summary,' +
					  'content,element,shadow,template'
					);

					var isUnaryTag = makeMap(
					  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +
					  'link,meta,param,source,track,wbr',
					  true
					);

					// Elements that you can, intentionally, leave open
					// (and which close themselves)
					var canBeLeftOpenTag = makeMap(
					  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source',
					  true
					);

					// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
					// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content
					var isNonPhrasingTag = makeMap(
					  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +
					  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +
					  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +
					  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +
					  'title,tr,track',
					  true
					);

					// this map is intentionally selective, only covering SVG elements that may
					// contain child elements.
					var isSVG = makeMap(
					  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font,' +
					  'font-face,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +
					  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',
					  true
					);

					var isPreTag = function (tag) { return tag === 'pre'; };

					var isReservedTag = function (tag) {
					  return isHTMLTag(tag) || isSVG(tag)
					};

					function getTagNamespace (tag) {
					  if (isSVG(tag)) {
					    return 'svg'
					  }
					  // basic support for MathML
					  // note it doesn't support other MathML elements being component roots
					  if (tag === 'math') {
					    return 'math'
					  }
					}

					var unknownElementCache = Object.create(null);
					function isUnknownElement (tag) {
					  /* istanbul ignore if */
					  if (!inBrowser) {
					    return true
					  }
					  if (isReservedTag(tag)) {
					    return false
					  }
					  tag = tag.toLowerCase();
					  /* istanbul ignore if */
					  if (unknownElementCache[tag] != null) {
					    return unknownElementCache[tag]
					  }
					  var el = document.createElement(tag);
					  if (tag.indexOf('-') > -1) {
					    // http://stackoverflow.com/a/28210364/1070244
					    return (unknownElementCache[tag] = (
					      el.constructor === window.HTMLUnknownElement ||
					      el.constructor === window.HTMLElement
					    ))
					  } else {
					    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))
					  }
					}

					/*  */

					/**
					 * Query an element selector if it's not an element already.
					 */
					function query (el) {
					  if (typeof el === 'string') {
					    var selector = el;
					    el = document.querySelector(el);
					    if (!el) {
					      "development" !== 'production' && warn(
					        'Cannot find element: ' + selector
					      );
					      return document.createElement('div')
					    }
					  }
					  return el
					}

					/*  */

					function createElement$1 (tagName, vnode) {
					  var elm = document.createElement(tagName);
					  if (tagName !== 'select') {
					    return elm
					  }
					  if (vnode.data && vnode.data.attrs && 'multiple' in vnode.data.attrs) {
					    elm.setAttribute('multiple', 'multiple');
					  }
					  return elm
					}

					function createElementNS (namespace, tagName) {
					  return document.createElementNS(namespaceMap[namespace], tagName)
					}

					function createTextNode (text) {
					  return document.createTextNode(text)
					}

					function createComment (text) {
					  return document.createComment(text)
					}

					function insertBefore (parentNode, newNode, referenceNode) {
					  parentNode.insertBefore(newNode, referenceNode);
					}

					function removeChild (node, child) {
					  node.removeChild(child);
					}

					function appendChild (node, child) {
					  node.appendChild(child);
					}

					function parentNode (node) {
					  return node.parentNode
					}

					function nextSibling (node) {
					  return node.nextSibling
					}

					function tagName (node) {
					  return node.tagName
					}

					function setTextContent (node, text) {
					  node.textContent = text;
					}

					function childNodes (node) {
					  return node.childNodes
					}

					function setAttribute (node, key, val) {
					  node.setAttribute(key, val);
					}


					var nodeOps = Object.freeze({
						createElement: createElement$1,
						createElementNS: createElementNS,
						createTextNode: createTextNode,
						createComment: createComment,
						insertBefore: insertBefore,
						removeChild: removeChild,
						appendChild: appendChild,
						parentNode: parentNode,
						nextSibling: nextSibling,
						tagName: tagName,
						setTextContent: setTextContent,
						childNodes: childNodes,
						setAttribute: setAttribute
					});

					/*  */

					var ref = {
					  create: function create (_, vnode) {
					    registerRef(vnode);
					  },
					  update: function update (oldVnode, vnode) {
					    if (oldVnode.data.ref !== vnode.data.ref) {
					      registerRef(oldVnode, true);
					      registerRef(vnode);
					    }
					  },
					  destroy: function destroy (vnode) {
					    registerRef(vnode, true);
					  }
					};

					function registerRef (vnode, isRemoval) {
					  var key = vnode.data.ref;
					  if (!key) { return }

					  var vm = vnode.context;
					  var ref = vnode.child || vnode.elm;
					  var refs = vm.$refs;
					  if (isRemoval) {
					    if (Array.isArray(refs[key])) {
					      remove$1(refs[key], ref);
					    } else if (refs[key] === ref) {
					      refs[key] = undefined;
					    }
					  } else {
					    if (vnode.data.refInFor) {
					      if (Array.isArray(refs[key])) {
					        refs[key].push(ref);
					      } else {
					        refs[key] = [ref];
					      }
					    } else {
					      refs[key] = ref;
					    }
					  }
					}

					/**
					 * Virtual DOM patching algorithm based on Snabbdom by
					 * Simon Friis Vindum (@paldepind)
					 * Licensed under the MIT License
					 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
					 *
					 * modified by Evan You (@yyx990803)
					 *

					/*
					 * Not type-checking this because this file is perf-critical and the cost
					 * of making flow understand it is not worth it.
					 */

					var emptyNode = new VNode('', {}, []);

					var hooks$1 = ['create', 'update', 'remove', 'destroy'];

					function isUndef (s) {
					  return s == null
					}

					function isDef (s) {
					  return s != null
					}

					function sameVnode (vnode1, vnode2) {
					  return (
					    vnode1.key === vnode2.key &&
					    vnode1.tag === vnode2.tag &&
					    vnode1.isComment === vnode2.isComment &&
					    !vnode1.data === !vnode2.data
					  )
					}

					function createKeyToOldIdx (children, beginIdx, endIdx) {
					  var i, key;
					  var map = {};
					  for (i = beginIdx; i <= endIdx; ++i) {
					    key = children[i].key;
					    if (isDef(key)) { map[key] = i; }
					  }
					  return map
					}

					function createPatchFunction (backend) {
					  var i, j;
					  var cbs = {};

					  var modules = backend.modules;
					  var nodeOps = backend.nodeOps;

					  for (i = 0; i < hooks$1.length; ++i) {
					    cbs[hooks$1[i]] = [];
					    for (j = 0; j < modules.length; ++j) {
					      if (modules[j][hooks$1[i]] !== undefined) { cbs[hooks$1[i]].push(modules[j][hooks$1[i]]); }
					    }
					  }

					  function emptyNodeAt (elm) {
					    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)
					  }

					  function createRmCb (childElm, listeners) {
					    function remove$$1 () {
					      if (--remove$$1.listeners === 0) {
					        removeElement(childElm);
					      }
					    }
					    remove$$1.listeners = listeners;
					    return remove$$1
					  }

					  function removeElement (el) {
					    var parent = nodeOps.parentNode(el);
					    // element may have already been removed due to v-html
					    if (parent) {
					      nodeOps.removeChild(parent, el);
					    }
					  }

					  function createElm (vnode, insertedVnodeQueue, nested) {
					    var i;
					    var data = vnode.data;
					    vnode.isRootInsert = !nested;
					    if (isDef(data)) {
					      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode); }
					      // after calling the init hook, if the vnode is a child component
					      // it should've created a child instance and mounted it. the child
					      // component also has set the placeholder vnode's elm.
					      // in that case we can just return the element and be done.
					      if (isDef(i = vnode.child)) {
					        initComponent(vnode, insertedVnodeQueue);
					        return vnode.elm
					      }
					    }
					    var children = vnode.children;
					    var tag = vnode.tag;
					    if (isDef(tag)) {
					      {
					        if (
					          !vnode.ns &&
					          !(config.ignoredElements && config.ignoredElements.indexOf(tag) > -1) &&
					          config.isUnknownElement(tag)
					        ) {
					          warn(
					            'Unknown custom element: <' + tag + '> - did you ' +
					            'register the component correctly? For recursive components, ' +
					            'make sure to provide the "name" option.',
					            vnode.context
					          );
					        }
					      }
					      vnode.elm = vnode.ns
					        ? nodeOps.createElementNS(vnode.ns, tag)
					        : nodeOps.createElement(tag, vnode);
					      setScope(vnode);
					      createChildren(vnode, children, insertedVnodeQueue);
					      if (isDef(data)) {
					        invokeCreateHooks(vnode, insertedVnodeQueue);
					      }
					    } else if (vnode.isComment) {
					      vnode.elm = nodeOps.createComment(vnode.text);
					    } else {
					      vnode.elm = nodeOps.createTextNode(vnode.text);
					    }
					    return vnode.elm
					  }

					  function createChildren (vnode, children, insertedVnodeQueue) {
					    if (Array.isArray(children)) {
					      for (var i = 0; i < children.length; ++i) {
					        nodeOps.appendChild(vnode.elm, createElm(children[i], insertedVnodeQueue, true));
					      }
					    } else if (isPrimitive(vnode.text)) {
					      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));
					    }
					  }

					  function isPatchable (vnode) {
					    while (vnode.child) {
					      vnode = vnode.child._vnode;
					    }
					    return isDef(vnode.tag)
					  }

					  function invokeCreateHooks (vnode, insertedVnodeQueue) {
					    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
					      cbs.create[i$1](emptyNode, vnode);
					    }
					    i = vnode.data.hook; // Reuse variable
					    if (isDef(i)) {
					      if (i.create) { i.create(emptyNode, vnode); }
					      if (i.insert) { insertedVnodeQueue.push(vnode); }
					    }
					  }

					  function initComponent (vnode, insertedVnodeQueue) {
					    if (vnode.data.pendingInsert) {
					      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
					    }
					    vnode.elm = vnode.child.$el;
					    if (isPatchable(vnode)) {
					      invokeCreateHooks(vnode, insertedVnodeQueue);
					      setScope(vnode);
					    } else {
					      // empty component root.
					      // skip all element-related modules except for ref (#3455)
					      registerRef(vnode);
					      // make sure to invoke the insert hook
					      insertedVnodeQueue.push(vnode);
					    }
					  }

					  // set scope id attribute for scoped CSS.
					  // this is implemented as a special case to avoid the overhead
					  // of going through the normal attribute patching process.
					  function setScope (vnode) {
					    var i;
					    if (isDef(i = vnode.context) && isDef(i = i.$options._scopeId)) {
					      nodeOps.setAttribute(vnode.elm, i, '');
					    }
					    if (isDef(i = activeInstance) &&
					        i !== vnode.context &&
					        isDef(i = i.$options._scopeId)) {
					      nodeOps.setAttribute(vnode.elm, i, '');
					    }
					  }

					  function addVnodes (parentElm, before, vnodes, startIdx, endIdx, insertedVnodeQueue) {
					    for (; startIdx <= endIdx; ++startIdx) {
					      nodeOps.insertBefore(parentElm, createElm(vnodes[startIdx], insertedVnodeQueue), before);
					    }
					  }

					  function invokeDestroyHook (vnode) {
					    var i, j;
					    var data = vnode.data;
					    if (isDef(data)) {
					      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }
					      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }
					    }
					    if (isDef(i = vnode.children)) {
					      for (j = 0; j < vnode.children.length; ++j) {
					        invokeDestroyHook(vnode.children[j]);
					      }
					    }
					  }

					  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {
					    for (; startIdx <= endIdx; ++startIdx) {
					      var ch = vnodes[startIdx];
					      if (isDef(ch)) {
					        if (isDef(ch.tag)) {
					          removeAndInvokeRemoveHook(ch);
					          invokeDestroyHook(ch);
					        } else { // Text node
					          nodeOps.removeChild(parentElm, ch.elm);
					        }
					      }
					    }
					  }

					  function removeAndInvokeRemoveHook (vnode, rm) {
					    if (rm || isDef(vnode.data)) {
					      var listeners = cbs.remove.length + 1;
					      if (!rm) {
					        // directly removing
					        rm = createRmCb(vnode.elm, listeners);
					      } else {
					        // we have a recursively passed down rm callback
					        // increase the listeners count
					        rm.listeners += listeners;
					      }
					      // recursively invoke hooks on child component root node
					      if (isDef(i = vnode.child) && isDef(i = i._vnode) && isDef(i.data)) {
					        removeAndInvokeRemoveHook(i, rm);
					      }
					      for (i = 0; i < cbs.remove.length; ++i) {
					        cbs.remove[i](vnode, rm);
					      }
					      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
					        i(vnode, rm);
					      } else {
					        rm();
					      }
					    } else {
					      removeElement(vnode.elm);
					    }
					  }

					  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
					    var oldStartIdx = 0;
					    var newStartIdx = 0;
					    var oldEndIdx = oldCh.length - 1;
					    var oldStartVnode = oldCh[0];
					    var oldEndVnode = oldCh[oldEndIdx];
					    var newEndIdx = newCh.length - 1;
					    var newStartVnode = newCh[0];
					    var newEndVnode = newCh[newEndIdx];
					    var oldKeyToIdx, idxInOld, elmToMove, before;

					    // removeOnly is a special flag used only by <transition-group>
					    // to ensure removed elements stay in correct relative positions
					    // during leaving transitions
					    var canMove = !removeOnly;

					    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
					      if (isUndef(oldStartVnode)) {
					        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
					      } else if (isUndef(oldEndVnode)) {
					        oldEndVnode = oldCh[--oldEndIdx];
					      } else if (sameVnode(oldStartVnode, newStartVnode)) {
					        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
					        oldStartVnode = oldCh[++oldStartIdx];
					        newStartVnode = newCh[++newStartIdx];
					      } else if (sameVnode(oldEndVnode, newEndVnode)) {
					        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
					        oldEndVnode = oldCh[--oldEndIdx];
					        newEndVnode = newCh[--newEndIdx];
					      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
					        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
					        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
					        oldStartVnode = oldCh[++oldStartIdx];
					        newEndVnode = newCh[--newEndIdx];
					      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
					        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
					        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
					        oldEndVnode = oldCh[--oldEndIdx];
					        newStartVnode = newCh[++newStartIdx];
					      } else {
					        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }
					        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;
					        if (isUndef(idxInOld)) { // New element
					          nodeOps.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
					          newStartVnode = newCh[++newStartIdx];
					        } else {
					          elmToMove = oldCh[idxInOld];
					          /* istanbul ignore if */
					          if ("development" !== 'production' && !elmToMove) {
					            warn(
					              'It seems there are duplicate keys that is causing an update error. ' +
					              'Make sure each v-for item has a unique key.'
					            );
					          }
					          if (elmToMove.tag !== newStartVnode.tag) {
					            // same key but different element. treat as new element
					            nodeOps.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);
					            newStartVnode = newCh[++newStartIdx];
					          } else {
					            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
					            oldCh[idxInOld] = undefined;
					            canMove && nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);
					            newStartVnode = newCh[++newStartIdx];
					          }
					        }
					      }
					    }
					    if (oldStartIdx > oldEndIdx) {
					      before = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
					      addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
					    } else if (newStartIdx > newEndIdx) {
					      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
					    }
					  }

					  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {
					    if (oldVnode === vnode) {
					      return
					    }
					    // reuse element for static trees.
					    // note we only do this if the vnode is cloned -
					    // if the new node is not cloned it means the render functions have been
					    // reset by the hot-reload-api and we need to do a proper re-render.
					    if (vnode.isStatic &&
					        oldVnode.isStatic &&
					        vnode.key === oldVnode.key &&
					        (vnode.isCloned || vnode.isOnce)) {
					      vnode.elm = oldVnode.elm;
					      return
					    }
					    var i;
					    var data = vnode.data;
					    var hasData = isDef(data);
					    if (hasData && isDef(i = data.hook) && isDef(i = i.prepatch)) {
					      i(oldVnode, vnode);
					    }
					    var elm = vnode.elm = oldVnode.elm;
					    var oldCh = oldVnode.children;
					    var ch = vnode.children;
					    if (hasData && isPatchable(vnode)) {
					      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }
					      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }
					    }
					    if (isUndef(vnode.text)) {
					      if (isDef(oldCh) && isDef(ch)) {
					        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }
					      } else if (isDef(ch)) {
					        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }
					        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
					      } else if (isDef(oldCh)) {
					        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
					      } else if (isDef(oldVnode.text)) {
					        nodeOps.setTextContent(elm, '');
					      }
					    } else if (oldVnode.text !== vnode.text) {
					      nodeOps.setTextContent(elm, vnode.text);
					    }
					    if (hasData) {
					      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }
					    }
					  }

					  function invokeInsertHook (vnode, queue, initial) {
					    // delay insert hooks for component root nodes, invoke them after the
					    // element is really inserted
					    if (initial && vnode.parent) {
					      vnode.parent.data.pendingInsert = queue;
					    } else {
					      for (var i = 0; i < queue.length; ++i) {
					        queue[i].data.hook.insert(queue[i]);
					      }
					    }
					  }

					  var bailed = false;
					  function hydrate (elm, vnode, insertedVnodeQueue) {
					    {
					      if (!assertNodeMatch(elm, vnode)) {
					        return false
					      }
					    }
					    vnode.elm = elm;
					    var tag = vnode.tag;
					    var data = vnode.data;
					    var children = vnode.children;
					    if (isDef(data)) {
					      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }
					      if (isDef(i = vnode.child)) {
					        // child component. it should have hydrated its own tree.
					        initComponent(vnode, insertedVnodeQueue);
					        return true
					      }
					    }
					    if (isDef(tag)) {
					      if (isDef(children)) {
					        var childNodes = nodeOps.childNodes(elm);
					        // empty element, allow client to pick up and populate children
					        if (!childNodes.length) {
					          createChildren(vnode, children, insertedVnodeQueue);
					        } else {
					          var childrenMatch = true;
					          if (childNodes.length !== children.length) {
					            childrenMatch = false;
					          } else {
					            for (var i$1 = 0; i$1 < children.length; i$1++) {
					              if (!hydrate(childNodes[i$1], children[i$1], insertedVnodeQueue)) {
					                childrenMatch = false;
					                break
					              }
					            }
					          }
					          if (!childrenMatch) {
					            if ("development" !== 'production' &&
					                typeof console !== 'undefined' &&
					                !bailed) {
					              bailed = true;
					              console.warn('Parent: ', elm);
					              console.warn('Mismatching childNodes vs. VNodes: ', childNodes, children);
					            }
					            return false
					          }
					        }
					      }
					      if (isDef(data)) {
					        invokeCreateHooks(vnode, insertedVnodeQueue);
					      }
					    }
					    return true
					  }

					  function assertNodeMatch (node, vnode) {
					    if (vnode.tag) {
					      return (
					        vnode.tag.indexOf('vue-component') === 0 ||
					        vnode.tag === nodeOps.tagName(node).toLowerCase()
					      )
					    } else {
					      return _toString(vnode.text) === node.data
					    }
					  }

					  return function patch (oldVnode, vnode, hydrating, removeOnly) {
					    if (!vnode) {
					      if (oldVnode) { invokeDestroyHook(oldVnode); }
					      return
					    }

					    var elm, parent;
					    var isInitialPatch = false;
					    var insertedVnodeQueue = [];

					    if (!oldVnode) {
					      // empty mount, create new root element
					      isInitialPatch = true;
					      createElm(vnode, insertedVnodeQueue);
					    } else {
					      var isRealElement = isDef(oldVnode.nodeType);
					      if (!isRealElement && sameVnode(oldVnode, vnode)) {
					        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);
					      } else {
					        if (isRealElement) {
					          // mounting to a real element
					          // check if this is server-rendered content and if we can perform
					          // a successful hydration.
					          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute('server-rendered')) {
					            oldVnode.removeAttribute('server-rendered');
					            hydrating = true;
					          }
					          if (hydrating) {
					            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
					              invokeInsertHook(vnode, insertedVnodeQueue, true);
					              return oldVnode
					            } else {
					              warn(
					                'The client-side rendered virtual DOM tree is not matching ' +
					                'server-rendered content. This is likely caused by incorrect ' +
					                'HTML markup, for example nesting block-level elements inside ' +
					                '<p>, or missing <tbody>. Bailing hydration and performing ' +
					                'full client-side render.'
					              );
					            }
					          }
					          // either not server-rendered, or hydration failed.
					          // create an empty node and replace it
					          oldVnode = emptyNodeAt(oldVnode);
					        }
					        elm = oldVnode.elm;
					        parent = nodeOps.parentNode(elm);

					        createElm(vnode, insertedVnodeQueue);

					        // component root element replaced.
					        // update parent placeholder node element.
					        if (vnode.parent) {
					          vnode.parent.elm = vnode.elm;
					          if (isPatchable(vnode)) {
					            for (var i = 0; i < cbs.create.length; ++i) {
					              cbs.create[i](emptyNode, vnode.parent);
					            }
					          }
					        }

					        if (parent !== null) {
					          nodeOps.insertBefore(parent, vnode.elm, nodeOps.nextSibling(elm));
					          removeVnodes(parent, [oldVnode], 0, 0);
					        } else if (isDef(oldVnode.tag)) {
					          invokeDestroyHook(oldVnode);
					        }
					      }
					    }

					    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
					    return vnode.elm
					  }
					}

					/*  */

					var directives = {
					  create: updateDirectives,
					  update: updateDirectives,
					  destroy: function unbindDirectives (vnode) {
					    updateDirectives(vnode, emptyNode);
					  }
					};

					function updateDirectives (
					  oldVnode,
					  vnode
					) {
					  if (!oldVnode.data.directives && !vnode.data.directives) {
					    return
					  }
					  var isCreate = oldVnode === emptyNode;
					  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
					  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);

					  var dirsWithInsert = [];
					  var dirsWithPostpatch = [];

					  var key, oldDir, dir;
					  for (key in newDirs) {
					    oldDir = oldDirs[key];
					    dir = newDirs[key];
					    if (!oldDir) {
					      // new directive, bind
					      callHook$1(dir, 'bind', vnode, oldVnode);
					      if (dir.def && dir.def.inserted) {
					        dirsWithInsert.push(dir);
					      }
					    } else {
					      // existing directive, update
					      dir.oldValue = oldDir.value;
					      callHook$1(dir, 'update', vnode, oldVnode);
					      if (dir.def && dir.def.componentUpdated) {
					        dirsWithPostpatch.push(dir);
					      }
					    }
					  }

					  if (dirsWithInsert.length) {
					    var callInsert = function () {
					      dirsWithInsert.forEach(function (dir) {
					        callHook$1(dir, 'inserted', vnode, oldVnode);
					      });
					    };
					    if (isCreate) {
					      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert, 'dir-insert');
					    } else {
					      callInsert();
					    }
					  }

					  if (dirsWithPostpatch.length) {
					    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {
					      dirsWithPostpatch.forEach(function (dir) {
					        callHook$1(dir, 'componentUpdated', vnode, oldVnode);
					      });
					    }, 'dir-postpatch');
					  }

					  if (!isCreate) {
					    for (key in oldDirs) {
					      if (!newDirs[key]) {
					        // no longer present, unbind
					        callHook$1(oldDirs[key], 'unbind', oldVnode);
					      }
					    }
					  }
					}

					var emptyModifiers = Object.create(null);

					function normalizeDirectives$1 (
					  dirs,
					  vm
					) {
					  var res = Object.create(null);
					  if (!dirs) {
					    return res
					  }
					  var i, dir;
					  for (i = 0; i < dirs.length; i++) {
					    dir = dirs[i];
					    if (!dir.modifiers) {
					      dir.modifiers = emptyModifiers;
					    }
					    res[getRawDirName(dir)] = dir;
					    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
					  }
					  return res
					}

					function getRawDirName (dir) {
					  return dir.rawName || ((dir.name) + "." + (Object.keys(dir.modifiers || {}).join('.')))
					}

					function callHook$1 (dir, hook, vnode, oldVnode) {
					  var fn = dir.def && dir.def[hook];
					  if (fn) {
					    fn(vnode.elm, dir, vnode, oldVnode);
					  }
					}

					var baseModules = [
					  ref,
					  directives
					];

					/*  */

					function updateAttrs (oldVnode, vnode) {
					  if (!oldVnode.data.attrs && !vnode.data.attrs) {
					    return
					  }
					  var key, cur, old;
					  var elm = vnode.elm;
					  var oldAttrs = oldVnode.data.attrs || {};
					  var attrs = vnode.data.attrs || {};
					  // clone observed objects, as the user probably wants to mutate it
					  if (attrs.__ob__) {
					    attrs = vnode.data.attrs = extend({}, attrs);
					  }

					  for (key in attrs) {
					    cur = attrs[key];
					    old = oldAttrs[key];
					    if (old !== cur) {
					      setAttr(elm, key, cur);
					    }
					  }
					  for (key in oldAttrs) {
					    if (attrs[key] == null) {
					      if (isXlink(key)) {
					        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
					      } else if (!isEnumeratedAttr(key)) {
					        elm.removeAttribute(key);
					      }
					    }
					  }
					}

					function setAttr (el, key, value) {
					  if (isBooleanAttr(key)) {
					    // set attribute for blank value
					    // e.g. <option disabled>Select one</option>
					    if (isFalsyAttrValue(value)) {
					      el.removeAttribute(key);
					    } else {
					      el.setAttribute(key, key);
					    }
					  } else if (isEnumeratedAttr(key)) {
					    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');
					  } else if (isXlink(key)) {
					    if (isFalsyAttrValue(value)) {
					      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
					    } else {
					      el.setAttributeNS(xlinkNS, key, value);
					    }
					  } else {
					    if (isFalsyAttrValue(value)) {
					      el.removeAttribute(key);
					    } else {
					      el.setAttribute(key, value);
					    }
					  }
					}

					var attrs = {
					  create: updateAttrs,
					  update: updateAttrs
					};

					/*  */

					function updateClass (oldVnode, vnode) {
					  var el = vnode.elm;
					  var data = vnode.data;
					  var oldData = oldVnode.data;
					  if (!data.staticClass && !data.class &&
					      (!oldData || (!oldData.staticClass && !oldData.class))) {
					    return
					  }

					  var cls = genClassForVnode(vnode);

					  // handle transition classes
					  var transitionClass = el._transitionClasses;
					  if (transitionClass) {
					    cls = concat(cls, stringifyClass(transitionClass));
					  }

					  // set the class
					  if (cls !== el._prevClass) {
					    el.setAttribute('class', cls);
					    el._prevClass = cls;
					  }
					}

					var klass = {
					  create: updateClass,
					  update: updateClass
					};

					// skip type checking this file because we need to attach private properties
					// to elements

					function updateDOMListeners (oldVnode, vnode) {
					  if (!oldVnode.data.on && !vnode.data.on) {
					    return
					  }
					  var on = vnode.data.on || {};
					  var oldOn = oldVnode.data.on || {};
					  var add = vnode.elm._v_add || (vnode.elm._v_add = function (event, handler, capture) {
					    vnode.elm.addEventListener(event, handler, capture);
					  });
					  var remove = vnode.elm._v_remove || (vnode.elm._v_remove = function (event, handler) {
					    vnode.elm.removeEventListener(event, handler);
					  });
					  updateListeners(on, oldOn, add, remove, vnode.context);
					}

					var events = {
					  create: updateDOMListeners,
					  update: updateDOMListeners
					};

					/*  */

					function updateDOMProps (oldVnode, vnode) {
					  if (!oldVnode.data.domProps && !vnode.data.domProps) {
					    return
					  }
					  var key, cur;
					  var elm = vnode.elm;
					  var oldProps = oldVnode.data.domProps || {};
					  var props = vnode.data.domProps || {};
					  // clone observed objects, as the user probably wants to mutate it
					  if (props.__ob__) {
					    props = vnode.data.domProps = extend({}, props);
					  }

					  for (key in oldProps) {
					    if (props[key] == null) {
					      elm[key] = '';
					    }
					  }
					  for (key in props) {
					    // ignore children if the node has textContent or innerHTML,
					    // as these will throw away existing DOM nodes and cause removal errors
					    // on subsequent patches (#3360)
					    if ((key === 'textContent' || key === 'innerHTML') && vnode.children) {
					      vnode.children.length = 0;
					    }
					    cur = props[key];
					    if (key === 'value') {
					      // store value as _value as well since
					      // non-string values will be stringified
					      elm._value = cur;
					      // avoid resetting cursor position when value is the same
					      var strCur = cur == null ? '' : String(cur);
					      if (elm.value !== strCur && !elm.composing) {
					        elm.value = strCur;
					      }
					    } else {
					      elm[key] = cur;
					    }
					  }
					}

					var domProps = {
					  create: updateDOMProps,
					  update: updateDOMProps
					};

					/*  */

					var cssVarRE = /^--/;
					var setProp = function (el, name, val) {
					  /* istanbul ignore if */
					  if (cssVarRE.test(name)) {
					    el.style.setProperty(name, val);
					  } else {
					    el.style[normalize(name)] = val;
					  }
					};

					var prefixes = ['Webkit', 'Moz', 'ms'];

					var testEl;
					var normalize = cached(function (prop) {
					  testEl = testEl || document.createElement('div');
					  prop = camelize(prop);
					  if (prop !== 'filter' && (prop in testEl.style)) {
					    return prop
					  }
					  var upper = prop.charAt(0).toUpperCase() + prop.slice(1);
					  for (var i = 0; i < prefixes.length; i++) {
					    var prefixed = prefixes[i] + upper;
					    if (prefixed in testEl.style) {
					      return prefixed
					    }
					  }
					});

					function updateStyle (oldVnode, vnode) {
					  if ((!oldVnode.data || !oldVnode.data.style) && !vnode.data.style) {
					    return
					  }
					  var cur, name;
					  var el = vnode.elm;
					  var oldStyle = oldVnode.data.style || {};
					  var style = vnode.data.style || {};

					  // handle string
					  if (typeof style === 'string') {
					    el.style.cssText = style;
					    return
					  }

					  var needClone = style.__ob__;

					  // handle array syntax
					  if (Array.isArray(style)) {
					    style = vnode.data.style = toObject(style);
					  }

					  // clone the style for future updates,
					  // in case the user mutates the style object in-place.
					  if (needClone) {
					    style = vnode.data.style = extend({}, style);
					  }

					  for (name in oldStyle) {
					    if (style[name] == null) {
					      setProp(el, name, '');
					    }
					  }
					  for (name in style) {
					    cur = style[name];
					    if (cur !== oldStyle[name]) {
					      // ie9 setting to null has no effect, must use empty string
					      setProp(el, name, cur == null ? '' : cur);
					    }
					  }
					}

					var style = {
					  create: updateStyle,
					  update: updateStyle
					};

					/*  */

					/**
					 * Add class with compatibility for SVG since classList is not supported on
					 * SVG elements in IE
					 */
					function addClass (el, cls) {
					  /* istanbul ignore if */
					  if (!cls || !cls.trim()) {
					    return
					  }

					  /* istanbul ignore else */
					  if (el.classList) {
					    if (cls.indexOf(' ') > -1) {
					      cls.split(/\s+/).forEach(function (c) { return el.classList.add(c); });
					    } else {
					      el.classList.add(cls);
					    }
					  } else {
					    var cur = ' ' + el.getAttribute('class') + ' ';
					    if (cur.indexOf(' ' + cls + ' ') < 0) {
					      el.setAttribute('class', (cur + cls).trim());
					    }
					  }
					}

					/**
					 * Remove class with compatibility for SVG since classList is not supported on
					 * SVG elements in IE
					 */
					function removeClass (el, cls) {
					  /* istanbul ignore if */
					  if (!cls || !cls.trim()) {
					    return
					  }

					  /* istanbul ignore else */
					  if (el.classList) {
					    if (cls.indexOf(' ') > -1) {
					      cls.split(/\s+/).forEach(function (c) { return el.classList.remove(c); });
					    } else {
					      el.classList.remove(cls);
					    }
					  } else {
					    var cur = ' ' + el.getAttribute('class') + ' ';
					    var tar = ' ' + cls + ' ';
					    while (cur.indexOf(tar) >= 0) {
					      cur = cur.replace(tar, ' ');
					    }
					    el.setAttribute('class', cur.trim());
					  }
					}

					/*  */

					var hasTransition = inBrowser && !isIE9;
					var TRANSITION = 'transition';
					var ANIMATION = 'animation';

					// Transition property/event sniffing
					var transitionProp = 'transition';
					var transitionEndEvent = 'transitionend';
					var animationProp = 'animation';
					var animationEndEvent = 'animationend';
					if (hasTransition) {
					  /* istanbul ignore if */
					  if (window.ontransitionend === undefined &&
					    window.onwebkittransitionend !== undefined) {
					    transitionProp = 'WebkitTransition';
					    transitionEndEvent = 'webkitTransitionEnd';
					  }
					  if (window.onanimationend === undefined &&
					    window.onwebkitanimationend !== undefined) {
					    animationProp = 'WebkitAnimation';
					    animationEndEvent = 'webkitAnimationEnd';
					  }
					}

					var raf = (inBrowser && window.requestAnimationFrame) || setTimeout;
					function nextFrame (fn) {
					  raf(function () {
					    raf(fn);
					  });
					}

					function addTransitionClass (el, cls) {
					  (el._transitionClasses || (el._transitionClasses = [])).push(cls);
					  addClass(el, cls);
					}

					function removeTransitionClass (el, cls) {
					  if (el._transitionClasses) {
					    remove$1(el._transitionClasses, cls);
					  }
					  removeClass(el, cls);
					}

					function whenTransitionEnds (
					  el,
					  expectedType,
					  cb
					) {
					  var ref = getTransitionInfo(el, expectedType);
					  var type = ref.type;
					  var timeout = ref.timeout;
					  var propCount = ref.propCount;
					  if (!type) { return cb() }
					  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
					  var ended = 0;
					  var end = function () {
					    el.removeEventListener(event, onEnd);
					    cb();
					  };
					  var onEnd = function (e) {
					    if (e.target === el) {
					      if (++ended >= propCount) {
					        end();
					      }
					    }
					  };
					  setTimeout(function () {
					    if (ended < propCount) {
					      end();
					    }
					  }, timeout + 1);
					  el.addEventListener(event, onEnd);
					}

					var transformRE = /\b(transform|all)(,|$)/;

					function getTransitionInfo (el, expectedType) {
					  var styles = window.getComputedStyle(el);
					  var transitioneDelays = styles[transitionProp + 'Delay'].split(', ');
					  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');
					  var transitionTimeout = getTimeout(transitioneDelays, transitionDurations);
					  var animationDelays = styles[animationProp + 'Delay'].split(', ');
					  var animationDurations = styles[animationProp + 'Duration'].split(', ');
					  var animationTimeout = getTimeout(animationDelays, animationDurations);

					  var type;
					  var timeout = 0;
					  var propCount = 0;
					  /* istanbul ignore if */
					  if (expectedType === TRANSITION) {
					    if (transitionTimeout > 0) {
					      type = TRANSITION;
					      timeout = transitionTimeout;
					      propCount = transitionDurations.length;
					    }
					  } else if (expectedType === ANIMATION) {
					    if (animationTimeout > 0) {
					      type = ANIMATION;
					      timeout = animationTimeout;
					      propCount = animationDurations.length;
					    }
					  } else {
					    timeout = Math.max(transitionTimeout, animationTimeout);
					    type = timeout > 0
					      ? transitionTimeout > animationTimeout
					        ? TRANSITION
					        : ANIMATION
					      : null;
					    propCount = type
					      ? type === TRANSITION
					        ? transitionDurations.length
					        : animationDurations.length
					      : 0;
					  }
					  var hasTransform =
					    type === TRANSITION &&
					    transformRE.test(styles[transitionProp + 'Property']);
					  return {
					    type: type,
					    timeout: timeout,
					    propCount: propCount,
					    hasTransform: hasTransform
					  }
					}

					function getTimeout (delays, durations) {
					  /* istanbul ignore next */
					  while (delays.length < durations.length) {
					    delays = delays.concat(delays);
					  }

					  return Math.max.apply(null, durations.map(function (d, i) {
					    return toMs(d) + toMs(delays[i])
					  }))
					}

					function toMs (s) {
					  return Number(s.slice(0, -1)) * 1000
					}

					/*  */

					function enter (vnode) {
					  var el = vnode.elm;

					  // call leave callback now
					  if (el._leaveCb) {
					    el._leaveCb.cancelled = true;
					    el._leaveCb();
					  }

					  var data = resolveTransition(vnode.data.transition);
					  if (!data) {
					    return
					  }

					  /* istanbul ignore if */
					  if (el._enterCb || el.nodeType !== 1) {
					    return
					  }

					  var css = data.css;
					  var type = data.type;
					  var enterClass = data.enterClass;
					  var enterActiveClass = data.enterActiveClass;
					  var appearClass = data.appearClass;
					  var appearActiveClass = data.appearActiveClass;
					  var beforeEnter = data.beforeEnter;
					  var enter = data.enter;
					  var afterEnter = data.afterEnter;
					  var enterCancelled = data.enterCancelled;
					  var beforeAppear = data.beforeAppear;
					  var appear = data.appear;
					  var afterAppear = data.afterAppear;
					  var appearCancelled = data.appearCancelled;

					  // activeInstance will always be the <transition> component managing this
					  // transition. One edge case to check is when the <transition> is placed
					  // as the root node of a child component. In that case we need to check
					  // <transition>'s parent for appear check.
					  var transitionNode = activeInstance.$vnode;
					  var context = transitionNode && transitionNode.parent
					    ? transitionNode.parent.context
					    : activeInstance;

					  var isAppear = !context._isMounted || !vnode.isRootInsert;

					  if (isAppear && !appear && appear !== '') {
					    return
					  }

					  var startClass = isAppear ? appearClass : enterClass;
					  var activeClass = isAppear ? appearActiveClass : enterActiveClass;
					  var beforeEnterHook = isAppear ? (beforeAppear || beforeEnter) : beforeEnter;
					  var enterHook = isAppear ? (typeof appear === 'function' ? appear : enter) : enter;
					  var afterEnterHook = isAppear ? (afterAppear || afterEnter) : afterEnter;
					  var enterCancelledHook = isAppear ? (appearCancelled || enterCancelled) : enterCancelled;

					  var expectsCSS = css !== false && !isIE9;
					  var userWantsControl =
					    enterHook &&
					    // enterHook may be a bound method which exposes
					    // the length of original fn as _length
					    (enterHook._length || enterHook.length) > 1;

					  var cb = el._enterCb = once(function () {
					    if (expectsCSS) {
					      removeTransitionClass(el, activeClass);
					    }
					    if (cb.cancelled) {
					      if (expectsCSS) {
					        removeTransitionClass(el, startClass);
					      }
					      enterCancelledHook && enterCancelledHook(el);
					    } else {
					      afterEnterHook && afterEnterHook(el);
					    }
					    el._enterCb = null;
					  });

					  if (!vnode.data.show) {
					    // remove pending leave element on enter by injecting an insert hook
					    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {
					      var parent = el.parentNode;
					      var pendingNode = parent && parent._pending && parent._pending[vnode.key];
					      if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {
					        pendingNode.elm._leaveCb();
					      }
					      enterHook && enterHook(el, cb);
					    }, 'transition-insert');
					  }

					  // start enter transition
					  beforeEnterHook && beforeEnterHook(el);
					  if (expectsCSS) {
					    addTransitionClass(el, startClass);
					    addTransitionClass(el, activeClass);
					    nextFrame(function () {
					      removeTransitionClass(el, startClass);
					      if (!cb.cancelled && !userWantsControl) {
					        whenTransitionEnds(el, type, cb);
					      }
					    });
					  }

					  if (vnode.data.show) {
					    enterHook && enterHook(el, cb);
					  }

					  if (!expectsCSS && !userWantsControl) {
					    cb();
					  }
					}

					function leave (vnode, rm) {
					  var el = vnode.elm;

					  // call enter callback now
					  if (el._enterCb) {
					    el._enterCb.cancelled = true;
					    el._enterCb();
					  }

					  var data = resolveTransition(vnode.data.transition);
					  if (!data) {
					    return rm()
					  }

					  /* istanbul ignore if */
					  if (el._leaveCb || el.nodeType !== 1) {
					    return
					  }

					  var css = data.css;
					  var type = data.type;
					  var leaveClass = data.leaveClass;
					  var leaveActiveClass = data.leaveActiveClass;
					  var beforeLeave = data.beforeLeave;
					  var leave = data.leave;
					  var afterLeave = data.afterLeave;
					  var leaveCancelled = data.leaveCancelled;
					  var delayLeave = data.delayLeave;

					  var expectsCSS = css !== false && !isIE9;
					  var userWantsControl =
					    leave &&
					    // leave hook may be a bound method which exposes
					    // the length of original fn as _length
					    (leave._length || leave.length) > 1;

					  var cb = el._leaveCb = once(function () {
					    if (el.parentNode && el.parentNode._pending) {
					      el.parentNode._pending[vnode.key] = null;
					    }
					    if (expectsCSS) {
					      removeTransitionClass(el, leaveActiveClass);
					    }
					    if (cb.cancelled) {
					      if (expectsCSS) {
					        removeTransitionClass(el, leaveClass);
					      }
					      leaveCancelled && leaveCancelled(el);
					    } else {
					      rm();
					      afterLeave && afterLeave(el);
					    }
					    el._leaveCb = null;
					  });

					  if (delayLeave) {
					    delayLeave(performLeave);
					  } else {
					    performLeave();
					  }

					  function performLeave () {
					    // the delayed leave may have already been cancelled
					    if (cb.cancelled) {
					      return
					    }
					    // record leaving element
					    if (!vnode.data.show) {
					      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
					    }
					    beforeLeave && beforeLeave(el);
					    if (expectsCSS) {
					      addTransitionClass(el, leaveClass);
					      addTransitionClass(el, leaveActiveClass);
					      nextFrame(function () {
					        removeTransitionClass(el, leaveClass);
					        if (!cb.cancelled && !userWantsControl) {
					          whenTransitionEnds(el, type, cb);
					        }
					      });
					    }
					    leave && leave(el, cb);
					    if (!expectsCSS && !userWantsControl) {
					      cb();
					    }
					  }
					}

					function resolveTransition (def$$1) {
					  if (!def$$1) {
					    return
					  }
					  /* istanbul ignore else */
					  if (typeof def$$1 === 'object') {
					    var res = {};
					    if (def$$1.css !== false) {
					      extend(res, autoCssTransition(def$$1.name || 'v'));
					    }
					    extend(res, def$$1);
					    return res
					  } else if (typeof def$$1 === 'string') {
					    return autoCssTransition(def$$1)
					  }
					}

					var autoCssTransition = cached(function (name) {
					  return {
					    enterClass: (name + "-enter"),
					    leaveClass: (name + "-leave"),
					    appearClass: (name + "-enter"),
					    enterActiveClass: (name + "-enter-active"),
					    leaveActiveClass: (name + "-leave-active"),
					    appearActiveClass: (name + "-enter-active")
					  }
					});

					function once (fn) {
					  var called = false;
					  return function () {
					    if (!called) {
					      called = true;
					      fn();
					    }
					  }
					}

					var transition = inBrowser ? {
					  create: function create (_, vnode) {
					    if (!vnode.data.show) {
					      enter(vnode);
					    }
					  },
					  remove: function remove (vnode, rm) {
					    /* istanbul ignore else */
					    if (!vnode.data.show) {
					      leave(vnode, rm);
					    } else {
					      rm();
					    }
					  }
					} : {};

					var platformModules = [
					  attrs,
					  klass,
					  events,
					  domProps,
					  style,
					  transition
					];

					/*  */

					// the directive module should be applied last, after all
					// built-in modules have been applied.
					var modules = platformModules.concat(baseModules);

					var patch$1 = createPatchFunction({ nodeOps: nodeOps, modules: modules });

					/**
					 * Not type checking this file because flow doesn't like attaching
					 * properties to Elements.
					 */

					var modelableTagRE = /^input|select|textarea|vue-component-[0-9]+(-[0-9a-zA-Z_-]*)?$/;

					/* istanbul ignore if */
					if (isIE9) {
					  // http://www.matts411.com/post/internet-explorer-9-oninput/
					  document.addEventListener('selectionchange', function () {
					    var el = document.activeElement;
					    if (el && el.vmodel) {
					      trigger(el, 'input');
					    }
					  });
					}

					var model = {
					  inserted: function inserted (el, binding, vnode) {
					    {
					      if (!modelableTagRE.test(vnode.tag)) {
					        warn(
					          "v-model is not supported on element type: <" + (vnode.tag) + ">. " +
					          'If you are working with contenteditable, it\'s recommended to ' +
					          'wrap a library dedicated for that purpose inside a custom component.',
					          vnode.context
					        );
					      }
					    }
					    if (vnode.tag === 'select') {
					      var cb = function () {
					        setSelected(el, binding, vnode.context);
					      };
					      cb();
					      /* istanbul ignore if */
					      if (isIE || isEdge) {
					        setTimeout(cb, 0);
					      }
					    } else if (
					      (vnode.tag === 'textarea' || el.type === 'text') &&
					      !binding.modifiers.lazy
					    ) {
					      if (!isAndroid) {
					        el.addEventListener('compositionstart', onCompositionStart);
					        el.addEventListener('compositionend', onCompositionEnd);
					      }
					      /* istanbul ignore if */
					      if (isIE9) {
					        el.vmodel = true;
					      }
					    }
					  },
					  componentUpdated: function componentUpdated (el, binding, vnode) {
					    if (vnode.tag === 'select') {
					      setSelected(el, binding, vnode.context);
					      // in case the options rendered by v-for have changed,
					      // it's possible that the value is out-of-sync with the rendered options.
					      // detect such cases and filter out values that no longer has a matching
					      // option in the DOM.
					      var needReset = el.multiple
					        ? binding.value.some(function (v) { return hasNoMatchingOption(v, el.options); })
					        : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, el.options);
					      if (needReset) {
					        trigger(el, 'change');
					      }
					    }
					  }
					};

					function setSelected (el, binding, vm) {
					  var value = binding.value;
					  var isMultiple = el.multiple;
					  if (isMultiple && !Array.isArray(value)) {
					    "development" !== 'production' && warn(
					      "<select multiple v-model=\"" + (binding.expression) + "\"> " +
					      "expects an Array value for its binding, but got " + (Object.prototype.toString.call(value).slice(8, -1)),
					      vm
					    );
					    return
					  }
					  var selected, option;
					  for (var i = 0, l = el.options.length; i < l; i++) {
					    option = el.options[i];
					    if (isMultiple) {
					      selected = looseIndexOf(value, getValue(option)) > -1;
					      if (option.selected !== selected) {
					        option.selected = selected;
					      }
					    } else {
					      if (looseEqual(getValue(option), value)) {
					        if (el.selectedIndex !== i) {
					          el.selectedIndex = i;
					        }
					        return
					      }
					    }
					  }
					  if (!isMultiple) {
					    el.selectedIndex = -1;
					  }
					}

					function hasNoMatchingOption (value, options) {
					  for (var i = 0, l = options.length; i < l; i++) {
					    if (looseEqual(getValue(options[i]), value)) {
					      return false
					    }
					  }
					  return true
					}

					function getValue (option) {
					  return '_value' in option
					    ? option._value
					    : option.value
					}

					function onCompositionStart (e) {
					  e.target.composing = true;
					}

					function onCompositionEnd (e) {
					  e.target.composing = false;
					  trigger(e.target, 'input');
					}

					function trigger (el, type) {
					  var e = document.createEvent('HTMLEvents');
					  e.initEvent(type, true, true);
					  el.dispatchEvent(e);
					}

					/*  */

					// recursively search for possible transition defined inside the component root
					function locateNode (vnode) {
					  return vnode.child && (!vnode.data || !vnode.data.transition)
					    ? locateNode(vnode.child._vnode)
					    : vnode
					}

					var show = {
					  bind: function bind (el, ref, vnode) {
					    var value = ref.value;

					    vnode = locateNode(vnode);
					    var transition = vnode.data && vnode.data.transition;
					    if (value && transition && !isIE9) {
					      enter(vnode);
					    }
					    var originalDisplay = el.style.display === 'none' ? '' : el.style.display;
					    el.style.display = value ? originalDisplay : 'none';
					    el.__vOriginalDisplay = originalDisplay;
					  },
					  update: function update (el, ref, vnode) {
					    var value = ref.value;
					    var oldValue = ref.oldValue;

					    /* istanbul ignore if */
					    if (value === oldValue) { return }
					    vnode = locateNode(vnode);
					    var transition = vnode.data && vnode.data.transition;
					    if (transition && !isIE9) {
					      if (value) {
					        enter(vnode);
					        el.style.display = el.__vOriginalDisplay;
					      } else {
					        leave(vnode, function () {
					          el.style.display = 'none';
					        });
					      }
					    } else {
					      el.style.display = value ? el.__vOriginalDisplay : 'none';
					    }
					  }
					};

					var platformDirectives = {
					  model: model,
					  show: show
					};

					/*  */

					// Provides transition support for a single element/component.
					// supports transition mode (out-in / in-out)

					var transitionProps = {
					  name: String,
					  appear: Boolean,
					  css: Boolean,
					  mode: String,
					  type: String,
					  enterClass: String,
					  leaveClass: String,
					  enterActiveClass: String,
					  leaveActiveClass: String,
					  appearClass: String,
					  appearActiveClass: String
					};

					// in case the child is also an abstract component, e.g. <keep-alive>
					// we want to recursively retrieve the real component to be rendered
					function getRealChild (vnode) {
					  var compOptions = vnode && vnode.componentOptions;
					  if (compOptions && compOptions.Ctor.options.abstract) {
					    return getRealChild(getFirstComponentChild(compOptions.children))
					  } else {
					    return vnode
					  }
					}

					function extractTransitionData (comp) {
					  var data = {};
					  var options = comp.$options;
					  // props
					  for (var key in options.propsData) {
					    data[key] = comp[key];
					  }
					  // events.
					  // extract listeners and pass them directly to the transition methods
					  var listeners = options._parentListeners;
					  for (var key$1 in listeners) {
					    data[camelize(key$1)] = listeners[key$1].fn;
					  }
					  return data
					}

					function placeholder (h, rawChild) {
					  return /\d-keep-alive$/.test(rawChild.tag)
					    ? h('keep-alive')
					    : null
					}

					function hasParentTransition (vnode) {
					  while ((vnode = vnode.parent)) {
					    if (vnode.data.transition) {
					      return true
					    }
					  }
					}

					var Transition = {
					  name: 'transition',
					  props: transitionProps,
					  abstract: true,
					  render: function render (h) {
					    var this$1 = this;

					    var children = this.$slots.default;
					    if (!children) {
					      return
					    }

					    // filter out text nodes (possible whitespaces)
					    children = children.filter(function (c) { return c.tag; });
					    /* istanbul ignore if */
					    if (!children.length) {
					      return
					    }

					    // warn multiple elements
					    if ("development" !== 'production' && children.length > 1) {
					      warn(
					        '<transition> can only be used on a single element. Use ' +
					        '<transition-group> for lists.',
					        this.$parent
					      );
					    }

					    var mode = this.mode;

					    // warn invalid mode
					    if ("development" !== 'production' &&
					        mode && mode !== 'in-out' && mode !== 'out-in') {
					      warn(
					        'invalid <transition> mode: ' + mode,
					        this.$parent
					      );
					    }

					    var rawChild = children[0];

					    // if this is a component root node and the component's
					    // parent container node also has transition, skip.
					    if (hasParentTransition(this.$vnode)) {
					      return rawChild
					    }

					    // apply transition data to child
					    // use getRealChild() to ignore abstract components e.g. keep-alive
					    var child = getRealChild(rawChild);
					    /* istanbul ignore if */
					    if (!child) {
					      return rawChild
					    }

					    if (this._leaving) {
					      return placeholder(h, rawChild)
					    }

					    var key = child.key = child.key == null || child.isStatic
					      ? ("__v" + (child.tag + this._uid) + "__")
					      : child.key;
					    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
					    var oldRawChild = this._vnode;
					    var oldChild = getRealChild(oldRawChild);

					    // mark v-show
					    // so that the transition module can hand over the control to the directive
					    if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {
					      child.data.show = true;
					    }

					    if (oldChild && oldChild.data && oldChild.key !== key) {
					      // replace old child transition data with fresh one
					      // important for dynamic transitions!
					      var oldData = oldChild.data.transition = extend({}, data);

					      // handle transition mode
					      if (mode === 'out-in') {
					        // return placeholder node and queue update when leave finishes
					        this._leaving = true;
					        mergeVNodeHook(oldData, 'afterLeave', function () {
					          this$1._leaving = false;
					          this$1.$forceUpdate();
					        }, key);
					        return placeholder(h, rawChild)
					      } else if (mode === 'in-out') {
					        var delayedLeave;
					        var performLeave = function () { delayedLeave(); };
					        mergeVNodeHook(data, 'afterEnter', performLeave, key);
					        mergeVNodeHook(data, 'enterCancelled', performLeave, key);
					        mergeVNodeHook(oldData, 'delayLeave', function (leave) {
					          delayedLeave = leave;
					        }, key);
					      }
					    }

					    return rawChild
					  }
					};

					/*  */

					// Provides transition support for list items.
					// supports move transitions using the FLIP technique.

					// Because the vdom's children update algorithm is "unstable" - i.e.
					// it doesn't guarantee the relative positioning of removed elements,
					// we force transition-group to update its children into two passes:
					// in the first pass, we remove all nodes that need to be removed,
					// triggering their leaving transition; in the second pass, we insert/move
					// into the final disired state. This way in the second pass removed
					// nodes will remain where they should be.

					var props = extend({
					  tag: String,
					  moveClass: String
					}, transitionProps);

					delete props.mode;

					var TransitionGroup = {
					  props: props,

					  render: function render (h) {
					    var tag = this.tag || this.$vnode.data.tag || 'span';
					    var map = Object.create(null);
					    var prevChildren = this.prevChildren = this.children;
					    var rawChildren = this.$slots.default || [];
					    var children = this.children = [];
					    var transitionData = extractTransitionData(this);

					    for (var i = 0; i < rawChildren.length; i++) {
					      var c = rawChildren[i];
					      if (c.tag) {
					        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
					          children.push(c);
					          map[c.key] = c
					          ;(c.data || (c.data = {})).transition = transitionData;
					        } else {
					          var opts = c.componentOptions;
					          var name = opts
					            ? (opts.Ctor.options.name || opts.tag)
					            : c.tag;
					          warn(("<transition-group> children must be keyed: <" + name + ">"));
					        }
					      }
					    }

					    if (prevChildren) {
					      var kept = [];
					      var removed = [];
					      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
					        var c$1 = prevChildren[i$1];
					        c$1.data.transition = transitionData;
					        c$1.data.pos = c$1.elm.getBoundingClientRect();
					        if (map[c$1.key]) {
					          kept.push(c$1);
					        } else {
					          removed.push(c$1);
					        }
					      }
					      this.kept = h(tag, null, kept);
					      this.removed = removed;
					    }

					    return h(tag, null, children)
					  },

					  beforeUpdate: function beforeUpdate () {
					    // force removing pass
					    this.__patch__(
					      this._vnode,
					      this.kept,
					      false, // hydrating
					      true // removeOnly (!important, avoids unnecessary moves)
					    );
					    this._vnode = this.kept;
					  },

					  updated: function updated () {
					    var children = this.prevChildren;
					    var moveClass = this.moveClass || (this.name + '-move');
					    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
					      return
					    }

					    // we divide the work into three loops to avoid mixing DOM reads and writes
					    // in each iteration - which helps prevent layout thrashing.
					    children.forEach(callPendingCbs);
					    children.forEach(recordPosition);
					    children.forEach(applyTranslation);

					    // force reflow to put everything in position
					    var f = document.body.offsetHeight; // eslint-disable-line

					    children.forEach(function (c) {
					      if (c.data.moved) {
					        var el = c.elm;
					        var s = el.style;
					        addTransitionClass(el, moveClass);
					        s.transform = s.WebkitTransform = s.transitionDuration = '';
					        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {
					          if (!e || /transform$/.test(e.propertyName)) {
					            el.removeEventListener(transitionEndEvent, cb);
					            el._moveCb = null;
					            removeTransitionClass(el, moveClass);
					          }
					        });
					      }
					    });
					  },

					  methods: {
					    hasMove: function hasMove (el, moveClass) {
					      /* istanbul ignore if */
					      if (!hasTransition) {
					        return false
					      }
					      if (this._hasMove != null) {
					        return this._hasMove
					      }
					      addTransitionClass(el, moveClass);
					      var info = getTransitionInfo(el);
					      removeTransitionClass(el, moveClass);
					      return (this._hasMove = info.hasTransform)
					    }
					  }
					};

					function callPendingCbs (c) {
					  /* istanbul ignore if */
					  if (c.elm._moveCb) {
					    c.elm._moveCb();
					  }
					  /* istanbul ignore if */
					  if (c.elm._enterCb) {
					    c.elm._enterCb();
					  }
					}

					function recordPosition (c) {
					  c.data.newPos = c.elm.getBoundingClientRect();
					}

					function applyTranslation (c) {
					  var oldPos = c.data.pos;
					  var newPos = c.data.newPos;
					  var dx = oldPos.left - newPos.left;
					  var dy = oldPos.top - newPos.top;
					  if (dx || dy) {
					    c.data.moved = true;
					    var s = c.elm.style;
					    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
					    s.transitionDuration = '0s';
					  }
					}

					var platformComponents = {
					  Transition: Transition,
					  TransitionGroup: TransitionGroup
					};

					/*  */

					// install platform specific utils
					Vue$2.config.isUnknownElement = isUnknownElement;
					Vue$2.config.isReservedTag = isReservedTag;
					Vue$2.config.getTagNamespace = getTagNamespace;
					Vue$2.config.mustUseProp = mustUseProp;

					// install platform runtime directives & components
					extend(Vue$2.options.directives, platformDirectives);
					extend(Vue$2.options.components, platformComponents);

					// install platform patch function
					Vue$2.prototype.__patch__ = config._isServer ? noop : patch$1;

					// wrap mount
					Vue$2.prototype.$mount = function (
					  el,
					  hydrating
					) {
					  el = el && !config._isServer ? query(el) : undefined;
					  return this._mount(el, hydrating)
					};

					// devtools global hook
					/* istanbul ignore next */
					setTimeout(function () {
					  if (config.devtools) {
					    if (devtools) {
					      devtools.emit('init', Vue$2);
					    } else if (
					      "development" !== 'production' &&
					      inBrowser && /Chrome\/\d+/.test(window.navigator.userAgent)
					    ) {
					      console.log(
					        'Download the Vue Devtools for a better development experience:\n' +
					        'https://github.com/vuejs/vue-devtools'
					      );
					    }
					  }
					}, 0);

					/*  */

					// check whether current browser encodes a char inside attribute values
					function shouldDecode (content, encoded) {
					  var div = document.createElement('div');
					  div.innerHTML = "<div a=\"" + content + "\">";
					  return div.innerHTML.indexOf(encoded) > 0
					}

					// #3663
					// IE encodes newlines inside attribute values while other browsers don't
					var shouldDecodeNewlines = inBrowser ? shouldDecode('\n', '&#10;') : false;

					/*  */

					var decoder = document.createElement('div');

					function decode (html) {
					  decoder.innerHTML = html;
					  return decoder.textContent
					}

					/**
					 * Not type-checking this file because it's mostly vendor code.
					 */

					/*!
					 * HTML Parser By John Resig (ejohn.org)
					 * Modified by Juriy "kangax" Zaytsev
					 * Original code by Erik Arvidsson, Mozilla Public License
					 * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
					 */

					// Regular Expressions for parsing tags and attributes
					var singleAttrIdentifier = /([^\s"'<>/=]+)/;
					var singleAttrAssign = /(?:=)/;
					var singleAttrValues = [
					  // attr value double quotes
					  /"([^"]*)"+/.source,
					  // attr value, single quotes
					  /'([^']*)'+/.source,
					  // attr value, no quotes
					  /([^\s"'=<>`]+)/.source
					];
					var attribute = new RegExp(
					  '^\\s*' + singleAttrIdentifier.source +
					  '(?:\\s*(' + singleAttrAssign.source + ')' +
					  '\\s*(?:' + singleAttrValues.join('|') + '))?'
					);

					// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName
					// but for Vue templates we can enforce a simple charset
					var ncname = '[a-zA-Z_][\\w\\-\\.]*';
					var qnameCapture = '((?:' + ncname + '\\:)?' + ncname + ')';
					var startTagOpen = new RegExp('^<' + qnameCapture);
					var startTagClose = /^\s*(\/?)>/;
					var endTag = new RegExp('^<\\/' + qnameCapture + '[^>]*>');
					var doctype = /^<!DOCTYPE [^>]+>/i;
					var comment = /^<!--/;
					var conditionalComment = /^<!\[/;

					var IS_REGEX_CAPTURING_BROKEN = false;
					'x'.replace(/x(.)?/g, function (m, g) {
					  IS_REGEX_CAPTURING_BROKEN = g === '';
					});

					// Special Elements (can contain anything)
					var isScriptOrStyle = makeMap('script,style', true);
					var hasLang = function (attr) { return attr.name === 'lang' && attr.value !== 'html'; };
					var isSpecialTag = function (tag, isSFC, stack) {
					  if (isScriptOrStyle(tag)) {
					    return true
					  }
					  // top-level template that has a pre-processor
					  if (
					    isSFC &&
					    tag === 'template' &&
					    stack.length === 1 &&
					    stack[0].attrs.some(hasLang)
					  ) {
					    return true
					  }
					  return false
					};

					var reCache = {};

					var ltRE = /&lt;/g;
					var gtRE = /&gt;/g;
					var nlRE = /&#10;/g;
					var ampRE = /&amp;/g;
					var quoteRE = /&quot;/g;

					function decodeAttr (value, shouldDecodeNewlines) {
					  if (shouldDecodeNewlines) {
					    value = value.replace(nlRE, '\n');
					  }
					  return value
					    .replace(ltRE, '<')
					    .replace(gtRE, '>')
					    .replace(ampRE, '&')
					    .replace(quoteRE, '"')
					}

					function parseHTML (html, options) {
					  var stack = [];
					  var expectHTML = options.expectHTML;
					  var isUnaryTag$$1 = options.isUnaryTag || no;
					  var index = 0;
					  var last, lastTag;
					  while (html) {
					    last = html;
					    // Make sure we're not in a script or style element
					    if (!lastTag || !isSpecialTag(lastTag, options.sfc, stack)) {
					      var textEnd = html.indexOf('<');
					      if (textEnd === 0) {
					        // Comment:
					        if (comment.test(html)) {
					          var commentEnd = html.indexOf('-->');

					          if (commentEnd >= 0) {
					            advance(commentEnd + 3);
					            continue
					          }
					        }

					        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
					        if (conditionalComment.test(html)) {
					          var conditionalEnd = html.indexOf(']>');

					          if (conditionalEnd >= 0) {
					            advance(conditionalEnd + 2);
					            continue
					          }
					        }

					        // Doctype:
					        var doctypeMatch = html.match(doctype);
					        if (doctypeMatch) {
					          advance(doctypeMatch[0].length);
					          continue
					        }

					        // End tag:
					        var endTagMatch = html.match(endTag);
					        if (endTagMatch) {
					          var curIndex = index;
					          advance(endTagMatch[0].length);
					          parseEndTag(endTagMatch[0], endTagMatch[1], curIndex, index);
					          continue
					        }

					        // Start tag:
					        var startTagMatch = parseStartTag();
					        if (startTagMatch) {
					          handleStartTag(startTagMatch);
					          continue
					        }
					      }

					      var text = void 0, rest$1 = void 0, next = void 0;
					      if (textEnd > 0) {
					        rest$1 = html.slice(textEnd);
					        while (
					          !endTag.test(rest$1) &&
					          !startTagOpen.test(rest$1) &&
					          !comment.test(rest$1) &&
					          !conditionalComment.test(rest$1)
					        ) {
					          // < in plain text, be forgiving and treat it as text
					          next = rest$1.indexOf('<', 1);
					          if (next < 0) { break }
					          textEnd += next;
					          rest$1 = html.slice(textEnd);
					        }
					        text = html.substring(0, textEnd);
					        advance(textEnd);
					      }

					      if (textEnd < 0) {
					        text = html;
					        html = '';
					      }

					      if (options.chars && text) {
					        options.chars(text);
					      }
					    } else {
					      var stackedTag = lastTag.toLowerCase();
					      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));
					      var endTagLength = 0;
					      var rest = html.replace(reStackedTag, function (all, text, endTag) {
					        endTagLength = endTag.length;
					        if (stackedTag !== 'script' && stackedTag !== 'style' && stackedTag !== 'noscript') {
					          text = text
					            .replace(/<!--([\s\S]*?)-->/g, '$1')
					            .replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
					        }
					        if (options.chars) {
					          options.chars(text);
					        }
					        return ''
					      });
					      index += html.length - rest.length;
					      html = rest;
					      parseEndTag('</' + stackedTag + '>', stackedTag, index - endTagLength, index);
					    }

					    if (html === last && options.chars) {
					      options.chars(html);
					      break
					    }
					  }

					  // Clean up any remaining tags
					  parseEndTag();

					  function advance (n) {
					    index += n;
					    html = html.substring(n);
					  }

					  function parseStartTag () {
					    var start = html.match(startTagOpen);
					    if (start) {
					      var match = {
					        tagName: start[1],
					        attrs: [],
					        start: index
					      };
					      advance(start[0].length);
					      var end, attr;
					      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {
					        advance(attr[0].length);
					        match.attrs.push(attr);
					      }
					      if (end) {
					        match.unarySlash = end[1];
					        advance(end[0].length);
					        match.end = index;
					        return match
					      }
					    }
					  }

					  function handleStartTag (match) {
					    var tagName = match.tagName;
					    var unarySlash = match.unarySlash;

					    if (expectHTML) {
					      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
					        parseEndTag('', lastTag);
					      }
					      if (canBeLeftOpenTag(tagName) && lastTag === tagName) {
					        parseEndTag('', tagName);
					      }
					    }

					    var unary = isUnaryTag$$1(tagName) || tagName === 'html' && lastTag === 'head' || !!unarySlash;

					    var l = match.attrs.length;
					    var attrs = new Array(l);
					    for (var i = 0; i < l; i++) {
					      var args = match.attrs[i];
					      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778
					      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('""') === -1) {
					        if (args[3] === '') { delete args[3]; }
					        if (args[4] === '') { delete args[4]; }
					        if (args[5] === '') { delete args[5]; }
					      }
					      var value = args[3] || args[4] || args[5] || '';
					      attrs[i] = {
					        name: args[1],
					        value: decodeAttr(
					          value,
					          options.shouldDecodeNewlines
					        )
					      };
					    }

					    if (!unary) {
					      stack.push({ tag: tagName, attrs: attrs });
					      lastTag = tagName;
					      unarySlash = '';
					    }

					    if (options.start) {
					      options.start(tagName, attrs, unary, match.start, match.end);
					    }
					  }

					  function parseEndTag (tag, tagName, start, end) {
					    var pos;
					    if (start == null) { start = index; }
					    if (end == null) { end = index; }

					    // Find the closest opened tag of the same type
					    if (tagName) {
					      var needle = tagName.toLowerCase();
					      for (pos = stack.length - 1; pos >= 0; pos--) {
					        if (stack[pos].tag.toLowerCase() === needle) {
					          break
					        }
					      }
					    } else {
					      // If no tag name is provided, clean shop
					      pos = 0;
					    }

					    if (pos >= 0) {
					      // Close all the open elements, up the stack
					      for (var i = stack.length - 1; i >= pos; i--) {
					        if (options.end) {
					          options.end(stack[i].tag, start, end);
					        }
					      }

					      // Remove the open elements from the stack
					      stack.length = pos;
					      lastTag = pos && stack[pos - 1].tag;
					    } else if (tagName.toLowerCase() === 'br') {
					      if (options.start) {
					        options.start(tagName, [], true, start, end);
					      }
					    } else if (tagName.toLowerCase() === 'p') {
					      if (options.start) {
					        options.start(tagName, [], false, start, end);
					      }
					      if (options.end) {
					        options.end(tagName, start, end);
					      }
					    }
					  }
					}

					/*  */

					function parseFilters (exp) {
					  var inSingle = false;
					  var inDouble = false;
					  var curly = 0;
					  var square = 0;
					  var paren = 0;
					  var lastFilterIndex = 0;
					  var c, prev, i, expression, filters;

					  for (i = 0; i < exp.length; i++) {
					    prev = c;
					    c = exp.charCodeAt(i);
					    if (inSingle) {
					      // check single quote
					      if (c === 0x27 && prev !== 0x5C) { inSingle = !inSingle; }
					    } else if (inDouble) {
					      // check double quote
					      if (c === 0x22 && prev !== 0x5C) { inDouble = !inDouble; }
					    } else if (
					      c === 0x7C && // pipe
					      exp.charCodeAt(i + 1) !== 0x7C &&
					      exp.charCodeAt(i - 1) !== 0x7C &&
					      !curly && !square && !paren
					    ) {
					      if (expression === undefined) {
					        // first filter, end of expression
					        lastFilterIndex = i + 1;
					        expression = exp.slice(0, i).trim();
					      } else {
					        pushFilter();
					      }
					    } else {
					      switch (c) {
					        case 0x22: inDouble = true; break // "
					        case 0x27: inSingle = true; break // '
					        case 0x28: paren++; break         // (
					        case 0x29: paren--; break         // )
					        case 0x5B: square++; break        // [
					        case 0x5D: square--; break        // ]
					        case 0x7B: curly++; break         // {
					        case 0x7D: curly--; break         // }
					      }
					    }
					  }

					  if (expression === undefined) {
					    expression = exp.slice(0, i).trim();
					  } else if (lastFilterIndex !== 0) {
					    pushFilter();
					  }

					  function pushFilter () {
					    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
					    lastFilterIndex = i + 1;
					  }

					  if (filters) {
					    for (i = 0; i < filters.length; i++) {
					      expression = wrapFilter(expression, filters[i]);
					    }
					  }

					  return expression
					}

					function wrapFilter (exp, filter) {
					  var i = filter.indexOf('(');
					  if (i < 0) {
					    // _f: resolveFilter
					    return ("_f(\"" + filter + "\")(" + exp + ")")
					  } else {
					    var name = filter.slice(0, i);
					    var args = filter.slice(i + 1);
					    return ("_f(\"" + name + "\")(" + exp + "," + args)
					  }
					}

					/*  */

					var defaultTagRE = /\{\{((?:.|\n)+?)\}\}/g;
					var regexEscapeRE = /[-.*+?^${}()|[\]/\\]/g;

					var buildRegex = cached(function (delimiters) {
					  var open = delimiters[0].replace(regexEscapeRE, '\\$&');
					  var close = delimiters[1].replace(regexEscapeRE, '\\$&');
					  return new RegExp(open + '((?:.|\\n)+?)' + close, 'g')
					});

					function parseText (
					  text,
					  delimiters
					) {
					  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;
					  if (!tagRE.test(text)) {
					    return
					  }
					  var tokens = [];
					  var lastIndex = tagRE.lastIndex = 0;
					  var match, index;
					  while ((match = tagRE.exec(text))) {
					    index = match.index;
					    // push text token
					    if (index > lastIndex) {
					      tokens.push(JSON.stringify(text.slice(lastIndex, index)));
					    }
					    // tag token
					    var exp = parseFilters(match[1].trim());
					    tokens.push(("_s(" + exp + ")"));
					    lastIndex = index + match[0].length;
					  }
					  if (lastIndex < text.length) {
					    tokens.push(JSON.stringify(text.slice(lastIndex)));
					  }
					  return tokens.join('+')
					}

					/*  */

					function baseWarn (msg) {
					  console.error(("[Vue parser]: " + msg));
					}

					function pluckModuleFunction (
					  modules,
					  key
					) {
					  return modules
					    ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })
					    : []
					}

					function addProp (el, name, value) {
					  (el.props || (el.props = [])).push({ name: name, value: value });
					}

					function addAttr (el, name, value) {
					  (el.attrs || (el.attrs = [])).push({ name: name, value: value });
					}

					function addDirective (
					  el,
					  name,
					  rawName,
					  value,
					  arg,
					  modifiers
					) {
					  (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });
					}

					function addHandler (
					  el,
					  name,
					  value,
					  modifiers,
					  important
					) {
					  // check capture modifier
					  if (modifiers && modifiers.capture) {
					    delete modifiers.capture;
					    name = '!' + name; // mark the event as captured
					  }
					  var events;
					  if (modifiers && modifiers.native) {
					    delete modifiers.native;
					    events = el.nativeEvents || (el.nativeEvents = {});
					  } else {
					    events = el.events || (el.events = {});
					  }
					  var newHandler = { value: value, modifiers: modifiers };
					  var handlers = events[name];
					  /* istanbul ignore if */
					  if (Array.isArray(handlers)) {
					    important ? handlers.unshift(newHandler) : handlers.push(newHandler);
					  } else if (handlers) {
					    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
					  } else {
					    events[name] = newHandler;
					  }
					}

					function getBindingAttr (
					  el,
					  name,
					  getStatic
					) {
					  var dynamicValue =
					    getAndRemoveAttr(el, ':' + name) ||
					    getAndRemoveAttr(el, 'v-bind:' + name);
					  if (dynamicValue != null) {
					    return dynamicValue
					  } else if (getStatic !== false) {
					    var staticValue = getAndRemoveAttr(el, name);
					    if (staticValue != null) {
					      return JSON.stringify(staticValue)
					    }
					  }
					}

					function getAndRemoveAttr (el, name) {
					  var val;
					  if ((val = el.attrsMap[name]) != null) {
					    var list = el.attrsList;
					    for (var i = 0, l = list.length; i < l; i++) {
					      if (list[i].name === name) {
					        list.splice(i, 1);
					        break
					      }
					    }
					  }
					  return val
					}

					/*  */

					var dirRE = /^v-|^@|^:/;
					var forAliasRE = /(.*?)\s+(?:in|of)\s+(.*)/;
					var forIteratorRE = /\(([^,]*),([^,]*)(?:,([^,]*))?\)/;
					var bindRE = /^:|^v-bind:/;
					var onRE = /^@|^v-on:/;
					var argRE = /:(.*)$/;
					var modifierRE = /\.[^.]+/g;
					var specialNewlineRE = /\u2028|\u2029/g;

					var decodeHTMLCached = cached(decode);

					// configurable state
					var warn$1;
					var platformGetTagNamespace;
					var platformMustUseProp;
					var platformIsPreTag;
					var preTransforms;
					var transforms;
					var postTransforms;
					var delimiters;

					/**
					 * Convert HTML string to AST.
					 */
					function parse (
					  template,
					  options
					) {
					  warn$1 = options.warn || baseWarn;
					  platformGetTagNamespace = options.getTagNamespace || no;
					  platformMustUseProp = options.mustUseProp || no;
					  platformIsPreTag = options.isPreTag || no;
					  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');
					  transforms = pluckModuleFunction(options.modules, 'transformNode');
					  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');
					  delimiters = options.delimiters;
					  var stack = [];
					  var preserveWhitespace = options.preserveWhitespace !== false;
					  var root;
					  var currentParent;
					  var inVPre = false;
					  var inPre = false;
					  var warned = false;
					  parseHTML(template, {
					    expectHTML: options.expectHTML,
					    isUnaryTag: options.isUnaryTag,
					    shouldDecodeNewlines: options.shouldDecodeNewlines,
					    start: function start (tag, attrs, unary) {
					      // check namespace.
					      // inherit parent ns if there is one
					      var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);

					      // handle IE svg bug
					      /* istanbul ignore if */
					      if (options.isIE && ns === 'svg') {
					        attrs = guardIESVGBug(attrs);
					      }

					      var element = {
					        type: 1,
					        tag: tag,
					        attrsList: attrs,
					        attrsMap: makeAttrsMap(attrs, options.isIE),
					        parent: currentParent,
					        children: []
					      };
					      if (ns) {
					        element.ns = ns;
					      }

					      if ("client" !== 'server' && isForbiddenTag(element)) {
					        element.forbidden = true;
					        "development" !== 'production' && warn$1(
					          'Templates should only be responsible for mapping the state to the ' +
					          'UI. Avoid placing tags with side-effects in your templates, such as ' +
					          "<" + tag + ">."
					        );
					      }

					      // apply pre-transforms
					      for (var i = 0; i < preTransforms.length; i++) {
					        preTransforms[i](element, options);
					      }

					      if (!inVPre) {
					        processPre(element);
					        if (element.pre) {
					          inVPre = true;
					        }
					      }
					      if (platformIsPreTag(element.tag)) {
					        inPre = true;
					      }
					      if (inVPre) {
					        processRawAttrs(element);
					      } else {
					        processFor(element);
					        processIf(element);
					        processOnce(element);
					        processKey(element);

					        // determine whether this is a plain element after
					        // removing structural attributes
					        element.plain = !element.key && !attrs.length;

					        processRef(element);
					        processSlot(element);
					        processComponent(element);
					        for (var i$1 = 0; i$1 < transforms.length; i$1++) {
					          transforms[i$1](element, options);
					        }
					        processAttrs(element);
					      }

					      function checkRootConstraints (el) {
					        if ("development" !== 'production' && !warned) {
					          if (el.tag === 'slot' || el.tag === 'template') {
					            warned = true;
					            warn$1(
					              "Cannot use <" + (el.tag) + "> as component root element because it may " +
					              'contain multiple nodes:\n' + template
					            );
					          }
					          if (el.attrsMap.hasOwnProperty('v-for')) {
					            warned = true;
					            warn$1(
					              'Cannot use v-for on stateful component root element because ' +
					              'it renders multiple elements:\n' + template
					            );
					          }
					        }
					      }

					      // tree management
					      if (!root) {
					        root = element;
					        checkRootConstraints(root);
					      } else if (!stack.length) {
					        // allow 2 root elements with v-if and v-else
					        if (root.if && element.else) {
					          checkRootConstraints(element);
					          root.elseBlock = element;
					        } else if ("development" !== 'production' && !warned) {
					          warned = true;
					          warn$1(
					            ("Component template should contain exactly one root element:\n\n" + template)
					          );
					        }
					      }
					      if (currentParent && !element.forbidden) {
					        if (element.else) {
					          processElse(element, currentParent);
					        } else {
					          currentParent.children.push(element);
					          element.parent = currentParent;
					        }
					      }
					      if (!unary) {
					        currentParent = element;
					        stack.push(element);
					      }
					      // apply post-transforms
					      for (var i$2 = 0; i$2 < postTransforms.length; i$2++) {
					        postTransforms[i$2](element, options);
					      }
					    },

					    end: function end () {
					      // remove trailing whitespace
					      var element = stack[stack.length - 1];
					      var lastNode = element.children[element.children.length - 1];
					      if (lastNode && lastNode.type === 3 && lastNode.text === ' ') {
					        element.children.pop();
					      }
					      // pop stack
					      stack.length -= 1;
					      currentParent = stack[stack.length - 1];
					      // check pre state
					      if (element.pre) {
					        inVPre = false;
					      }
					      if (platformIsPreTag(element.tag)) {
					        inPre = false;
					      }
					    },

					    chars: function chars (text) {
					      if (!currentParent) {
					        if ("development" !== 'production' && !warned && text === template) {
					          warned = true;
					          warn$1(
					            'Component template requires a root element, rather than just text:\n\n' + template
					          );
					        }
					        return
					      }
					      text = inPre || text.trim()
					        ? decodeHTMLCached(text)
					        // only preserve whitespace if its not right after a starting tag
					        : preserveWhitespace && currentParent.children.length ? ' ' : '';
					      if (text) {
					        var expression;
					        if (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {
					          currentParent.children.push({
					            type: 2,
					            expression: expression,
					            text: text
					          });
					        } else {
					          // #3895 special character
					          text = text.replace(specialNewlineRE, '');
					          currentParent.children.push({
					            type: 3,
					            text: text
					          });
					        }
					      }
					    }
					  });
					  return root
					}

					function processPre (el) {
					  if (getAndRemoveAttr(el, 'v-pre') != null) {
					    el.pre = true;
					  }
					}

					function processRawAttrs (el) {
					  var l = el.attrsList.length;
					  if (l) {
					    var attrs = el.attrs = new Array(l);
					    for (var i = 0; i < l; i++) {
					      attrs[i] = {
					        name: el.attrsList[i].name,
					        value: JSON.stringify(el.attrsList[i].value)
					      };
					    }
					  } else if (!el.pre) {
					    // non root node in pre blocks with no attributes
					    el.plain = true;
					  }
					}

					function processKey (el) {
					  var exp = getBindingAttr(el, 'key');
					  if (exp) {
					    if ("development" !== 'production' && el.tag === 'template') {
					      warn$1("<template> cannot be keyed. Place the key on real elements instead.");
					    }
					    el.key = exp;
					  }
					}

					function processRef (el) {
					  var ref = getBindingAttr(el, 'ref');
					  if (ref) {
					    el.ref = ref;
					    el.refInFor = checkInFor(el);
					  }
					}

					function processFor (el) {
					  var exp;
					  if ((exp = getAndRemoveAttr(el, 'v-for'))) {
					    var inMatch = exp.match(forAliasRE);
					    if (!inMatch) {
					      "development" !== 'production' && warn$1(
					        ("Invalid v-for expression: " + exp)
					      );
					      return
					    }
					    el.for = inMatch[2].trim();
					    var alias = inMatch[1].trim();
					    var iteratorMatch = alias.match(forIteratorRE);
					    if (iteratorMatch) {
					      el.alias = iteratorMatch[1].trim();
					      el.iterator1 = iteratorMatch[2].trim();
					      if (iteratorMatch[3]) {
					        el.iterator2 = iteratorMatch[3].trim();
					      }
					    } else {
					      el.alias = alias;
					    }
					  }
					}

					function processIf (el) {
					  var exp = getAndRemoveAttr(el, 'v-if');
					  if (exp) {
					    el.if = exp;
					  }
					  if (getAndRemoveAttr(el, 'v-else') != null) {
					    el.else = true;
					  }
					}

					function processElse (el, parent) {
					  var prev = findPrevElement(parent.children);
					  if (prev && prev.if) {
					    prev.elseBlock = el;
					  } else {
					    warn$1(
					      ("v-else used on element <" + (el.tag) + "> without corresponding v-if.")
					    );
					  }
					}

					function processOnce (el) {
					  var once = getAndRemoveAttr(el, 'v-once');
					  if (once != null) {
					    el.once = true;
					  }
					}

					function processSlot (el) {
					  if (el.tag === 'slot') {
					    el.slotName = getBindingAttr(el, 'name');
					  } else {
					    var slotTarget = getBindingAttr(el, 'slot');
					    if (slotTarget) {
					      el.slotTarget = slotTarget;
					    }
					  }
					}

					function processComponent (el) {
					  var binding;
					  if ((binding = getBindingAttr(el, 'is'))) {
					    el.component = binding;
					  }
					  if (getAndRemoveAttr(el, 'inline-template') != null) {
					    el.inlineTemplate = true;
					  }
					}

					function processAttrs (el) {
					  var list = el.attrsList;
					  var i, l, name, rawName, value, arg, modifiers, isProp;
					  for (i = 0, l = list.length; i < l; i++) {
					    name = rawName = list[i].name;
					    value = list[i].value;
					    if (dirRE.test(name)) {
					      // mark element as dynamic
					      el.hasBindings = true;
					      // modifiers
					      modifiers = parseModifiers(name);
					      if (modifiers) {
					        name = name.replace(modifierRE, '');
					      }
					      if (bindRE.test(name)) { // v-bind
					        name = name.replace(bindRE, '');
					        if (modifiers && modifiers.prop) {
					          isProp = true;
					          name = camelize(name);
					          if (name === 'innerHtml') { name = 'innerHTML'; }
					        }
					        if (isProp || platformMustUseProp(name)) {
					          addProp(el, name, value);
					        } else {
					          addAttr(el, name, value);
					        }
					      } else if (onRE.test(name)) { // v-on
					        name = name.replace(onRE, '');
					        addHandler(el, name, value, modifiers);
					      } else { // normal directives
					        name = name.replace(dirRE, '');
					        // parse arg
					        var argMatch = name.match(argRE);
					        if (argMatch && (arg = argMatch[1])) {
					          name = name.slice(0, -(arg.length + 1));
					        }
					        addDirective(el, name, rawName, value, arg, modifiers);
					        if ("development" !== 'production' && name === 'model') {
					          checkForAliasModel(el, value);
					        }
					      }
					    } else {
					      // literal attribute
					      {
					        var expression = parseText(value, delimiters);
					        if (expression) {
					          warn$1(
					            name + "=\"" + value + "\": " +
					            'Interpolation inside attributes has been removed. ' +
					            'Use v-bind or the colon shorthand instead. For example, ' +
					            'instead of <div id="{{ val }}">, use <div :id="val">.'
					          );
					        }
					      }
					      addAttr(el, name, JSON.stringify(value));
					    }
					  }
					}

					function checkInFor (el) {
					  var parent = el;
					  while (parent) {
					    if (parent.for !== undefined) {
					      return true
					    }
					    parent = parent.parent;
					  }
					  return false
					}

					function parseModifiers (name) {
					  var match = name.match(modifierRE);
					  if (match) {
					    var ret = {};
					    match.forEach(function (m) { ret[m.slice(1)] = true; });
					    return ret
					  }
					}

					function makeAttrsMap (attrs, isIE) {
					  var map = {};
					  for (var i = 0, l = attrs.length; i < l; i++) {
					    if ("development" !== 'production' && map[attrs[i].name] && !isIE) {
					      warn$1('duplicate attribute: ' + attrs[i].name);
					    }
					    map[attrs[i].name] = attrs[i].value;
					  }
					  return map
					}

					function findPrevElement (children) {
					  var i = children.length;
					  while (i--) {
					    if (children[i].tag) { return children[i] }
					  }
					}

					function isForbiddenTag (el) {
					  return (
					    el.tag === 'style' ||
					    (el.tag === 'script' && (
					      !el.attrsMap.type ||
					      el.attrsMap.type === 'text/javascript'
					    ))
					  )
					}

					var ieNSBug = /^xmlns:NS\d+/;
					var ieNSPrefix = /^NS\d+:/;

					/* istanbul ignore next */
					function guardIESVGBug (attrs) {
					  var res = [];
					  for (var i = 0; i < attrs.length; i++) {
					    var attr = attrs[i];
					    if (!ieNSBug.test(attr.name)) {
					      attr.name = attr.name.replace(ieNSPrefix, '');
					      res.push(attr);
					    }
					  }
					  return res
					}

					function checkForAliasModel (el, value) {
					  var _el = el;
					  while (_el) {
					    if (_el.for && _el.alias === value) {
					      warn$1(
					        "<" + (el.tag) + " v-model=\"" + value + "\">: " +
					        "You are binding v-model directly to a v-for iteration alias. " +
					        "This will not be able to modify the v-for source array because " +
					        "writing to the alias is like modifying a function local variable. " +
					        "Consider using an array of objects and use v-model on an object property instead."
					      );
					    }
					    _el = _el.parent;
					  }
					}

					/*  */

					var isStaticKey;
					var isPlatformReservedTag;

					var genStaticKeysCached = cached(genStaticKeys$1);

					/**
					 * Goal of the optimizer: walk the generated template AST tree
					 * and detect sub-trees that are purely static, i.e. parts of
					 * the DOM that never needs to change.
					 *
					 * Once we detect these sub-trees, we can:
					 *
					 * 1. Hoist them into constants, so that we no longer need to
					 *    create fresh nodes for them on each re-render;
					 * 2. Completely skip them in the patching process.
					 */
					function optimize (root, options) {
					  if (!root) { return }
					  isStaticKey = genStaticKeysCached(options.staticKeys || '');
					  isPlatformReservedTag = options.isReservedTag || (function () { return false; });
					  // first pass: mark all non-static nodes.
					  markStatic(root);
					  // second pass: mark static roots.
					  markStaticRoots(root, false);
					}

					function genStaticKeys$1 (keys) {
					  return makeMap(
					    'type,tag,attrsList,attrsMap,plain,parent,children,attrs' +
					    (keys ? ',' + keys : '')
					  )
					}

					function markStatic (node) {
					  node.static = isStatic(node);
					  if (node.type === 1) {
					    for (var i = 0, l = node.children.length; i < l; i++) {
					      var child = node.children[i];
					      markStatic(child);
					      if (!child.static) {
					        node.static = false;
					      }
					    }
					  }
					}

					function markStaticRoots (node, isInFor) {
					  if (node.type === 1) {
					    if (node.static || node.once) {
					      node.staticInFor = isInFor;
					    }
					    if (node.static) {
					      node.staticRoot = true;
					      return
					    }
					    if (node.children) {
					      for (var i = 0, l = node.children.length; i < l; i++) {
					        markStaticRoots(node.children[i], isInFor || !!node.for);
					      }
					    }
					  }
					}

					function isStatic (node) {
					  if (node.type === 2) { // expression
					    return false
					  }
					  if (node.type === 3) { // text
					    return true
					  }
					  return !!(node.pre || (
					    !node.hasBindings && // no dynamic bindings
					    !node.if && !node.for && // not v-if or v-for or v-else
					    !isBuiltInTag(node.tag) && // not a built-in
					    isPlatformReservedTag(node.tag) && // not a component
					    !isDirectChildOfTemplateFor(node) &&
					    Object.keys(node).every(isStaticKey)
					  ))
					}

					function isDirectChildOfTemplateFor (node) {
					  while (node.parent) {
					    node = node.parent;
					    if (node.tag !== 'template') {
					      return false
					    }
					    if (node.for) {
					      return true
					    }
					  }
					  return false
					}

					/*  */

					var simplePathRE = /^\s*[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['.*?']|\[".*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*\s*$/;

					// keyCode aliases
					var keyCodes = {
					  esc: 27,
					  tab: 9,
					  enter: 13,
					  space: 32,
					  up: 38,
					  left: 37,
					  right: 39,
					  down: 40,
					  'delete': [8, 46]
					};

					var modifierCode = {
					  stop: '$event.stopPropagation();',
					  prevent: '$event.preventDefault();',
					  self: 'if($event.target !== $event.currentTarget)return;'
					};

					function genHandlers (events, native) {
					  var res = native ? 'nativeOn:{' : 'on:{';
					  for (var name in events) {
					    res += "\"" + name + "\":" + (genHandler(events[name])) + ",";
					  }
					  return res.slice(0, -1) + '}'
					}

					function genHandler (
					  handler
					) {
					  if (!handler) {
					    return 'function(){}'
					  } else if (Array.isArray(handler)) {
					    return ("[" + (handler.map(genHandler).join(',')) + "]")
					  } else if (!handler.modifiers) {
					    return simplePathRE.test(handler.value)
					      ? handler.value
					      : ("function($event){" + (handler.value) + "}")
					  } else {
					    var code = '';
					    var keys = [];
					    for (var key in handler.modifiers) {
					      if (modifierCode[key]) {
					        code += modifierCode[key];
					      } else {
					        keys.push(key);
					      }
					    }
					    if (keys.length) {
					      code = genKeyFilter(keys) + code;
					    }
					    var handlerCode = simplePathRE.test(handler.value)
					      ? handler.value + '($event)'
					      : handler.value;
					    return 'function($event){' + code + handlerCode + '}'
					  }
					}

					function genKeyFilter (keys) {
					  var code = keys.length === 1
					    ? normalizeKeyCode(keys[0])
					    : Array.prototype.concat.apply([], keys.map(normalizeKeyCode));
					  if (Array.isArray(code)) {
					    return ("if(" + (code.map(function (c) { return ("$event.keyCode!==" + c); }).join('&&')) + ")return;")
					  } else {
					    return ("if($event.keyCode!==" + code + ")return;")
					  }
					}

					function normalizeKeyCode (key) {
					  return (
					    parseInt(key, 10) || // number keyCode
					    keyCodes[key] || // built-in alias
					    ("_k(" + (JSON.stringify(key)) + ")") // custom alias
					  )
					}

					/*  */

					function bind$2 (el, dir) {
					  el.wrapData = function (code) {
					    return ("_b(" + code + "," + (dir.value) + (dir.modifiers && dir.modifiers.prop ? ',true' : '') + ")")
					  };
					}

					var baseDirectives = {
					  bind: bind$2,
					  cloak: noop
					};

					/*  */

					// configurable state
					var warn$2;
					var transforms$1;
					var dataGenFns;
					var platformDirectives$1;
					var staticRenderFns;
					var onceCount;
					var currentOptions;

					function generate (
					  ast,
					  options
					) {
					  // save previous staticRenderFns so generate calls can be nested
					  var prevStaticRenderFns = staticRenderFns;
					  var currentStaticRenderFns = staticRenderFns = [];
					  var prevOnceCount = onceCount;
					  onceCount = 0;
					  currentOptions = options;
					  warn$2 = options.warn || baseWarn;
					  transforms$1 = pluckModuleFunction(options.modules, 'transformCode');
					  dataGenFns = pluckModuleFunction(options.modules, 'genData');
					  platformDirectives$1 = options.directives || {};
					  var code = ast ? genElement(ast) : '_h("div")';
					  staticRenderFns = prevStaticRenderFns;
					  onceCount = prevOnceCount;
					  return {
					    render: ("with(this){return " + code + "}"),
					    staticRenderFns: currentStaticRenderFns
					  }
					}

					function genElement (el) {
					  if (el.staticRoot && !el.staticProcessed) {
					    return genStatic(el)
					  } else if (el.once && !el.onceProcessed) {
					    return genOnce(el)
					  } else if (el.for && !el.forProcessed) {
					    return genFor(el)
					  } else if (el.if && !el.ifProcessed) {
					    return genIf(el)
					  } else if (el.tag === 'template' && !el.slotTarget) {
					    return genChildren(el) || 'void 0'
					  } else if (el.tag === 'slot') {
					    return genSlot(el)
					  } else {
					    // component or element
					    var code;
					    if (el.component) {
					      code = genComponent(el.component, el);
					    } else {
					      var data = el.plain ? undefined : genData(el);

					      var children = el.inlineTemplate ? null : genChildren(el);
					      code = "_h('" + (el.tag) + "'" + (data ? ("," + data) : '') + (children ? ("," + children) : '') + ")";
					    }
					    // module transforms
					    for (var i = 0; i < transforms$1.length; i++) {
					      code = transforms$1[i](el, code);
					    }
					    return code
					  }
					}

					// hoist static sub-trees out
					function genStatic (el) {
					  el.staticProcessed = true;
					  staticRenderFns.push(("with(this){return " + (genElement(el)) + "}"));
					  return ("_m(" + (staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + ")")
					}

					// v-once
					function genOnce (el) {
					  el.onceProcessed = true;
					  if (el.staticInFor) {
					    var key = '';
					    var parent = el.parent;
					    while (parent) {
					      if (parent.for) {
					        key = parent.key;
					        break
					      }
					      parent = parent.parent;
					    }
					    if (!key) {
					      "development" !== 'production' && warn$2(
					        "v-once can only be used inside v-for that is keyed. "
					      );
					      return genElement(el)
					    }
					    return ("_o(" + (genElement(el)) + "," + (onceCount++) + (key ? ("," + key) : "") + ")")
					  } else {
					    return genStatic(el)
					  }
					}

					function genIf (el) {
					  var exp = el.if;
					  el.ifProcessed = true; // avoid recursion
					  return ("(" + exp + ")?" + (genElement(el)) + ":" + (genElse(el)))
					}

					function genElse (el) {
					  return el.elseBlock
					    ? genElement(el.elseBlock)
					    : '_e()'
					}

					function genFor (el) {
					  var exp = el.for;
					  var alias = el.alias;
					  var iterator1 = el.iterator1 ? ("," + (el.iterator1)) : '';
					  var iterator2 = el.iterator2 ? ("," + (el.iterator2)) : '';
					  el.forProcessed = true; // avoid recursion
					  return "_l((" + exp + ")," +
					    "function(" + alias + iterator1 + iterator2 + "){" +
					      "return " + (genElement(el)) +
					    '})'
					}

					function genData (el) {
					  var data = '{';

					  // directives first.
					  // directives may mutate the el's other properties before they are generated.
					  var dirs = genDirectives(el);
					  if (dirs) { data += dirs + ','; }

					  // key
					  if (el.key) {
					    data += "key:" + (el.key) + ",";
					  }
					  // ref
					  if (el.ref) {
					    data += "ref:" + (el.ref) + ",";
					  }
					  if (el.refInFor) {
					    data += "refInFor:true,";
					  }
					  // record original tag name for components using "is" attribute
					  if (el.component) {
					    data += "tag:\"" + (el.tag) + "\",";
					  }
					  // slot target
					  if (el.slotTarget) {
					    data += "slot:" + (el.slotTarget) + ",";
					  }
					  // module data generation functions
					  for (var i = 0; i < dataGenFns.length; i++) {
					    data += dataGenFns[i](el);
					  }
					  // attributes
					  if (el.attrs) {
					    data += "attrs:{" + (genProps(el.attrs)) + "},";
					  }
					  // DOM props
					  if (el.props) {
					    data += "domProps:{" + (genProps(el.props)) + "},";
					  }
					  // event handlers
					  if (el.events) {
					    data += (genHandlers(el.events)) + ",";
					  }
					  if (el.nativeEvents) {
					    data += (genHandlers(el.nativeEvents, true)) + ",";
					  }
					  // inline-template
					  if (el.inlineTemplate) {
					    var ast = el.children[0];
					    if ("development" !== 'production' && (
					      el.children.length > 1 || ast.type !== 1
					    )) {
					      warn$2('Inline-template components must have exactly one child element.');
					    }
					    if (ast.type === 1) {
					      var inlineRenderFns = generate(ast, currentOptions);
					      data += "inlineTemplate:{render:function(){" + (inlineRenderFns.render) + "},staticRenderFns:[" + (inlineRenderFns.staticRenderFns.map(function (code) { return ("function(){" + code + "}"); }).join(',')) + "]}";
					    }
					  }
					  data = data.replace(/,$/, '') + '}';
					  // v-bind data wrap
					  if (el.wrapData) {
					    data = el.wrapData(data);
					  }
					  return data
					}

					function genDirectives (el) {
					  var dirs = el.directives;
					  if (!dirs) { return }
					  var res = 'directives:[';
					  var hasRuntime = false;
					  var i, l, dir, needRuntime;
					  for (i = 0, l = dirs.length; i < l; i++) {
					    dir = dirs[i];
					    needRuntime = true;
					    var gen = platformDirectives$1[dir.name] || baseDirectives[dir.name];
					    if (gen) {
					      // compile-time directive that manipulates AST.
					      // returns true if it also needs a runtime counterpart.
					      needRuntime = !!gen(el, dir, warn$2);
					    }
					    if (needRuntime) {
					      hasRuntime = true;
					      res += "{name:\"" + (dir.name) + "\",rawName:\"" + (dir.rawName) + "\"" + (dir.value ? (",value:(" + (dir.value) + "),expression:" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (",arg:\"" + (dir.arg) + "\"") : '') + (dir.modifiers ? (",modifiers:" + (JSON.stringify(dir.modifiers))) : '') + "},";
					    }
					  }
					  if (hasRuntime) {
					    return res.slice(0, -1) + ']'
					  }
					}

					function genChildren (el) {
					  if (el.children.length) {
					    return '[' + el.children.map(genNode).join(',') + ']'
					  }
					}

					function genNode (node) {
					  if (node.type === 1) {
					    return genElement(node)
					  } else {
					    return genText(node)
					  }
					}

					function genText (text) {
					  return text.type === 2
					    ? text.expression // no need for () because already wrapped in _s()
					    : JSON.stringify(text.text)
					}

					function genSlot (el) {
					  var slotName = el.slotName || '"default"';
					  var children = genChildren(el);
					  return ("_t(" + slotName + (children ? ("," + children) : '') + ")")
					}

					// componentName is el.component, take it as argument to shun flow's pessimistic refinement
					function genComponent (componentName, el) {
					  var children = el.inlineTemplate ? null : genChildren(el);
					  return ("_h(" + componentName + "," + (genData(el)) + (children ? ("," + children) : '') + ")")
					}

					function genProps (props) {
					  var res = '';
					  for (var i = 0; i < props.length; i++) {
					    var prop = props[i];
					    res += "\"" + (prop.name) + "\":" + (prop.value) + ",";
					  }
					  return res.slice(0, -1)
					}

					/*  */

					/**
					 * Compile a template.
					 */
					function compile$1 (
					  template,
					  options
					) {
					  var ast = parse(template.trim(), options);
					  optimize(ast, options);
					  var code = generate(ast, options);
					  return {
					    ast: ast,
					    render: code.render,
					    staticRenderFns: code.staticRenderFns
					  }
					}

					/*  */

					// operators like typeof, instanceof and in are allowed
					var prohibitedKeywordRE = new RegExp('\\b' + (
					  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +
					  'super,throw,while,yield,delete,export,import,return,switch,default,' +
					  'extends,finally,continue,debugger,function,arguments'
					).split(',').join('\\b|\\b') + '\\b');
					// check valid identifier for v-for
					var identRE = /[A-Za-z_$][\w$]*/;
					// strip strings in expressions
					var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;

					// detect problematic expressions in a template
					function detectErrors (ast) {
					  var errors = [];
					  if (ast) {
					    checkNode(ast, errors);
					  }
					  return errors
					}

					function checkNode (node, errors) {
					  if (node.type === 1) {
					    for (var name in node.attrsMap) {
					      if (dirRE.test(name)) {
					        var value = node.attrsMap[name];
					        if (value) {
					          if (name === 'v-for') {
					            checkFor(node, ("v-for=\"" + value + "\""), errors);
					          } else {
					            checkExpression(value, (name + "=\"" + value + "\""), errors);
					          }
					        }
					      }
					    }
					    if (node.children) {
					      for (var i = 0; i < node.children.length; i++) {
					        checkNode(node.children[i], errors);
					      }
					    }
					  } else if (node.type === 2) {
					    checkExpression(node.expression, node.text, errors);
					  }
					}

					function checkFor (node, text, errors) {
					  checkExpression(node.for || '', text, errors);
					  checkIdentifier(node.alias, 'v-for alias', text, errors);
					  checkIdentifier(node.iterator1, 'v-for iterator', text, errors);
					  checkIdentifier(node.iterator2, 'v-for iterator', text, errors);
					}

					function checkIdentifier (ident, type, text, errors) {
					  if (typeof ident === 'string' && !identRE.test(ident)) {
					    errors.push(("- invalid " + type + " \"" + ident + "\" in expression: " + text));
					  }
					}

					function checkExpression (exp, text, errors) {
					  try {
					    new Function(("return " + exp));
					  } catch (e) {
					    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);
					    if (keywordMatch) {
					      errors.push(
					        "- avoid using JavaScript keyword as property name: " +
					        "\"" + (keywordMatch[0]) + "\" in expression " + text
					      );
					    } else {
					      errors.push(("- invalid expression: " + text));
					    }
					  }
					}

					/*  */

					function transformNode (el, options) {
					  var warn = options.warn || baseWarn;
					  var staticClass = getAndRemoveAttr(el, 'class');
					  if ("development" !== 'production' && staticClass) {
					    var expression = parseText(staticClass, options.delimiters);
					    if (expression) {
					      warn(
					        "class=\"" + staticClass + "\": " +
					        'Interpolation inside attributes has been removed. ' +
					        'Use v-bind or the colon shorthand instead. For example, ' +
					        'instead of <div class="{{ val }}">, use <div :class="val">.'
					      );
					    }
					  }
					  if (staticClass) {
					    el.staticClass = JSON.stringify(staticClass);
					  }
					  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);
					  if (classBinding) {
					    el.classBinding = classBinding;
					  }
					}

					function genData$1 (el) {
					  var data = '';
					  if (el.staticClass) {
					    data += "staticClass:" + (el.staticClass) + ",";
					  }
					  if (el.classBinding) {
					    data += "class:" + (el.classBinding) + ",";
					  }
					  return data
					}

					var klass$1 = {
					  staticKeys: ['staticClass'],
					  transformNode: transformNode,
					  genData: genData$1
					};

					/*  */

					function transformNode$1 (el) {
					  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);
					  if (styleBinding) {
					    el.styleBinding = styleBinding;
					  }
					}

					function genData$2 (el) {
					  return el.styleBinding
					    ? ("style:(" + (el.styleBinding) + "),")
					    : ''
					}

					var style$1 = {
					  transformNode: transformNode$1,
					  genData: genData$2
					};

					var modules$1 = [
					  klass$1,
					  style$1
					];

					/*  */

					var len;
					var str;
					var chr;
					var index$1;
					var expressionPos;
					var expressionEndPos;

					/**
					 * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)
					 *
					 * for loop possible cases:
					 *
					 * - test
					 * - test[idx]
					 * - test[test1[idx]]
					 * - test["a"][idx]
					 * - xxx.test[a[a].test1[idx]]
					 * - test.xxx.a["asa"][test1[idx]]
					 *
					 */

					function parseModel (val) {
					  str = val;
					  len = str.length;
					  index$1 = expressionPos = expressionEndPos = 0;

					  if (val.indexOf('[') < 0) {
					    return {
					      exp: val,
					      idx: null
					    }
					  }

					  while (!eof()) {
					    chr = next();
					    /* istanbul ignore if */
					    if (isStringStart(chr)) {
					      parseString(chr);
					    } else if (chr === 0x5B) {
					      parseBracket(chr);
					    }
					  }

					  return {
					    exp: val.substring(0, expressionPos),
					    idx: val.substring(expressionPos + 1, expressionEndPos)
					  }
					}

					function next () {
					  return str.charCodeAt(++index$1)
					}

					function eof () {
					  return index$1 >= len
					}

					function isStringStart (chr) {
					  return chr === 0x22 || chr === 0x27
					}

					function parseBracket (chr) {
					  var inBracket = 1;
					  expressionPos = index$1;
					  while (!eof()) {
					    chr = next();
					    if (isStringStart(chr)) {
					      parseString(chr);
					      continue
					    }
					    if (chr === 0x5B) { inBracket++; }
					    if (chr === 0x5D) { inBracket--; }
					    if (inBracket === 0) {
					      expressionEndPos = index$1;
					      break
					    }
					  }
					}

					function parseString (chr) {
					  var stringQuote = chr;
					  while (!eof()) {
					    chr = next();
					    if (chr === stringQuote) {
					      break
					    }
					  }
					}

					/*  */

					var warn$3;

					function model$1 (
					  el,
					  dir,
					  _warn
					) {
					  warn$3 = _warn;
					  var value = dir.value;
					  var modifiers = dir.modifiers;
					  var tag = el.tag;
					  var type = el.attrsMap.type;
					  {
					    var dynamicType = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];
					    if (tag === 'input' && dynamicType) {
					      warn$3(
					        "<input :type=\"" + dynamicType + "\" v-model=\"" + value + "\">:\n" +
					        "v-model does not support dynamic input types. Use v-if branches instead."
					      );
					    }
					  }
					  if (tag === 'select') {
					    genSelect(el, value, modifiers);
					  } else if (tag === 'input' && type === 'checkbox') {
					    genCheckboxModel(el, value, modifiers);
					  } else if (tag === 'input' && type === 'radio') {
					    genRadioModel(el, value, modifiers);
					  } else {
					    genDefaultModel(el, value, modifiers);
					  }
					  // ensure runtime directive metadata
					  return true
					}

					function genCheckboxModel (
					  el,
					  value,
					  modifiers
					) {
					  if ("development" !== 'production' &&
					    el.attrsMap.checked != null) {
					    warn$3(
					      "<" + (el.tag) + " v-model=\"" + value + "\" checked>:\n" +
					      "inline checked attributes will be ignored when using v-model. " +
					      'Declare initial values in the component\'s data option instead.'
					    );
					  }
					  var number = modifiers && modifiers.number;
					  var valueBinding = getBindingAttr(el, 'value') || 'null';
					  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';
					  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';
					  addProp(el, 'checked',
					    "Array.isArray(" + value + ")" +
					      "?_i(" + value + "," + valueBinding + ")>-1" +
					      ":_q(" + value + "," + trueValueBinding + ")"
					  );
					  addHandler(el, 'change',
					    "var $$a=" + value + "," +
					        '$$el=$event.target,' +
					        "$$c=$$el.checked?(" + trueValueBinding + "):(" + falseValueBinding + ");" +
					    'if(Array.isArray($$a)){' +
					      "var $$v=" + (number ? '_n(' + valueBinding + ')' : valueBinding) + "," +
					          '$$i=_i($$a,$$v);' +
					      "if($$c){$$i<0&&(" + value + "=$$a.concat($$v))}" +
					      "else{$$i>-1&&(" + value + "=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}" +
					    "}else{" + value + "=$$c}",
					    null, true
					  );
					}

					function genRadioModel (
					    el,
					    value,
					    modifiers
					) {
					  if ("development" !== 'production' &&
					    el.attrsMap.checked != null) {
					    warn$3(
					      "<" + (el.tag) + " v-model=\"" + value + "\" checked>:\n" +
					      "inline checked attributes will be ignored when using v-model. " +
					      'Declare initial values in the component\'s data option instead.'
					    );
					  }
					  var number = modifiers && modifiers.number;
					  var valueBinding = getBindingAttr(el, 'value') || 'null';
					  valueBinding = number ? ("_n(" + valueBinding + ")") : valueBinding;
					  addProp(el, 'checked', ("_q(" + value + "," + valueBinding + ")"));
					  addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);
					}

					function genDefaultModel (
					  el,
					  value,
					  modifiers
					) {
					  {
					    if (el.tag === 'input' && el.attrsMap.value) {
					      warn$3(
					        "<" + (el.tag) + " v-model=\"" + value + "\" value=\"" + (el.attrsMap.value) + "\">:\n" +
					        'inline value attributes will be ignored when using v-model. ' +
					        'Declare initial values in the component\'s data option instead.'
					      );
					    }
					    if (el.tag === 'textarea' && el.children.length) {
					      warn$3(
					        "<textarea v-model=\"" + value + "\">:\n" +
					        'inline content inside <textarea> will be ignored when using v-model. ' +
					        'Declare initial values in the component\'s data option instead.'
					      );
					    }
					  }

					  var type = el.attrsMap.type;
					  var ref = modifiers || {};
					  var lazy = ref.lazy;
					  var number = ref.number;
					  var trim = ref.trim;
					  var event = lazy || (isIE && type === 'range') ? 'change' : 'input';
					  var needCompositionGuard = !lazy && type !== 'range';
					  var isNative = el.tag === 'input' || el.tag === 'textarea';

					  var valueExpression = isNative
					    ? ("$event.target.value" + (trim ? '.trim()' : ''))
					    : "$event";
					  valueExpression = number || type === 'number'
					    ? ("_n(" + valueExpression + ")")
					    : valueExpression;
					  var code = genAssignmentCode(value, valueExpression);
					  if (isNative && needCompositionGuard) {
					    code = "if($event.target.composing)return;" + code;
					  }
					  // inputs with type="file" are read only and setting the input's
					  // value will throw an error.
					  if ("development" !== 'production' &&
					      type === 'file') {
					    warn$3(
					      "<" + (el.tag) + " v-model=\"" + value + "\" type=\"file\">:\n" +
					      "File inputs are read only. Use a v-on:change listener instead."
					    );
					  }
					  addProp(el, 'value', isNative ? ("_s(" + value + ")") : ("(" + value + ")"));
					  addHandler(el, event, code, null, true);
					}

					function genSelect (
					    el,
					    value,
					    modifiers
					) {
					  {
					    el.children.some(checkOptionWarning);
					  }

					  var number = modifiers && modifiers.number;
					  var assignment = "Array.prototype.filter" +
					    ".call($event.target.options,function(o){return o.selected})" +
					    ".map(function(o){var val = \"_value\" in o ? o._value : o.value;" +
					    "return " + (number ? '_n(val)' : 'val') + "})" +
					    (el.attrsMap.multiple == null ? '[0]' : '');

					  var code = genAssignmentCode(value, assignment);
					  addHandler(el, 'change', code, null, true);
					}

					function checkOptionWarning (option) {
					  if (option.type === 1 &&
					    option.tag === 'option' &&
					    option.attrsMap.selected != null) {
					    warn$3(
					      "<select v-model=\"" + (option.parent.attrsMap['v-model']) + "\">:\n" +
					      'inline selected attributes on <option> will be ignored when using v-model. ' +
					      'Declare initial values in the component\'s data option instead.'
					    );
					    return true
					  }
					  return false
					}

					function genAssignmentCode (value, assignment) {
					  var modelRs = parseModel(value);
					  if (modelRs.idx === null) {
					    return (value + "=" + assignment)
					  } else {
					    return "var $$exp = " + (modelRs.exp) + ", $$idx = " + (modelRs.idx) + ";" +
					      "if (!Array.isArray($$exp)){" +
					        value + "=" + assignment + "}" +
					      "else{$$exp.splice($$idx, 1, " + assignment + ")}"
					  }
					}

					/*  */

					function text (el, dir) {
					  if (dir.value) {
					    addProp(el, 'textContent', ("_s(" + (dir.value) + ")"));
					  }
					}

					/*  */

					function html (el, dir) {
					  if (dir.value) {
					    addProp(el, 'innerHTML', ("_s(" + (dir.value) + ")"));
					  }
					}

					var directives$1 = {
					  model: model$1,
					  text: text,
					  html: html
					};

					/*  */

					var cache = Object.create(null);

					var baseOptions = {
					  isIE: isIE,
					  expectHTML: true,
					  modules: modules$1,
					  staticKeys: genStaticKeys(modules$1),
					  directives: directives$1,
					  isReservedTag: isReservedTag,
					  isUnaryTag: isUnaryTag,
					  mustUseProp: mustUseProp,
					  getTagNamespace: getTagNamespace,
					  isPreTag: isPreTag
					};

					function compile$$1 (
					  template,
					  options
					) {
					  options = options
					    ? extend(extend({}, baseOptions), options)
					    : baseOptions;
					  return compile$1(template, options)
					}

					function compileToFunctions (
					  template,
					  options,
					  vm
					) {
					  var _warn = (options && options.warn) || warn;
					  // detect possible CSP restriction
					  /* istanbul ignore if */
					  {
					    try {
					      new Function('return 1');
					    } catch (e) {
					      if (e.toString().match(/unsafe-eval|CSP/)) {
					        _warn(
					          'It seems you are using the standalone build of Vue.js in an ' +
					          'environment with Content Security Policy that prohibits unsafe-eval. ' +
					          'The template compiler cannot work in this environment. Consider ' +
					          'relaxing the policy to allow unsafe-eval or pre-compiling your ' +
					          'templates into render functions.'
					        );
					      }
					    }
					  }
					  var key = options && options.delimiters
					    ? String(options.delimiters) + template
					    : template;
					  if (cache[key]) {
					    return cache[key]
					  }
					  var res = {};
					  var compiled = compile$$1(template, options);
					  res.render = makeFunction(compiled.render);
					  var l = compiled.staticRenderFns.length;
					  res.staticRenderFns = new Array(l);
					  for (var i = 0; i < l; i++) {
					    res.staticRenderFns[i] = makeFunction(compiled.staticRenderFns[i]);
					  }
					  {
					    if (res.render === noop || res.staticRenderFns.some(function (fn) { return fn === noop; })) {
					      _warn(
					        "failed to compile template:\n\n" + template + "\n\n" +
					        detectErrors(compiled.ast).join('\n') +
					        '\n\n',
					        vm
					      );
					    }
					  }
					  return (cache[key] = res)
					}

					function makeFunction (code) {
					  try {
					    return new Function(code)
					  } catch (e) {
					    return noop
					  }
					}

					/*  */

					var idToTemplate = cached(function (id) {
					  var el = query(id);
					  return el && el.innerHTML
					});

					var mount = Vue$2.prototype.$mount;
					Vue$2.prototype.$mount = function (
					  el,
					  hydrating
					) {
					  el = el && query(el);

					  /* istanbul ignore if */
					  if (el === document.body || el === document.documentElement) {
					    "development" !== 'production' && warn(
					      "Do not mount Vue to <html> or <body> - mount to normal elements instead."
					    );
					    return this
					  }

					  var options = this.$options;
					  // resolve template/el and convert to render function
					  if (!options.render) {
					    var template = options.template;
					    if (template) {
					      if (typeof template === 'string') {
					        if (template.charAt(0) === '#') {
					          template = idToTemplate(template);
					        }
					      } else if (template.nodeType) {
					        template = template.innerHTML;
					      } else {
					        {
					          warn('invalid template option:' + template, this);
					        }
					        return this
					      }
					    } else if (el) {
					      template = getOuterHTML(el);
					    }
					    if (template) {
					      var ref = compileToFunctions(template, {
					        warn: warn,
					        shouldDecodeNewlines: shouldDecodeNewlines,
					        delimiters: options.delimiters
					      }, this);
					      var render = ref.render;
					      var staticRenderFns = ref.staticRenderFns;
					      options.render = render;
					      options.staticRenderFns = staticRenderFns;
					    }
					  }
					  return mount.call(this, el, hydrating)
					};

					/**
					 * Get outerHTML of elements, taking care
					 * of SVG elements in IE as well.
					 */
					function getOuterHTML (el) {
					  if (el.outerHTML) {
					    return el.outerHTML
					  } else {
					    var container = document.createElement('div');
					    container.appendChild(el.cloneNode(true));
					    return container.innerHTML
					  }
					}

					Vue$2.compile = compileToFunctions;

					return Vue$2;

					})));


				/***/ },
				/* 2 */
				/***/ function(module, exports, __webpack_require__) {

					var Vue = __webpack_require__(1);
					new Vue({
					    el: '#gamearea',
					    data: {
					        length: 6,
					        message: 'Hello Vue!',
					        items: [
					            { name: 'vedge vedgeAnim edge' },
					            { name: 'vedge vedgeAnim edge' }
					        ]
					    }
					})

				/***/ },
				/* 3 */
				/***/ function(module, exports, __webpack_require__) {

					var $ = __webpack_require__(4);
					// Global variables
					var boardSize = 6;
					var tunnelLength = 12;
					var maxTunnelLength;
					var numProbes = 0;
					var probesList = [];
					var tunnel = new Tunnel();
					var finalTunnelGuess = [];
					var gameMode = -1;
					// 0 = Regular
					// 1 = Easy Mode
					var player1Name = "";
					var player2Name = "";
					var player1Score = 0;
					var player2Score = 0;
					var round = 1;
					var winningScore = 0;
					var winningPlayer = "";
					var computer = -1;
					// 0 = Humans
					// 1 = AI
					var gameState = -1;
					// 0 = badGuy placing tunnels
					// 1 = detector placing 1st hour probes
					// 2 = detector placing 2nd hour probes
					// 3 = detector placing 3rd hour probes
					// 4 = detector detecting


					// Clear the board before a new game
					var clearBoard = function () {
					    $(".animate").filter(function() {
					        $(this).removeClass("animate");
					    });
					    $(".final").filter(function() {
					        $(this).removeClass("final");
					    });
					    $(".detectedEdge").filter(function() {
					        $(this).removeClass("detectedEdge");
					    });
					    $(".reveal").filter(function() {
					        $(this).removeClass("reveal");
					    });
					}

					function Node(id) {
					    this.edges = [];
					    this.id = id;

					    this.addEdge = function(e0) {
					        this.edges.push(e0);
					    };

					    this.removeEdge = function(e0) {
					        var index = this.edges.indexOf(e0);
					        this.edges.splice(index, 1);
					    }
					}

					Node.prototype.toString = function nodeToString() {
					    var ret = this.id + ": ";
					    for (var i = 0; i < this.edges.length; i++) {
					        ret += (this.edges[i].id + " ");
					    }
					    return ret;
					}

					function Edge(n1, n2, id) {
					    this.n1 = n1;
					    this.n2 = n2;
					    this.id = id;
					    this.allNodes = [];
					}

					Edge.prototype.toString = function edgeToString() {
					    var ret = this.id + ": ";
					    console.log(ret)
					    for (var i = 0; i < this.allNodes.length; i++) {
					        ret += (this.allNodes[i].id + " ");
					    }
					    return ret;
					}

					function Tunnel() {
					    this.edges = {};
					    this.nodes = {};

					    this.addNode = function(node) {
					        var nodeId = node.id;
					        this.nodes[nodeId] = node;
					    };

					    this.removeNode = function(node) {
					        var nodeId = node.id;
					        delete this.nodes[nodeId];
					    };

					    this.addEdge = function(edge) {
					        var edgeId = edge.id;
					        this.edges[edgeId] = edge;
					    };

					    this.removeEdge = function(edge1) {
					        var edgeId = edge1.id;
					        delete this.edges[edgeId];
					    };

					    this.getStartNode = function() {
					        // Get all nodes that are touching the top row
					        var starts = [];
					        for (var nodeId in this.nodes) {
					            if (!this.nodes.hasOwnProperty(nodeId)) {
					                //not direct property of nodes
					                continue;
					            }

					            node = this.nodes[nodeId];
					            if (Number(node.id) < (boardSize + 1)) {
					                starts.push(node);
					            }
					        }

					        // Out of all nodes on top row, get all that have just one edge
					        var validStarts = [];
					        for (var i = 0; i < starts.length; i++) {
					            if (starts[i].edges.length == 1) {
					                validStarts.push(starts[i]);
					                console.log("valid starts: ", validStarts);
					            }
					        }

					        // If there is just one such node, it's our start
					        // Else there isn't a valid start node and tunnel is invalid
					        console.log("length of validStarts: ", validStarts.length);
					        if (validStarts.length == 1) {
					            console.log("validStarts[0] is ", validStarts[0]);
					            return validStarts[0];
					        }
					        else {
					            return null;
					        }
					    };

					    this.getEndNode = function() {
					        // Get all nodes that are touching the bottom row
					        var ends = [];
					        for (var nodeId in this.nodes) {
					            if (!this.nodes.hasOwnProperty(nodeId)) {
					                // Not direct property of nodes
					                continue;
					            }

					            node = this.nodes[nodeId];
					            if (Number(node.id) >= (boardSize * (boardSize + 1))) {
					                ends.push(node);
					            }
					        }

					        // Out of all nodes on top row, get all that have just one edge
					        var validEnds = [];
					        for (var i = 0; i < ends.length; i++) {
					            if (ends[i].edges.length == 1) {
					                validEnds.push(ends[i]);
					            }
					        }

					        // If there is just one such node, it's our start
					        // Else there isn't a valid start node and tunnel is invalid
					        if (validEnds.length == 1) {
					            return validEnds[0];
					        }
					        else {
					            return null;
					        }
					    };

					    this.validTunnel = function() {
					        console.log("EDGE INFO ", this.edges);
					        console.log("NODES ", this.nodes);
					        //duplicate nodes and edges
					        var allEdgeIds = [];
					        for (var item in this.edges) {
					            allEdgeIds.push(item);
					        }
					        console.log("All edge ids: ", allEdgeIds);
					        var allNodeIds = [];
					        for (var item in this.nodes) {
					            allNodeIds.push(item);
					        }
					        console.log("All nodes: ", allNodeIds);

					        var currNode = this.getStartNode();
					        console.log("Start node: ", currNode);

					        //if there is no start node, tunnel is invalid
					        if (currNode == null) {
					            return false;
					        }

					        //if there is no end node, tunnel is invalid
					        if (this.getEndNode() == null) {
					            return false;
					        }
					        console.log("end node: ", this.getEndNode());

					        //remove start node and it's only edge from total
					        allEdgeIds.splice(allEdgeIds.indexOf(currNode.edges[0].id), 1);

					        //get 2nd node
					        if(currNode.edges[0].n1 != currNode) {
					            currNode = currNode.edges[0].n1;
					        }
					        else {
					            currNode = currNode.edges[0].n2;
					        }

					        while (true) {
					            console.log("beg of loop", currNode.id);

					            //end conditions
					            if (currNode == this.getEndNode()) {
					                console.log("Reached end node");
					                //if we've removed all the edges we're good
					                if (allEdgeIds.length == 0) {
					                    return true;
					                }
					                else {
					                    console.log("AllEdgeIds does NOT == 0");
					                    return false;
					                }
					            }

					            //check that each node we reach only has 2 edges
					            if(currNode.edges.length != 2) {
					                console.log(currNode, "doesn't have 2 edges");
					                return false;
					            }

					            //check that one of the two edges is still alive
					            var nextEdge = null;
					            console.log("curr node edges:", currNode.edges);
					            console.log("All edge Ids: ", allEdgeIds);
					            for (var i = 0; i < currNode.edges.length; i++) {
					                console.log("currNode.edges[i].id ", currNode.edges[i].id);
					                if (allEdgeIds.indexOf(currNode.edges[i].id) > -1) {
					                    nextEdge = this.edges[currNode.edges[i].id];
					                }
					            }

					            //neither edge still in total list, tunnel invalid
					            if (nextEdge == null) {
					                console.log(nextEdge, "neither edge still in total list");
					                return false;
					            }

					            //clean up - remove curr node and curr edge
					            allEdgeIds.splice(allEdgeIds.indexOf(nextEdge.id), 1);

					            //get the next node
					            if(nextEdge.n1 != currNode) {
					                currNode = nextEdge.n1;
					            }
					            else {
					                currNode = nextEdge.n2;
					            }
					        }

					    };

					    this.clearTunnel = function() {
					        this.edges = {};
					        this.nodes = {};
					    }
					}

					Tunnel.prototype.toString = function tunnelToString() {
					    var ret = "tunnel: \n";
					    ret += "nodes: ";
					    for (var n in this.nodes) {
					        ret += (this.nodes[n].id + " ");
					    }
					    ret += "\nedges: ";
					    for (var e in this.edges) {
					        ret += (this.edges[e].id + " ");
					    }
					    ret += "\n";
					    return ret;
					}

					// Determine if was clicked before or not and add/remove edge from tunnel class
					var edges = document.getElementsByClassName("edge");

					var edgeClicked = function() {
					    var edgeId = this.getAttribute('x');
					    console.log(edgeId)
					    if (gameState == 0) {
					        $(this).toggleClass("animate");
					        if (edgeId in tunnel.edges) {
					            // Get nodes
					            tunnelLength++;
					            var n1 = tunnel.edges[edgeId].n1;
					            var n2 = tunnel.edges[edgeId].n2;
					            // Remove this edge from each node's edge list
					            n1.removeEdge(tunnel.edges[edgeId]);
					            n2.removeEdge(tunnel.edges[edgeId]);
					            if (n1.edges.length == 0) {
					                tunnel.removeNode(n1);
					            }
					            if (n2.edges.length == 0) {
					                tunnel.removeNode(n2);
					            }
					            tunnel.removeEdge(tunnel.edges[edgeId]);
					        } else {
					            // Check if there are no pieces
					            if (tunnelLength <= 0) {
					                remainingPieces.innerHTML = "There are no remaining edges! Please remove an edge to continue building.";
					                return;
					            }
					            tunnelLength--;
					            if (edgeId[0] == "h") {
					                console.log("slice: ", edgeId.slice(1));
					                var rNum = Math.floor(edgeId.slice(1) / boardSize);
					                console.log("rNum: ", rNum);
					                var n1Id = Number(edgeId.slice(1)) + rNum;
					                var n2Id = (n1Id + 1).toString();
					                console.log("n1Id: ", n1Id);
					                console.log("n2Id: ", n2Id);
					                var n1;
					                var n2;

					                if (n1Id in tunnel.nodes) {
					                    n1 = tunnel.nodes[n1Id];
					                } else {
					                    n1 = new Node(n1Id);
					                    tunnel.addNode(n1);
					                }

					                if (n2Id in tunnel.nodes) {
					                    n2 = tunnel.nodes[n2Id];
					                } else {
					                    n2 = new Node(n2Id);
					                    tunnel.addNode(n2);
					                }

					                var newEdge = new Edge(n1, n2, edgeId);
					                tunnel.addEdge(newEdge);
					                n1.addEdge(newEdge);
					                n2.addEdge(newEdge);
					            } else {
					                var n1Id = edgeId.slice(1);
					                var n2Id = (Number(edgeId.slice(1)) + boardSize + 1).toString();
					                console.log("n1Id: ", n1Id);
					                console.log("n2Id: ", n2Id);
					                var n1;
					                var n2;

					                if (n1Id in tunnel.nodes) {
					                    n1 = tunnel.nodes[n1Id];
					                } else {
					                    n1 = new Node(n1Id);
					                    tunnel.addNode(n1);
					                }

					                if (n2Id in tunnel.nodes) {
					                    n2 = tunnel.nodes[n2Id];
					                } else {
					                    n2 = new Node(n2Id);
					                    tunnel.addNode(n2);
					                }

					                var newEdge = new Edge(n1, n2, edgeId);
					                tunnel.addEdge(newEdge);
					                n1.addEdge(newEdge);
					                n2.addEdge(newEdge);
					            }
					        }

					        // this.style.background = this.style.background=='yellow'? '#63f9ff':'yellow';
					        remainingPieces.innerHTML = "Edges left: " + tunnelLength;
					        console.log(tunnel.edges);
					        console.log("Tunnel nodes: ", tunnel.nodes);
					    } else if (gameState == 4) {
					        if (finalTunnelGuess.indexOf(edgeId) > -1) {
					            finalTunnelGuess.splice(finalTunnelGuess.indexOf(edgeId), 1);
					        } else {
					            finalTunnelGuess.push(edgeId);
					        }
					        $(this).toggleClass("final");
					    }
					};

					for(var i = 0; i < edges.length; i++){
					    edges[i].addEventListener('click', edgeClicked, false);
					}

					// Get probes and add event listener to each one
					var probes = document.getElementsByClassName("probe");

					var probeClicked = function() {
					    if (gameState == 1 || gameState == 2 || gameState == 3) {
					        $(this).toggleClass("animate");
					        probeId = this.id;
					        console.log("Probe id: ", probeId);
					        index = probesList.indexOf(probeId);
					        console.log("Numprobes: " + numProbes);
					        console.log("Index: " + index);
					        if (index < 0) {
					            probesList.push(probeId.slice(1));
					            numProbes++;
					        } else {
					            probesList.splice(index, 1);
					            numProbes--;
					        }
					        // this.style.background = this.style.background == 'red' ? 'blue' : 'red';
					    }
					};

					for(var i=0;i<probes.length;i++){
					    probes[i].addEventListener('click', probeClicked, false);
					}

					var startGameInRegularMode = function () {
					    clearBoard();
					    gameMode = 0;
					    alert("Detector, please look away while Badguy builds a tunnel.");
					    startGame();
					}

					var startGameInEasyMode = function () {
					    clearBoard();
					    gameMode = 1;
					    alert("Detector, please look away while Badguy builds a tunnel.");
					    startGame();
					}

					var startGameAI = function () {
					    computer = 1;
					    gameMode = 0;
					    gameState = 0;
					    console.log("GAME STATE IN START AI ", gameState);
					    tunnel = createAITunnel();
					    startGame();
					}

					var startGameEasyAI = function () {
					    computer = 1;
					    gameMode = 1;
					    gameState = 0;
					    tunnel = createAITunnel();
					    startGame();
					}

					var startGame = function () {
					    clearBoard();
					    if (round == 1) {
					        tunnelLength = Math.floor(Math.random() * 13) + 8;
					        maxTunnelLength = tunnelLength;
					        alert("Maximum tunnel length is " + tunnelLength + ".");
					    } else {
					        tunnelLength = maxTunnelLength;
					    }
					    gameState++;
					    console.log("GAME STATE IS ", gameState);
					    document.getElementById('start').style.display = 'none';
					    document.getElementById('startEasy').style.display = 'none';
					    document.getElementById('startAI').style.display = 'none';
					    document.getElementById('startEasyAI').style.display = 'none';
					    document.getElementById('submitGuess').style.display = 'none';
					    if (gameState == 0) {
					        tunnelInfo.innerHTML = "Tunnel can be up to " + tunnelLength + " edges long.";
					        remainingPieces.innerHTML = "Edges left: " + tunnelLength;
					        document.getElementById('tunnelDone').style.display = 'block';
					    } else if (gameState == 1) {
					        message.innerHTML = "Computer opponent has constructed a tunnel. Detector, begin placing probes.";
					        document.getElementById('probesPlaced1').style.display = 'block';
					    }
					};

					var doneAddingTunnels = function () {
					    var valid = tunnel.validTunnel();
					    console.log(valid);

					    // If the tunnel isn't valid, don't let the game keep going
					    if(!valid) {
					        alert("Your tunnel is invalid. It must start on the top edge, end on the bottom edge, and be a single simple path.");
					        return;
					    }

					    document.getElementById('tunnelDone').style.display = 'none';
					    document.getElementById('probesPlaced1').style.display = 'block';
					    tunnelInfo.innerHTML = "";
					    remainingPieces.innerHTML = "";
					    currentTunnel.innerHTML = "";
					    message.innerHTML = "Done adding tunnels. Time for Detector to place first round of probes.";
					    for (var e in tunnel.edges) {
					        console.log("TRYING TO UNHIGHLIGHT");
					        console.log("tunnel.edges[e].id is ", tunnel.edges[e].id);
					        $("#" + tunnel.edges[e].id).toggleClass("animate");
					    }

					    // tunnelLength = 12;
					    // tunnel = createAITunnel();

					    console.log("final final tunnel:");
					    console.log("nodes");
					    for (var n in tunnel.nodes) {
					        console.log(tunnel.nodes[n] + "");
					    }
					    console.log("edges: ");
					    for (var e in tunnel.edges) {
					        console.log(tunnel.edges[e] + "");
					    }

					    gameState++;
					};

					var doneAddingProbes = function () {
					    message.innerHTML = "Done adding probes. Let's see how you did.";
					    for (var i = 0; i < probesList.length; i++) {
					        console.log("probesList[i] is ", probesList[i]);
					        if (probesList[i] in tunnel.nodes) {
					            console.log("we got in the if statement");
					            for (var j = 0; j < tunnel.nodes[probesList[i]].edges.length; j++) {
					                console.log("Found edge ", tunnel.nodes[probesList[i]].edges[j].id);
					                if (gameMode == 1) {
					                    $("#" + tunnel.nodes[probesList[i]].edges[j].id).addClass("animate");
					                }
					            }
					            $("#p" + probesList[i]).removeClass("animate");
					            $("#p" + probesList[i]).addClass("detectedEdge");
					        }
					    }

					    if (gameState == 1 || gameState == 2) {
					        //update score
					        if (computer == 1) {
					            //only need to update player1 score
					            player1Score += probesList.length;
					        } else {
					            if (round == 1) {
					                player1Score += probesList.length;
					            } else {
					                player2Score += probesList.length;
					            }
					        }

					        console.log("done with probe placement in round " + round);
					        console.log("player 1 score: " + player1Score);
					        console.log("player 2 score: " + player2Score);

					        probesList = [];
					        message.innerHTML = "Detector, please place another round of probes.";
					        document.getElementById('probesPlaced1').style.display = 'none';
					        document.getElementById('probesPlaced2').style.display = 'block';

					        gameState++;

					    } else if (gameState == 3) {
					        // Update score
					        if (computer == 1) {
					            // Only need to update player1 score
					            player1Score += probesList.length;
					        } else {
					            if (round == 1) {
					                player1Score += probesList.length;
					            } else {
					                player2Score += probesList.length;
					            }
					        }

					        console.log("done with probe placement in round " + round);
					        console.log("player 1 score: " + player1Score);
					        console.log("player 2 score: " + player2Score);

					        document.getElementById('probesPlaced2').style.display = 'none';
					        document.getElementById('submitGuess').style.display = 'block';
					        message.innerHTML = "Now, select all edges in the tunnel to submit your final guess.";
					        gameState++;
					    }

					    console.log("probes list after done ", probesList);
					};

					function restartGame() {
					    message.innerHTML = "";
					    round++;
					    if (computer == 1) {
					        if (gameMode == 0) { //regular ai
					            numProbes = 0;
					            probesList = [];
					            tunnel = new Tunnel();
					            finalTunnelGuess = [];
					            gameMode = -1;
					            computer = -1;
					            gameState = -1;
					            startGameAI();
					        } else {
					            numProbes = 0;
					            probesList = [];
					            tunnel = new Tunnel();
					            finalTunnelGuess = [];
					            gameMode = -1;
					            computer = -1;
					            gameState = -1;
					            startGameEasyAI();
					        }
					    } else {
					        if (gameMode == 0) {
					            numProbes = 0;
					            probesList = [];
					            tunnel = new Tunnel();
					            finalTunnelGuess = [];
					            gameMode = -1;
					            computer = -1;
					            gameState = -1;
					            startGameInRegularMode();
					        } else {
					            numProbes = 0;
					            probesList = [];
					            tunnel = new Tunnel();
					            finalTunnelGuess = [];
					            gameMode = -1;
					            computer = -1;
					            gameState = -1;
					            startGameInEasyMode();
					        }
					    }
					}

					var revealTunnel = function () {
					    for (var e in tunnel.edges) {
					        console.log("REVEALING TUNNEL");
					        console.log("tunnel.edges[e].id is ", tunnel.edges[e].id);
					        $("#" + tunnel.edges[e].id).removeClass("final");
					        $("#" + tunnel.edges[e].id).removeClass("animate");
					        $("#" + tunnel.edges[e].id).addClass("reveal");
					    }
					}

					var submitGuess = function () {
					    console.log("Final tunnel guess: ", finalTunnelGuess);
					    console.log("The actual tunnel: ", tunnel.edges);
					    console.log("Final tunnel guess LENGTH: ", finalTunnelGuess.length);
					    console.log("Tunnel length: ", Object.keys(tunnel.edges).length);
					    var clone = finalTunnelGuess.slice(0);
					    if (finalTunnelGuess.length != Object.keys(tunnel.edges).length) {
					        console.log("Tunnel length not the same");
					        if (round == 1) {
					            player1Score = 10000;
					            revealTunnel();
					            alert("You are a horrible Detector. Keep your day job. Your score is infinity.");
					        } else {
					            player2Score = 10000;
					            revealTunnel();
					            alert("You are a horrible Detector. Keep your day job. Your score is infinity.");
					        }
					    } else {
					        console.log("Tunnel length is good");
					        for (var i = 0; i < finalTunnelGuess.length; i++) {
					            console.log("Final tunnel guess: iteration ",i, finalTunnelGuess);
					            if (finalTunnelGuess[i] in tunnel.edges) {
					                console.log("Found match: " + finalTunnelGuess[i]);
					                clone.splice(clone.indexOf(finalTunnelGuess[i]), 1);
					                console.log("Clone: " + clone)
					            }
					        }
					        console.log("clone length ", clone.length);
					        if (!clone.length) {
					            if (round == 1) {
					                alert("Good job. Your score is " + player1Score + ".");
					            } else {
					                alert("Good job. Your score is " + player2Score + ".");
					            }
					        } else {
					            if (round == 1) {
					                player1Score = 10000;
					                revealTunnel();
					                alert("You are a horrible Detector. Keep your day job. Your score is infinity.");
					            } else {
					                player2Score = 10000;
					                revealTunnel();
					                alert("You are a horrible Detector. Keep your day job. Your score is infinity.");
					            }
					        }
					    }

					    if (round == 1 && computer != 1) {
					        // Popup that they need to switch roles
					        alert("Round 1 over. Now switch roles. The game will restart when you click OK.");
					        restartGame();
					    } else if (computer == 1) {
					        alert("Game over. You may submit your score.");
					        document.getElementById('submitGuess').style.display = 'none';
					        message.innerHTML = "";
					        document.getElementById("score").style.display="inline-block";
					    } else {
					        if (player1Score < player2Score ) {
					            winningScore = player1Score;
					            winningPlayer = player1Name;
					        } else {
					            winningScore = player2Score;
					            winningPlayer = player2Name;
					        }
					        if(computer != 1) {
					            if (player1Score < player2Score) {
					                alert("The game is over. Player 1 won with a score of " + player1Score + ". Player 1 can save their score.");
					            } else {
					                alert("The game is over. Player 2 won with a score of " + player2Score + ". Player 2 can save their score.");
					            }
					        } else {
					            alert("The game is over. Your score is " + player1Score + ". You can save your score.");
					            document.getElementById('submitGuess').style.display = 'none';
					            message.innerHTML = "";
					        }
					        document.getElementById('submitGuess').style.display = 'none';
					        message.innerHTML = "";
					        document.getElementById("score").style.display="inline-block";
					    }
					};


					// AI tunnel stuff
					function createAITunnel() {
					    var aiTunnel = new Tunnel();
					    var graph = new Graph();
					    graph.createGraph();
					    var currentTunnelLength = 0;

					    var start = Math.floor(Math.random() * (boardSize+1));
					    var currNodeFromGraph = graph.nodes[start];
					    var currNode = new Node(start);

					    var counter = 0;

					    while(true) {
					        console.log("curr node: " + currNode);

					        // Check if on end and if yes break
					        if (Math.floor(currNode.id / (boardSize+1)) == boardSize) {
					            console.log("on end!")
					            console.log("final tunnel: " + aiTunnel);
					            aiTunnel.addNode(currNode);
					            break;
					        }

					        // Pick an edge from the current nodes edges that's not the incoming edge
					        var potentialEdge = getRandomEdge(currNodeFromGraph, aiTunnel);
					        console.log("first potential edge: " + potentialEdge);

					        // See if adding that edge leaves enough pipes to get to the end
					        while (!potentialEdgeValid(potentialEdge, currNode, aiTunnel)) {
					            //while(false) {
					            potentialEdge = getRandomEdge(currNodeFromGraph, aiTunnel);
					            console.log("edge was invalid, got new one: " + potentialEdge);
					            //sleepFor(1000);
					        }

					        // Now we have a good edge, update it's n1
					        potentialEdge.n1 = currNode;

					        // Add the edge to currNode
					        currNode.addEdge(potentialEdge);

					        // Add them both to the tunnel
					        aiTunnel.addNode(currNode);
					        aiTunnel.addEdge(potentialEdge);

					        // Get the next node
					        var currNodeId = currNode.id;
					        var newNodeId = null;
					        // console.log("curr node id: " + currNodeId);
					        for (var i = 0; i < potentialEdge.allNodes.length; i++) {
					            // console.log("potentialEdge.allNodes[i].id: " + potentialEdge.allNodes[i].id );
					            if (potentialEdge.allNodes[i].id != currNodeId) {
					                newNodeId = potentialEdge.allNodes[i].id;
					            }
					        }
					        // console.log("new node id: " + newNodeId);

					        currNodeFromGraph = graph.nodes[newNodeId];
					        currNode = new Node(newNodeId);
					        currNode.addEdge(potentialEdge);
					        potentialEdge.n2 = currNode;
					        counter++;

					        console.log("tunnel: " + aiTunnel);

					    }

					    return aiTunnel;
					}

					function potentialEdgeValid(potentialEdge, currNode, tunnel) {

					    if(potentialEdge.id in tunnel.edges) {
					        console.log("edge exists, not valid");
					        return false;
					    }

					    tunnel.addEdge(potentialEdge);
					    tunnel.addNode(currNode);

					    var tunnelLengthSoFar = Object.keys(tunnel.edges).length;
					    var edgesLeft = tunnelLength - tunnelLengthSoFar;
					    var rowNum = getRowNum(potentialEdge);


					    console.log();
					    console.log("======= starting validation ========")
					    console.log("checking if edge " + potentialEdge.id + " is valid to add to tunnel: ");
					    console.log(tunnel + "");
					    console.log("tunnel len so far: " + tunnelLengthSoFar);
					    console.log("edges left so far: " + edgesLeft);
					    console.log("row num of edge: " + rowNum);

					    // Check that the other end of the new edge isn't already in the tunnel
					    // (This means we created a loop)
					    var currNodeId = currNode.id;
					    var newNodeId = null;
					    console.log("curr node id: " + currNodeId);
					    for (var i = 0; i < potentialEdge.allNodes.length; i++) {
					        //console.log("potentialEdge.allNodes[i].id: " + potentialEdge.allNodes[i].id );
					        if (potentialEdge.allNodes[i].id != currNodeId) {
					            newNodeId = potentialEdge.allNodes[i].id;
					        }
					    }
					    console.log("new node id: " + newNodeId);

					    if (newNodeId in tunnel.nodes) {
					        console.log("we created a loop, not valid");
					        tunnel.removeEdge(potentialEdge);
					        tunnel.removeNode(currNode);
					        return false;
					    }


					    // If the edge is horizontal then need (remaining pieces - (boardSize - rowNum)) >= 0
					    // Check if have enough nodes to end
					    var neededToEnd = -1;
					    if (potentialEdge.id[0] == "h") {
					        console.log("edge is horiz");
					        // Check if h edge below is already in tunnel
					        var edgeBelowId = Number(potentialEdge.id.slice(1)) + boardSize;
					        var edgeBelow = "h" + edgeBelowId;
					        if (edgeBelow in tunnel.edges) {
					            console.log("can't add this horiz edge because will cause box");
					            tunnel.removeEdge(potentialEdge);
					            tunnel.removeNode(currNode);
					            return false;
					        }
					        neededToEnd = boardSize - rowNum;
					    } else {
					        if (newNodeId > currNodeId) { //edge is going down
					            console.log("edge is v going down")
					            neededToEnd = (boardSize - rowNum) - 1;
					        } else {
					            console.log("edge is v going up");
					            // console.log("so for now returning false");
					            // return false;
					            // can't go up on the edges
					            var potEdgeIdNum = Number(potentialEdge.id.slice(1));
					            if(potEdgeIdNum % (boardSize + 1) == 0 || potEdgeIdNum % (boardSize + 1) == boardSize) {
					                console.log("can't go up on an outside edge");
					                tunnel.removeEdge(potentialEdge);
					                tunnel.removeNode(currNode);
					                return false;
					            }

					            neededToEnd = (boardSize - rowNum) + 1;
					        }
					    }
					    console.log("needed to end: " + neededToEnd);
					    console.log("======== done with check =========");
					    console.log();
					    tunnel.removeEdge(potentialEdge);
					    tunnel.removeNode(currNode);
					    return ((edgesLeft - neededToEnd) >= 0);

					    //if edge is vertical
					    //if edge is downward need (remaining pieces - (boardSize - rownum) - 1) >= 0
					    //else if upward need (remaining pieces - (boardSize - rownum) + 1) >= 0
					}

					function getRowNum(edge) {
					    var edgeId = Number(edge.id.slice(1));
					    if(edge.id[0] == "h") {
					        return Math.floor(edgeId / (boardSize));
					    } else {
					        return Math.floor(edgeId / (boardSize + 1));
					    }
					}

					function getRandomEdge(node, tunnel) {
					    // Given the tunnel and the current node
					    var nodeId = node.id;

					    var existingEdgeId;
					    if (nodeId in tunnel.nodes) {
					        var nodeFromTunnel = tunnel.nodes[nodeId];
					        existingEdgeId = nodeFromTunnel.edges[0];
					    } else {
					        existingEdgeId = "bad"
					    }

					    var potentialEdges = [];

					    for (var i = 0; i < node.edges.length; i++) {
					        if (node.edges[i].id != existingEdgeId) {
					            potentialEdges.push(node.edges[i]);
					        }
					    }

					    console.log("list of potential edge candidates for node " + nodeId);
					    for(var i = 0; i < potentialEdges.length; i++) {
					        console.log(potentialEdges[i].id);
					    }

					    var rand = potentialEdges[Math.floor(Math.random() * potentialEdges.length)];
					    return rand;
					}

					function Graph() {
					    this.nodes = {};
					    this.edges = {};
					    this.nodeIds = [];
					    this.edgeIds = [];

					    this.createGraph = function() {
					        console.log("!23")
					        for(var i = 0; i < ((boardSize+1)*(boardSize+1)); i++) {
					            var node = new Node(i);
					            this.nodes[i] = node;
					            this.nodeIds.push(i);
					            var horizontalEdgeIds = getHorizontalEdgesIds(i);
					            var verticalEdgeIds = getVerticalEdgesIds(i);

					            for(var j = 0; j < horizontalEdgeIds.length; j++) {
					                var edgeId = horizontalEdgeIds[j];
					                if (edgeId in this.edges) {
					                    // Add the node to the edge
					                    this.edges[edgeId].allNodes.push(node);
					                    node.addEdge(this.edges[edgeId]);
					                } else {
					                    // Create new edge and add it to edge object
					                    var edge = new Edge(null, null, edgeId);
					                    edge.allNodes.push(node);
					                    this.edges[edgeId] = edge;
					                    this.edgeIds.push(edgeId);
					                    node.addEdge(edge);
					                }
					            }

					            for (var j = 0; j < verticalEdgeIds.length; j++) {
					                var edgeId = verticalEdgeIds[j];
					                if (edgeId in this.edges) {
					                    // Add the node to it
					                    this.edges[edgeId].allNodes.push(node);
					                    node.addEdge(this.edges[edgeId]);
					                } else {
					                    // Create new edge
					                    var edge = new Edge(null, null, edgeId);
					                    edge.allNodes.push(node);
					                    this.edges[edgeId] = edge;
					                    this.edgeIds.push(edgeId);
					                    node.addEdge(this.edges[edgeId]);
					                }
					            }
					        }
					        console.log("nodes");
					        for (var n in this.nodes) {
					            console.log("" + this.nodes[n]);
					        }
					        console.log("edges");
					        for (var e in this.edges) {
					            console.log("" + this.edges[e]);
					        }
					    }
					}

					function getHorizontalEdgesIds(i) {
					    var horizontalEdgeIds = [];

					    // console.log("getting horizontal edges for node " + i);

					    // Create left and right edges
					    var rowNum = Math.floor(i / (boardSize + 1));
					    var leftEdge = i - (rowNum + 1);
					    var rightEdge = i - rowNum;
					    var leftEdgeId = "h" + leftEdge;
					    var rightEdgeId = "h" + rightEdge;

					    // console.log("row num: " + rowNum);
					    // console.log("left edge: " + leftEdge);
					    // console.log("right edge: " + rightEdge);

					    // If on left border, only has right edge
					    if (i % (boardSize + 1) == 0) {
					        // console.log("on left border");
					        leftEdgeId = null;
					    }

					    // If on right border only has left edge
					    if (i % (boardSize + 1) == 6) {
					        // console.log("on right border");
					        rightEdgeId = null;
					    }

					    // Add non null edges
					    if (leftEdgeId != null) {
					        horizontalEdgeIds.push(leftEdgeId);
					    }

					    if (rightEdgeId != null) {
					        horizontalEdgeIds.push(rightEdgeId);
					    }

					    // console.log("final result: " , horizontalEdgeIds);
					    return horizontalEdgeIds;
					}

					function getVerticalEdgesIds(i) {
					    var verticalEdgeIds = [];
					    // console.log("getting vertical edges for node " + i);

					    // If on the first row only has a down edge
					    if (i <= boardSize) {
					        // console.log("on first row");
					        var edgeId = "v" + i;
					        verticalEdgeIds.push(edgeId);
					        return verticalEdgeIds;
					    }

					    // If on the bottom row only has an up edge
					    if (i >= (boardSize * (boardSize + 1))) {
					        // console.log("on bottom row");
					        var upEdgeIdNum = i - (boardSize + 1);
					        var upEdgeId = "v" + upEdgeIdNum;
					        verticalEdgeIds.push(upEdgeId);
					        return verticalEdgeIds;
					    }

					    // Else has both edges
					    var downEdgeId = "v" + i;
					    var upEdgeIdNum = i - (boardSize + 1);
					    var upEdgeId = "v" + upEdgeIdNum;
					    verticalEdgeIds.push(downEdgeId);
					    verticalEdgeIds.push(upEdgeId);
					    // console.log("final result: ", verticalEdgeIds);
					    return verticalEdgeIds;
					}

					function edgeIsHorizontal(edge) {
					    var edgeId = edge.id;
					    var dir = edgeId.slice(0,1);
					    if (dir == "h") {
					        return true;
					    } else {
					        return false;
					    }
					}


					// Add button event listeners

					// Start game in normal mode
					document.getElementById('start').addEventListener('click', startGameInRegularMode, false);

					// Start game in easy mode
					document.getElementById('startEasy').addEventListener('click', startGameInEasyMode, false);

					// Start game with AI
					document.getElementById('startAI').addEventListener('click', startGameAI, false);

					// Start game with AI in easy mode
					document.getElementById('startEasyAI').addEventListener('click', startGameEasyAI, false);

					document.getElementById('tunnelDone').addEventListener('click', doneAddingTunnels, false);

					document.getElementById('probesPlaced1').addEventListener('click', doneAddingProbes, false);

					document.getElementById('probesPlaced2').addEventListener('click', doneAddingProbes, false);

					document.getElementById('submitGuess').addEventListener('click', submitGuess, false);



				/***/ },
				/* 4 */
				/***/ function(module, exports, __webpack_require__) {

					var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function () {
					function create(window) {

					  if(window == null ) {
					    window = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"jsdom\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())).jsdom().createWindow();
					    // assume window is a jsdom instance...
					    // jsdom includes an incomplete version of XMLHttpRequest
					    window.XMLHttpRequest = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"xmlhttprequest\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())).XMLHttpRequest;
					    // trick jQuery into thinking CORS is supported (should be in node-XMLHttpRequest)
					    window.XMLHttpRequest.prototype.withCredentials = false;
					    
					    if(window.location == null) {
					      window.location = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"location\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));  
					    }

					    if(window.navigator == null) {
					      window.navigator = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"navigator\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
					    }
					  }
					  

					  var location = window.location,
					      navigator = window.navigator,
					      XMLHttpRequest = window.XMLHttpRequest;

					  /*!
					 * jQuery JavaScript Library v1.7.2
					 * http://jquery.com/
					 *
					 * Copyright 2011, John Resig
					 * Dual licensed under the MIT or GPL Version 2 licenses.
					 * http://jquery.org/license
					 *
					 * Includes Sizzle.js
					 * http://sizzlejs.com/
					 * Copyright 2011, The Dojo Foundation
					 * Released under the MIT, BSD, and GPL Licenses.
					 *
					 * Date: Wed Mar 21 12:46:34 2012 -0700
					 */
					(function( window, undefined ) {

					// Use the correct document accordingly with window argument (sandbox)
					var document = window.document,
						navigator = window.navigator,
						location = window.location;
					var jQuery = (function() {

					// Define a local copy of jQuery
					var jQuery = function( selector, context ) {
							// The jQuery object is actually just the init constructor 'enhanced'
							return new jQuery.fn.init( selector, context, rootjQuery );
						},

						// Map over jQuery in case of overwrite
						_jQuery = window.jQuery,

						// Map over the $ in case of overwrite
						_$ = window.$,

						// A central reference to the root jQuery(document)
						rootjQuery,

						// A simple way to check for HTML strings or ID strings
						// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
						quickExpr = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,

						// Check if a string has a non-whitespace character in it
						rnotwhite = /\S/,

						// Used for trimming whitespace
						trimLeft = /^\s+/,
						trimRight = /\s+$/,

						// Match a standalone tag
						rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>)?$/,

						// JSON RegExp
						rvalidchars = /^[\],:{}\s]*$/,
						rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,
						rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
						rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,

						// Useragent RegExp
						rwebkit = /(webkit)[ \/]([\w.]+)/,
						ropera = /(opera)(?:.*version)?[ \/]([\w.]+)/,
						rmsie = /(msie) ([\w.]+)/,
						rmozilla = /(mozilla)(?:.*? rv:([\w.]+))?/,

						// Matches dashed string for camelizing
						rdashAlpha = /-([a-z]|[0-9])/ig,
						rmsPrefix = /^-ms-/,

						// Used by jQuery.camelCase as callback to replace()
						fcamelCase = function( all, letter ) {
							return ( letter + "" ).toUpperCase();
						},

						// Keep a UserAgent string for use with jQuery.browser
						userAgent = navigator.userAgent,

						// For matching the engine and version of the browser
						browserMatch,

						// The deferred used on DOM ready
						readyList,

						// The ready event handler
						DOMContentLoaded,

						// Save a reference to some core methods
						toString = Object.prototype.toString,
						hasOwn = Object.prototype.hasOwnProperty,
						push = Array.prototype.push,
						slice = Array.prototype.slice,
						trim = String.prototype.trim,
						indexOf = Array.prototype.indexOf,

						// [[Class]] -> type pairs
						class2type = {};

					jQuery.fn = jQuery.prototype = {
						constructor: jQuery,
						init: function( selector, context, rootjQuery ) {
							var match, elem, ret, doc;

							// Handle $(""), $(null), or $(undefined)
							if ( !selector ) {
								return this;
							}

							// Handle $(DOMElement)
							if ( selector.nodeType ) {
								this.context = this[0] = selector;
								this.length = 1;
								return this;
							}

							// The body element only exists once, optimize finding it
							if ( selector === "body" && !context && document.body ) {
								this.context = document;
								this[0] = document.body;
								this.selector = selector;
								this.length = 1;
								return this;
							}

							// Handle HTML strings
							if ( typeof selector === "string" ) {
								// Are we dealing with HTML string or an ID?
								if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {
									// Assume that strings that start and end with <> are HTML and skip the regex check
									match = [ null, selector, null ];

								} else {
									match = quickExpr.exec( selector );
								}

								// Verify a match, and that no context was specified for #id
								if ( match && (match[1] || !context) ) {

									// HANDLE: $(html) -> $(array)
									if ( match[1] ) {
										context = context instanceof jQuery ? context[0] : context;
										doc = ( context ? context.ownerDocument || context : document );

										// If a single string is passed in and it's a single tag
										// just do a createElement and skip the rest
										ret = rsingleTag.exec( selector );

										if ( ret ) {
											if ( jQuery.isPlainObject( context ) ) {
												selector = [ document.createElement( ret[1] ) ];
												jQuery.fn.attr.call( selector, context, true );

											} else {
												selector = [ doc.createElement( ret[1] ) ];
											}

										} else {
											ret = jQuery.buildFragment( [ match[1] ], [ doc ] );
											selector = ( ret.cacheable ? jQuery.clone(ret.fragment) : ret.fragment ).childNodes;
										}

										return jQuery.merge( this, selector );

									// HANDLE: $("#id")
									} else {
										elem = document.getElementById( match[2] );

										// Check parentNode to catch when Blackberry 4.6 returns
										// nodes that are no longer in the document #6963
										if ( elem && elem.parentNode ) {
											// Handle the case where IE and Opera return items
											// by name instead of ID
											if ( elem.id !== match[2] ) {
												return rootjQuery.find( selector );
											}

											// Otherwise, we inject the element directly into the jQuery object
											this.length = 1;
											this[0] = elem;
										}

										this.context = document;
										this.selector = selector;
										return this;
									}

								// HANDLE: $(expr, $(...))
								} else if ( !context || context.jquery ) {
									return ( context || rootjQuery ).find( selector );

								// HANDLE: $(expr, context)
								// (which is just equivalent to: $(context).find(expr)
								} else {
									return this.constructor( context ).find( selector );
								}

							// HANDLE: $(function)
							// Shortcut for document ready
							} else if ( jQuery.isFunction( selector ) ) {
								return rootjQuery.ready( selector );
							}

							if ( selector.selector !== undefined ) {
								this.selector = selector.selector;
								this.context = selector.context;
							}

							return jQuery.makeArray( selector, this );
						},

						// Start with an empty selector
						selector: "",

						// The current version of jQuery being used
						jquery: "1.7.2",

						// The default length of a jQuery object is 0
						length: 0,

						// The number of elements contained in the matched element set
						size: function() {
							return this.length;
						},

						toArray: function() {
							return slice.call( this, 0 );
						},

						// Get the Nth element in the matched element set OR
						// Get the whole matched element set as a clean array
						get: function( num ) {
							return num == null ?

								// Return a 'clean' array
								this.toArray() :

								// Return just the object
								( num < 0 ? this[ this.length + num ] : this[ num ] );
						},

						// Take an array of elements and push it onto the stack
						// (returning the new matched element set)
						pushStack: function( elems, name, selector ) {
							// Build a new jQuery matched element set
							var ret = this.constructor();

							if ( jQuery.isArray( elems ) ) {
								push.apply( ret, elems );

							} else {
								jQuery.merge( ret, elems );
							}

							// Add the old object onto the stack (as a reference)
							ret.prevObject = this;

							ret.context = this.context;

							if ( name === "find" ) {
								ret.selector = this.selector + ( this.selector ? " " : "" ) + selector;
							} else if ( name ) {
								ret.selector = this.selector + "." + name + "(" + selector + ")";
							}

							// Return the newly-formed element set
							return ret;
						},

						// Execute a callback for every element in the matched set.
						// (You can seed the arguments with an array of args, but this is
						// only used internally.)
						each: function( callback, args ) {
							return jQuery.each( this, callback, args );
						},

						ready: function( fn ) {
							// Attach the listeners
							jQuery.bindReady();

							// Add the callback
							readyList.add( fn );

							return this;
						},

						eq: function( i ) {
							i = +i;
							return i === -1 ?
								this.slice( i ) :
								this.slice( i, i + 1 );
						},

						first: function() {
							return this.eq( 0 );
						},

						last: function() {
							return this.eq( -1 );
						},

						slice: function() {
							return this.pushStack( slice.apply( this, arguments ),
								"slice", slice.call(arguments).join(",") );
						},

						map: function( callback ) {
							return this.pushStack( jQuery.map(this, function( elem, i ) {
								return callback.call( elem, i, elem );
							}));
						},

						end: function() {
							return this.prevObject || this.constructor(null);
						},

						// For internal use only.
						// Behaves like an Array's method, not like a jQuery method.
						push: push,
						sort: [].sort,
						splice: [].splice
					};

					// Give the init function the jQuery prototype for later instantiation
					jQuery.fn.init.prototype = jQuery.fn;

					jQuery.extend = jQuery.fn.extend = function() {
						var options, name, src, copy, copyIsArray, clone,
							target = arguments[0] || {},
							i = 1,
							length = arguments.length,
							deep = false;

						// Handle a deep copy situation
						if ( typeof target === "boolean" ) {
							deep = target;
							target = arguments[1] || {};
							// skip the boolean and the target
							i = 2;
						}

						// Handle case when target is a string or something (possible in deep copy)
						if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
							target = {};
						}

						// extend jQuery itself if only one argument is passed
						if ( length === i ) {
							target = this;
							--i;
						}

						for ( ; i < length; i++ ) {
							// Only deal with non-null/undefined values
							if ( (options = arguments[ i ]) != null ) {
								// Extend the base object
								for ( name in options ) {
									src = target[ name ];
									copy = options[ name ];

									// Prevent never-ending loop
									if ( target === copy ) {
										continue;
									}

									// Recurse if we're merging plain objects or arrays
									if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
										if ( copyIsArray ) {
											copyIsArray = false;
											clone = src && jQuery.isArray(src) ? src : [];

										} else {
											clone = src && jQuery.isPlainObject(src) ? src : {};
										}

										// Never move original objects, clone them
										target[ name ] = jQuery.extend( deep, clone, copy );

									// Don't bring in undefined values
									} else if ( copy !== undefined ) {
										target[ name ] = copy;
									}
								}
							}
						}

						// Return the modified object
						return target;
					};

					jQuery.extend({
						noConflict: function( deep ) {
							if ( window.$ === jQuery ) {
								window.$ = _$;
							}

							if ( deep && window.jQuery === jQuery ) {
								window.jQuery = _jQuery;
							}

							return jQuery;
						},

						// Is the DOM ready to be used? Set to true once it occurs.
						isReady: false,

						// A counter to track how many items to wait for before
						// the ready event fires. See #6781
						readyWait: 1,

						// Hold (or release) the ready event
						holdReady: function( hold ) {
							if ( hold ) {
								jQuery.readyWait++;
							} else {
								jQuery.ready( true );
							}
						},

						// Handle when the DOM is ready
						ready: function( wait ) {
							// Either a released hold or an DOMready/load event and not yet ready
							if ( (wait === true && !--jQuery.readyWait) || (wait !== true && !jQuery.isReady) ) {
								// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
								if ( !document.body ) {
									return setTimeout( jQuery.ready, 1 );
								}

								// Remember that the DOM is ready
								jQuery.isReady = true;

								// If a normal DOM Ready event fired, decrement, and wait if need be
								if ( wait !== true && --jQuery.readyWait > 0 ) {
									return;
								}

								// If there are functions bound, to execute
								readyList.fireWith( document, [ jQuery ] );

								// Trigger any bound ready events
								if ( jQuery.fn.trigger ) {
									jQuery( document ).trigger( "ready" ).off( "ready" );
								}
							}
						},

						bindReady: function() {
							if ( readyList ) {
								return;
							}

							readyList = jQuery.Callbacks( "once memory" );

							// Catch cases where $(document).ready() is called after the
							// browser event has already occurred.
							if ( document.readyState === "complete" ) {
								// Handle it asynchronously to allow scripts the opportunity to delay ready
								return setTimeout( jQuery.ready, 1 );
							}

							// Mozilla, Opera and webkit nightlies currently support this event
							if ( document.addEventListener ) {
								// Use the handy event callback
								document.addEventListener( "DOMContentLoaded", DOMContentLoaded, false );

								// A fallback to window.onload, that will always work
								window.addEventListener( "load", jQuery.ready, false );

							// If IE event model is used
							} else if ( document.attachEvent ) {
								// ensure firing before onload,
								// maybe late but safe also for iframes
								document.attachEvent( "onreadystatechange", DOMContentLoaded );

								// A fallback to window.onload, that will always work
								window.attachEvent( "onload", jQuery.ready );

								// If IE and not a frame
								// continually check to see if the document is ready
								var toplevel = false;

								try {
									toplevel = window.frameElement == null;
								} catch(e) {}

								if ( document.documentElement.doScroll && toplevel ) {
									doScrollCheck();
								}
							}
						},

						// See test/unit/core.js for details concerning isFunction.
						// Since version 1.3, DOM methods and functions like alert
						// aren't supported. They return false on IE (#2968).
						isFunction: function( obj ) {
							return jQuery.type(obj) === "function";
						},

						isArray: Array.isArray || function( obj ) {
							return jQuery.type(obj) === "array";
						},

						isWindow: function( obj ) {
							return obj != null && obj == obj.window;
						},

						isNumeric: function( obj ) {
							return !isNaN( parseFloat(obj) ) && isFinite( obj );
						},

						type: function( obj ) {
							return obj == null ?
								String( obj ) :
								class2type[ toString.call(obj) ] || "object";
						},

						isPlainObject: function( obj ) {
							// Must be an Object.
							// Because of IE, we also have to check the presence of the constructor property.
							// Make sure that DOM nodes and window objects don't pass through, as well
							if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
								return false;
							}

							try {
								// Not own constructor property must be Object
								if ( obj.constructor &&
									!hasOwn.call(obj, "constructor") &&
									!hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
									return false;
								}
							} catch ( e ) {
								// IE8,9 Will throw exceptions on certain host objects #9897
								return false;
							}

							// Own properties are enumerated firstly, so to speed up,
							// if last one is own, then all properties are own.

							var key;
							for ( key in obj ) {}

							return key === undefined || hasOwn.call( obj, key );
						},

						isEmptyObject: function( obj ) {
							for ( var name in obj ) {
								return false;
							}
							return true;
						},

						error: function( msg ) {
							throw new Error( msg );
						},

						parseJSON: function( data ) {
							if ( typeof data !== "string" || !data ) {
								return null;
							}

							// Make sure leading/trailing whitespace is removed (IE can't handle it)
							data = jQuery.trim( data );

							// Attempt to parse using the native JSON parser first
							if ( window.JSON && window.JSON.parse ) {
								return window.JSON.parse( data );
							}

							// Make sure the incoming data is actual JSON
							// Logic borrowed from http://json.org/json2.js
							if ( rvalidchars.test( data.replace( rvalidescape, "@" )
								.replace( rvalidtokens, "]" )
								.replace( rvalidbraces, "")) ) {

								return ( new Function( "return " + data ) )();

							}
							jQuery.error( "Invalid JSON: " + data );
						},

						// Cross-browser xml parsing
						parseXML: function( data ) {
							if ( typeof data !== "string" || !data ) {
								return null;
							}
							var xml, tmp;
							try {
								if ( window.DOMParser ) { // Standard
									tmp = new DOMParser();
									xml = tmp.parseFromString( data , "text/xml" );
								} else { // IE
									xml = new ActiveXObject( "Microsoft.XMLDOM" );
									xml.async = "false";
									xml.loadXML( data );
								}
							} catch( e ) {
								xml = undefined;
							}
							if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
								jQuery.error( "Invalid XML: " + data );
							}
							return xml;
						},

						noop: function() {},

						// Evaluates a script in a global context
						// Workarounds based on findings by Jim Driscoll
						// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
						globalEval: function( data ) {
							if ( data && rnotwhite.test( data ) ) {
								// We use execScript on Internet Explorer
								// We use an anonymous function so that context is window
								// rather than jQuery in Firefox
								( window.execScript || function( data ) {
									window[ "eval" ].call( window, data );
								} )( data );
							}
						},

						// Convert dashed to camelCase; used by the css and data modules
						// Microsoft forgot to hump their vendor prefix (#9572)
						camelCase: function( string ) {
							return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
						},

						nodeName: function( elem, name ) {
							return elem.nodeName && elem.nodeName.toUpperCase() === name.toUpperCase();
						},

						// args is for internal usage only
						each: function( object, callback, args ) {
							var name, i = 0,
								length = object.length,
								isObj = length === undefined || jQuery.isFunction( object );

							if ( args ) {
								if ( isObj ) {
									for ( name in object ) {
										if ( callback.apply( object[ name ], args ) === false ) {
											break;
										}
									}
								} else {
									for ( ; i < length; ) {
										if ( callback.apply( object[ i++ ], args ) === false ) {
											break;
										}
									}
								}

							// A special, fast, case for the most common use of each
							} else {
								if ( isObj ) {
									for ( name in object ) {
										if ( callback.call( object[ name ], name, object[ name ] ) === false ) {
											break;
										}
									}
								} else {
									for ( ; i < length; ) {
										if ( callback.call( object[ i ], i, object[ i++ ] ) === false ) {
											break;
										}
									}
								}
							}

							return object;
						},

						// Use native String.trim function wherever possible
						trim: trim ?
							function( text ) {
								return text == null ?
									"" :
									trim.call( text );
							} :

							// Otherwise use our own trimming functionality
							function( text ) {
								return text == null ?
									"" :
									text.toString().replace( trimLeft, "" ).replace( trimRight, "" );
							},

						// results is for internal usage only
						makeArray: function( array, results ) {
							var ret = results || [];

							if ( array != null ) {
								// The window, strings (and functions) also have 'length'
								// Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930
								var type = jQuery.type( array );

								if ( array.length == null || type === "string" || type === "function" || type === "regexp" || jQuery.isWindow( array ) ) {
									push.call( ret, array );
								} else {
									jQuery.merge( ret, array );
								}
							}

							return ret;
						},

						inArray: function( elem, array, i ) {
							var len;

							if ( array ) {
								if ( indexOf ) {
									return indexOf.call( array, elem, i );
								}

								len = array.length;
								i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;

								for ( ; i < len; i++ ) {
									// Skip accessing in sparse arrays
									if ( i in array && array[ i ] === elem ) {
										return i;
									}
								}
							}

							return -1;
						},

						merge: function( first, second ) {
							var i = first.length,
								j = 0;

							if ( typeof second.length === "number" ) {
								for ( var l = second.length; j < l; j++ ) {
									first[ i++ ] = second[ j ];
								}

							} else {
								while ( second[j] !== undefined ) {
									first[ i++ ] = second[ j++ ];
								}
							}

							first.length = i;

							return first;
						},

						grep: function( elems, callback, inv ) {
							var ret = [], retVal;
							inv = !!inv;

							// Go through the array, only saving the items
							// that pass the validator function
							for ( var i = 0, length = elems.length; i < length; i++ ) {
								retVal = !!callback( elems[ i ], i );
								if ( inv !== retVal ) {
									ret.push( elems[ i ] );
								}
							}

							return ret;
						},

						// arg is for internal usage only
						map: function( elems, callback, arg ) {
							var value, key, ret = [],
								i = 0,
								length = elems.length,
								// jquery objects are treated as arrays
								isArray = elems instanceof jQuery || length !== undefined && typeof length === "number" && ( ( length > 0 && elems[ 0 ] && elems[ length -1 ] ) || length === 0 || jQuery.isArray( elems ) ) ;

							// Go through the array, translating each of the items to their
							if ( isArray ) {
								for ( ; i < length; i++ ) {
									value = callback( elems[ i ], i, arg );

									if ( value != null ) {
										ret[ ret.length ] = value;
									}
								}

							// Go through every key on the object,
							} else {
								for ( key in elems ) {
									value = callback( elems[ key ], key, arg );

									if ( value != null ) {
										ret[ ret.length ] = value;
									}
								}
							}

							// Flatten any nested arrays
							return ret.concat.apply( [], ret );
						},

						// A global GUID counter for objects
						guid: 1,

						// Bind a function to a context, optionally partially applying any
						// arguments.
						proxy: function( fn, context ) {
							if ( typeof context === "string" ) {
								var tmp = fn[ context ];
								context = fn;
								fn = tmp;
							}

							// Quick check to determine if target is callable, in the spec
							// this throws a TypeError, but we will just return undefined.
							if ( !jQuery.isFunction( fn ) ) {
								return undefined;
							}

							// Simulated bind
							var args = slice.call( arguments, 2 ),
								proxy = function() {
									return fn.apply( context, args.concat( slice.call( arguments ) ) );
								};

							// Set the guid of unique handler to the same of original handler, so it can be removed
							proxy.guid = fn.guid = fn.guid || proxy.guid || jQuery.guid++;

							return proxy;
						},

						// Mutifunctional method to get and set values to a collection
						// The value/s can optionally be executed if it's a function
						access: function( elems, fn, key, value, chainable, emptyGet, pass ) {
							var exec,
								bulk = key == null,
								i = 0,
								length = elems.length;

							// Sets many values
							if ( key && typeof key === "object" ) {
								for ( i in key ) {
									jQuery.access( elems, fn, i, key[i], 1, emptyGet, value );
								}
								chainable = 1;

							// Sets one value
							} else if ( value !== undefined ) {
								// Optionally, function values get executed if exec is true
								exec = pass === undefined && jQuery.isFunction( value );

								if ( bulk ) {
									// Bulk operations only iterate when executing function values
									if ( exec ) {
										exec = fn;
										fn = function( elem, key, value ) {
											return exec.call( jQuery( elem ), value );
										};

									// Otherwise they run against the entire set
									} else {
										fn.call( elems, value );
										fn = null;
									}
								}

								if ( fn ) {
									for (; i < length; i++ ) {
										fn( elems[i], key, exec ? value.call( elems[i], i, fn( elems[i], key ) ) : value, pass );
									}
								}

								chainable = 1;
							}

							return chainable ?
								elems :

								// Gets
								bulk ?
									fn.call( elems ) :
									length ? fn( elems[0], key ) : emptyGet;
						},

						now: function() {
							return ( new Date() ).getTime();
						},

						// Use of jQuery.browser is frowned upon.
						// More details: http://docs.jquery.com/Utilities/jQuery.browser
						uaMatch: function( ua ) {
							ua = ua.toLowerCase();

							var match = rwebkit.exec( ua ) ||
								ropera.exec( ua ) ||
								rmsie.exec( ua ) ||
								ua.indexOf("compatible") < 0 && rmozilla.exec( ua ) ||
								[];

							return { browser: match[1] || "", version: match[2] || "0" };
						},

						sub: function() {
							function jQuerySub( selector, context ) {
								return new jQuerySub.fn.init( selector, context );
							}
							jQuery.extend( true, jQuerySub, this );
							jQuerySub.superclass = this;
							jQuerySub.fn = jQuerySub.prototype = this();
							jQuerySub.fn.constructor = jQuerySub;
							jQuerySub.sub = this.sub;
							jQuerySub.fn.init = function init( selector, context ) {
								if ( context && context instanceof jQuery && !(context instanceof jQuerySub) ) {
									context = jQuerySub( context );
								}

								return jQuery.fn.init.call( this, selector, context, rootjQuerySub );
							};
							jQuerySub.fn.init.prototype = jQuerySub.fn;
							var rootjQuerySub = jQuerySub(document);
							return jQuerySub;
						},

						browser: {}
					});

					// Populate the class2type map
					jQuery.each("Boolean Number String Function Array Date RegExp Object".split(" "), function(i, name) {
						class2type[ "[object " + name + "]" ] = name.toLowerCase();
					});

					browserMatch = jQuery.uaMatch( userAgent );
					if ( browserMatch.browser ) {
						jQuery.browser[ browserMatch.browser ] = true;
						jQuery.browser.version = browserMatch.version;
					}

					// Deprecated, use jQuery.browser.webkit instead
					if ( jQuery.browser.webkit ) {
						jQuery.browser.safari = true;
					}

					// IE doesn't match non-breaking spaces with \s
					if ( rnotwhite.test( "\xA0" ) ) {
						trimLeft = /^[\s\xA0]+/;
						trimRight = /[\s\xA0]+$/;
					}

					// All jQuery objects should point back to these
					rootjQuery = jQuery(document);

					// Cleanup functions for the document ready method
					if ( document.addEventListener ) {
						DOMContentLoaded = function() {
							document.removeEventListener( "DOMContentLoaded", DOMContentLoaded, false );
							jQuery.ready();
						};

					} else if ( document.attachEvent ) {
						DOMContentLoaded = function() {
							// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
							if ( document.readyState === "complete" ) {
								document.detachEvent( "onreadystatechange", DOMContentLoaded );
								jQuery.ready();
							}
						};
					}

					// The DOM ready check for Internet Explorer
					function doScrollCheck() {
						if ( jQuery.isReady ) {
							return;
						}

						try {
							// If IE is used, use the trick by Diego Perini
							// http://javascript.nwbox.com/IEContentLoaded/
							document.documentElement.doScroll("left");
						} catch(e) {
							setTimeout( doScrollCheck, 1 );
							return;
						}

						// and execute any waiting functions
						jQuery.ready();
					}

					return jQuery;

					})();


					// String to Object flags format cache
					var flagsCache = {};

					// Convert String-formatted flags into Object-formatted ones and store in cache
					function createFlags( flags ) {
						var object = flagsCache[ flags ] = {},
							i, length;
						flags = flags.split( /\s+/ );
						for ( i = 0, length = flags.length; i < length; i++ ) {
							object[ flags[i] ] = true;
						}
						return object;
					}

					/*
					 * Create a callback list using the following parameters:
					 *
					 *	flags:	an optional list of space-separated flags that will change how
					 *			the callback list behaves
					 *
					 * By default a callback list will act like an event callback list and can be
					 * "fired" multiple times.
					 *
					 * Possible flags:
					 *
					 *	once:			will ensure the callback list can only be fired once (like a Deferred)
					 *
					 *	memory:			will keep track of previous values and will call any callback added
					 *					after the list has been fired right away with the latest "memorized"
					 *					values (like a Deferred)
					 *
					 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
					 *
					 *	stopOnFalse:	interrupt callings when a callback returns false
					 *
					 */
					jQuery.Callbacks = function( flags ) {

						// Convert flags from String-formatted to Object-formatted
						// (we check in cache first)
						flags = flags ? ( flagsCache[ flags ] || createFlags( flags ) ) : {};

						var // Actual callback list
							list = [],
							// Stack of fire calls for repeatable lists
							stack = [],
							// Last fire value (for non-forgettable lists)
							memory,
							// Flag to know if list was already fired
							fired,
							// Flag to know if list is currently firing
							firing,
							// First callback to fire (used internally by add and fireWith)
							firingStart,
							// End of the loop when firing
							firingLength,
							// Index of currently firing callback (modified by remove if needed)
							firingIndex,
							// Add one or several callbacks to the list
							add = function( args ) {
								var i,
									length,
									elem,
									type,
									actual;
								for ( i = 0, length = args.length; i < length; i++ ) {
									elem = args[ i ];
									type = jQuery.type( elem );
									if ( type === "array" ) {
										// Inspect recursively
										add( elem );
									} else if ( type === "function" ) {
										// Add if not in unique mode and callback is not in
										if ( !flags.unique || !self.has( elem ) ) {
											list.push( elem );
										}
									}
								}
							},
							// Fire callbacks
							fire = function( context, args ) {
								args = args || [];
								memory = !flags.memory || [ context, args ];
								fired = true;
								firing = true;
								firingIndex = firingStart || 0;
								firingStart = 0;
								firingLength = list.length;
								for ( ; list && firingIndex < firingLength; firingIndex++ ) {
									if ( list[ firingIndex ].apply( context, args ) === false && flags.stopOnFalse ) {
										memory = true; // Mark as halted
										break;
									}
								}
								firing = false;
								if ( list ) {
									if ( !flags.once ) {
										if ( stack && stack.length ) {
											memory = stack.shift();
											self.fireWith( memory[ 0 ], memory[ 1 ] );
										}
									} else if ( memory === true ) {
										self.disable();
									} else {
										list = [];
									}
								}
							},
							// Actual Callbacks object
							self = {
								// Add a callback or a collection of callbacks to the list
								add: function() {
									if ( list ) {
										var length = list.length;
										add( arguments );
										// Do we need to add the callbacks to the
										// current firing batch?
										if ( firing ) {
											firingLength = list.length;
										// With memory, if we're not firing then
										// we should call right away, unless previous
										// firing was halted (stopOnFalse)
										} else if ( memory && memory !== true ) {
											firingStart = length;
											fire( memory[ 0 ], memory[ 1 ] );
										}
									}
									return this;
								},
								// Remove a callback from the list
								remove: function() {
									if ( list ) {
										var args = arguments,
											argIndex = 0,
											argLength = args.length;
										for ( ; argIndex < argLength ; argIndex++ ) {
											for ( var i = 0; i < list.length; i++ ) {
												if ( args[ argIndex ] === list[ i ] ) {
													// Handle firingIndex and firingLength
													if ( firing ) {
														if ( i <= firingLength ) {
															firingLength--;
															if ( i <= firingIndex ) {
																firingIndex--;
															}
														}
													}
													// Remove the element
													list.splice( i--, 1 );
													// If we have some unicity property then
													// we only need to do this once
													if ( flags.unique ) {
														break;
													}
												}
											}
										}
									}
									return this;
								},
								// Control if a given callback is in the list
								has: function( fn ) {
									if ( list ) {
										var i = 0,
											length = list.length;
										for ( ; i < length; i++ ) {
											if ( fn === list[ i ] ) {
												return true;
											}
										}
									}
									return false;
								},
								// Remove all callbacks from the list
								empty: function() {
									list = [];
									return this;
								},
								// Have the list do nothing anymore
								disable: function() {
									list = stack = memory = undefined;
									return this;
								},
								// Is it disabled?
								disabled: function() {
									return !list;
								},
								// Lock the list in its current state
								lock: function() {
									stack = undefined;
									if ( !memory || memory === true ) {
										self.disable();
									}
									return this;
								},
								// Is it locked?
								locked: function() {
									return !stack;
								},
								// Call all callbacks with the given context and arguments
								fireWith: function( context, args ) {
									if ( stack ) {
										if ( firing ) {
											if ( !flags.once ) {
												stack.push( [ context, args ] );
											}
										} else if ( !( flags.once && memory ) ) {
											fire( context, args );
										}
									}
									return this;
								},
								// Call all the callbacks with the given arguments
								fire: function() {
									self.fireWith( this, arguments );
									return this;
								},
								// To know if the callbacks have already been called at least once
								fired: function() {
									return !!fired;
								}
							};

						return self;
					};




					var // Static reference to slice
						sliceDeferred = [].slice;

					jQuery.extend({

						Deferred: function( func ) {
							var doneList = jQuery.Callbacks( "once memory" ),
								failList = jQuery.Callbacks( "once memory" ),
								progressList = jQuery.Callbacks( "memory" ),
								state = "pending",
								lists = {
									resolve: doneList,
									reject: failList,
									notify: progressList
								},
								promise = {
									done: doneList.add,
									fail: failList.add,
									progress: progressList.add,

									state: function() {
										return state;
									},

									// Deprecated
									isResolved: doneList.fired,
									isRejected: failList.fired,

									then: function( doneCallbacks, failCallbacks, progressCallbacks ) {
										deferred.done( doneCallbacks ).fail( failCallbacks ).progress( progressCallbacks );
										return this;
									},
									always: function() {
										deferred.done.apply( deferred, arguments ).fail.apply( deferred, arguments );
										return this;
									},
									pipe: function( fnDone, fnFail, fnProgress ) {
										return jQuery.Deferred(function( newDefer ) {
											jQuery.each( {
												done: [ fnDone, "resolve" ],
												fail: [ fnFail, "reject" ],
												progress: [ fnProgress, "notify" ]
											}, function( handler, data ) {
												var fn = data[ 0 ],
													action = data[ 1 ],
													returned;
												if ( jQuery.isFunction( fn ) ) {
													deferred[ handler ](function() {
														returned = fn.apply( this, arguments );
														if ( returned && jQuery.isFunction( returned.promise ) ) {
															returned.promise().then( newDefer.resolve, newDefer.reject, newDefer.notify );
														} else {
															newDefer[ action + "With" ]( this === deferred ? newDefer : this, [ returned ] );
														}
													});
												} else {
													deferred[ handler ]( newDefer[ action ] );
												}
											});
										}).promise();
									},
									// Get a promise for this deferred
									// If obj is provided, the promise aspect is added to the object
									promise: function( obj ) {
										if ( obj == null ) {
											obj = promise;
										} else {
											for ( var key in promise ) {
												obj[ key ] = promise[ key ];
											}
										}
										return obj;
									}
								},
								deferred = promise.promise({}),
								key;

							for ( key in lists ) {
								deferred[ key ] = lists[ key ].fire;
								deferred[ key + "With" ] = lists[ key ].fireWith;
							}

							// Handle state
							deferred.done( function() {
								state = "resolved";
							}, failList.disable, progressList.lock ).fail( function() {
								state = "rejected";
							}, doneList.disable, progressList.lock );

							// Call given func if any
							if ( func ) {
								func.call( deferred, deferred );
							}

							// All done!
							return deferred;
						},

						// Deferred helper
						when: function( firstParam ) {
							var args = sliceDeferred.call( arguments, 0 ),
								i = 0,
								length = args.length,
								pValues = new Array( length ),
								count = length,
								pCount = length,
								deferred = length <= 1 && firstParam && jQuery.isFunction( firstParam.promise ) ?
									firstParam :
									jQuery.Deferred(),
								promise = deferred.promise();
							function resolveFunc( i ) {
								return function( value ) {
									args[ i ] = arguments.length > 1 ? sliceDeferred.call( arguments, 0 ) : value;
									if ( !( --count ) ) {
										deferred.resolveWith( deferred, args );
									}
								};
							}
							function progressFunc( i ) {
								return function( value ) {
									pValues[ i ] = arguments.length > 1 ? sliceDeferred.call( arguments, 0 ) : value;
									deferred.notifyWith( promise, pValues );
								};
							}
							if ( length > 1 ) {
								for ( ; i < length; i++ ) {
									if ( args[ i ] && args[ i ].promise && jQuery.isFunction( args[ i ].promise ) ) {
										args[ i ].promise().then( resolveFunc(i), deferred.reject, progressFunc(i) );
									} else {
										--count;
									}
								}
								if ( !count ) {
									deferred.resolveWith( deferred, args );
								}
							} else if ( deferred !== firstParam ) {
								deferred.resolveWith( deferred, length ? [ firstParam ] : [] );
							}
							return promise;
						}
					});




					jQuery.support = (function() {

						var support,
							all,
							a,
							select,
							opt,
							input,
							fragment,
							tds,
							events,
							eventName,
							i,
							isSupported,
							div = document.createElement( "div" ),
							documentElement = document.documentElement;

						// Preliminary tests
						div.setAttribute("className", "t");
						div.innerHTML = "   <link/><table></table><a href='/a' style='top:1px;float:left;opacity:.55;'>a</a><input type='checkbox'/>";

						all = div.getElementsByTagName( "*" );
						a = div.getElementsByTagName( "a" )[ 0 ];

						// Can't get basic test support
						if ( !all || !all.length || !a ) {
							return {};
						}

						// First batch of supports tests
						select = document.createElement( "select" );
						opt = select.appendChild( document.createElement("option") );
						input = div.getElementsByTagName( "input" )[ 0 ];

						support = {
							// IE strips leading whitespace when .innerHTML is used
							leadingWhitespace: ( div.firstChild.nodeType === 3 ),

							// Make sure that tbody elements aren't automatically inserted
							// IE will insert them into empty tables
							tbody: !div.getElementsByTagName("tbody").length,

							// Make sure that link elements get serialized correctly by innerHTML
							// This requires a wrapper element in IE
							htmlSerialize: !!div.getElementsByTagName("link").length,

							// Get the style information from getAttribute
							// (IE uses .cssText instead)
							style: /top/.test( a.getAttribute("style") ),

							// Make sure that URLs aren't manipulated
							// (IE normalizes it by default)
							hrefNormalized: ( a.getAttribute("href") === "/a" ),

							// Make sure that element opacity exists
							// (IE uses filter instead)
							// Use a regex to work around a WebKit issue. See #5145
							opacity: /^0.55/.test( a.style.opacity ),

							// Verify style float existence
							// (IE uses styleFloat instead of cssFloat)
							cssFloat: !!a.style.cssFloat,

							// Make sure that if no value is specified for a checkbox
							// that it defaults to "on".
							// (WebKit defaults to "" instead)
							checkOn: ( input.value === "on" ),

							// Make sure that a selected-by-default option has a working selected property.
							// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
							optSelected: opt.selected,

							// Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
							getSetAttribute: div.className !== "t",

							// Tests for enctype support on a form(#6743)
							enctype: !!document.createElement("form").enctype,

							// Makes sure cloning an html5 element does not cause problems
							// Where outerHTML is undefined, this still works
							html5Clone: document.createElement("nav").cloneNode( true ).outerHTML !== "<:nav></:nav>",

							// Will be defined later
							submitBubbles: true,
							changeBubbles: true,
							focusinBubbles: false,
							deleteExpando: true,
							noCloneEvent: true,
							inlineBlockNeedsLayout: false,
							shrinkWrapBlocks: false,
							reliableMarginRight: true,
							pixelMargin: true
						};

						// jQuery.boxModel DEPRECATED in 1.3, use jQuery.support.boxModel instead
						jQuery.boxModel = support.boxModel = (document.compatMode === "CSS1Compat");

						// Make sure checked status is properly cloned
						input.checked = true;
						support.noCloneChecked = input.cloneNode( true ).checked;

						// Make sure that the options inside disabled selects aren't marked as disabled
						// (WebKit marks them as disabled)
						select.disabled = true;
						support.optDisabled = !opt.disabled;

						// Test to see if it's possible to delete an expando from an element
						// Fails in Internet Explorer
						try {
							delete div.test;
						} catch( e ) {
							support.deleteExpando = false;
						}

						if ( !div.addEventListener && div.attachEvent && div.fireEvent ) {
							div.attachEvent( "onclick", function() {
								// Cloning a node shouldn't copy over any
								// bound event handlers (IE does this)
								support.noCloneEvent = false;
							});
							div.cloneNode( true ).fireEvent( "onclick" );
						}

						// Check if a radio maintains its value
						// after being appended to the DOM
						input = document.createElement("input");
						input.value = "t";
						input.setAttribute("type", "radio");
						support.radioValue = input.value === "t";

						input.setAttribute("checked", "checked");

						// #11217 - WebKit loses check when the name is after the checked attribute
						input.setAttribute( "name", "t" );

						div.appendChild( input );
						fragment = document.createDocumentFragment();
						fragment.appendChild( div.lastChild );

						// WebKit doesn't clone checked state correctly in fragments
						support.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;

						// Check if a disconnected checkbox will retain its checked
						// value of true after appended to the DOM (IE6/7)
						support.appendChecked = input.checked;

						fragment.removeChild( input );
						fragment.appendChild( div );

						// Technique from Juriy Zaytsev
						// http://perfectionkills.com/detecting-event-support-without-browser-sniffing/
						// We only care about the case where non-standard event systems
						// are used, namely in IE. Short-circuiting here helps us to
						// avoid an eval call (in setAttribute) which can cause CSP
						// to go haywire. See: https://developer.mozilla.org/en/Security/CSP
						if ( div.attachEvent ) {
							for ( i in {
								submit: 1,
								change: 1,
								focusin: 1
							}) {
								eventName = "on" + i;
								isSupported = ( eventName in div );
								if ( !isSupported ) {
									div.setAttribute( eventName, "return;" );
									isSupported = ( typeof div[ eventName ] === "function" );
								}
								support[ i + "Bubbles" ] = isSupported;
							}
						}

						fragment.removeChild( div );

						// Null elements to avoid leaks in IE
						fragment = select = opt = div = input = null;

						// Run tests that need a body at doc ready
						jQuery(function() {
							var container, outer, inner, table, td, offsetSupport,
								marginDiv, conMarginTop, style, html, positionTopLeftWidthHeight,
								paddingMarginBorderVisibility, paddingMarginBorder,
								body = document.getElementsByTagName("body")[0];

							if ( !body ) {
								// Return for frameset docs that don't have a body
								return;
							}

							conMarginTop = 1;
							paddingMarginBorder = "padding:0;margin:0;border:";
							positionTopLeftWidthHeight = "position:absolute;top:0;left:0;width:1px;height:1px;";
							paddingMarginBorderVisibility = paddingMarginBorder + "0;visibility:hidden;";
							style = "style='" + positionTopLeftWidthHeight + paddingMarginBorder + "5px solid #000;";
							html = "<div " + style + "display:block;'><div style='" + paddingMarginBorder + "0;display:block;overflow:hidden;'></div></div>" +
								"<table " + style + "' cellpadding='0' cellspacing='0'>" +
								"<tr><td></td></tr></table>";

							container = document.createElement("div");
							container.style.cssText = paddingMarginBorderVisibility + "width:0;height:0;position:static;top:0;margin-top:" + conMarginTop + "px";
							body.insertBefore( container, body.firstChild );

							// Construct the test element
							div = document.createElement("div");
							container.appendChild( div );

							// Check if table cells still have offsetWidth/Height when they are set
							// to display:none and there are still other visible table cells in a
							// table row; if so, offsetWidth/Height are not reliable for use when
							// determining if an element has been hidden directly using
							// display:none (it is still safe to use offsets if a parent element is
							// hidden; don safety goggles and see bug #4512 for more information).
							// (only IE 8 fails this test)
							div.innerHTML = "<table><tr><td style='" + paddingMarginBorder + "0;display:none'></td><td>t</td></tr></table>";
							tds = div.getElementsByTagName( "td" );
							isSupported = ( tds[ 0 ].offsetHeight === 0 );

							tds[ 0 ].style.display = "";
							tds[ 1 ].style.display = "none";

							// Check if empty table cells still have offsetWidth/Height
							// (IE <= 8 fail this test)
							support.reliableHiddenOffsets = isSupported && ( tds[ 0 ].offsetHeight === 0 );

							// Check if div with explicit width and no margin-right incorrectly
							// gets computed margin-right based on width of container. For more
							// info see bug #3333
							// Fails in WebKit before Feb 2011 nightlies
							// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
							if ( window.getComputedStyle ) {
								div.innerHTML = "";
								marginDiv = document.createElement( "div" );
								marginDiv.style.width = "0";
								marginDiv.style.marginRight = "0";
								div.style.width = "2px";
								div.appendChild( marginDiv );
								support.reliableMarginRight =
									( parseInt( ( window.getComputedStyle( marginDiv, null ) || { marginRight: 0 } ).marginRight, 10 ) || 0 ) === 0;
							}

							if ( typeof div.style.zoom !== "undefined" ) {
								// Check if natively block-level elements act like inline-block
								// elements when setting their display to 'inline' and giving
								// them layout
								// (IE < 8 does this)
								div.innerHTML = "";
								div.style.width = div.style.padding = "1px";
								div.style.border = 0;
								div.style.overflow = "hidden";
								div.style.display = "inline";
								div.style.zoom = 1;
								support.inlineBlockNeedsLayout = ( div.offsetWidth === 3 );

								// Check if elements with layout shrink-wrap their children
								// (IE 6 does this)
								div.style.display = "block";
								div.style.overflow = "visible";
								div.innerHTML = "<div style='width:5px;'></div>";
								support.shrinkWrapBlocks = ( div.offsetWidth !== 3 );
							}

							div.style.cssText = positionTopLeftWidthHeight + paddingMarginBorderVisibility;
							div.innerHTML = html;

							outer = div.firstChild;
							inner = outer.firstChild;
							td = outer.nextSibling.firstChild.firstChild;

							offsetSupport = {
								doesNotAddBorder: ( inner.offsetTop !== 5 ),
								doesAddBorderForTableAndCells: ( td.offsetTop === 5 )
							};

							inner.style.position = "fixed";
							inner.style.top = "20px";

							// safari subtracts parent border width here which is 5px
							offsetSupport.fixedPosition = ( inner.offsetTop === 20 || inner.offsetTop === 15 );
							inner.style.position = inner.style.top = "";

							outer.style.overflow = "hidden";
							outer.style.position = "relative";

							offsetSupport.subtractsBorderForOverflowNotVisible = ( inner.offsetTop === -5 );
							offsetSupport.doesNotIncludeMarginInBodyOffset = ( body.offsetTop !== conMarginTop );

							if ( window.getComputedStyle ) {
								div.style.marginTop = "1%";
								support.pixelMargin = ( window.getComputedStyle( div, null ) || { marginTop: 0 } ).marginTop !== "1%";
							}

							if ( typeof container.style.zoom !== "undefined" ) {
								container.style.zoom = 1;
							}

							body.removeChild( container );
							marginDiv = div = container = null;

							jQuery.extend( support, offsetSupport );
						});

						return support;
					})();




					var rbrace = /^(?:\{.*\}|\[.*\])$/,
						rmultiDash = /([A-Z])/g;

					jQuery.extend({
						cache: {},

						// Please use with caution
						uuid: 0,

						// Unique for each copy of jQuery on the page
						// Non-digits removed to match rinlinejQuery
						expando: "jQuery" + ( jQuery.fn.jquery + Math.random() ).replace( /\D/g, "" ),

						// The following elements throw uncatchable exceptions if you
						// attempt to add expando properties to them.
						noData: {
							"embed": true,
							// Ban all objects except for Flash (which handle expandos)
							"object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
							"applet": true
						},

						hasData: function( elem ) {
							elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];
							return !!elem && !isEmptyDataObject( elem );
						},

						data: function( elem, name, data, pvt /* Internal Use Only */ ) {
							if ( !jQuery.acceptData( elem ) ) {
								return;
							}

							var privateCache, thisCache, ret,
								internalKey = jQuery.expando,
								getByName = typeof name === "string",

								// We have to handle DOM nodes and JS objects differently because IE6-7
								// can't GC object references properly across the DOM-JS boundary
								isNode = elem.nodeType,

								// Only DOM nodes need the global jQuery cache; JS object data is
								// attached directly to the object so GC can occur automatically
								cache = isNode ? jQuery.cache : elem,

								// Only defining an ID for JS objects if its cache already exists allows
								// the code to shortcut on the same path as a DOM node with no cache
								id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey,
								isEvents = name === "events";

							// Avoid doing any more work than we need to when trying to get data on an
							// object that has no data at all
							if ( (!id || !cache[id] || (!isEvents && !pvt && !cache[id].data)) && getByName && data === undefined ) {
								return;
							}

							if ( !id ) {
								// Only DOM nodes need a new unique ID for each element since their data
								// ends up in the global cache
								if ( isNode ) {
									elem[ internalKey ] = id = ++jQuery.uuid;
								} else {
									id = internalKey;
								}
							}

							if ( !cache[ id ] ) {
								cache[ id ] = {};

								// Avoids exposing jQuery metadata on plain JS objects when the object
								// is serialized using JSON.stringify
								if ( !isNode ) {
									cache[ id ].toJSON = jQuery.noop;
								}
							}

							// An object can be passed to jQuery.data instead of a key/value pair; this gets
							// shallow copied over onto the existing cache
							if ( typeof name === "object" || typeof name === "function" ) {
								if ( pvt ) {
									cache[ id ] = jQuery.extend( cache[ id ], name );
								} else {
									cache[ id ].data = jQuery.extend( cache[ id ].data, name );
								}
							}

							privateCache = thisCache = cache[ id ];

							// jQuery data() is stored in a separate object inside the object's internal data
							// cache in order to avoid key collisions between internal data and user-defined
							// data.
							if ( !pvt ) {
								if ( !thisCache.data ) {
									thisCache.data = {};
								}

								thisCache = thisCache.data;
							}

							if ( data !== undefined ) {
								thisCache[ jQuery.camelCase( name ) ] = data;
							}

							// Users should not attempt to inspect the internal events object using jQuery.data,
							// it is undocumented and subject to change. But does anyone listen? No.
							if ( isEvents && !thisCache[ name ] ) {
								return privateCache.events;
							}

							// Check for both converted-to-camel and non-converted data property names
							// If a data property was specified
							if ( getByName ) {

								// First Try to find as-is property data
								ret = thisCache[ name ];

								// Test for null|undefined property data
								if ( ret == null ) {

									// Try to find the camelCased property
									ret = thisCache[ jQuery.camelCase( name ) ];
								}
							} else {
								ret = thisCache;
							}

							return ret;
						},

						removeData: function( elem, name, pvt /* Internal Use Only */ ) {
							if ( !jQuery.acceptData( elem ) ) {
								return;
							}

							var thisCache, i, l,

								// Reference to internal data cache key
								internalKey = jQuery.expando,

								isNode = elem.nodeType,

								// See jQuery.data for more information
								cache = isNode ? jQuery.cache : elem,

								// See jQuery.data for more information
								id = isNode ? elem[ internalKey ] : internalKey;

							// If there is already no cache entry for this object, there is no
							// purpose in continuing
							if ( !cache[ id ] ) {
								return;
							}

							if ( name ) {

								thisCache = pvt ? cache[ id ] : cache[ id ].data;

								if ( thisCache ) {

									// Support array or space separated string names for data keys
									if ( !jQuery.isArray( name ) ) {

										// try the string as a key before any manipulation
										if ( name in thisCache ) {
											name = [ name ];
										} else {

											// split the camel cased version by spaces unless a key with the spaces exists
											name = jQuery.camelCase( name );
											if ( name in thisCache ) {
												name = [ name ];
											} else {
												name = name.split( " " );
											}
										}
									}

									for ( i = 0, l = name.length; i < l; i++ ) {
										delete thisCache[ name[i] ];
									}

									// If there is no data left in the cache, we want to continue
									// and let the cache object itself get destroyed
									if ( !( pvt ? isEmptyDataObject : jQuery.isEmptyObject )( thisCache ) ) {
										return;
									}
								}
							}

							// See jQuery.data for more information
							if ( !pvt ) {
								delete cache[ id ].data;

								// Don't destroy the parent cache unless the internal data object
								// had been the only thing left in it
								if ( !isEmptyDataObject(cache[ id ]) ) {
									return;
								}
							}

							// Browsers that fail expando deletion also refuse to delete expandos on
							// the window, but it will allow it on all other JS objects; other browsers
							// don't care
							// Ensure that `cache` is not a window object #10080
							if ( jQuery.support.deleteExpando || !cache.setInterval ) {
								delete cache[ id ];
							} else {
								cache[ id ] = null;
							}

							// We destroyed the cache and need to eliminate the expando on the node to avoid
							// false lookups in the cache for entries that no longer exist
							if ( isNode ) {
								// IE does not allow us to delete expando properties from nodes,
								// nor does it have a removeAttribute function on Document nodes;
								// we must handle all of these cases
								if ( jQuery.support.deleteExpando ) {
									delete elem[ internalKey ];
								} else if ( elem.removeAttribute ) {
									elem.removeAttribute( internalKey );
								} else {
									elem[ internalKey ] = null;
								}
							}
						},

						// For internal use only.
						_data: function( elem, name, data ) {
							return jQuery.data( elem, name, data, true );
						},

						// A method for determining if a DOM node can handle the data expando
						acceptData: function( elem ) {
							if ( elem.nodeName ) {
								var match = jQuery.noData[ elem.nodeName.toLowerCase() ];

								if ( match ) {
									return !(match === true || elem.getAttribute("classid") !== match);
								}
							}

							return true;
						}
					});

					jQuery.fn.extend({
						data: function( key, value ) {
							var parts, part, attr, name, l,
								elem = this[0],
								i = 0,
								data = null;

							// Gets all values
							if ( key === undefined ) {
								if ( this.length ) {
									data = jQuery.data( elem );

									if ( elem.nodeType === 1 && !jQuery._data( elem, "parsedAttrs" ) ) {
										attr = elem.attributes;
										for ( l = attr.length; i < l; i++ ) {
											name = attr[i].name;

											if ( name.indexOf( "data-" ) === 0 ) {
												name = jQuery.camelCase( name.substring(5) );

												dataAttr( elem, name, data[ name ] );
											}
										}
										jQuery._data( elem, "parsedAttrs", true );
									}
								}

								return data;
							}

							// Sets multiple values
							if ( typeof key === "object" ) {
								return this.each(function() {
									jQuery.data( this, key );
								});
							}

							parts = key.split( ".", 2 );
							parts[1] = parts[1] ? "." + parts[1] : "";
							part = parts[1] + "!";

							return jQuery.access( this, function( value ) {

								if ( value === undefined ) {
									data = this.triggerHandler( "getData" + part, [ parts[0] ] );

									// Try to fetch any internally stored data first
									if ( data === undefined && elem ) {
										data = jQuery.data( elem, key );
										data = dataAttr( elem, key, data );
									}

									return data === undefined && parts[1] ?
										this.data( parts[0] ) :
										data;
								}

								parts[1] = value;
								this.each(function() {
									var self = jQuery( this );

									self.triggerHandler( "setData" + part, parts );
									jQuery.data( this, key, value );
									self.triggerHandler( "changeData" + part, parts );
								});
							}, null, value, arguments.length > 1, null, false );
						},

						removeData: function( key ) {
							return this.each(function() {
								jQuery.removeData( this, key );
							});
						}
					});

					function dataAttr( elem, key, data ) {
						// If nothing was found internally, try to fetch any
						// data from the HTML5 data-* attribute
						if ( data === undefined && elem.nodeType === 1 ) {

							var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();

							data = elem.getAttribute( name );

							if ( typeof data === "string" ) {
								try {
									data = data === "true" ? true :
									data === "false" ? false :
									data === "null" ? null :
									jQuery.isNumeric( data ) ? +data :
										rbrace.test( data ) ? jQuery.parseJSON( data ) :
										data;
								} catch( e ) {}

								// Make sure we set the data so it isn't changed later
								jQuery.data( elem, key, data );

							} else {
								data = undefined;
							}
						}

						return data;
					}

					// checks a cache object for emptiness
					function isEmptyDataObject( obj ) {
						for ( var name in obj ) {

							// if the public data object is empty, the private is still empty
							if ( name === "data" && jQuery.isEmptyObject( obj[name] ) ) {
								continue;
							}
							if ( name !== "toJSON" ) {
								return false;
							}
						}

						return true;
					}




					function handleQueueMarkDefer( elem, type, src ) {
						var deferDataKey = type + "defer",
							queueDataKey = type + "queue",
							markDataKey = type + "mark",
							defer = jQuery._data( elem, deferDataKey );
						if ( defer &&
							( src === "queue" || !jQuery._data(elem, queueDataKey) ) &&
							( src === "mark" || !jQuery._data(elem, markDataKey) ) ) {
							// Give room for hard-coded callbacks to fire first
							// and eventually mark/queue something else on the element
							setTimeout( function() {
								if ( !jQuery._data( elem, queueDataKey ) &&
									!jQuery._data( elem, markDataKey ) ) {
									jQuery.removeData( elem, deferDataKey, true );
									defer.fire();
								}
							}, 0 );
						}
					}

					jQuery.extend({

						_mark: function( elem, type ) {
							if ( elem ) {
								type = ( type || "fx" ) + "mark";
								jQuery._data( elem, type, (jQuery._data( elem, type ) || 0) + 1 );
							}
						},

						_unmark: function( force, elem, type ) {
							if ( force !== true ) {
								type = elem;
								elem = force;
								force = false;
							}
							if ( elem ) {
								type = type || "fx";
								var key = type + "mark",
									count = force ? 0 : ( (jQuery._data( elem, key ) || 1) - 1 );
								if ( count ) {
									jQuery._data( elem, key, count );
								} else {
									jQuery.removeData( elem, key, true );
									handleQueueMarkDefer( elem, type, "mark" );
								}
							}
						},

						queue: function( elem, type, data ) {
							var q;
							if ( elem ) {
								type = ( type || "fx" ) + "queue";
								q = jQuery._data( elem, type );

								// Speed up dequeue by getting out quickly if this is just a lookup
								if ( data ) {
									if ( !q || jQuery.isArray(data) ) {
										q = jQuery._data( elem, type, jQuery.makeArray(data) );
									} else {
										q.push( data );
									}
								}
								return q || [];
							}
						},

						dequeue: function( elem, type ) {
							type = type || "fx";

							var queue = jQuery.queue( elem, type ),
								fn = queue.shift(),
								hooks = {};

							// If the fx queue is dequeued, always remove the progress sentinel
							if ( fn === "inprogress" ) {
								fn = queue.shift();
							}

							if ( fn ) {
								// Add a progress sentinel to prevent the fx queue from being
								// automatically dequeued
								if ( type === "fx" ) {
									queue.unshift( "inprogress" );
								}

								jQuery._data( elem, type + ".run", hooks );
								fn.call( elem, function() {
									jQuery.dequeue( elem, type );
								}, hooks );
							}

							if ( !queue.length ) {
								jQuery.removeData( elem, type + "queue " + type + ".run", true );
								handleQueueMarkDefer( elem, type, "queue" );
							}
						}
					});

					jQuery.fn.extend({
						queue: function( type, data ) {
							var setter = 2;

							if ( typeof type !== "string" ) {
								data = type;
								type = "fx";
								setter--;
							}

							if ( arguments.length < setter ) {
								return jQuery.queue( this[0], type );
							}

							return data === undefined ?
								this :
								this.each(function() {
									var queue = jQuery.queue( this, type, data );

									if ( type === "fx" && queue[0] !== "inprogress" ) {
										jQuery.dequeue( this, type );
									}
								});
						},
						dequeue: function( type ) {
							return this.each(function() {
								jQuery.dequeue( this, type );
							});
						},
						// Based off of the plugin by Clint Helfers, with permission.
						// http://blindsignals.com/index.php/2009/07/jquery-delay/
						delay: function( time, type ) {
							time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
							type = type || "fx";

							return this.queue( type, function( next, hooks ) {
								var timeout = setTimeout( next, time );
								hooks.stop = function() {
									clearTimeout( timeout );
								};
							});
						},
						clearQueue: function( type ) {
							return this.queue( type || "fx", [] );
						},
						// Get a promise resolved when queues of a certain type
						// are emptied (fx is the type by default)
						promise: function( type, object ) {
							if ( typeof type !== "string" ) {
								object = type;
								type = undefined;
							}
							type = type || "fx";
							var defer = jQuery.Deferred(),
								elements = this,
								i = elements.length,
								count = 1,
								deferDataKey = type + "defer",
								queueDataKey = type + "queue",
								markDataKey = type + "mark",
								tmp;
							function resolve() {
								if ( !( --count ) ) {
									defer.resolveWith( elements, [ elements ] );
								}
							}
							while( i-- ) {
								if (( tmp = jQuery.data( elements[ i ], deferDataKey, undefined, true ) ||
										( jQuery.data( elements[ i ], queueDataKey, undefined, true ) ||
											jQuery.data( elements[ i ], markDataKey, undefined, true ) ) &&
										jQuery.data( elements[ i ], deferDataKey, jQuery.Callbacks( "once memory" ), true ) )) {
									count++;
									tmp.add( resolve );
								}
							}
							resolve();
							return defer.promise( object );
						}
					});




					var rclass = /[\n\t\r]/g,
						rspace = /\s+/,
						rreturn = /\r/g,
						rtype = /^(?:button|input)$/i,
						rfocusable = /^(?:button|input|object|select|textarea)$/i,
						rclickable = /^a(?:rea)?$/i,
						rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,
						getSetAttribute = jQuery.support.getSetAttribute,
						nodeHook, boolHook, fixSpecified;

					jQuery.fn.extend({
						attr: function( name, value ) {
							return jQuery.access( this, jQuery.attr, name, value, arguments.length > 1 );
						},

						removeAttr: function( name ) {
							return this.each(function() {
								jQuery.removeAttr( this, name );
							});
						},

						prop: function( name, value ) {
							return jQuery.access( this, jQuery.prop, name, value, arguments.length > 1 );
						},

						removeProp: function( name ) {
							name = jQuery.propFix[ name ] || name;
							return this.each(function() {
								// try/catch handles cases where IE balks (such as removing a property on window)
								try {
									this[ name ] = undefined;
									delete this[ name ];
								} catch( e ) {}
							});
						},

						addClass: function( value ) {
							var classNames, i, l, elem,
								setClass, c, cl;

							if ( jQuery.isFunction( value ) ) {
								return this.each(function( j ) {
									jQuery( this ).addClass( value.call(this, j, this.className) );
								});
							}

							if ( value && typeof value === "string" ) {
								classNames = value.split( rspace );

								for ( i = 0, l = this.length; i < l; i++ ) {
									elem = this[ i ];

									if ( elem.nodeType === 1 ) {
										if ( !elem.className && classNames.length === 1 ) {
											elem.className = value;

										} else {
											setClass = " " + elem.className + " ";

											for ( c = 0, cl = classNames.length; c < cl; c++ ) {
												if ( !~setClass.indexOf( " " + classNames[ c ] + " " ) ) {
													setClass += classNames[ c ] + " ";
												}
											}
											elem.className = jQuery.trim( setClass );
										}
									}
								}
							}

							return this;
						},

						removeClass: function( value ) {
							var classNames, i, l, elem, className, c, cl;

							if ( jQuery.isFunction( value ) ) {
								return this.each(function( j ) {
									jQuery( this ).removeClass( value.call(this, j, this.className) );
								});
							}

							if ( (value && typeof value === "string") || value === undefined ) {
								classNames = ( value || "" ).split( rspace );

								for ( i = 0, l = this.length; i < l; i++ ) {
									elem = this[ i ];

									if ( elem.nodeType === 1 && elem.className ) {
										if ( value ) {
											className = (" " + elem.className + " ").replace( rclass, " " );
											for ( c = 0, cl = classNames.length; c < cl; c++ ) {
												className = className.replace(" " + classNames[ c ] + " ", " ");
											}
											elem.className = jQuery.trim( className );

										} else {
											elem.className = "";
										}
									}
								}
							}

							return this;
						},

						toggleClass: function( value, stateVal ) {
							var type = typeof value,
								isBool = typeof stateVal === "boolean";

							if ( jQuery.isFunction( value ) ) {
								return this.each(function( i ) {
									jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
								});
							}

							return this.each(function() {
								if ( type === "string" ) {
									// toggle individual class names
									var className,
										i = 0,
										self = jQuery( this ),
										state = stateVal,
										classNames = value.split( rspace );

									while ( (className = classNames[ i++ ]) ) {
										// check each className given, space seperated list
										state = isBool ? state : !self.hasClass( className );
										self[ state ? "addClass" : "removeClass" ]( className );
									}

								} else if ( type === "undefined" || type === "boolean" ) {
									if ( this.className ) {
										// store className if set
										jQuery._data( this, "__className__", this.className );
									}

									// toggle whole className
									this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";
								}
							});
						},

						hasClass: function( selector ) {
							var className = " " + selector + " ",
								i = 0,
								l = this.length;
							for ( ; i < l; i++ ) {
								if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) > -1 ) {
									return true;
								}
							}

							return false;
						},

						val: function( value ) {
							var hooks, ret, isFunction,
								elem = this[0];

							if ( !arguments.length ) {
								if ( elem ) {
									hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

									if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
										return ret;
									}

									ret = elem.value;

									return typeof ret === "string" ?
										// handle most common string cases
										ret.replace(rreturn, "") :
										// handle cases where value is null/undef or number
										ret == null ? "" : ret;
								}

								return;
							}

							isFunction = jQuery.isFunction( value );

							return this.each(function( i ) {
								var self = jQuery(this), val;

								if ( this.nodeType !== 1 ) {
									return;
								}

								if ( isFunction ) {
									val = value.call( this, i, self.val() );
								} else {
									val = value;
								}

								// Treat null/undefined as ""; convert numbers to string
								if ( val == null ) {
									val = "";
								} else if ( typeof val === "number" ) {
									val += "";
								} else if ( jQuery.isArray( val ) ) {
									val = jQuery.map(val, function ( value ) {
										return value == null ? "" : value + "";
									});
								}

								hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

								// If set returns undefined, fall back to normal setting
								if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
									this.value = val;
								}
							});
						}
					});

					jQuery.extend({
						valHooks: {
							option: {
								get: function( elem ) {
									// attributes.value is undefined in Blackberry 4.7 but
									// uses .value. See #6932
									var val = elem.attributes.value;
									return !val || val.specified ? elem.value : elem.text;
								}
							},
							select: {
								get: function( elem ) {
									var value, i, max, option,
										index = elem.selectedIndex,
										values = [],
										options = elem.options,
										one = elem.type === "select-one";

									// Nothing was selected
									if ( index < 0 ) {
										return null;
									}

									// Loop through all the selected options
									i = one ? index : 0;
									max = one ? index + 1 : options.length;
									for ( ; i < max; i++ ) {
										option = options[ i ];

										// Don't return options that are disabled or in a disabled optgroup
										if ( option.selected && (jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) &&
												(!option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" )) ) {

											// Get the specific value for the option
											value = jQuery( option ).val();

											// We don't need an array for one selects
											if ( one ) {
												return value;
											}

											// Multi-Selects return an array
											values.push( value );
										}
									}

									// Fixes Bug #2551 -- select.val() broken in IE after form.reset()
									if ( one && !values.length && options.length ) {
										return jQuery( options[ index ] ).val();
									}

									return values;
								},

								set: function( elem, value ) {
									var values = jQuery.makeArray( value );

									jQuery(elem).find("option").each(function() {
										this.selected = jQuery.inArray( jQuery(this).val(), values ) >= 0;
									});

									if ( !values.length ) {
										elem.selectedIndex = -1;
									}
									return values;
								}
							}
						},

						attrFn: {
							val: true,
							css: true,
							html: true,
							text: true,
							data: true,
							width: true,
							height: true,
							offset: true
						},

						attr: function( elem, name, value, pass ) {
							var ret, hooks, notxml,
								nType = elem.nodeType;

							// don't get/set attributes on text, comment and attribute nodes
							if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
								return;
							}

							if ( pass && name in jQuery.attrFn ) {
								return jQuery( elem )[ name ]( value );
							}

							// Fallback to prop when attributes are not supported
							if ( typeof elem.getAttribute === "undefined" ) {
								return jQuery.prop( elem, name, value );
							}

							notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

							// All attributes are lowercase
							// Grab necessary hook if one is defined
							if ( notxml ) {
								name = name.toLowerCase();
								hooks = jQuery.attrHooks[ name ] || ( rboolean.test( name ) ? boolHook : nodeHook );
							}

							if ( value !== undefined ) {

								if ( value === null ) {
									jQuery.removeAttr( elem, name );
									return;

								} else if ( hooks && "set" in hooks && notxml && (ret = hooks.set( elem, value, name )) !== undefined ) {
									return ret;

								} else {
									elem.setAttribute( name, "" + value );
									return value;
								}

							} else if ( hooks && "get" in hooks && notxml && (ret = hooks.get( elem, name )) !== null ) {
								return ret;

							} else {

								ret = elem.getAttribute( name );

								// Non-existent attributes return null, we normalize to undefined
								return ret === null ?
									undefined :
									ret;
							}
						},

						removeAttr: function( elem, value ) {
							var propName, attrNames, name, l, isBool,
								i = 0;

							if ( value && elem.nodeType === 1 ) {
								attrNames = value.toLowerCase().split( rspace );
								l = attrNames.length;

								for ( ; i < l; i++ ) {
									name = attrNames[ i ];

									if ( name ) {
										propName = jQuery.propFix[ name ] || name;
										isBool = rboolean.test( name );

										// See #9699 for explanation of this approach (setting first, then removal)
										// Do not do this for boolean attributes (see #10870)
										if ( !isBool ) {
											jQuery.attr( elem, name, "" );
										}
										elem.removeAttribute( getSetAttribute ? name : propName );

										// Set corresponding property to false for boolean attributes
										if ( isBool && propName in elem ) {
											elem[ propName ] = false;
										}
									}
								}
							}
						},

						attrHooks: {
							type: {
								set: function( elem, value ) {
									// We can't allow the type property to be changed (since it causes problems in IE)
									if ( rtype.test( elem.nodeName ) && elem.parentNode ) {
										jQuery.error( "type property can't be changed" );
									} else if ( !jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {
										// Setting the type on a radio button after the value resets the value in IE6-9
										// Reset value to it's default in case type is set after value
										// This is for element creation
										var val = elem.value;
										elem.setAttribute( "type", value );
										if ( val ) {
											elem.value = val;
										}
										return value;
									}
								}
							},
							// Use the value property for back compat
							// Use the nodeHook for button elements in IE6/7 (#1954)
							value: {
								get: function( elem, name ) {
									if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
										return nodeHook.get( elem, name );
									}
									return name in elem ?
										elem.value :
										null;
								},
								set: function( elem, value, name ) {
									if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
										return nodeHook.set( elem, value, name );
									}
									// Does not return so that setAttribute is also used
									elem.value = value;
								}
							}
						},

						propFix: {
							tabindex: "tabIndex",
							readonly: "readOnly",
							"for": "htmlFor",
							"class": "className",
							maxlength: "maxLength",
							cellspacing: "cellSpacing",
							cellpadding: "cellPadding",
							rowspan: "rowSpan",
							colspan: "colSpan",
							usemap: "useMap",
							frameborder: "frameBorder",
							contenteditable: "contentEditable"
						},

						prop: function( elem, name, value ) {
							var ret, hooks, notxml,
								nType = elem.nodeType;

							// don't get/set properties on text, comment and attribute nodes
							if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
								return;
							}

							notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

							if ( notxml ) {
								// Fix name and attach hooks
								name = jQuery.propFix[ name ] || name;
								hooks = jQuery.propHooks[ name ];
							}

							if ( value !== undefined ) {
								if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
									return ret;

								} else {
									return ( elem[ name ] = value );
								}

							} else {
								if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
									return ret;

								} else {
									return elem[ name ];
								}
							}
						},

						propHooks: {
							tabIndex: {
								get: function( elem ) {
									// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
									// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
									var attributeNode = elem.getAttributeNode("tabindex");

									return attributeNode && attributeNode.specified ?
										parseInt( attributeNode.value, 10 ) :
										rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
											0 :
											undefined;
								}
							}
						}
					});

					// Add the tabIndex propHook to attrHooks for back-compat (different case is intentional)
					jQuery.attrHooks.tabindex = jQuery.propHooks.tabIndex;

					// Hook for boolean attributes
					boolHook = {
						get: function( elem, name ) {
							// Align boolean attributes with corresponding properties
							// Fall back to attribute presence where some booleans are not supported
							var attrNode,
								property = jQuery.prop( elem, name );
							return property === true || typeof property !== "boolean" && ( attrNode = elem.getAttributeNode(name) ) && attrNode.nodeValue !== false ?
								name.toLowerCase() :
								undefined;
						},
						set: function( elem, value, name ) {
							var propName;
							if ( value === false ) {
								// Remove boolean attributes when set to false
								jQuery.removeAttr( elem, name );
							} else {
								// value is true since we know at this point it's type boolean and not false
								// Set boolean attributes to the same name and set the DOM property
								propName = jQuery.propFix[ name ] || name;
								if ( propName in elem ) {
									// Only set the IDL specifically if it already exists on the element
									elem[ propName ] = true;
								}

								elem.setAttribute( name, name.toLowerCase() );
							}
							return name;
						}
					};

					// IE6/7 do not support getting/setting some attributes with get/setAttribute
					if ( !getSetAttribute ) {

						fixSpecified = {
							name: true,
							id: true,
							coords: true
						};

						// Use this for any attribute in IE6/7
						// This fixes almost every IE6/7 issue
						nodeHook = jQuery.valHooks.button = {
							get: function( elem, name ) {
								var ret;
								ret = elem.getAttributeNode( name );
								return ret && ( fixSpecified[ name ] ? ret.nodeValue !== "" : ret.specified ) ?
									ret.nodeValue :
									undefined;
							},
							set: function( elem, value, name ) {
								// Set the existing or create a new attribute node
								var ret = elem.getAttributeNode( name );
								if ( !ret ) {
									ret = document.createAttribute( name );
									elem.setAttributeNode( ret );
								}
								return ( ret.nodeValue = value + "" );
							}
						};

						// Apply the nodeHook to tabindex
						jQuery.attrHooks.tabindex.set = nodeHook.set;

						// Set width and height to auto instead of 0 on empty string( Bug #8150 )
						// This is for removals
						jQuery.each([ "width", "height" ], function( i, name ) {
							jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
								set: function( elem, value ) {
									if ( value === "" ) {
										elem.setAttribute( name, "auto" );
										return value;
									}
								}
							});
						});

						// Set contenteditable to false on removals(#10429)
						// Setting to empty string throws an error as an invalid value
						jQuery.attrHooks.contenteditable = {
							get: nodeHook.get,
							set: function( elem, value, name ) {
								if ( value === "" ) {
									value = "false";
								}
								nodeHook.set( elem, value, name );
							}
						};
					}


					// Some attributes require a special call on IE
					if ( !jQuery.support.hrefNormalized ) {
						jQuery.each([ "href", "src", "width", "height" ], function( i, name ) {
							jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
								get: function( elem ) {
									var ret = elem.getAttribute( name, 2 );
									return ret === null ? undefined : ret;
								}
							});
						});
					}

					if ( !jQuery.support.style ) {
						jQuery.attrHooks.style = {
							get: function( elem ) {
								// Return undefined in the case of empty string
								// Normalize to lowercase since IE uppercases css property names
								return elem.style.cssText.toLowerCase() || undefined;
							},
							set: function( elem, value ) {
								return ( elem.style.cssText = "" + value );
							}
						};
					}

					// Safari mis-reports the default selected property of an option
					// Accessing the parent's selectedIndex property fixes it
					if ( !jQuery.support.optSelected ) {
						jQuery.propHooks.selected = jQuery.extend( jQuery.propHooks.selected, {
							get: function( elem ) {
								var parent = elem.parentNode;

								if ( parent ) {
									parent.selectedIndex;

									// Make sure that it also works with optgroups, see #5701
									if ( parent.parentNode ) {
										parent.parentNode.selectedIndex;
									}
								}
								return null;
							}
						});
					}

					// IE6/7 call enctype encoding
					if ( !jQuery.support.enctype ) {
						jQuery.propFix.enctype = "encoding";
					}

					// Radios and checkboxes getter/setter
					if ( !jQuery.support.checkOn ) {
						jQuery.each([ "radio", "checkbox" ], function() {
							jQuery.valHooks[ this ] = {
								get: function( elem ) {
									// Handle the case where in Webkit "" is returned instead of "on" if a value isn't specified
									return elem.getAttribute("value") === null ? "on" : elem.value;
								}
							};
						});
					}
					jQuery.each([ "radio", "checkbox" ], function() {
						jQuery.valHooks[ this ] = jQuery.extend( jQuery.valHooks[ this ], {
							set: function( elem, value ) {
								if ( jQuery.isArray( value ) ) {
									return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
								}
							}
						});
					});




					var rformElems = /^(?:textarea|input|select)$/i,
						rtypenamespace = /^([^\.]*)?(?:\.(.+))?$/,
						rhoverHack = /(?:^|\s)hover(\.\S+)?\b/,
						rkeyEvent = /^key/,
						rmouseEvent = /^(?:mouse|contextmenu)|click/,
						rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
						rquickIs = /^(\w*)(?:#([\w\-]+))?(?:\.([\w\-]+))?$/,
						quickParse = function( selector ) {
							var quick = rquickIs.exec( selector );
							if ( quick ) {
								//   0  1    2   3
								// [ _, tag, id, class ]
								quick[1] = ( quick[1] || "" ).toLowerCase();
								quick[3] = quick[3] && new RegExp( "(?:^|\\s)" + quick[3] + "(?:\\s|$)" );
							}
							return quick;
						},
						quickIs = function( elem, m ) {
							var attrs = elem.attributes || {};
							return (
								(!m[1] || elem.nodeName.toLowerCase() === m[1]) &&
								(!m[2] || (attrs.id || {}).value === m[2]) &&
								(!m[3] || m[3].test( (attrs[ "class" ] || {}).value ))
							);
						},
						hoverHack = function( events ) {
							return jQuery.event.special.hover ? events : events.replace( rhoverHack, "mouseenter$1 mouseleave$1" );
						};

					/*
					 * Helper functions for managing events -- not part of the public interface.
					 * Props to Dean Edwards' addEvent library for many of the ideas.
					 */
					jQuery.event = {

						add: function( elem, types, handler, data, selector ) {

							var elemData, eventHandle, events,
								t, tns, type, namespaces, handleObj,
								handleObjIn, quick, handlers, special;

							// Don't attach events to noData or text/comment nodes (allow plain objects tho)
							if ( elem.nodeType === 3 || elem.nodeType === 8 || !types || !handler || !(elemData = jQuery._data( elem )) ) {
								return;
							}

							// Caller can pass in an object of custom data in lieu of the handler
							if ( handler.handler ) {
								handleObjIn = handler;
								handler = handleObjIn.handler;
								selector = handleObjIn.selector;
							}

							// Make sure that the handler has a unique ID, used to find/remove it later
							if ( !handler.guid ) {
								handler.guid = jQuery.guid++;
							}

							// Init the element's event structure and main handler, if this is the first
							events = elemData.events;
							if ( !events ) {
								elemData.events = events = {};
							}
							eventHandle = elemData.handle;
							if ( !eventHandle ) {
								elemData.handle = eventHandle = function( e ) {
									// Discard the second event of a jQuery.event.trigger() and
									// when an event is called after a page has unloaded
									return typeof jQuery !== "undefined" && (!e || jQuery.event.triggered !== e.type) ?
										jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
										undefined;
								};
								// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
								eventHandle.elem = elem;
							}

							// Handle multiple events separated by a space
							// jQuery(...).bind("mouseover mouseout", fn);
							types = jQuery.trim( hoverHack(types) ).split( " " );
							for ( t = 0; t < types.length; t++ ) {

								tns = rtypenamespace.exec( types[t] ) || [];
								type = tns[1];
								namespaces = ( tns[2] || "" ).split( "." ).sort();

								// If event changes its type, use the special event handlers for the changed type
								special = jQuery.event.special[ type ] || {};

								// If selector defined, determine special event api type, otherwise given type
								type = ( selector ? special.delegateType : special.bindType ) || type;

								// Update special based on newly reset type
								special = jQuery.event.special[ type ] || {};

								// handleObj is passed to all event handlers
								handleObj = jQuery.extend({
									type: type,
									origType: tns[1],
									data: data,
									handler: handler,
									guid: handler.guid,
									selector: selector,
									quick: selector && quickParse( selector ),
									namespace: namespaces.join(".")
								}, handleObjIn );

								// Init the event handler queue if we're the first
								handlers = events[ type ];
								if ( !handlers ) {
									handlers = events[ type ] = [];
									handlers.delegateCount = 0;

									// Only use addEventListener/attachEvent if the special events handler returns false
									if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
										// Bind the global event handler to the element
										if ( elem.addEventListener ) {
											elem.addEventListener( type, eventHandle, false );

										} else if ( elem.attachEvent ) {
											elem.attachEvent( "on" + type, eventHandle );
										}
									}
								}

								if ( special.add ) {
									special.add.call( elem, handleObj );

									if ( !handleObj.handler.guid ) {
										handleObj.handler.guid = handler.guid;
									}
								}

								// Add to the element's handler list, delegates in front
								if ( selector ) {
									handlers.splice( handlers.delegateCount++, 0, handleObj );
								} else {
									handlers.push( handleObj );
								}

								// Keep track of which events have ever been used, for event optimization
								jQuery.event.global[ type ] = true;
							}

							// Nullify elem to prevent memory leaks in IE
							elem = null;
						},

						global: {},

						// Detach an event or set of events from an element
						remove: function( elem, types, handler, selector, mappedTypes ) {

							var elemData = jQuery.hasData( elem ) && jQuery._data( elem ),
								t, tns, type, origType, namespaces, origCount,
								j, events, special, handle, eventType, handleObj;

							if ( !elemData || !(events = elemData.events) ) {
								return;
							}

							// Once for each type.namespace in types; type may be omitted
							types = jQuery.trim( hoverHack( types || "" ) ).split(" ");
							for ( t = 0; t < types.length; t++ ) {
								tns = rtypenamespace.exec( types[t] ) || [];
								type = origType = tns[1];
								namespaces = tns[2];

								// Unbind all events (on this namespace, if provided) for the element
								if ( !type ) {
									for ( type in events ) {
										jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
									}
									continue;
								}

								special = jQuery.event.special[ type ] || {};
								type = ( selector? special.delegateType : special.bindType ) || type;
								eventType = events[ type ] || [];
								origCount = eventType.length;
								namespaces = namespaces ? new RegExp("(^|\\.)" + namespaces.split(".").sort().join("\\.(?:.*\\.)?") + "(\\.|$)") : null;

								// Remove matching events
								for ( j = 0; j < eventType.length; j++ ) {
									handleObj = eventType[ j ];

									if ( ( mappedTypes || origType === handleObj.origType ) &&
										 ( !handler || handler.guid === handleObj.guid ) &&
										 ( !namespaces || namespaces.test( handleObj.namespace ) ) &&
										 ( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
										eventType.splice( j--, 1 );

										if ( handleObj.selector ) {
											eventType.delegateCount--;
										}
										if ( special.remove ) {
											special.remove.call( elem, handleObj );
										}
									}
								}

								// Remove generic event handler if we removed something and no more handlers exist
								// (avoids potential for endless recursion during removal of special event handlers)
								if ( eventType.length === 0 && origCount !== eventType.length ) {
									if ( !special.teardown || special.teardown.call( elem, namespaces ) === false ) {
										jQuery.removeEvent( elem, type, elemData.handle );
									}

									delete events[ type ];
								}
							}

							// Remove the expando if it's no longer used
							if ( jQuery.isEmptyObject( events ) ) {
								handle = elemData.handle;
								if ( handle ) {
									handle.elem = null;
								}

								// removeData also checks for emptiness and clears the expando if empty
								// so use it instead of delete
								jQuery.removeData( elem, [ "events", "handle" ], true );
							}
						},

						// Events that are safe to short-circuit if no handlers are attached.
						// Native DOM events should not be added, they may have inline handlers.
						customEvent: {
							"getData": true,
							"setData": true,
							"changeData": true
						},

						trigger: function( event, data, elem, onlyHandlers ) {
							// Don't do events on text and comment nodes
							if ( elem && (elem.nodeType === 3 || elem.nodeType === 8) ) {
								return;
							}

							// Event object or event type
							var type = event.type || event,
								namespaces = [],
								cache, exclusive, i, cur, old, ontype, special, handle, eventPath, bubbleType;

							// focus/blur morphs to focusin/out; ensure we're not firing them right now
							if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
								return;
							}

							if ( type.indexOf( "!" ) >= 0 ) {
								// Exclusive events trigger only for the exact event (no namespaces)
								type = type.slice(0, -1);
								exclusive = true;
							}

							if ( type.indexOf( "." ) >= 0 ) {
								// Namespaced trigger; create a regexp to match event type in handle()
								namespaces = type.split(".");
								type = namespaces.shift();
								namespaces.sort();
							}

							if ( (!elem || jQuery.event.customEvent[ type ]) && !jQuery.event.global[ type ] ) {
								// No jQuery handlers for this event type, and it can't have inline handlers
								return;
							}

							// Caller can pass in an Event, Object, or just an event type string
							event = typeof event === "object" ?
								// jQuery.Event object
								event[ jQuery.expando ] ? event :
								// Object literal
								new jQuery.Event( type, event ) :
								// Just the event type (string)
								new jQuery.Event( type );

							event.type = type;
							event.isTrigger = true;
							event.exclusive = exclusive;
							event.namespace = namespaces.join( "." );
							event.namespace_re = event.namespace? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.)?") + "(\\.|$)") : null;
							ontype = type.indexOf( ":" ) < 0 ? "on" + type : "";

							// Handle a global trigger
							if ( !elem ) {

								// TODO: Stop taunting the data cache; remove global events and always attach to document
								cache = jQuery.cache;
								for ( i in cache ) {
									if ( cache[ i ].events && cache[ i ].events[ type ] ) {
										jQuery.event.trigger( event, data, cache[ i ].handle.elem, true );
									}
								}
								return;
							}

							// Clean up the event in case it is being reused
							event.result = undefined;
							if ( !event.target ) {
								event.target = elem;
							}

							// Clone any incoming data and prepend the event, creating the handler arg list
							data = data != null ? jQuery.makeArray( data ) : [];
							data.unshift( event );

							// Allow special events to draw outside the lines
							special = jQuery.event.special[ type ] || {};
							if ( special.trigger && special.trigger.apply( elem, data ) === false ) {
								return;
							}

							// Determine event propagation path in advance, per W3C events spec (#9951)
							// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
							eventPath = [[ elem, special.bindType || type ]];
							if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

								bubbleType = special.delegateType || type;
								cur = rfocusMorph.test( bubbleType + type ) ? elem : elem.parentNode;
								old = null;
								for ( ; cur; cur = cur.parentNode ) {
									eventPath.push([ cur, bubbleType ]);
									old = cur;
								}

								// Only add window if we got to document (e.g., not plain obj or detached DOM)
								if ( old && old === elem.ownerDocument ) {
									eventPath.push([ old.defaultView || old.parentWindow || window, bubbleType ]);
								}
							}

							// Fire handlers on the event path
							for ( i = 0; i < eventPath.length && !event.isPropagationStopped(); i++ ) {

								cur = eventPath[i][0];
								event.type = eventPath[i][1];

								handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] && jQuery._data( cur, "handle" );
								if ( handle ) {
									handle.apply( cur, data );
								}
								// Note that this is a bare JS function and not a jQuery handler
								handle = ontype && cur[ ontype ];
								if ( handle && jQuery.acceptData( cur ) && handle.apply( cur, data ) === false ) {
									event.preventDefault();
								}
							}
							event.type = type;

							// If nobody prevented the default action, do it now
							if ( !onlyHandlers && !event.isDefaultPrevented() ) {

								if ( (!special._default || special._default.apply( elem.ownerDocument, data ) === false) &&
									!(type === "click" && jQuery.nodeName( elem, "a" )) && jQuery.acceptData( elem ) ) {

									// Call a native DOM method on the target with the same name name as the event.
									// Can't use an .isFunction() check here because IE6/7 fails that test.
									// Don't do default actions on window, that's where global variables be (#6170)
									// IE<9 dies on focus/blur to hidden element (#1486)
									if ( ontype && elem[ type ] && ((type !== "focus" && type !== "blur") || event.target.offsetWidth !== 0) && !jQuery.isWindow( elem ) ) {

										// Don't re-trigger an onFOO event when we call its FOO() method
										old = elem[ ontype ];

										if ( old ) {
											elem[ ontype ] = null;
										}

										// Prevent re-triggering of the same event, since we already bubbled it above
										jQuery.event.triggered = type;
										elem[ type ]();
										jQuery.event.triggered = undefined;

										if ( old ) {
											elem[ ontype ] = old;
										}
									}
								}
							}

							return event.result;
						},

						dispatch: function( event ) {

							// Make a writable jQuery.Event from the native event object
							event = jQuery.event.fix( event || window.event );

							var handlers = ( (jQuery._data( this, "events" ) || {} )[ event.type ] || []),
								delegateCount = handlers.delegateCount,
								args = [].slice.call( arguments, 0 ),
								run_all = !event.exclusive && !event.namespace,
								special = jQuery.event.special[ event.type ] || {},
								handlerQueue = [],
								i, j, cur, jqcur, ret, selMatch, matched, matches, handleObj, sel, related;

							// Use the fix-ed jQuery.Event rather than the (read-only) native event
							args[0] = event;
							event.delegateTarget = this;

							// Call the preDispatch hook for the mapped type, and let it bail if desired
							if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
								return;
							}

							// Determine handlers that should run if there are delegated events
							// Avoid non-left-click bubbling in Firefox (#3861)
							if ( delegateCount && !(event.button && event.type === "click") ) {

								// Pregenerate a single jQuery object for reuse with .is()
								jqcur = jQuery(this);
								jqcur.context = this.ownerDocument || this;

								for ( cur = event.target; cur != this; cur = cur.parentNode || this ) {

									// Don't process events on disabled elements (#6911, #8165)
									if ( cur.disabled !== true ) {
										selMatch = {};
										matches = [];
										jqcur[0] = cur;
										for ( i = 0; i < delegateCount; i++ ) {
											handleObj = handlers[ i ];
											sel = handleObj.selector;

											if ( selMatch[ sel ] === undefined ) {
												selMatch[ sel ] = (
													handleObj.quick ? quickIs( cur, handleObj.quick ) : jqcur.is( sel )
												);
											}
											if ( selMatch[ sel ] ) {
												matches.push( handleObj );
											}
										}
										if ( matches.length ) {
											handlerQueue.push({ elem: cur, matches: matches });
										}
									}
								}
							}

							// Add the remaining (directly-bound) handlers
							if ( handlers.length > delegateCount ) {
								handlerQueue.push({ elem: this, matches: handlers.slice( delegateCount ) });
							}

							// Run delegates first; they may want to stop propagation beneath us
							for ( i = 0; i < handlerQueue.length && !event.isPropagationStopped(); i++ ) {
								matched = handlerQueue[ i ];
								event.currentTarget = matched.elem;

								for ( j = 0; j < matched.matches.length && !event.isImmediatePropagationStopped(); j++ ) {
									handleObj = matched.matches[ j ];

									// Triggered event must either 1) be non-exclusive and have no namespace, or
									// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
									if ( run_all || (!event.namespace && !handleObj.namespace) || event.namespace_re && event.namespace_re.test( handleObj.namespace ) ) {

										event.data = handleObj.data;
										event.handleObj = handleObj;

										ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
												.apply( matched.elem, args );

										if ( ret !== undefined ) {
											event.result = ret;
											if ( ret === false ) {
												event.preventDefault();
												event.stopPropagation();
											}
										}
									}
								}
							}

							// Call the postDispatch hook for the mapped type
							if ( special.postDispatch ) {
								special.postDispatch.call( this, event );
							}

							return event.result;
						},

						// Includes some event props shared by KeyEvent and MouseEvent
						// *** attrChange attrName relatedNode srcElement  are not normalized, non-W3C, deprecated, will be removed in 1.8 ***
						props: "attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

						fixHooks: {},

						keyHooks: {
							props: "char charCode key keyCode".split(" "),
							filter: function( event, original ) {

								// Add which for key events
								if ( event.which == null ) {
									event.which = original.charCode != null ? original.charCode : original.keyCode;
								}

								return event;
							}
						},

						mouseHooks: {
							props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
							filter: function( event, original ) {
								var eventDoc, doc, body,
									button = original.button,
									fromElement = original.fromElement;

								// Calculate pageX/Y if missing and clientX/Y available
								if ( event.pageX == null && original.clientX != null ) {
									eventDoc = event.target.ownerDocument || document;
									doc = eventDoc.documentElement;
									body = eventDoc.body;

									event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
									event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
								}

								// Add relatedTarget, if necessary
								if ( !event.relatedTarget && fromElement ) {
									event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
								}

								// Add which for click: 1 === left; 2 === middle; 3 === right
								// Note: button is not normalized, so don't use it
								if ( !event.which && button !== undefined ) {
									event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
								}

								return event;
							}
						},

						fix: function( event ) {
							if ( event[ jQuery.expando ] ) {
								return event;
							}

							// Create a writable copy of the event object and normalize some properties
							var i, prop,
								originalEvent = event,
								fixHook = jQuery.event.fixHooks[ event.type ] || {},
								copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

							event = jQuery.Event( originalEvent );

							for ( i = copy.length; i; ) {
								prop = copy[ --i ];
								event[ prop ] = originalEvent[ prop ];
							}

							// Fix target property, if necessary (#1925, IE 6/7/8 & Safari2)
							if ( !event.target ) {
								event.target = originalEvent.srcElement || document;
							}

							// Target should not be a text node (#504, Safari)
							if ( event.target.nodeType === 3 ) {
								event.target = event.target.parentNode;
							}

							// For mouse/key events; add metaKey if it's not there (#3368, IE6/7/8)
							if ( event.metaKey === undefined ) {
								event.metaKey = event.ctrlKey;
							}

							return fixHook.filter? fixHook.filter( event, originalEvent ) : event;
						},

						special: {
							ready: {
								// Make sure the ready event is setup
								setup: jQuery.bindReady
							},

							load: {
								// Prevent triggered image.load events from bubbling to window.load
								noBubble: true
							},

							focus: {
								delegateType: "focusin"
							},
							blur: {
								delegateType: "focusout"
							},

							beforeunload: {
								setup: function( data, namespaces, eventHandle ) {
									// We only want to do this special case on windows
									if ( jQuery.isWindow( this ) ) {
										this.onbeforeunload = eventHandle;
									}
								},

								teardown: function( namespaces, eventHandle ) {
									if ( this.onbeforeunload === eventHandle ) {
										this.onbeforeunload = null;
									}
								}
							}
						},

						simulate: function( type, elem, event, bubble ) {
							// Piggyback on a donor event to simulate a different one.
							// Fake originalEvent to avoid donor's stopPropagation, but if the
							// simulated event prevents default then we do the same on the donor.
							var e = jQuery.extend(
								new jQuery.Event(),
								event,
								{ type: type,
									isSimulated: true,
									originalEvent: {}
								}
							);
							if ( bubble ) {
								jQuery.event.trigger( e, null, elem );
							} else {
								jQuery.event.dispatch.call( elem, e );
							}
							if ( e.isDefaultPrevented() ) {
								event.preventDefault();
							}
						}
					};

					// Some plugins are using, but it's undocumented/deprecated and will be removed.
					// The 1.7 special event interface should provide all the hooks needed now.
					jQuery.event.handle = jQuery.event.dispatch;

					jQuery.removeEvent = document.removeEventListener ?
						function( elem, type, handle ) {
							if ( elem.removeEventListener ) {
								elem.removeEventListener( type, handle, false );
							}
						} :
						function( elem, type, handle ) {
							if ( elem.detachEvent ) {
								elem.detachEvent( "on" + type, handle );
							}
						};

					jQuery.Event = function( src, props ) {
						// Allow instantiation without the 'new' keyword
						if ( !(this instanceof jQuery.Event) ) {
							return new jQuery.Event( src, props );
						}

						// Event object
						if ( src && src.type ) {
							this.originalEvent = src;
							this.type = src.type;

							// Events bubbling up the document may have been marked as prevented
							// by a handler lower down the tree; reflect the correct value.
							this.isDefaultPrevented = ( src.defaultPrevented || src.returnValue === false ||
								src.getPreventDefault && src.getPreventDefault() ) ? returnTrue : returnFalse;

						// Event type
						} else {
							this.type = src;
						}

						// Put explicitly provided properties onto the event object
						if ( props ) {
							jQuery.extend( this, props );
						}

						// Create a timestamp if incoming event doesn't have one
						this.timeStamp = src && src.timeStamp || jQuery.now();

						// Mark it as fixed
						this[ jQuery.expando ] = true;
					};

					function returnFalse() {
						return false;
					}
					function returnTrue() {
						return true;
					}

					// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
					// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
					jQuery.Event.prototype = {
						preventDefault: function() {
							this.isDefaultPrevented = returnTrue;

							var e = this.originalEvent;
							if ( !e ) {
								return;
							}

							// if preventDefault exists run it on the original event
							if ( e.preventDefault ) {
								e.preventDefault();

							// otherwise set the returnValue property of the original event to false (IE)
							} else {
								e.returnValue = false;
							}
						},
						stopPropagation: function() {
							this.isPropagationStopped = returnTrue;

							var e = this.originalEvent;
							if ( !e ) {
								return;
							}
							// if stopPropagation exists run it on the original event
							if ( e.stopPropagation ) {
								e.stopPropagation();
							}
							// otherwise set the cancelBubble property of the original event to true (IE)
							e.cancelBubble = true;
						},
						stopImmediatePropagation: function() {
							this.isImmediatePropagationStopped = returnTrue;
							this.stopPropagation();
						},
						isDefaultPrevented: returnFalse,
						isPropagationStopped: returnFalse,
						isImmediatePropagationStopped: returnFalse
					};

					// Create mouseenter/leave events using mouseover/out and event-time checks
					jQuery.each({
						mouseenter: "mouseover",
						mouseleave: "mouseout"
					}, function( orig, fix ) {
						jQuery.event.special[ orig ] = {
							delegateType: fix,
							bindType: fix,

							handle: function( event ) {
								var target = this,
									related = event.relatedTarget,
									handleObj = event.handleObj,
									selector = handleObj.selector,
									ret;

								// For mousenter/leave call the handler if related is outside the target.
								// NB: No relatedTarget if the mouse left/entered the browser window
								if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
									event.type = handleObj.origType;
									ret = handleObj.handler.apply( this, arguments );
									event.type = fix;
								}
								return ret;
							}
						};
					});

					// IE submit delegation
					if ( !jQuery.support.submitBubbles ) {

						jQuery.event.special.submit = {
							setup: function() {
								// Only need this for delegated form submit events
								if ( jQuery.nodeName( this, "form" ) ) {
									return false;
								}

								// Lazy-add a submit handler when a descendant form may potentially be submitted
								jQuery.event.add( this, "click._submit keypress._submit", function( e ) {
									// Node name check avoids a VML-related crash in IE (#9807)
									var elem = e.target,
										form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ? elem.form : undefined;
									if ( form && !form._submit_attached ) {
										jQuery.event.add( form, "submit._submit", function( event ) {
											event._submit_bubble = true;
										});
										form._submit_attached = true;
									}
								});
								// return undefined since we don't need an event listener
							},
							
							postDispatch: function( event ) {
								// If form was submitted by the user, bubble the event up the tree
								if ( event._submit_bubble ) {
									delete event._submit_bubble;
									if ( this.parentNode && !event.isTrigger ) {
										jQuery.event.simulate( "submit", this.parentNode, event, true );
									}
								}
							},

							teardown: function() {
								// Only need this for delegated form submit events
								if ( jQuery.nodeName( this, "form" ) ) {
									return false;
								}

								// Remove delegated handlers; cleanData eventually reaps submit handlers attached above
								jQuery.event.remove( this, "._submit" );
							}
						};
					}

					// IE change delegation and checkbox/radio fix
					if ( !jQuery.support.changeBubbles ) {

						jQuery.event.special.change = {

							setup: function() {

								if ( rformElems.test( this.nodeName ) ) {
									// IE doesn't fire change on a check/radio until blur; trigger it on click
									// after a propertychange. Eat the blur-change in special.change.handle.
									// This still fires onchange a second time for check/radio after blur.
									if ( this.type === "checkbox" || this.type === "radio" ) {
										jQuery.event.add( this, "propertychange._change", function( event ) {
											if ( event.originalEvent.propertyName === "checked" ) {
												this._just_changed = true;
											}
										});
										jQuery.event.add( this, "click._change", function( event ) {
											if ( this._just_changed && !event.isTrigger ) {
												this._just_changed = false;
												jQuery.event.simulate( "change", this, event, true );
											}
										});
									}
									return false;
								}
								// Delegated event; lazy-add a change handler on descendant inputs
								jQuery.event.add( this, "beforeactivate._change", function( e ) {
									var elem = e.target;

									if ( rformElems.test( elem.nodeName ) && !elem._change_attached ) {
										jQuery.event.add( elem, "change._change", function( event ) {
											if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {
												jQuery.event.simulate( "change", this.parentNode, event, true );
											}
										});
										elem._change_attached = true;
									}
								});
							},

							handle: function( event ) {
								var elem = event.target;

								// Swallow native change events from checkbox/radio, we already triggered them above
								if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox") ) {
									return event.handleObj.handler.apply( this, arguments );
								}
							},

							teardown: function() {
								jQuery.event.remove( this, "._change" );

								return rformElems.test( this.nodeName );
							}
						};
					}

					// Create "bubbling" focus and blur events
					if ( !jQuery.support.focusinBubbles ) {
						jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

							// Attach a single capturing handler while someone wants focusin/focusout
							var attaches = 0,
								handler = function( event ) {
									jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
								};

							jQuery.event.special[ fix ] = {
								setup: function() {
									if ( attaches++ === 0 ) {
										document.addEventListener( orig, handler, true );
									}
								},
								teardown: function() {
									if ( --attaches === 0 ) {
										document.removeEventListener( orig, handler, true );
									}
								}
							};
						});
					}

					jQuery.fn.extend({

						on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
							var origFn, type;

							// Types can be a map of types/handlers
							if ( typeof types === "object" ) {
								// ( types-Object, selector, data )
								if ( typeof selector !== "string" ) { // && selector != null
									// ( types-Object, data )
									data = data || selector;
									selector = undefined;
								}
								for ( type in types ) {
									this.on( type, selector, data, types[ type ], one );
								}
								return this;
							}

							if ( data == null && fn == null ) {
								// ( types, fn )
								fn = selector;
								data = selector = undefined;
							} else if ( fn == null ) {
								if ( typeof selector === "string" ) {
									// ( types, selector, fn )
									fn = data;
									data = undefined;
								} else {
									// ( types, data, fn )
									fn = data;
									data = selector;
									selector = undefined;
								}
							}
							if ( fn === false ) {
								fn = returnFalse;
							} else if ( !fn ) {
								return this;
							}

							if ( one === 1 ) {
								origFn = fn;
								fn = function( event ) {
									// Can use an empty set, since event contains the info
									jQuery().off( event );
									return origFn.apply( this, arguments );
								};
								// Use same guid so caller can remove using origFn
								fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
							}
							return this.each( function() {
								jQuery.event.add( this, types, fn, data, selector );
							});
						},
						one: function( types, selector, data, fn ) {
							return this.on( types, selector, data, fn, 1 );
						},
						off: function( types, selector, fn ) {
							if ( types && types.preventDefault && types.handleObj ) {
								// ( event )  dispatched jQuery.Event
								var handleObj = types.handleObj;
								jQuery( types.delegateTarget ).off(
									handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
									handleObj.selector,
									handleObj.handler
								);
								return this;
							}
							if ( typeof types === "object" ) {
								// ( types-object [, selector] )
								for ( var type in types ) {
									this.off( type, selector, types[ type ] );
								}
								return this;
							}
							if ( selector === false || typeof selector === "function" ) {
								// ( types [, fn] )
								fn = selector;
								selector = undefined;
							}
							if ( fn === false ) {
								fn = returnFalse;
							}
							return this.each(function() {
								jQuery.event.remove( this, types, fn, selector );
							});
						},

						bind: function( types, data, fn ) {
							return this.on( types, null, data, fn );
						},
						unbind: function( types, fn ) {
							return this.off( types, null, fn );
						},

						live: function( types, data, fn ) {
							jQuery( this.context ).on( types, this.selector, data, fn );
							return this;
						},
						die: function( types, fn ) {
							jQuery( this.context ).off( types, this.selector || "**", fn );
							return this;
						},

						delegate: function( selector, types, data, fn ) {
							return this.on( types, selector, data, fn );
						},
						undelegate: function( selector, types, fn ) {
							// ( namespace ) or ( selector, types [, fn] )
							return arguments.length == 1? this.off( selector, "**" ) : this.off( types, selector, fn );
						},

						trigger: function( type, data ) {
							return this.each(function() {
								jQuery.event.trigger( type, data, this );
							});
						},
						triggerHandler: function( type, data ) {
							if ( this[0] ) {
								return jQuery.event.trigger( type, data, this[0], true );
							}
						},

						toggle: function( fn ) {
							// Save reference to arguments for access in closure
							var args = arguments,
								guid = fn.guid || jQuery.guid++,
								i = 0,
								toggler = function( event ) {
									// Figure out which function to execute
									var lastToggle = ( jQuery._data( this, "lastToggle" + fn.guid ) || 0 ) % i;
									jQuery._data( this, "lastToggle" + fn.guid, lastToggle + 1 );

									// Make sure that clicks stop
									event.preventDefault();

									// and execute the function
									return args[ lastToggle ].apply( this, arguments ) || false;
								};

							// link all the functions, so any of them can unbind this click handler
							toggler.guid = guid;
							while ( i < args.length ) {
								args[ i++ ].guid = guid;
							}

							return this.click( toggler );
						},

						hover: function( fnOver, fnOut ) {
							return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
						}
					});

					jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
						"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
						"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

						// Handle event binding
						jQuery.fn[ name ] = function( data, fn ) {
							if ( fn == null ) {
								fn = data;
								data = null;
							}

							return arguments.length > 0 ?
								this.on( name, null, data, fn ) :
								this.trigger( name );
						};

						if ( jQuery.attrFn ) {
							jQuery.attrFn[ name ] = true;
						}

						if ( rkeyEvent.test( name ) ) {
							jQuery.event.fixHooks[ name ] = jQuery.event.keyHooks;
						}

						if ( rmouseEvent.test( name ) ) {
							jQuery.event.fixHooks[ name ] = jQuery.event.mouseHooks;
						}
					});



					/*!
					 * Sizzle CSS Selector Engine
					 *  Copyright 2011, The Dojo Foundation
					 *  Released under the MIT, BSD, and GPL Licenses.
					 *  More information: http://sizzlejs.com/
					 */
					(function(){

					var chunker = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,
						expando = "sizcache" + (Math.random() + '').replace('.', ''),
						done = 0,
						toString = Object.prototype.toString,
						hasDuplicate = false,
						baseHasDuplicate = true,
						rBackslash = /\\/g,
						rReturn = /\r\n/g,
						rNonWord = /\W/;

					// Here we check if the JavaScript engine is using some sort of
					// optimization where it does not always call our comparision
					// function. If that is the case, discard the hasDuplicate value.
					//   Thus far that includes Google Chrome.
					[0, 0].sort(function() {
						baseHasDuplicate = false;
						return 0;
					});

					var Sizzle = function( selector, context, results, seed ) {
						results = results || [];
						context = context || document;

						var origContext = context;

						if ( context.nodeType !== 1 && context.nodeType !== 9 ) {
							return [];
						}

						if ( !selector || typeof selector !== "string" ) {
							return results;
						}

						var m, set, checkSet, extra, ret, cur, pop, i,
							prune = true,
							contextXML = Sizzle.isXML( context ),
							parts = [],
							soFar = selector;

						// Reset the position of the chunker regexp (start from head)
						do {
							chunker.exec( "" );
							m = chunker.exec( soFar );

							if ( m ) {
								soFar = m[3];

								parts.push( m[1] );

								if ( m[2] ) {
									extra = m[3];
									break;
								}
							}
						} while ( m );

						if ( parts.length > 1 && origPOS.exec( selector ) ) {

							if ( parts.length === 2 && Expr.relative[ parts[0] ] ) {
								set = posProcess( parts[0] + parts[1], context, seed );

							} else {
								set = Expr.relative[ parts[0] ] ?
									[ context ] :
									Sizzle( parts.shift(), context );

								while ( parts.length ) {
									selector = parts.shift();

									if ( Expr.relative[ selector ] ) {
										selector += parts.shift();
									}

									set = posProcess( selector, set, seed );
								}
							}

						} else {
							// Take a shortcut and set the context if the root selector is an ID
							// (but not if it'll be faster if the inner selector is an ID)
							if ( !seed && parts.length > 1 && context.nodeType === 9 && !contextXML &&
									Expr.match.ID.test(parts[0]) && !Expr.match.ID.test(parts[parts.length - 1]) ) {

								ret = Sizzle.find( parts.shift(), context, contextXML );
								context = ret.expr ?
									Sizzle.filter( ret.expr, ret.set )[0] :
									ret.set[0];
							}

							if ( context ) {
								ret = seed ?
									{ expr: parts.pop(), set: makeArray(seed) } :
									Sizzle.find( parts.pop(), parts.length === 1 && (parts[0] === "~" || parts[0] === "+") && context.parentNode ? context.parentNode : context, contextXML );

								set = ret.expr ?
									Sizzle.filter( ret.expr, ret.set ) :
									ret.set;

								if ( parts.length > 0 ) {
									checkSet = makeArray( set );

								} else {
									prune = false;
								}

								while ( parts.length ) {
									cur = parts.pop();
									pop = cur;

									if ( !Expr.relative[ cur ] ) {
										cur = "";
									} else {
										pop = parts.pop();
									}

									if ( pop == null ) {
										pop = context;
									}

									Expr.relative[ cur ]( checkSet, pop, contextXML );
								}

							} else {
								checkSet = parts = [];
							}
						}

						if ( !checkSet ) {
							checkSet = set;
						}

						if ( !checkSet ) {
							Sizzle.error( cur || selector );
						}

						if ( toString.call(checkSet) === "[object Array]" ) {
							if ( !prune ) {
								results.push.apply( results, checkSet );

							} else if ( context && context.nodeType === 1 ) {
								for ( i = 0; checkSet[i] != null; i++ ) {
									if ( checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && Sizzle.contains(context, checkSet[i])) ) {
										results.push( set[i] );
									}
								}

							} else {
								for ( i = 0; checkSet[i] != null; i++ ) {
									if ( checkSet[i] && checkSet[i].nodeType === 1 ) {
										results.push( set[i] );
									}
								}
							}

						} else {
							makeArray( checkSet, results );
						}

						if ( extra ) {
							Sizzle( extra, origContext, results, seed );
							Sizzle.uniqueSort( results );
						}

						return results;
					};

					Sizzle.uniqueSort = function( results ) {
						if ( sortOrder ) {
							hasDuplicate = baseHasDuplicate;
							results.sort( sortOrder );

							if ( hasDuplicate ) {
								for ( var i = 1; i < results.length; i++ ) {
									if ( results[i] === results[ i - 1 ] ) {
										results.splice( i--, 1 );
									}
								}
							}
						}

						return results;
					};

					Sizzle.matches = function( expr, set ) {
						return Sizzle( expr, null, null, set );
					};

					Sizzle.matchesSelector = function( node, expr ) {
						return Sizzle( expr, null, null, [node] ).length > 0;
					};

					Sizzle.find = function( expr, context, isXML ) {
						var set, i, len, match, type, left;

						if ( !expr ) {
							return [];
						}

						for ( i = 0, len = Expr.order.length; i < len; i++ ) {
							type = Expr.order[i];

							if ( (match = Expr.leftMatch[ type ].exec( expr )) ) {
								left = match[1];
								match.splice( 1, 1 );

								if ( left.substr( left.length - 1 ) !== "\\" ) {
									match[1] = (match[1] || "").replace( rBackslash, "" );
									set = Expr.find[ type ]( match, context, isXML );

									if ( set != null ) {
										expr = expr.replace( Expr.match[ type ], "" );
										break;
									}
								}
							}
						}

						if ( !set ) {
							set = typeof context.getElementsByTagName !== "undefined" ?
								context.getElementsByTagName( "*" ) :
								[];
						}

						return { set: set, expr: expr };
					};

					Sizzle.filter = function( expr, set, inplace, not ) {
						var match, anyFound,
							type, found, item, filter, left,
							i, pass,
							old = expr,
							result = [],
							curLoop = set,
							isXMLFilter = set && set[0] && Sizzle.isXML( set[0] );

						while ( expr && set.length ) {
							for ( type in Expr.filter ) {
								if ( (match = Expr.leftMatch[ type ].exec( expr )) != null && match[2] ) {
									filter = Expr.filter[ type ];
									left = match[1];

									anyFound = false;

									match.splice(1,1);

									if ( left.substr( left.length - 1 ) === "\\" ) {
										continue;
									}

									if ( curLoop === result ) {
										result = [];
									}

									if ( Expr.preFilter[ type ] ) {
										match = Expr.preFilter[ type ]( match, curLoop, inplace, result, not, isXMLFilter );

										if ( !match ) {
											anyFound = found = true;

										} else if ( match === true ) {
											continue;
										}
									}

									if ( match ) {
										for ( i = 0; (item = curLoop[i]) != null; i++ ) {
											if ( item ) {
												found = filter( item, match, i, curLoop );
												pass = not ^ found;

												if ( inplace && found != null ) {
													if ( pass ) {
														anyFound = true;

													} else {
														curLoop[i] = false;
													}

												} else if ( pass ) {
													result.push( item );
													anyFound = true;
												}
											}
										}
									}

									if ( found !== undefined ) {
										if ( !inplace ) {
											curLoop = result;
										}

										expr = expr.replace( Expr.match[ type ], "" );

										if ( !anyFound ) {
											return [];
										}

										break;
									}
								}
							}

							// Improper expression
							if ( expr === old ) {
								if ( anyFound == null ) {
									Sizzle.error( expr );

								} else {
									break;
								}
							}

							old = expr;
						}

						return curLoop;
					};

					Sizzle.error = function( msg ) {
						throw new Error( "Syntax error, unrecognized expression: " + msg );
					};

					/**
					 * Utility function for retreiving the text value of an array of DOM nodes
					 * @param {Array|Element} elem
					 */
					var getText = Sizzle.getText = function( elem ) {
					    var i, node,
							nodeType = elem.nodeType,
							ret = "";

						if ( nodeType ) {
							if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
								// Use textContent || innerText for elements
								if ( typeof elem.textContent === 'string' ) {
									return elem.textContent;
								} else if ( typeof elem.innerText === 'string' ) {
									// Replace IE's carriage returns
									return elem.innerText.replace( rReturn, '' );
								} else {
									// Traverse it's children
									for ( elem = elem.firstChild; elem; elem = elem.nextSibling) {
										ret += getText( elem );
									}
								}
							} else if ( nodeType === 3 || nodeType === 4 ) {
								return elem.nodeValue;
							}
						} else {

							// If no nodeType, this is expected to be an array
							for ( i = 0; (node = elem[i]); i++ ) {
								// Do not traverse comment nodes
								if ( node.nodeType !== 8 ) {
									ret += getText( node );
								}
							}
						}
						return ret;
					};

					var Expr = Sizzle.selectors = {
						order: [ "ID", "NAME", "TAG" ],

						match: {
							ID: /#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
							CLASS: /\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
							NAME: /\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,
							ATTR: /\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(?:(['"])(.*?)\3|(#?(?:[\w\u00c0-\uFFFF\-]|\\.)*)|)|)\s*\]/,
							TAG: /^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,
							CHILD: /:(only|nth|last|first)-child(?:\(\s*(even|odd|(?:[+\-]?\d+|(?:[+\-]?\d*)?n\s*(?:[+\-]\s*\d+)?))\s*\))?/,
							POS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,
							PSEUDO: /:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/
						},

						leftMatch: {},

						attrMap: {
							"class": "className",
							"for": "htmlFor"
						},

						attrHandle: {
							href: function( elem ) {
								return elem.getAttribute( "href" );
							},
							type: function( elem ) {
								return elem.getAttribute( "type" );
							}
						},

						relative: {
							"+": function(checkSet, part){
								var isPartStr = typeof part === "string",
									isTag = isPartStr && !rNonWord.test( part ),
									isPartStrNotTag = isPartStr && !isTag;

								if ( isTag ) {
									part = part.toLowerCase();
								}

								for ( var i = 0, l = checkSet.length, elem; i < l; i++ ) {
									if ( (elem = checkSet[i]) ) {
										while ( (elem = elem.previousSibling) && elem.nodeType !== 1 ) {}

										checkSet[i] = isPartStrNotTag || elem && elem.nodeName.toLowerCase() === part ?
											elem || false :
											elem === part;
									}
								}

								if ( isPartStrNotTag ) {
									Sizzle.filter( part, checkSet, true );
								}
							},

							">": function( checkSet, part ) {
								var elem,
									isPartStr = typeof part === "string",
									i = 0,
									l = checkSet.length;

								if ( isPartStr && !rNonWord.test( part ) ) {
									part = part.toLowerCase();

									for ( ; i < l; i++ ) {
										elem = checkSet[i];

										if ( elem ) {
											var parent = elem.parentNode;
											checkSet[i] = parent.nodeName.toLowerCase() === part ? parent : false;
										}
									}

								} else {
									for ( ; i < l; i++ ) {
										elem = checkSet[i];

										if ( elem ) {
											checkSet[i] = isPartStr ?
												elem.parentNode :
												elem.parentNode === part;
										}
									}

									if ( isPartStr ) {
										Sizzle.filter( part, checkSet, true );
									}
								}
							},

							"": function(checkSet, part, isXML){
								var nodeCheck,
									doneName = done++,
									checkFn = dirCheck;

								if ( typeof part === "string" && !rNonWord.test( part ) ) {
									part = part.toLowerCase();
									nodeCheck = part;
									checkFn = dirNodeCheck;
								}

								checkFn( "parentNode", part, doneName, checkSet, nodeCheck, isXML );
							},

							"~": function( checkSet, part, isXML ) {
								var nodeCheck,
									doneName = done++,
									checkFn = dirCheck;

								if ( typeof part === "string" && !rNonWord.test( part ) ) {
									part = part.toLowerCase();
									nodeCheck = part;
									checkFn = dirNodeCheck;
								}

								checkFn( "previousSibling", part, doneName, checkSet, nodeCheck, isXML );
							}
						},

						find: {
							ID: function( match, context, isXML ) {
								if ( typeof context.getElementById !== "undefined" && !isXML ) {
									var m = context.getElementById(match[1]);
									// Check parentNode to catch when Blackberry 4.6 returns
									// nodes that are no longer in the document #6963
									return m && m.parentNode ? [m] : [];
								}
							},

							NAME: function( match, context ) {
								if ( typeof context.getElementsByName !== "undefined" ) {
									var ret = [],
										results = context.getElementsByName( match[1] );

									for ( var i = 0, l = results.length; i < l; i++ ) {
										if ( results[i].getAttribute("name") === match[1] ) {
											ret.push( results[i] );
										}
									}

									return ret.length === 0 ? null : ret;
								}
							},

							TAG: function( match, context ) {
								if ( typeof context.getElementsByTagName !== "undefined" ) {
									return context.getElementsByTagName( match[1] );
								}
							}
						},
						preFilter: {
							CLASS: function( match, curLoop, inplace, result, not, isXML ) {
								match = " " + match[1].replace( rBackslash, "" ) + " ";

								if ( isXML ) {
									return match;
								}

								for ( var i = 0, elem; (elem = curLoop[i]) != null; i++ ) {
									if ( elem ) {
										if ( not ^ (elem.className && (" " + elem.className + " ").replace(/[\t\n\r]/g, " ").indexOf(match) >= 0) ) {
											if ( !inplace ) {
												result.push( elem );
											}

										} else if ( inplace ) {
											curLoop[i] = false;
										}
									}
								}

								return false;
							},

							ID: function( match ) {
								return match[1].replace( rBackslash, "" );
							},

							TAG: function( match, curLoop ) {
								return match[1].replace( rBackslash, "" ).toLowerCase();
							},

							CHILD: function( match ) {
								if ( match[1] === "nth" ) {
									if ( !match[2] ) {
										Sizzle.error( match[0] );
									}

									match[2] = match[2].replace(/^\+|\s*/g, '');

									// parse equations like 'even', 'odd', '5', '2n', '3n+2', '4n-1', '-n+6'
									var test = /(-?)(\d*)(?:n([+\-]?\d*))?/.exec(
										match[2] === "even" && "2n" || match[2] === "odd" && "2n+1" ||
										!/\D/.test( match[2] ) && "0n+" + match[2] || match[2]);

									// calculate the numbers (first)n+(last) including if they are negative
									match[2] = (test[1] + (test[2] || 1)) - 0;
									match[3] = test[3] - 0;
								}
								else if ( match[2] ) {
									Sizzle.error( match[0] );
								}

								// TODO: Move to normal caching system
								match[0] = done++;

								return match;
							},

							ATTR: function( match, curLoop, inplace, result, not, isXML ) {
								var name = match[1] = match[1].replace( rBackslash, "" );

								if ( !isXML && Expr.attrMap[name] ) {
									match[1] = Expr.attrMap[name];
								}

								// Handle if an un-quoted value was used
								match[4] = ( match[4] || match[5] || "" ).replace( rBackslash, "" );

								if ( match[2] === "~=" ) {
									match[4] = " " + match[4] + " ";
								}

								return match;
							},

							PSEUDO: function( match, curLoop, inplace, result, not ) {
								if ( match[1] === "not" ) {
									// If we're dealing with a complex expression, or a simple one
									if ( ( chunker.exec(match[3]) || "" ).length > 1 || /^\w/.test(match[3]) ) {
										match[3] = Sizzle(match[3], null, null, curLoop);

									} else {
										var ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);

										if ( !inplace ) {
											result.push.apply( result, ret );
										}

										return false;
									}

								} else if ( Expr.match.POS.test( match[0] ) || Expr.match.CHILD.test( match[0] ) ) {
									return true;
								}

								return match;
							},

							POS: function( match ) {
								match.unshift( true );

								return match;
							}
						},

						filters: {
							enabled: function( elem ) {
								return elem.disabled === false && elem.type !== "hidden";
							},

							disabled: function( elem ) {
								return elem.disabled === true;
							},

							checked: function( elem ) {
								return elem.checked === true;
							},

							selected: function( elem ) {
								// Accessing this property makes selected-by-default
								// options in Safari work properly
								if ( elem.parentNode ) {
									elem.parentNode.selectedIndex;
								}

								return elem.selected === true;
							},

							parent: function( elem ) {
								return !!elem.firstChild;
							},

							empty: function( elem ) {
								return !elem.firstChild;
							},

							has: function( elem, i, match ) {
								return !!Sizzle( match[3], elem ).length;
							},

							header: function( elem ) {
								return (/h\d/i).test( elem.nodeName );
							},

							text: function( elem ) {
								var attr = elem.getAttribute( "type" ), type = elem.type;
								// IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc)
								// use getAttribute instead to test this case
								return elem.nodeName.toLowerCase() === "input" && "text" === type && ( attr === type || attr === null );
							},

							radio: function( elem ) {
								return elem.nodeName.toLowerCase() === "input" && "radio" === elem.type;
							},

							checkbox: function( elem ) {
								return elem.nodeName.toLowerCase() === "input" && "checkbox" === elem.type;
							},

							file: function( elem ) {
								return elem.nodeName.toLowerCase() === "input" && "file" === elem.type;
							},

							password: function( elem ) {
								return elem.nodeName.toLowerCase() === "input" && "password" === elem.type;
							},

							submit: function( elem ) {
								var name = elem.nodeName.toLowerCase();
								return (name === "input" || name === "button") && "submit" === elem.type;
							},

							image: function( elem ) {
								return elem.nodeName.toLowerCase() === "input" && "image" === elem.type;
							},

							reset: function( elem ) {
								var name = elem.nodeName.toLowerCase();
								return (name === "input" || name === "button") && "reset" === elem.type;
							},

							button: function( elem ) {
								var name = elem.nodeName.toLowerCase();
								return name === "input" && "button" === elem.type || name === "button";
							},

							input: function( elem ) {
								return (/input|select|textarea|button/i).test( elem.nodeName );
							},

							focus: function( elem ) {
								return elem === elem.ownerDocument.activeElement;
							}
						},
						setFilters: {
							first: function( elem, i ) {
								return i === 0;
							},

							last: function( elem, i, match, array ) {
								return i === array.length - 1;
							},

							even: function( elem, i ) {
								return i % 2 === 0;
							},

							odd: function( elem, i ) {
								return i % 2 === 1;
							},

							lt: function( elem, i, match ) {
								return i < match[3] - 0;
							},

							gt: function( elem, i, match ) {
								return i > match[3] - 0;
							},

							nth: function( elem, i, match ) {
								return match[3] - 0 === i;
							},

							eq: function( elem, i, match ) {
								return match[3] - 0 === i;
							}
						},
						filter: {
							PSEUDO: function( elem, match, i, array ) {
								var name = match[1],
									filter = Expr.filters[ name ];

								if ( filter ) {
									return filter( elem, i, match, array );

								} else if ( name === "contains" ) {
									return (elem.textContent || elem.innerText || getText([ elem ]) || "").indexOf(match[3]) >= 0;

								} else if ( name === "not" ) {
									var not = match[3];

									for ( var j = 0, l = not.length; j < l; j++ ) {
										if ( not[j] === elem ) {
											return false;
										}
									}

									return true;

								} else {
									Sizzle.error( name );
								}
							},

							CHILD: function( elem, match ) {
								var first, last,
									doneName, parent, cache,
									count, diff,
									type = match[1],
									node = elem;

								switch ( type ) {
									case "only":
									case "first":
										while ( (node = node.previousSibling) ) {
											if ( node.nodeType === 1 ) {
												return false;
											}
										}

										if ( type === "first" ) {
											return true;
										}

										node = elem;

										/* falls through */
									case "last":
										while ( (node = node.nextSibling) ) {
											if ( node.nodeType === 1 ) {
												return false;
											}
										}

										return true;

									case "nth":
										first = match[2];
										last = match[3];

										if ( first === 1 && last === 0 ) {
											return true;
										}

										doneName = match[0];
										parent = elem.parentNode;

										if ( parent && (parent[ expando ] !== doneName || !elem.nodeIndex) ) {
											count = 0;

											for ( node = parent.firstChild; node; node = node.nextSibling ) {
												if ( node.nodeType === 1 ) {
													node.nodeIndex = ++count;
												}
											}

											parent[ expando ] = doneName;
										}

										diff = elem.nodeIndex - last;

										if ( first === 0 ) {
											return diff === 0;

										} else {
											return ( diff % first === 0 && diff / first >= 0 );
										}
								}
							},

							ID: function( elem, match ) {
								return elem.nodeType === 1 && elem.getAttribute("id") === match;
							},

							TAG: function( elem, match ) {
								return (match === "*" && elem.nodeType === 1) || !!elem.nodeName && elem.nodeName.toLowerCase() === match;
							},

							CLASS: function( elem, match ) {
								return (" " + (elem.className || elem.getAttribute("class")) + " ")
									.indexOf( match ) > -1;
							},

							ATTR: function( elem, match ) {
								var name = match[1],
									result = Sizzle.attr ?
										Sizzle.attr( elem, name ) :
										Expr.attrHandle[ name ] ?
										Expr.attrHandle[ name ]( elem ) :
										elem[ name ] != null ?
											elem[ name ] :
											elem.getAttribute( name ),
									value = result + "",
									type = match[2],
									check = match[4];

								return result == null ?
									type === "!=" :
									!type && Sizzle.attr ?
									result != null :
									type === "=" ?
									value === check :
									type === "*=" ?
									value.indexOf(check) >= 0 :
									type === "~=" ?
									(" " + value + " ").indexOf(check) >= 0 :
									!check ?
									value && result !== false :
									type === "!=" ?
									value !== check :
									type === "^=" ?
									value.indexOf(check) === 0 :
									type === "$=" ?
									value.substr(value.length - check.length) === check :
									type === "|=" ?
									value === check || value.substr(0, check.length + 1) === check + "-" :
									false;
							},

							POS: function( elem, match, i, array ) {
								var name = match[2],
									filter = Expr.setFilters[ name ];

								if ( filter ) {
									return filter( elem, i, match, array );
								}
							}
						}
					};

					var origPOS = Expr.match.POS,
						fescape = function(all, num){
							return "\\" + (num - 0 + 1);
						};

					for ( var type in Expr.match ) {
						Expr.match[ type ] = new RegExp( Expr.match[ type ].source + (/(?![^\[]*\])(?![^\(]*\))/.source) );
						Expr.leftMatch[ type ] = new RegExp( /(^(?:.|\r|\n)*?)/.source + Expr.match[ type ].source.replace(/\\(\d+)/g, fescape) );
					}
					// Expose origPOS
					// "global" as in regardless of relation to brackets/parens
					Expr.match.globalPOS = origPOS;

					var makeArray = function( array, results ) {
						array = Array.prototype.slice.call( array, 0 );

						if ( results ) {
							results.push.apply( results, array );
							return results;
						}

						return array;
					};

					// Perform a simple check to determine if the browser is capable of
					// converting a NodeList to an array using builtin methods.
					// Also verifies that the returned array holds DOM nodes
					// (which is not the case in the Blackberry browser)
					try {
						Array.prototype.slice.call( document.documentElement.childNodes, 0 )[0].nodeType;

					// Provide a fallback method if it does not work
					} catch( e ) {
						makeArray = function( array, results ) {
							var i = 0,
								ret = results || [];

							if ( toString.call(array) === "[object Array]" ) {
								Array.prototype.push.apply( ret, array );

							} else {
								if ( typeof array.length === "number" ) {
									for ( var l = array.length; i < l; i++ ) {
										ret.push( array[i] );
									}

								} else {
									for ( ; array[i]; i++ ) {
										ret.push( array[i] );
									}
								}
							}

							return ret;
						};
					}

					var sortOrder, siblingCheck;

					if ( document.documentElement.compareDocumentPosition ) {
						sortOrder = function( a, b ) {
							if ( a === b ) {
								hasDuplicate = true;
								return 0;
							}

							if ( !a.compareDocumentPosition || !b.compareDocumentPosition ) {
								return a.compareDocumentPosition ? -1 : 1;
							}

							return a.compareDocumentPosition(b) & 4 ? -1 : 1;
						};

					} else {
						sortOrder = function( a, b ) {
							// The nodes are identical, we can exit early
							if ( a === b ) {
								hasDuplicate = true;
								return 0;

							// Fallback to using sourceIndex (in IE) if it's available on both nodes
							} else if ( a.sourceIndex && b.sourceIndex ) {
								return a.sourceIndex - b.sourceIndex;
							}

							var al, bl,
								ap = [],
								bp = [],
								aup = a.parentNode,
								bup = b.parentNode,
								cur = aup;

							// If the nodes are siblings (or identical) we can do a quick check
							if ( aup === bup ) {
								return siblingCheck( a, b );

							// If no parents were found then the nodes are disconnected
							} else if ( !aup ) {
								return -1;

							} else if ( !bup ) {
								return 1;
							}

							// Otherwise they're somewhere else in the tree so we need
							// to build up a full list of the parentNodes for comparison
							while ( cur ) {
								ap.unshift( cur );
								cur = cur.parentNode;
							}

							cur = bup;

							while ( cur ) {
								bp.unshift( cur );
								cur = cur.parentNode;
							}

							al = ap.length;
							bl = bp.length;

							// Start walking down the tree looking for a discrepancy
							for ( var i = 0; i < al && i < bl; i++ ) {
								if ( ap[i] !== bp[i] ) {
									return siblingCheck( ap[i], bp[i] );
								}
							}

							// We ended someplace up the tree so do a sibling check
							return i === al ?
								siblingCheck( a, bp[i], -1 ) :
								siblingCheck( ap[i], b, 1 );
						};

						siblingCheck = function( a, b, ret ) {
							if ( a === b ) {
								return ret;
							}

							var cur = a.nextSibling;

							while ( cur ) {
								if ( cur === b ) {
									return -1;
								}

								cur = cur.nextSibling;
							}

							return 1;
						};
					}

					// Check to see if the browser returns elements by name when
					// querying by getElementById (and provide a workaround)
					(function(){
						// We're going to inject a fake input element with a specified name
						var form = document.createElement("div"),
							id = "script" + (new Date()).getTime(),
							root = document.documentElement;

						form.innerHTML = "<a name='" + id + "'/>";

						// Inject it into the root element, check its status, and remove it quickly
						root.insertBefore( form, root.firstChild );

						// The workaround has to do additional checks after a getElementById
						// Which slows things down for other browsers (hence the branching)
						if ( document.getElementById( id ) ) {
							Expr.find.ID = function( match, context, isXML ) {
								if ( typeof context.getElementById !== "undefined" && !isXML ) {
									var m = context.getElementById(match[1]);

									return m ?
										m.id === match[1] || typeof m.getAttributeNode !== "undefined" && m.getAttributeNode("id").nodeValue === match[1] ?
											[m] :
											undefined :
										[];
								}
							};

							Expr.filter.ID = function( elem, match ) {
								var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");

								return elem.nodeType === 1 && node && node.nodeValue === match;
							};
						}

						root.removeChild( form );

						// release memory in IE
						root = form = null;
					})();

					(function(){
						// Check to see if the browser returns only elements
						// when doing getElementsByTagName("*")

						// Create a fake element
						var div = document.createElement("div");
						div.appendChild( document.createComment("") );

						// Make sure no comments are found
						if ( div.getElementsByTagName("*").length > 0 ) {
							Expr.find.TAG = function( match, context ) {
								var results = context.getElementsByTagName( match[1] );

								// Filter out possible comments
								if ( match[1] === "*" ) {
									var tmp = [];

									for ( var i = 0; results[i]; i++ ) {
										if ( results[i].nodeType === 1 ) {
											tmp.push( results[i] );
										}
									}

									results = tmp;
								}

								return results;
							};
						}

						// Check to see if an attribute returns normalized href attributes
						div.innerHTML = "<a href='#'></a>";

						if ( div.firstChild && typeof div.firstChild.getAttribute !== "undefined" &&
								div.firstChild.getAttribute("href") !== "#" ) {

							Expr.attrHandle.href = function( elem ) {
								return elem.getAttribute( "href", 2 );
							};
						}

						// release memory in IE
						div = null;
					})();

					if ( document.querySelectorAll ) {
						(function(){
							var oldSizzle = Sizzle,
								div = document.createElement("div"),
								id = "__sizzle__";

							div.innerHTML = "<p class='TEST'></p>";

							// Safari can't handle uppercase or unicode characters when
							// in quirks mode.
							if ( div.querySelectorAll && div.querySelectorAll(".TEST").length === 0 ) {
								return;
							}

							Sizzle = function( query, context, extra, seed ) {
								context = context || document;

								// Only use querySelectorAll on non-XML documents
								// (ID selectors don't work in non-HTML documents)
								if ( !seed && !Sizzle.isXML(context) ) {
									// See if we find a selector to speed up
									var match = /^(\w+$)|^\.([\w\-]+$)|^#([\w\-]+$)/.exec( query );

									if ( match && (context.nodeType === 1 || context.nodeType === 9) ) {
										// Speed-up: Sizzle("TAG")
										if ( match[1] ) {
											return makeArray( context.getElementsByTagName( query ), extra );

										// Speed-up: Sizzle(".CLASS")
										} else if ( match[2] && Expr.find.CLASS && context.getElementsByClassName ) {
											return makeArray( context.getElementsByClassName( match[2] ), extra );
										}
									}

									if ( context.nodeType === 9 ) {
										// Speed-up: Sizzle("body")
										// The body element only exists once, optimize finding it
										if ( query === "body" && context.body ) {
											return makeArray( [ context.body ], extra );

										// Speed-up: Sizzle("#ID")
										} else if ( match && match[3] ) {
											var elem = context.getElementById( match[3] );

											// Check parentNode to catch when Blackberry 4.6 returns
											// nodes that are no longer in the document #6963
											if ( elem && elem.parentNode ) {
												// Handle the case where IE and Opera return items
												// by name instead of ID
												if ( elem.id === match[3] ) {
													return makeArray( [ elem ], extra );
												}

											} else {
												return makeArray( [], extra );
											}
										}

										try {
											return makeArray( context.querySelectorAll(query), extra );
										} catch(qsaError) {}

									// qSA works strangely on Element-rooted queries
									// We can work around this by specifying an extra ID on the root
									// and working up from there (Thanks to Andrew Dupont for the technique)
									// IE 8 doesn't work on object elements
									} else if ( context.nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
										var oldContext = context,
											old = context.getAttribute( "id" ),
											nid = old || id,
											hasParent = context.parentNode,
											relativeHierarchySelector = /^\s*[+~]/.test( query );

										if ( !old ) {
											context.setAttribute( "id", nid );
										} else {
											nid = nid.replace( /'/g, "\\//JQUERY_SOURCE" );
										}
										if ( relativeHierarchySelector && hasParent ) {
											context = context.parentNode;
										}

										try {
											if ( !relativeHierarchySelector || hasParent ) {
												return makeArray( context.querySelectorAll( "[id='" + nid + "'] " + query ), extra );
											}

										} catch(pseudoError) {
										} finally {
											if ( !old ) {
												oldContext.removeAttribute( "id" );
											}
										}
									}
								}

								return oldSizzle(query, context, extra, seed);
							};

							for ( var prop in oldSizzle ) {
								Sizzle[ prop ] = oldSizzle[ prop ];
							}

							// release memory in IE
							div = null;
						})();
					}

					(function(){
						var html = document.documentElement,
							matches = html.matchesSelector || html.mozMatchesSelector || html.webkitMatchesSelector || html.msMatchesSelector;

						if ( matches ) {
							// Check to see if it's possible to do matchesSelector
							// on a disconnected node (IE 9 fails this)
							var disconnectedMatch = !matches.call( document.createElement( "div" ), "div" ),
								pseudoWorks = false;

							try {
								// This should fail with an exception
								// Gecko does not error, returns false instead
								matches.call( document.documentElement, "[test!='']:sizzle" );

							} catch( pseudoError ) {
								pseudoWorks = true;
							}

							Sizzle.matchesSelector = function( node, expr ) {
								// Make sure that attribute selectors are quoted
								expr = expr.replace(/\=\s*([^'"\]]*)\s*\]/g, "='$1']");

								if ( !Sizzle.isXML( node ) ) {
									try {
										if ( pseudoWorks || !Expr.match.PSEUDO.test( expr ) && !/!=/.test( expr ) ) {
											var ret = matches.call( node, expr );

											// IE 9's matchesSelector returns false on disconnected nodes
											if ( ret || !disconnectedMatch ||
													// As well, disconnected nodes are said to be in a document
													// fragment in IE 9, so check for that
													node.document && node.document.nodeType !== 11 ) {
												return ret;
											}
										}
									} catch(e) {}
								}

								return Sizzle(expr, null, null, [node]).length > 0;
							};
						}
					})();

					(function(){
						var div = document.createElement("div");

						div.innerHTML = "<div class='test e'></div><div class='test'></div>";

						// Opera can't find a second classname (in 9.6)
						// Also, make sure that getElementsByClassName actually exists
						if ( !div.getElementsByClassName || div.getElementsByClassName("e").length === 0 ) {
							return;
						}

						// Safari caches class attributes, doesn't catch changes (in 3.2)
						div.lastChild.className = "e";

						if ( div.getElementsByClassName("e").length === 1 ) {
							return;
						}

						Expr.order.splice(1, 0, "CLASS");
						Expr.find.CLASS = function( match, context, isXML ) {
							if ( typeof context.getElementsByClassName !== "undefined" && !isXML ) {
								return context.getElementsByClassName(match[1]);
							}
						};

						// release memory in IE
						div = null;
					})();

					function dirNodeCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
						for ( var i = 0, l = checkSet.length; i < l; i++ ) {
							var elem = checkSet[i];

							if ( elem ) {
								var match = false;

								elem = elem[dir];

								while ( elem ) {
									if ( elem[ expando ] === doneName ) {
										match = checkSet[elem.sizset];
										break;
									}

									if ( elem.nodeType === 1 && !isXML ){
										elem[ expando ] = doneName;
										elem.sizset = i;
									}

									if ( elem.nodeName.toLowerCase() === cur ) {
										match = elem;
										break;
									}

									elem = elem[dir];
								}

								checkSet[i] = match;
							}
						}
					}

					function dirCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
						for ( var i = 0, l = checkSet.length; i < l; i++ ) {
							var elem = checkSet[i];

							if ( elem ) {
								var match = false;

								elem = elem[dir];

								while ( elem ) {
									if ( elem[ expando ] === doneName ) {
										match = checkSet[elem.sizset];
										break;
									}

									if ( elem.nodeType === 1 ) {
										if ( !isXML ) {
											elem[ expando ] = doneName;
											elem.sizset = i;
										}

										if ( typeof cur !== "string" ) {
											if ( elem === cur ) {
												match = true;
												break;
											}

										} else if ( Sizzle.filter( cur, [elem] ).length > 0 ) {
											match = elem;
											break;
										}
									}

									elem = elem[dir];
								}

								checkSet[i] = match;
							}
						}
					}

					if ( document.documentElement.contains ) {
						Sizzle.contains = function( a, b ) {
							return a !== b && (a.contains ? a.contains(b) : true);
						};

					} else if ( document.documentElement.compareDocumentPosition ) {
						Sizzle.contains = function( a, b ) {
							return !!(a.compareDocumentPosition(b) & 16);
						};

					} else {
						Sizzle.contains = function() {
							return false;
						};
					}

					Sizzle.isXML = function( elem ) {
						// documentElement is verified for cases where it doesn't yet exist
						// (such as loading iframes in IE - #4833)
						var documentElement = (elem ? elem.ownerDocument || elem : 0).documentElement;

						return documentElement ? documentElement.nodeName !== "HTML" : false;
					};

					var posProcess = function( selector, context, seed ) {
						var match,
							tmpSet = [],
							later = "",
							root = context.nodeType ? [context] : context;

						// Position selectors must be done after the filter
						// And so must :not(positional) so we move all PSEUDOs to the end
						while ( (match = Expr.match.PSEUDO.exec( selector )) ) {
							later += match[0];
							selector = selector.replace( Expr.match.PSEUDO, "" );
						}

						selector = Expr.relative[selector] ? selector + "*" : selector;

						for ( var i = 0, l = root.length; i < l; i++ ) {
							Sizzle( selector, root[i], tmpSet, seed );
						}

						return Sizzle.filter( later, tmpSet );
					};

					// EXPOSE
					// Override sizzle attribute retrieval
					Sizzle.attr = jQuery.attr;
					Sizzle.selectors.attrMap = {};
					jQuery.find = Sizzle;
					jQuery.expr = Sizzle.selectors;
					jQuery.expr[":"] = jQuery.expr.filters;
					jQuery.unique = Sizzle.uniqueSort;
					jQuery.text = Sizzle.getText;
					jQuery.isXMLDoc = Sizzle.isXML;
					jQuery.contains = Sizzle.contains;


					})();


					var runtil = /Until$/,
						rparentsprev = /^(?:parents|prevUntil|prevAll)/,
						// Note: This RegExp should be improved, or likely pulled from Sizzle
						rmultiselector = /,/,
						isSimple = /^.[^:#\[\.,]*$/,
						slice = Array.prototype.slice,
						POS = jQuery.expr.match.globalPOS,
						// methods guaranteed to produce a unique set when starting from a unique set
						guaranteedUnique = {
							children: true,
							contents: true,
							next: true,
							prev: true
						};

					jQuery.fn.extend({
						find: function( selector ) {
							var self = this,
								i, l;

							if ( typeof selector !== "string" ) {
								return jQuery( selector ).filter(function() {
									for ( i = 0, l = self.length; i < l; i++ ) {
										if ( jQuery.contains( self[ i ], this ) ) {
											return true;
										}
									}
								});
							}

							var ret = this.pushStack( "", "find", selector ),
								length, n, r;

							for ( i = 0, l = this.length; i < l; i++ ) {
								length = ret.length;
								jQuery.find( selector, this[i], ret );

								if ( i > 0 ) {
									// Make sure that the results are unique
									for ( n = length; n < ret.length; n++ ) {
										for ( r = 0; r < length; r++ ) {
											if ( ret[r] === ret[n] ) {
												ret.splice(n--, 1);
												break;
											}
										}
									}
								}
							}

							return ret;
						},

						has: function( target ) {
							var targets = jQuery( target );
							return this.filter(function() {
								for ( var i = 0, l = targets.length; i < l; i++ ) {
									if ( jQuery.contains( this, targets[i] ) ) {
										return true;
									}
								}
							});
						},

						not: function( selector ) {
							return this.pushStack( winnow(this, selector, false), "not", selector);
						},

						filter: function( selector ) {
							return this.pushStack( winnow(this, selector, true), "filter", selector );
						},

						is: function( selector ) {
							return !!selector && (
								typeof selector === "string" ?
									// If this is a positional selector, check membership in the returned set
									// so $("p:first").is("p:last") won't return true for a doc with two "p".
									POS.test( selector ) ?
										jQuery( selector, this.context ).index( this[0] ) >= 0 :
										jQuery.filter( selector, this ).length > 0 :
									this.filter( selector ).length > 0 );
						},

						closest: function( selectors, context ) {
							var ret = [], i, l, cur = this[0];

							// Array (deprecated as of jQuery 1.7)
							if ( jQuery.isArray( selectors ) ) {
								var level = 1;

								while ( cur && cur.ownerDocument && cur !== context ) {
									for ( i = 0; i < selectors.length; i++ ) {

										if ( jQuery( cur ).is( selectors[ i ] ) ) {
											ret.push({ selector: selectors[ i ], elem: cur, level: level });
										}
									}

									cur = cur.parentNode;
									level++;
								}

								return ret;
							}

							// String
							var pos = POS.test( selectors ) || typeof selectors !== "string" ?
									jQuery( selectors, context || this.context ) :
									0;

							for ( i = 0, l = this.length; i < l; i++ ) {
								cur = this[i];

								while ( cur ) {
									if ( pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors) ) {
										ret.push( cur );
										break;

									} else {
										cur = cur.parentNode;
										if ( !cur || !cur.ownerDocument || cur === context || cur.nodeType === 11 ) {
											break;
										}
									}
								}
							}

							ret = ret.length > 1 ? jQuery.unique( ret ) : ret;

							return this.pushStack( ret, "closest", selectors );
						},

						// Determine the position of an element within
						// the matched set of elements
						index: function( elem ) {

							// No argument, return index in parent
							if ( !elem ) {
								return ( this[0] && this[0].parentNode ) ? this.prevAll().length : -1;
							}

							// index in selector
							if ( typeof elem === "string" ) {
								return jQuery.inArray( this[0], jQuery( elem ) );
							}

							// Locate the position of the desired element
							return jQuery.inArray(
								// If it receives a jQuery object, the first element is used
								elem.jquery ? elem[0] : elem, this );
						},

						add: function( selector, context ) {
							var set = typeof selector === "string" ?
									jQuery( selector, context ) :
									jQuery.makeArray( selector && selector.nodeType ? [ selector ] : selector ),
								all = jQuery.merge( this.get(), set );

							return this.pushStack( isDisconnected( set[0] ) || isDisconnected( all[0] ) ?
								all :
								jQuery.unique( all ) );
						},

						andSelf: function() {
							return this.add( this.prevObject );
						}
					});

					// A painfully simple check to see if an element is disconnected
					// from a document (should be improved, where feasible).
					function isDisconnected( node ) {
						return !node || !node.parentNode || node.parentNode.nodeType === 11;
					}

					jQuery.each({
						parent: function( elem ) {
							var parent = elem.parentNode;
							return parent && parent.nodeType !== 11 ? parent : null;
						},
						parents: function( elem ) {
							return jQuery.dir( elem, "parentNode" );
						},
						parentsUntil: function( elem, i, until ) {
							return jQuery.dir( elem, "parentNode", until );
						},
						next: function( elem ) {
							return jQuery.nth( elem, 2, "nextSibling" );
						},
						prev: function( elem ) {
							return jQuery.nth( elem, 2, "previousSibling" );
						},
						nextAll: function( elem ) {
							return jQuery.dir( elem, "nextSibling" );
						},
						prevAll: function( elem ) {
							return jQuery.dir( elem, "previousSibling" );
						},
						nextUntil: function( elem, i, until ) {
							return jQuery.dir( elem, "nextSibling", until );
						},
						prevUntil: function( elem, i, until ) {
							return jQuery.dir( elem, "previousSibling", until );
						},
						siblings: function( elem ) {
							return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
						},
						children: function( elem ) {
							return jQuery.sibling( elem.firstChild );
						},
						contents: function( elem ) {
							return jQuery.nodeName( elem, "iframe" ) ?
								elem.contentDocument || elem.contentWindow.document :
								jQuery.makeArray( elem.childNodes );
						}
					}, function( name, fn ) {
						jQuery.fn[ name ] = function( until, selector ) {
							var ret = jQuery.map( this, fn, until );

							if ( !runtil.test( name ) ) {
								selector = until;
							}

							if ( selector && typeof selector === "string" ) {
								ret = jQuery.filter( selector, ret );
							}

							ret = this.length > 1 && !guaranteedUnique[ name ] ? jQuery.unique( ret ) : ret;

							if ( (this.length > 1 || rmultiselector.test( selector )) && rparentsprev.test( name ) ) {
								ret = ret.reverse();
							}

							return this.pushStack( ret, name, slice.call( arguments ).join(",") );
						};
					});

					jQuery.extend({
						filter: function( expr, elems, not ) {
							if ( not ) {
								expr = ":not(" + expr + ")";
							}

							return elems.length === 1 ?
								jQuery.find.matchesSelector(elems[0], expr) ? [ elems[0] ] : [] :
								jQuery.find.matches(expr, elems);
						},

						dir: function( elem, dir, until ) {
							var matched = [],
								cur = elem[ dir ];

							while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
								if ( cur.nodeType === 1 ) {
									matched.push( cur );
								}
								cur = cur[dir];
							}
							return matched;
						},

						nth: function( cur, result, dir, elem ) {
							result = result || 1;
							var num = 0;

							for ( ; cur; cur = cur[dir] ) {
								if ( cur.nodeType === 1 && ++num === result ) {
									break;
								}
							}

							return cur;
						},

						sibling: function( n, elem ) {
							var r = [];

							for ( ; n; n = n.nextSibling ) {
								if ( n.nodeType === 1 && n !== elem ) {
									r.push( n );
								}
							}

							return r;
						}
					});

					// Implement the identical functionality for filter and not
					function winnow( elements, qualifier, keep ) {

						// Can't pass null or undefined to indexOf in Firefox 4
						// Set to 0 to skip string check
						qualifier = qualifier || 0;

						if ( jQuery.isFunction( qualifier ) ) {
							return jQuery.grep(elements, function( elem, i ) {
								var retVal = !!qualifier.call( elem, i, elem );
								return retVal === keep;
							});

						} else if ( qualifier.nodeType ) {
							return jQuery.grep(elements, function( elem, i ) {
								return ( elem === qualifier ) === keep;
							});

						} else if ( typeof qualifier === "string" ) {
							var filtered = jQuery.grep(elements, function( elem ) {
								return elem.nodeType === 1;
							});

							if ( isSimple.test( qualifier ) ) {
								return jQuery.filter(qualifier, filtered, !keep);
							} else {
								qualifier = jQuery.filter( qualifier, filtered );
							}
						}

						return jQuery.grep(elements, function( elem, i ) {
							return ( jQuery.inArray( elem, qualifier ) >= 0 ) === keep;
						});
					}




					function createSafeFragment( document ) {
						var list = nodeNames.split( "|" ),
						safeFrag = document.createDocumentFragment();

						if ( safeFrag.createElement ) {
							while ( list.length ) {
								safeFrag.createElement(
									list.pop()
								);
							}
						}
						return safeFrag;
					}

					var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|" +
							"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
						rinlinejQuery = / jQuery\d+="(?:\d+|null)"/g,
						rleadingWhitespace = /^\s+/,
						rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,
						rtagName = /<([\w:]+)/,
						rtbody = /<tbody/i,
						rhtml = /<|&#?\w+;/,
						rnoInnerhtml = /<(?:script|style)/i,
						rnocache = /<(?:script|object|embed|option|style)/i,
						rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"),
						// checked="checked" or checked
						rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
						rscriptType = /\/(java|ecma)script/i,
						rcleanScript = /^\s*<!(?:\[CDATA\[|\-\-)/,
						wrapMap = {
							option: [ 1, "<select multiple='multiple'>", "</select>" ],
							legend: [ 1, "<fieldset>", "</fieldset>" ],
							thead: [ 1, "<table>", "</table>" ],
							tr: [ 2, "<table><tbody>", "</tbody></table>" ],
							td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
							col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
							area: [ 1, "<map>", "</map>" ],
							_default: [ 0, "", "" ]
						},
						safeFragment = createSafeFragment( document );

					wrapMap.optgroup = wrapMap.option;
					wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
					wrapMap.th = wrapMap.td;

					// IE can't serialize <link> and <script> tags normally
					if ( !jQuery.support.htmlSerialize ) {
						wrapMap._default = [ 1, "div<div>", "</div>" ];
					}

					jQuery.fn.extend({
						text: function( value ) {
							return jQuery.access( this, function( value ) {
								return value === undefined ?
									jQuery.text( this ) :
									this.empty().append( ( this[0] && this[0].ownerDocument || document ).createTextNode( value ) );
							}, null, value, arguments.length );
						},

						wrapAll: function( html ) {
							if ( jQuery.isFunction( html ) ) {
								return this.each(function(i) {
									jQuery(this).wrapAll( html.call(this, i) );
								});
							}

							if ( this[0] ) {
								// The elements to wrap the target around
								var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);

								if ( this[0].parentNode ) {
									wrap.insertBefore( this[0] );
								}

								wrap.map(function() {
									var elem = this;

									while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
										elem = elem.firstChild;
									}

									return elem;
								}).append( this );
							}

							return this;
						},

						wrapInner: function( html ) {
							if ( jQuery.isFunction( html ) ) {
								return this.each(function(i) {
									jQuery(this).wrapInner( html.call(this, i) );
								});
							}

							return this.each(function() {
								var self = jQuery( this ),
									contents = self.contents();

								if ( contents.length ) {
									contents.wrapAll( html );

								} else {
									self.append( html );
								}
							});
						},

						wrap: function( html ) {
							var isFunction = jQuery.isFunction( html );

							return this.each(function(i) {
								jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
							});
						},

						unwrap: function() {
							return this.parent().each(function() {
								if ( !jQuery.nodeName( this, "body" ) ) {
									jQuery( this ).replaceWith( this.childNodes );
								}
							}).end();
						},

						append: function() {
							return this.domManip(arguments, true, function( elem ) {
								if ( this.nodeType === 1 ) {
									this.appendChild( elem );
								}
							});
						},

						prepend: function() {
							return this.domManip(arguments, true, function( elem ) {
								if ( this.nodeType === 1 ) {
									this.insertBefore( elem, this.firstChild );
								}
							});
						},

						before: function() {
							if ( this[0] && this[0].parentNode ) {
								return this.domManip(arguments, false, function( elem ) {
									this.parentNode.insertBefore( elem, this );
								});
							} else if ( arguments.length ) {
								var set = jQuery.clean( arguments );
								set.push.apply( set, this.toArray() );
								return this.pushStack( set, "before", arguments );
							}
						},

						after: function() {
							if ( this[0] && this[0].parentNode ) {
								return this.domManip(arguments, false, function( elem ) {
									this.parentNode.insertBefore( elem, this.nextSibling );
								});
							} else if ( arguments.length ) {
								var set = this.pushStack( this, "after", arguments );
								set.push.apply( set, jQuery.clean(arguments) );
								return set;
							}
						},

						// keepData is for internal use only--do not document
						remove: function( selector, keepData ) {
							for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
								if ( !selector || jQuery.filter( selector, [ elem ] ).length ) {
									if ( !keepData && elem.nodeType === 1 ) {
										jQuery.cleanData( elem.getElementsByTagName("*") );
										jQuery.cleanData( [ elem ] );
									}

									if ( elem.parentNode ) {
										elem.parentNode.removeChild( elem );
									}
								}
							}

							return this;
						},

						empty: function() {
							for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
								// Remove element nodes and prevent memory leaks
								if ( elem.nodeType === 1 ) {
									jQuery.cleanData( elem.getElementsByTagName("*") );
								}

								// Remove any remaining nodes
								while ( elem.firstChild ) {
									elem.removeChild( elem.firstChild );
								}
							}

							return this;
						},

						clone: function( dataAndEvents, deepDataAndEvents ) {
							dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
							deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

							return this.map( function () {
								return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
							});
						},

						html: function( value ) {
							return jQuery.access( this, function( value ) {
								var elem = this[0] || {},
									i = 0,
									l = this.length;

								if ( value === undefined ) {
									return elem.nodeType === 1 ?
										elem.innerHTML.replace( rinlinejQuery, "" ) :
										null;
								}


								if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
									( jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&
									!wrapMap[ ( rtagName.exec( value ) || ["", ""] )[1].toLowerCase() ] ) {

									value = value.replace( rxhtmlTag, "<$1></$2>" );

									try {
										for (; i < l; i++ ) {
											// Remove element nodes and prevent memory leaks
											elem = this[i] || {};
											if ( elem.nodeType === 1 ) {
												jQuery.cleanData( elem.getElementsByTagName( "*" ) );
												elem.innerHTML = value;
											}
										}

										elem = 0;

									// If using innerHTML throws an exception, use the fallback method
									} catch(e) {}
								}

								if ( elem ) {
									this.empty().append( value );
								}
							}, null, value, arguments.length );
						},

						replaceWith: function( value ) {
							if ( this[0] && this[0].parentNode ) {
								// Make sure that the elements are removed from the DOM before they are inserted
								// this can help fix replacing a parent with child elements
								if ( jQuery.isFunction( value ) ) {
									return this.each(function(i) {
										var self = jQuery(this), old = self.html();
										self.replaceWith( value.call( this, i, old ) );
									});
								}

								if ( typeof value !== "string" ) {
									value = jQuery( value ).detach();
								}

								return this.each(function() {
									var next = this.nextSibling,
										parent = this.parentNode;

									jQuery( this ).remove();

									if ( next ) {
										jQuery(next).before( value );
									} else {
										jQuery(parent).append( value );
									}
								});
							} else {
								return this.length ?
									this.pushStack( jQuery(jQuery.isFunction(value) ? value() : value), "replaceWith", value ) :
									this;
							}
						},

						detach: function( selector ) {
							return this.remove( selector, true );
						},

						domManip: function( args, table, callback ) {
							var results, first, fragment, parent,
								value = args[0],
								scripts = [];

							// We can't cloneNode fragments that contain checked, in WebKit
							if ( !jQuery.support.checkClone && arguments.length === 3 && typeof value === "string" && rchecked.test( value ) ) {
								return this.each(function() {
									jQuery(this).domManip( args, table, callback, true );
								});
							}

							if ( jQuery.isFunction(value) ) {
								return this.each(function(i) {
									var self = jQuery(this);
									args[0] = value.call(this, i, table ? self.html() : undefined);
									self.domManip( args, table, callback );
								});
							}

							if ( this[0] ) {
								parent = value && value.parentNode;

								// If we're in a fragment, just use that instead of building a new one
								if ( jQuery.support.parentNode && parent && parent.nodeType === 11 && parent.childNodes.length === this.length ) {
									results = { fragment: parent };

								} else {
									results = jQuery.buildFragment( args, this, scripts );
								}

								fragment = results.fragment;

								if ( fragment.childNodes.length === 1 ) {
									first = fragment = fragment.firstChild;
								} else {
									first = fragment.firstChild;
								}

								if ( first ) {
									table = table && jQuery.nodeName( first, "tr" );

									for ( var i = 0, l = this.length, lastIndex = l - 1; i < l; i++ ) {
										callback.call(
											table ?
												root(this[i], first) :
												this[i],
											// Make sure that we do not leak memory by inadvertently discarding
											// the original fragment (which might have attached data) instead of
											// using it; in addition, use the original fragment object for the last
											// item instead of first because it can end up being emptied incorrectly
											// in certain situations (Bug #8070).
											// Fragments from the fragment cache must always be cloned and never used
											// in place.
											results.cacheable || ( l > 1 && i < lastIndex ) ?
												jQuery.clone( fragment, true, true ) :
												fragment
										);
									}
								}

								if ( scripts.length ) {
									jQuery.each( scripts, function( i, elem ) {
										if ( elem.src ) {
											jQuery.ajax({
												type: "GET",
												global: false,
												url: elem.src,
												async: false,
												dataType: "script"
											});
										} else {
											jQuery.globalEval( ( elem.text || elem.textContent || elem.innerHTML || "" ).replace( rcleanScript, "/*$0*/" ) );
										}

										if ( elem.parentNode ) {
											elem.parentNode.removeChild( elem );
										}
									});
								}
							}

							return this;
						}
					});

					function root( elem, cur ) {
						return jQuery.nodeName(elem, "table") ?
							(elem.getElementsByTagName("tbody")[0] ||
							elem.appendChild(elem.ownerDocument.createElement("tbody"))) :
							elem;
					}

					function cloneCopyEvent( src, dest ) {

						if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
							return;
						}

						var type, i, l,
							oldData = jQuery._data( src ),
							curData = jQuery._data( dest, oldData ),
							events = oldData.events;

						if ( events ) {
							delete curData.handle;
							curData.events = {};

							for ( type in events ) {
								for ( i = 0, l = events[ type ].length; i < l; i++ ) {
									jQuery.event.add( dest, type, events[ type ][ i ] );
								}
							}
						}

						// make the cloned public data object a copy from the original
						if ( curData.data ) {
							curData.data = jQuery.extend( {}, curData.data );
						}
					}

					function cloneFixAttributes( src, dest ) {
						var nodeName;

						// We do not need to do anything for non-Elements
						if ( dest.nodeType !== 1 ) {
							return;
						}

						// clearAttributes removes the attributes, which we don't want,
						// but also removes the attachEvent events, which we *do* want
						if ( dest.clearAttributes ) {
							dest.clearAttributes();
						}

						// mergeAttributes, in contrast, only merges back on the
						// original attributes, not the events
						if ( dest.mergeAttributes ) {
							dest.mergeAttributes( src );
						}

						nodeName = dest.nodeName.toLowerCase();

						// IE6-8 fail to clone children inside object elements that use
						// the proprietary classid attribute value (rather than the type
						// attribute) to identify the type of content to display
						if ( nodeName === "object" ) {
							dest.outerHTML = src.outerHTML;

						} else if ( nodeName === "input" && (src.type === "checkbox" || src.type === "radio") ) {
							// IE6-8 fails to persist the checked state of a cloned checkbox
							// or radio button. Worse, IE6-7 fail to give the cloned element
							// a checked appearance if the defaultChecked value isn't also set
							if ( src.checked ) {
								dest.defaultChecked = dest.checked = src.checked;
							}

							// IE6-7 get confused and end up setting the value of a cloned
							// checkbox/radio button to an empty string instead of "on"
							if ( dest.value !== src.value ) {
								dest.value = src.value;
							}

						// IE6-8 fails to return the selected option to the default selected
						// state when cloning options
						} else if ( nodeName === "option" ) {
							dest.selected = src.defaultSelected;

						// IE6-8 fails to set the defaultValue to the correct value when
						// cloning other types of input fields
						} else if ( nodeName === "input" || nodeName === "textarea" ) {
							dest.defaultValue = src.defaultValue;

						// IE blanks contents when cloning scripts
						} else if ( nodeName === "script" && dest.text !== src.text ) {
							dest.text = src.text;
						}

						// Event data gets referenced instead of copied if the expando
						// gets copied too
						dest.removeAttribute( jQuery.expando );

						// Clear flags for bubbling special change/submit events, they must
						// be reattached when the newly cloned events are first activated
						dest.removeAttribute( "_submit_attached" );
						dest.removeAttribute( "_change_attached" );
					}

					jQuery.buildFragment = function( args, nodes, scripts ) {
						var fragment, cacheable, cacheresults, doc,
						first = args[ 0 ];

						// nodes may contain either an explicit document object,
						// a jQuery collection or context object.
						// If nodes[0] contains a valid object to assign to doc
						if ( nodes && nodes[0] ) {
							doc = nodes[0].ownerDocument || nodes[0];
						}

						// Ensure that an attr object doesn't incorrectly stand in as a document object
						// Chrome and Firefox seem to allow this to occur and will throw exception
						// Fixes #8950
						if ( !doc.createDocumentFragment ) {
							doc = document;
						}

						// Only cache "small" (1/2 KB) HTML strings that are associated with the main document
						// Cloning options loses the selected state, so don't cache them
						// IE 6 doesn't like it when you put <object> or <embed> elements in a fragment
						// Also, WebKit does not clone 'checked' attributes on cloneNode, so don't cache
						// Lastly, IE6,7,8 will not correctly reuse cached fragments that were created from unknown elems #10501
						if ( args.length === 1 && typeof first === "string" && first.length < 512 && doc === document &&
							first.charAt(0) === "<" && !rnocache.test( first ) &&
							(jQuery.support.checkClone || !rchecked.test( first )) &&
							(jQuery.support.html5Clone || !rnoshimcache.test( first )) ) {

							cacheable = true;

							cacheresults = jQuery.fragments[ first ];
							if ( cacheresults && cacheresults !== 1 ) {
								fragment = cacheresults;
							}
						}

						if ( !fragment ) {
							fragment = doc.createDocumentFragment();
							jQuery.clean( args, doc, fragment, scripts );
						}

						if ( cacheable ) {
							jQuery.fragments[ first ] = cacheresults ? fragment : 1;
						}

						return { fragment: fragment, cacheable: cacheable };
					};

					jQuery.fragments = {};

					jQuery.each({
						appendTo: "append",
						prependTo: "prepend",
						insertBefore: "before",
						insertAfter: "after",
						replaceAll: "replaceWith"
					}, function( name, original ) {
						jQuery.fn[ name ] = function( selector ) {
							var ret = [],
								insert = jQuery( selector ),
								parent = this.length === 1 && this[0].parentNode;

							if ( parent && parent.nodeType === 11 && parent.childNodes.length === 1 && insert.length === 1 ) {
								insert[ original ]( this[0] );
								return this;

							} else {
								for ( var i = 0, l = insert.length; i < l; i++ ) {
									var elems = ( i > 0 ? this.clone(true) : this ).get();
									jQuery( insert[i] )[ original ]( elems );
									ret = ret.concat( elems );
								}

								return this.pushStack( ret, name, insert.selector );
							}
						};
					});

					function getAll( elem ) {
						if ( typeof elem.getElementsByTagName !== "undefined" ) {
							return elem.getElementsByTagName( "*" );

						} else if ( typeof elem.querySelectorAll !== "undefined" ) {
							return elem.querySelectorAll( "*" );

						} else {
							return [];
						}
					}

					// Used in clean, fixes the defaultChecked property
					function fixDefaultChecked( elem ) {
						if ( elem.type === "checkbox" || elem.type === "radio" ) {
							elem.defaultChecked = elem.checked;
						}
					}
					// Finds all inputs and passes them to fixDefaultChecked
					function findInputs( elem ) {
						var nodeName = ( elem.nodeName || "" ).toLowerCase();
						if ( nodeName === "input" ) {
							fixDefaultChecked( elem );
						// Skip scripts, get other children
						} else if ( nodeName !== "script" && typeof elem.getElementsByTagName !== "undefined" ) {
							jQuery.grep( elem.getElementsByTagName("input"), fixDefaultChecked );
						}
					}

					// Derived From: http://www.iecss.com/shimprove/javascript/shimprove.1-0-1.js
					function shimCloneNode( elem ) {
						var div = document.createElement( "div" );
						safeFragment.appendChild( div );

						div.innerHTML = elem.outerHTML;
						return div.firstChild;
					}

					jQuery.extend({
						clone: function( elem, dataAndEvents, deepDataAndEvents ) {
							var srcElements,
								destElements,
								i,
								// IE<=8 does not properly clone detached, unknown element nodes
								clone = jQuery.support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test( "<" + elem.nodeName + ">" ) ?
									elem.cloneNode( true ) :
									shimCloneNode( elem );

							if ( (!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &&
									(elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {
								// IE copies events bound via attachEvent when using cloneNode.
								// Calling detachEvent on the clone will also remove the events
								// from the original. In order to get around this, we use some
								// proprietary methods to clear the events. Thanks to MooTools
								// guys for this hotness.

								cloneFixAttributes( elem, clone );

								// Using Sizzle here is crazy slow, so we use getElementsByTagName instead
								srcElements = getAll( elem );
								destElements = getAll( clone );

								// Weird iteration because IE will replace the length property
								// with an element if you are cloning the body and one of the
								// elements on the page has a name or id of "length"
								for ( i = 0; srcElements[i]; ++i ) {
									// Ensure that the destination node is not null; Fixes #9587
									if ( destElements[i] ) {
										cloneFixAttributes( srcElements[i], destElements[i] );
									}
								}
							}

							// Copy the events from the original to the clone
							if ( dataAndEvents ) {
								cloneCopyEvent( elem, clone );

								if ( deepDataAndEvents ) {
									srcElements = getAll( elem );
									destElements = getAll( clone );

									for ( i = 0; srcElements[i]; ++i ) {
										cloneCopyEvent( srcElements[i], destElements[i] );
									}
								}
							}

							srcElements = destElements = null;

							// Return the cloned set
							return clone;
						},

						clean: function( elems, context, fragment, scripts ) {
							var checkScriptType, script, j,
									ret = [];

							context = context || document;

							// !context.createElement fails in IE with an error but returns typeof 'object'
							if ( typeof context.createElement === "undefined" ) {
								context = context.ownerDocument || context[0] && context[0].ownerDocument || document;
							}

							for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
								if ( typeof elem === "number" ) {
									elem += "";
								}

								if ( !elem ) {
									continue;
								}

								// Convert html string into DOM nodes
								if ( typeof elem === "string" ) {
									if ( !rhtml.test( elem ) ) {
										elem = context.createTextNode( elem );
									} else {
										// Fix "XHTML"-style tags in all browsers
										elem = elem.replace(rxhtmlTag, "<$1></$2>");

										// Trim whitespace, otherwise indexOf won't work as expected
										var tag = ( rtagName.exec( elem ) || ["", ""] )[1].toLowerCase(),
											wrap = wrapMap[ tag ] || wrapMap._default,
											depth = wrap[0],
											div = context.createElement("div"),
											safeChildNodes = safeFragment.childNodes,
											remove;

										// Append wrapper element to unknown element safe doc fragment
										if ( context === document ) {
											// Use the fragment we've already created for this document
											safeFragment.appendChild( div );
										} else {
											// Use a fragment created with the owner document
											createSafeFragment( context ).appendChild( div );
										}

										// Go to html and back, then peel off extra wrappers
										div.innerHTML = wrap[1] + elem + wrap[2];

										// Move to the right depth
										while ( depth-- ) {
											div = div.lastChild;
										}

										// Remove IE's autoinserted <tbody> from table fragments
										if ( !jQuery.support.tbody ) {

											// String was a <table>, *may* have spurious <tbody>
											var hasBody = rtbody.test(elem),
												tbody = tag === "table" && !hasBody ?
													div.firstChild && div.firstChild.childNodes :

													// String was a bare <thead> or <tfoot>
													wrap[1] === "<table>" && !hasBody ?
														div.childNodes :
														[];

											for ( j = tbody.length - 1; j >= 0 ; --j ) {
												if ( jQuery.nodeName( tbody[ j ], "tbody" ) && !tbody[ j ].childNodes.length ) {
													tbody[ j ].parentNode.removeChild( tbody[ j ] );
												}
											}
										}

										// IE completely kills leading whitespace when innerHTML is used
										if ( !jQuery.support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
											div.insertBefore( context.createTextNode( rleadingWhitespace.exec(elem)[0] ), div.firstChild );
										}

										elem = div.childNodes;

										// Clear elements from DocumentFragment (safeFragment or otherwise)
										// to avoid hoarding elements. Fixes #11356
										if ( div ) {
											div.parentNode.removeChild( div );

											// Guard against -1 index exceptions in FF3.6
											if ( safeChildNodes.length > 0 ) {
												remove = safeChildNodes[ safeChildNodes.length - 1 ];

												if ( remove && remove.parentNode ) {
													remove.parentNode.removeChild( remove );
												}
											}
										}
									}
								}

								// Resets defaultChecked for any radios and checkboxes
								// about to be appended to the DOM in IE 6/7 (#8060)
								var len;
								if ( !jQuery.support.appendChecked ) {
									if ( elem[0] && typeof (len = elem.length) === "number" ) {
										for ( j = 0; j < len; j++ ) {
											findInputs( elem[j] );
										}
									} else {
										findInputs( elem );
									}
								}

								if ( elem.nodeType ) {
									ret.push( elem );
								} else {
									ret = jQuery.merge( ret, elem );
								}
							}

							if ( fragment ) {
								checkScriptType = function( elem ) {
									return !elem.type || rscriptType.test( elem.type );
								};
								for ( i = 0; ret[i]; i++ ) {
									script = ret[i];
									if ( scripts && jQuery.nodeName( script, "script" ) && (!script.type || rscriptType.test( script.type )) ) {
										scripts.push( script.parentNode ? script.parentNode.removeChild( script ) : script );

									} else {
										if ( script.nodeType === 1 ) {
											var jsTags = jQuery.grep( script.getElementsByTagName( "script" ), checkScriptType );

											ret.splice.apply( ret, [i + 1, 0].concat( jsTags ) );
										}
										fragment.appendChild( script );
									}
								}
							}

							return ret;
						},

						cleanData: function( elems ) {
							var data, id,
								cache = jQuery.cache,
								special = jQuery.event.special,
								deleteExpando = jQuery.support.deleteExpando;

							for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
								if ( elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()] ) {
									continue;
								}

								id = elem[ jQuery.expando ];

								if ( id ) {
									data = cache[ id ];

									if ( data && data.events ) {
										for ( var type in data.events ) {
											if ( special[ type ] ) {
												jQuery.event.remove( elem, type );

											// This is a shortcut to avoid jQuery.event.remove's overhead
											} else {
												jQuery.removeEvent( elem, type, data.handle );
											}
										}

										// Null the DOM reference to avoid IE6/7/8 leak (#7054)
										if ( data.handle ) {
											data.handle.elem = null;
										}
									}

									if ( deleteExpando ) {
										delete elem[ jQuery.expando ];

									} else if ( elem.removeAttribute ) {
										elem.removeAttribute( jQuery.expando );
									}

									delete cache[ id ];
								}
							}
						}
					});




					var ralpha = /alpha\([^)]*\)/i,
						ropacity = /opacity=([^)]*)/,
						// fixed for IE9, see #8346
						rupper = /([A-Z]|^ms)/g,
						rnum = /^[\-+]?(?:\d*\.)?\d+$/i,
						rnumnonpx = /^-?(?:\d*\.)?\d+(?!px)[^\d\s]+$/i,
						rrelNum = /^([\-+])=([\-+.\de]+)/,
						rmargin = /^margin/,

						cssShow = { position: "absolute", visibility: "hidden", display: "block" },

						// order is important!
						cssExpand = [ "Top", "Right", "Bottom", "Left" ],

						curCSS,

						getComputedStyle,
						currentStyle;

					jQuery.fn.css = function( name, value ) {
						return jQuery.access( this, function( elem, name, value ) {
							return value !== undefined ?
								jQuery.style( elem, name, value ) :
								jQuery.css( elem, name );
						}, name, value, arguments.length > 1 );
					};

					jQuery.extend({
						// Add in style property hooks for overriding the default
						// behavior of getting and setting a style property
						cssHooks: {
							opacity: {
								get: function( elem, computed ) {
									if ( computed ) {
										// We should always get a number back from opacity
										var ret = curCSS( elem, "opacity" );
										return ret === "" ? "1" : ret;

									} else {
										return elem.style.opacity;
									}
								}
							}
						},

						// Exclude the following css properties to add px
						cssNumber: {
							"fillOpacity": true,
							"fontWeight": true,
							"lineHeight": true,
							"opacity": true,
							"orphans": true,
							"widows": true,
							"zIndex": true,
							"zoom": true
						},

						// Add in properties whose names you wish to fix before
						// setting or getting the value
						cssProps: {
							// normalize float css property
							"float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"
						},

						// Get and set the style property on a DOM Node
						style: function( elem, name, value, extra ) {
							// Don't set styles on text and comment nodes
							if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
								return;
							}

							// Make sure that we're working with the right name
							var ret, type, origName = jQuery.camelCase( name ),
								style = elem.style, hooks = jQuery.cssHooks[ origName ];

							name = jQuery.cssProps[ origName ] || origName;

							// Check if we're setting a value
							if ( value !== undefined ) {
								type = typeof value;

								// convert relative number strings (+= or -=) to relative numbers. #7345
								if ( type === "string" && (ret = rrelNum.exec( value )) ) {
									value = ( +( ret[1] + 1) * +ret[2] ) + parseFloat( jQuery.css( elem, name ) );
									// Fixes bug #9237
									type = "number";
								}

								// Make sure that NaN and null values aren't set. See: #7116
								if ( value == null || type === "number" && isNaN( value ) ) {
									return;
								}

								// If a number was passed in, add 'px' to the (except for certain CSS properties)
								if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
									value += "px";
								}

								// If a hook was provided, use that value, otherwise just set the specified value
								if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value )) !== undefined ) {
									// Wrapped to prevent IE from throwing errors when 'invalid' values are provided
									// Fixes bug #5509
									try {
										style[ name ] = value;
									} catch(e) {}
								}

							} else {
								// If a hook was provided get the non-computed value from there
								if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
									return ret;
								}

								// Otherwise just get the value from the style object
								return style[ name ];
							}
						},

						css: function( elem, name, extra ) {
							var ret, hooks;

							// Make sure that we're working with the right name
							name = jQuery.camelCase( name );
							hooks = jQuery.cssHooks[ name ];
							name = jQuery.cssProps[ name ] || name;

							// cssFloat needs a special treatment
							if ( name === "cssFloat" ) {
								name = "float";
							}

							// If a hook was provided get the computed value from there
							if ( hooks && "get" in hooks && (ret = hooks.get( elem, true, extra )) !== undefined ) {
								return ret;

							// Otherwise, if a way to get the computed value exists, use that
							} else if ( curCSS ) {
								return curCSS( elem, name );
							}
						},

						// A method for quickly swapping in/out CSS properties to get correct calculations
						swap: function( elem, options, callback ) {
							var old = {},
								ret, name;

							// Remember the old values, and insert the new ones
							for ( name in options ) {
								old[ name ] = elem.style[ name ];
								elem.style[ name ] = options[ name ];
							}

							ret = callback.call( elem );

							// Revert the old values
							for ( name in options ) {
								elem.style[ name ] = old[ name ];
							}

							return ret;
						}
					});

					// DEPRECATED in 1.3, Use jQuery.css() instead
					jQuery.curCSS = jQuery.css;

					if ( document.defaultView && document.defaultView.getComputedStyle ) {
						getComputedStyle = function( elem, name ) {
							var ret, defaultView, computedStyle, width,
								style = elem.style;

							name = name.replace( rupper, "-$1" ).toLowerCase();

							if ( (defaultView = elem.ownerDocument.defaultView) &&
									(computedStyle = defaultView.getComputedStyle( elem, null )) ) {

								ret = computedStyle.getPropertyValue( name );
								if ( ret === "" && !jQuery.contains( elem.ownerDocument.documentElement, elem ) ) {
									ret = jQuery.style( elem, name );
								}
							}

							// A tribute to the "awesome hack by Dean Edwards"
							// WebKit uses "computed value (percentage if specified)" instead of "used value" for margins
							// which is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
							if ( !jQuery.support.pixelMargin && computedStyle && rmargin.test( name ) && rnumnonpx.test( ret ) ) {
								width = style.width;
								style.width = ret;
								ret = computedStyle.width;
								style.width = width;
							}

							return ret;
						};
					}

					if ( document.documentElement.currentStyle ) {
						currentStyle = function( elem, name ) {
							var left, rsLeft, uncomputed,
								ret = elem.currentStyle && elem.currentStyle[ name ],
								style = elem.style;

							// Avoid setting ret to empty string here
							// so we don't default to auto
							if ( ret == null && style && (uncomputed = style[ name ]) ) {
								ret = uncomputed;
							}

							// From the awesome hack by Dean Edwards
							// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

							// If we're not dealing with a regular pixel number
							// but a number that has a weird ending, we need to convert it to pixels
							if ( rnumnonpx.test( ret ) ) {

								// Remember the original values
								left = style.left;
								rsLeft = elem.runtimeStyle && elem.runtimeStyle.left;

								// Put in the new values to get a computed value out
								if ( rsLeft ) {
									elem.runtimeStyle.left = elem.currentStyle.left;
								}
								style.left = name === "fontSize" ? "1em" : ret;
								ret = style.pixelLeft + "px";

								// Revert the changed values
								style.left = left;
								if ( rsLeft ) {
									elem.runtimeStyle.left = rsLeft;
								}
							}

							return ret === "" ? "auto" : ret;
						};
					}

					curCSS = getComputedStyle || currentStyle;

					function getWidthOrHeight( elem, name, extra ) {

						// Start with offset property
						var val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
							i = name === "width" ? 1 : 0,
							len = 4;

						if ( val > 0 ) {
							if ( extra !== "border" ) {
								for ( ; i < len; i += 2 ) {
									if ( !extra ) {
										val -= parseFloat( jQuery.css( elem, "padding" + cssExpand[ i ] ) ) || 0;
									}
									if ( extra === "margin" ) {
										val += parseFloat( jQuery.css( elem, extra + cssExpand[ i ] ) ) || 0;
									} else {
										val -= parseFloat( jQuery.css( elem, "border" + cssExpand[ i ] + "Width" ) ) || 0;
									}
								}
							}

							return val + "px";
						}

						// Fall back to computed then uncomputed css if necessary
						val = curCSS( elem, name );
						if ( val < 0 || val == null ) {
							val = elem.style[ name ];
						}

						// Computed unit is not pixels. Stop here and return.
						if ( rnumnonpx.test(val) ) {
							return val;
						}

						// Normalize "", auto, and prepare for extra
						val = parseFloat( val ) || 0;

						// Add padding, border, margin
						if ( extra ) {
							for ( ; i < len; i += 2 ) {
								val += parseFloat( jQuery.css( elem, "padding" + cssExpand[ i ] ) ) || 0;
								if ( extra !== "padding" ) {
									val += parseFloat( jQuery.css( elem, "border" + cssExpand[ i ] + "Width" ) ) || 0;
								}
								if ( extra === "margin" ) {
									val += parseFloat( jQuery.css( elem, extra + cssExpand[ i ]) ) || 0;
								}
							}
						}

						return val + "px";
					}

					jQuery.each([ "height", "width" ], function( i, name ) {
						jQuery.cssHooks[ name ] = {
							get: function( elem, computed, extra ) {
								if ( computed ) {
									if ( elem.offsetWidth !== 0 ) {
										return getWidthOrHeight( elem, name, extra );
									} else {
										return jQuery.swap( elem, cssShow, function() {
											return getWidthOrHeight( elem, name, extra );
										});
									}
								}
							},

							set: function( elem, value ) {
								return rnum.test( value ) ?
									value + "px" :
									value;
							}
						};
					});

					if ( !jQuery.support.opacity ) {
						jQuery.cssHooks.opacity = {
							get: function( elem, computed ) {
								// IE uses filters for opacity
								return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "" ) ?
									( parseFloat( RegExp.$1 ) / 100 ) + "" :
									computed ? "1" : "";
							},

							set: function( elem, value ) {
								var style = elem.style,
									currentStyle = elem.currentStyle,
									opacity = jQuery.isNumeric( value ) ? "alpha(opacity=" + value * 100 + ")" : "",
									filter = currentStyle && currentStyle.filter || style.filter || "";

								// IE has trouble with opacity if it does not have layout
								// Force it by setting the zoom level
								style.zoom = 1;

								// if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
								if ( value >= 1 && jQuery.trim( filter.replace( ralpha, "" ) ) === "" ) {

									// Setting style.filter to null, "" & " " still leave "filter:" in the cssText
									// if "filter:" is present at all, clearType is disabled, we want to avoid this
									// style.removeAttribute is IE Only, but so apparently is this code path...
									style.removeAttribute( "filter" );

									// if there there is no filter style applied in a css rule, we are done
									if ( currentStyle && !currentStyle.filter ) {
										return;
									}
								}

								// otherwise, set new filter values
								style.filter = ralpha.test( filter ) ?
									filter.replace( ralpha, opacity ) :
									filter + " " + opacity;
							}
						};
					}

					jQuery(function() {
						// This hook cannot be added until DOM ready because the support test
						// for it is not run until after DOM ready
						if ( !jQuery.support.reliableMarginRight ) {
							jQuery.cssHooks.marginRight = {
								get: function( elem, computed ) {
									// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
									// Work around by temporarily setting element display to inline-block
									return jQuery.swap( elem, { "display": "inline-block" }, function() {
										if ( computed ) {
											return curCSS( elem, "margin-right" );
										} else {
											return elem.style.marginRight;
										}
									});
								}
							};
						}
					});

					if ( jQuery.expr && jQuery.expr.filters ) {
						jQuery.expr.filters.hidden = function( elem ) {
							var width = elem.offsetWidth,
								height = elem.offsetHeight;

							return ( width === 0 && height === 0 ) || (!jQuery.support.reliableHiddenOffsets && ((elem.style && elem.style.display) || jQuery.css( elem, "display" )) === "none");
						};

						jQuery.expr.filters.visible = function( elem ) {
							return !jQuery.expr.filters.hidden( elem );
						};
					}

					// These hooks are used by animate to expand properties
					jQuery.each({
						margin: "",
						padding: "",
						border: "Width"
					}, function( prefix, suffix ) {

						jQuery.cssHooks[ prefix + suffix ] = {
							expand: function( value ) {
								var i,

									// assumes a single number if not a string
									parts = typeof value === "string" ? value.split(" ") : [ value ],
									expanded = {};

								for ( i = 0; i < 4; i++ ) {
									expanded[ prefix + cssExpand[ i ] + suffix ] =
										parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
								}

								return expanded;
							}
						};
					});




					var r20 = /%20/g,
						rbracket = /\[\]$/,
						rCRLF = /\r?\n/g,
						rhash = /#.*$/,
						rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
						rinput = /^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,
						// #7653, #8125, #8152: local protocol detection
						rlocalProtocol = /^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,
						rnoContent = /^(?:GET|HEAD)$/,
						rprotocol = /^\/\//,
						rquery = /\?/,
						rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
						rselectTextarea = /^(?:select|textarea)/i,
						rspacesAjax = /\s+/,
						rts = /([?&])_=[^&]*/,
						rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/,

						// Keep a copy of the old load method
						_load = jQuery.fn.load,

						/* Prefilters
						 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
						 * 2) These are called:
						 *    - BEFORE asking for a transport
						 *    - AFTER param serialization (s.data is a string if s.processData is true)
						 * 3) key is the dataType
						 * 4) the catchall symbol "*" can be used
						 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
						 */
						prefilters = {},

						/* Transports bindings
						 * 1) key is the dataType
						 * 2) the catchall symbol "*" can be used
						 * 3) selection will start with transport dataType and THEN go to "*" if needed
						 */
						transports = {},

						// Document location
						ajaxLocation,

						// Document location segments
						ajaxLocParts,

						// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
						allTypes = ["*/"] + ["*"];

					// #8138, IE may throw an exception when accessing
					// a field from window.location if document.domain has been set
					try {
						ajaxLocation = location.href;
					} catch( e ) {
						// Use the href attribute of an A element
						// since IE will modify it given document.location
						ajaxLocation = document.createElement( "a" );
						ajaxLocation.href = "";
						ajaxLocation = ajaxLocation.href;
					}

					// Segment location into parts
					ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

					// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
					function addToPrefiltersOrTransports( structure ) {

						// dataTypeExpression is optional and defaults to "*"
						return function( dataTypeExpression, func ) {

							if ( typeof dataTypeExpression !== "string" ) {
								func = dataTypeExpression;
								dataTypeExpression = "*";
							}

							if ( jQuery.isFunction( func ) ) {
								var dataTypes = dataTypeExpression.toLowerCase().split( rspacesAjax ),
									i = 0,
									length = dataTypes.length,
									dataType,
									list,
									placeBefore;

								// For each dataType in the dataTypeExpression
								for ( ; i < length; i++ ) {
									dataType = dataTypes[ i ];
									// We control if we're asked to add before
									// any existing element
									placeBefore = /^\+/.test( dataType );
									if ( placeBefore ) {
										dataType = dataType.substr( 1 ) || "*";
									}
									list = structure[ dataType ] = structure[ dataType ] || [];
									// then we add to the structure accordingly
									list[ placeBefore ? "unshift" : "push" ]( func );
								}
							}
						};
					}

					// Base inspection function for prefilters and transports
					function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR,
							dataType /* internal */, inspected /* internal */ ) {

						dataType = dataType || options.dataTypes[ 0 ];
						inspected = inspected || {};

						inspected[ dataType ] = true;

						var list = structure[ dataType ],
							i = 0,
							length = list ? list.length : 0,
							executeOnly = ( structure === prefilters ),
							selection;

						for ( ; i < length && ( executeOnly || !selection ); i++ ) {
							selection = list[ i ]( options, originalOptions, jqXHR );
							// If we got redirected to another dataType
							// we try there if executing only and not done already
							if ( typeof selection === "string" ) {
								if ( !executeOnly || inspected[ selection ] ) {
									selection = undefined;
								} else {
									options.dataTypes.unshift( selection );
									selection = inspectPrefiltersOrTransports(
											structure, options, originalOptions, jqXHR, selection, inspected );
								}
							}
						}
						// If we're only executing or nothing was selected
						// we try the catchall dataType if not done already
						if ( ( executeOnly || !selection ) && !inspected[ "*" ] ) {
							selection = inspectPrefiltersOrTransports(
									structure, options, originalOptions, jqXHR, "*", inspected );
						}
						// unnecessary when only executing (prefilters)
						// but it'll be ignored by the caller in that case
						return selection;
					}

					// A special extend for ajax options
					// that takes "flat" options (not to be deep extended)
					// Fixes #9887
					function ajaxExtend( target, src ) {
						var key, deep,
							flatOptions = jQuery.ajaxSettings.flatOptions || {};
						for ( key in src ) {
							if ( src[ key ] !== undefined ) {
								( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
							}
						}
						if ( deep ) {
							jQuery.extend( true, target, deep );
						}
					}

					jQuery.fn.extend({
						load: function( url, params, callback ) {
							if ( typeof url !== "string" && _load ) {
								return _load.apply( this, arguments );

							// Don't do a request if no elements are being requested
							} else if ( !this.length ) {
								return this;
							}

							var off = url.indexOf( " " );
							if ( off >= 0 ) {
								var selector = url.slice( off, url.length );
								url = url.slice( 0, off );
							}

							// Default to a GET request
							var type = "GET";

							// If the second parameter was provided
							if ( params ) {
								// If it's a function
								if ( jQuery.isFunction( params ) ) {
									// We assume that it's the callback
									callback = params;
									params = undefined;

								// Otherwise, build a param string
								} else if ( typeof params === "object" ) {
									params = jQuery.param( params, jQuery.ajaxSettings.traditional );
									type = "POST";
								}
							}

							var self = this;

							// Request the remote document
							jQuery.ajax({
								url: url,
								type: type,
								dataType: "html",
								data: params,
								// Complete callback (responseText is used internally)
								complete: function( jqXHR, status, responseText ) {
									// Store the response as specified by the jqXHR object
									responseText = jqXHR.responseText;
									// If successful, inject the HTML into all the matched elements
									if ( jqXHR.isResolved() ) {
										// #4825: Get the actual response in case
										// a dataFilter is present in ajaxSettings
										jqXHR.done(function( r ) {
											responseText = r;
										});
										// See if a selector was specified
										self.html( selector ?
											// Create a dummy div to hold the results
											jQuery("<div>")
												// inject the contents of the document in, removing the scripts
												// to avoid any 'Permission Denied' errors in IE
												.append(responseText.replace(rscript, ""))

												// Locate the specified elements
												.find(selector) :

											// If not, just inject the full result
											responseText );
									}

									if ( callback ) {
										self.each( callback, [ responseText, status, jqXHR ] );
									}
								}
							});

							return this;
						},

						serialize: function() {
							return jQuery.param( this.serializeArray() );
						},

						serializeArray: function() {
							return this.map(function(){
								return this.elements ? jQuery.makeArray( this.elements ) : this;
							})
							.filter(function(){
								return this.name && !this.disabled &&
									( this.checked || rselectTextarea.test( this.nodeName ) ||
										rinput.test( this.type ) );
							})
							.map(function( i, elem ){
								var val = jQuery( this ).val();

								return val == null ?
									null :
									jQuery.isArray( val ) ?
										jQuery.map( val, function( val, i ){
											return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
										}) :
										{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
							}).get();
						}
					});

					// Attach a bunch of functions for handling common AJAX events
					jQuery.each( "ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split( " " ), function( i, o ){
						jQuery.fn[ o ] = function( f ){
							return this.on( o, f );
						};
					});

					jQuery.each( [ "get", "post" ], function( i, method ) {
						jQuery[ method ] = function( url, data, callback, type ) {
							// shift arguments if data argument was omitted
							if ( jQuery.isFunction( data ) ) {
								type = type || callback;
								callback = data;
								data = undefined;
							}

							return jQuery.ajax({
								type: method,
								url: url,
								data: data,
								success: callback,
								dataType: type
							});
						};
					});

					jQuery.extend({

						getScript: function( url, callback ) {
							return jQuery.get( url, undefined, callback, "script" );
						},

						getJSON: function( url, data, callback ) {
							return jQuery.get( url, data, callback, "json" );
						},

						// Creates a full fledged settings object into target
						// with both ajaxSettings and settings fields.
						// If target is omitted, writes into ajaxSettings.
						ajaxSetup: function( target, settings ) {
							if ( settings ) {
								// Building a settings object
								ajaxExtend( target, jQuery.ajaxSettings );
							} else {
								// Extending ajaxSettings
								settings = target;
								target = jQuery.ajaxSettings;
							}
							ajaxExtend( target, settings );
							return target;
						},

						ajaxSettings: {
							url: ajaxLocation,
							isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
							global: true,
							type: "GET",
							contentType: "application/x-www-form-urlencoded; charset=UTF-8",
							processData: true,
							async: true,
							/*
							timeout: 0,
							data: null,
							dataType: null,
							username: null,
							password: null,
							cache: null,
							traditional: false,
							headers: {},
							*/

							accepts: {
								xml: "application/xml, text/xml",
								html: "text/html",
								text: "text/plain",
								json: "application/json, text/javascript",
								"*": allTypes
							},

							contents: {
								xml: /xml/,
								html: /html/,
								json: /json/
							},

							responseFields: {
								xml: "responseXML",
								text: "responseText"
							},

							// List of data converters
							// 1) key format is "source_type destination_type" (a single space in-between)
							// 2) the catchall symbol "*" can be used for source_type
							converters: {

								// Convert anything to text
								"* text": window.String,

								// Text to html (true = no transformation)
								"text html": true,

								// Evaluate text as a json expression
								"text json": jQuery.parseJSON,

								// Parse text as xml
								"text xml": jQuery.parseXML
							},

							// For options that shouldn't be deep extended:
							// you can add your own custom options here if
							// and when you create one that shouldn't be
							// deep extended (see ajaxExtend)
							flatOptions: {
								context: true,
								url: true
							}
						},

						ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
						ajaxTransport: addToPrefiltersOrTransports( transports ),

						// Main method
						ajax: function( url, options ) {

							// If url is an object, simulate pre-1.5 signature
							if ( typeof url === "object" ) {
								options = url;
								url = undefined;
							}

							// Force options to be an object
							options = options || {};

							var // Create the final options object
								s = jQuery.ajaxSetup( {}, options ),
								// Callbacks context
								callbackContext = s.context || s,
								// Context for global events
								// It's the callbackContext if one was provided in the options
								// and if it's a DOM node or a jQuery collection
								globalEventContext = callbackContext !== s &&
									( callbackContext.nodeType || callbackContext instanceof jQuery ) ?
											jQuery( callbackContext ) : jQuery.event,
								// Deferreds
								deferred = jQuery.Deferred(),
								completeDeferred = jQuery.Callbacks( "once memory" ),
								// Status-dependent callbacks
								statusCode = s.statusCode || {},
								// ifModified key
								ifModifiedKey,
								// Headers (they are sent all at once)
								requestHeaders = {},
								requestHeadersNames = {},
								// Response headers
								responseHeadersString,
								responseHeaders,
								// transport
								transport,
								// timeout handle
								timeoutTimer,
								// Cross-domain detection vars
								parts,
								// The jqXHR state
								state = 0,
								// To know if global events are to be dispatched
								fireGlobals,
								// Loop variable
								i,
								// Fake xhr
								jqXHR = {

									readyState: 0,

									// Caches the header
									setRequestHeader: function( name, value ) {
										if ( !state ) {
											var lname = name.toLowerCase();
											name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
											requestHeaders[ name ] = value;
										}
										return this;
									},

									// Raw string
									getAllResponseHeaders: function() {
										return state === 2 ? responseHeadersString : null;
									},

									// Builds headers hashtable if needed
									getResponseHeader: function( key ) {
										var match;
										if ( state === 2 ) {
											if ( !responseHeaders ) {
												responseHeaders = {};
												while( ( match = rheaders.exec( responseHeadersString ) ) ) {
													responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
												}
											}
											match = responseHeaders[ key.toLowerCase() ];
										}
										return match === undefined ? null : match;
									},

									// Overrides response content-type header
									overrideMimeType: function( type ) {
										if ( !state ) {
											s.mimeType = type;
										}
										return this;
									},

									// Cancel the request
									abort: function( statusText ) {
										statusText = statusText || "abort";
										if ( transport ) {
											transport.abort( statusText );
										}
										done( 0, statusText );
										return this;
									}
								};

							// Callback for when everything is done
							// It is defined here because jslint complains if it is declared
							// at the end of the function (which would be more logical and readable)
							function done( status, nativeStatusText, responses, headers ) {

								// Called once
								if ( state === 2 ) {
									return;
								}

								// State is "done" now
								state = 2;

								// Clear timeout if it exists
								if ( timeoutTimer ) {
									clearTimeout( timeoutTimer );
								}

								// Dereference transport for early garbage collection
								// (no matter how long the jqXHR object will be used)
								transport = undefined;

								// Cache response headers
								responseHeadersString = headers || "";

								// Set readyState
								jqXHR.readyState = status > 0 ? 4 : 0;

								var isSuccess,
									success,
									error,
									statusText = nativeStatusText,
									response = responses ? ajaxHandleResponses( s, jqXHR, responses ) : undefined,
									lastModified,
									etag;

								// If successful, handle type chaining
								if ( status >= 200 && status < 300 || status === 304 ) {

									// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
									if ( s.ifModified ) {

										if ( ( lastModified = jqXHR.getResponseHeader( "Last-Modified" ) ) ) {
											jQuery.lastModified[ ifModifiedKey ] = lastModified;
										}
										if ( ( etag = jqXHR.getResponseHeader( "Etag" ) ) ) {
											jQuery.etag[ ifModifiedKey ] = etag;
										}
									}

									// If not modified
									if ( status === 304 ) {

										statusText = "notmodified";
										isSuccess = true;

									// If we have data
									} else {

										try {
											success = ajaxConvert( s, response );
											statusText = "success";
											isSuccess = true;
										} catch(e) {
											// We have a parsererror
											statusText = "parsererror";
											error = e;
										}
									}
								} else {
									// We extract error from statusText
									// then normalize statusText and status for non-aborts
									error = statusText;
									if ( !statusText || status ) {
										statusText = "error";
										if ( status < 0 ) {
											status = 0;
										}
									}
								}

								// Set data for the fake xhr object
								jqXHR.status = status;
								jqXHR.statusText = "" + ( nativeStatusText || statusText );

								// Success/Error
								if ( isSuccess ) {
									deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
								} else {
									deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
								}

								// Status-dependent callbacks
								jqXHR.statusCode( statusCode );
								statusCode = undefined;

								if ( fireGlobals ) {
									globalEventContext.trigger( "ajax" + ( isSuccess ? "Success" : "Error" ),
											[ jqXHR, s, isSuccess ? success : error ] );
								}

								// Complete
								completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

								if ( fireGlobals ) {
									globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
									// Handle the global AJAX counter
									if ( !( --jQuery.active ) ) {
										jQuery.event.trigger( "ajaxStop" );
									}
								}
							}

							// Attach deferreds
							deferred.promise( jqXHR );
							jqXHR.success = jqXHR.done;
							jqXHR.error = jqXHR.fail;
							jqXHR.complete = completeDeferred.add;

							// Status-dependent callbacks
							jqXHR.statusCode = function( map ) {
								if ( map ) {
									var tmp;
									if ( state < 2 ) {
										for ( tmp in map ) {
											statusCode[ tmp ] = [ statusCode[tmp], map[tmp] ];
										}
									} else {
										tmp = map[ jqXHR.status ];
										jqXHR.then( tmp, tmp );
									}
								}
								return this;
							};

							// Remove hash character (#7531: and string promotion)
							// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
							// We also use the url parameter if available
							s.url = ( ( url || s.url ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

							// Extract dataTypes list
							s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().split( rspacesAjax );

							// Determine if a cross-domain request is in order
							if ( s.crossDomain == null ) {
								parts = rurl.exec( s.url.toLowerCase() );
								s.crossDomain = !!( parts &&
									( parts[ 1 ] != ajaxLocParts[ 1 ] || parts[ 2 ] != ajaxLocParts[ 2 ] ||
										( parts[ 3 ] || ( parts[ 1 ] === "http:" ? 80 : 443 ) ) !=
											( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? 80 : 443 ) ) )
								);
							}

							// Convert data if not already a string
							if ( s.data && s.processData && typeof s.data !== "string" ) {
								s.data = jQuery.param( s.data, s.traditional );
							}

							// Apply prefilters
							inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

							// If request was aborted inside a prefilter, stop there
							if ( state === 2 ) {
								return false;
							}

							// We can fire global events as of now if asked to
							fireGlobals = s.global;

							// Uppercase the type
							s.type = s.type.toUpperCase();

							// Determine if request has content
							s.hasContent = !rnoContent.test( s.type );

							// Watch for a new set of requests
							if ( fireGlobals && jQuery.active++ === 0 ) {
								jQuery.event.trigger( "ajaxStart" );
							}

							// More options handling for requests with no content
							if ( !s.hasContent ) {

								// If data is available, append data to url
								if ( s.data ) {
									s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.data;
									// #9682: remove data so that it's not used in an eventual retry
									delete s.data;
								}

								// Get ifModifiedKey before adding the anti-cache parameter
								ifModifiedKey = s.url;

								// Add anti-cache in url if needed
								if ( s.cache === false ) {

									var ts = jQuery.now(),
										// try replacing _= if it is there
										ret = s.url.replace( rts, "$1_=" + ts );

									// if nothing was replaced, add timestamp to the end
									s.url = ret + ( ( ret === s.url ) ? ( rquery.test( s.url ) ? "&" : "?" ) + "_=" + ts : "" );
								}
							}

							// Set the correct header, if data is being sent
							if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
								jqXHR.setRequestHeader( "Content-Type", s.contentType );
							}

							// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
							if ( s.ifModified ) {
								ifModifiedKey = ifModifiedKey || s.url;
								if ( jQuery.lastModified[ ifModifiedKey ] ) {
									jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ ifModifiedKey ] );
								}
								if ( jQuery.etag[ ifModifiedKey ] ) {
									jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ ifModifiedKey ] );
								}
							}

							// Set the Accepts header for the server, depending on the dataType
							jqXHR.setRequestHeader(
								"Accept",
								s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
									s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
									s.accepts[ "*" ]
							);

							// Check for headers option
							for ( i in s.headers ) {
								jqXHR.setRequestHeader( i, s.headers[ i ] );
							}

							// Allow custom headers/mimetypes and early abort
							if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
									// Abort if not done already
									jqXHR.abort();
									return false;

							}

							// Install callbacks on deferreds
							for ( i in { success: 1, error: 1, complete: 1 } ) {
								jqXHR[ i ]( s[ i ] );
							}

							// Get transport
							transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

							// If no transport, we auto-abort
							if ( !transport ) {
								done( -1, "No Transport" );
							} else {
								jqXHR.readyState = 1;
								// Send global event
								if ( fireGlobals ) {
									globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
								}
								// Timeout
								if ( s.async && s.timeout > 0 ) {
									timeoutTimer = setTimeout( function(){
										jqXHR.abort( "timeout" );
									}, s.timeout );
								}

								try {
									state = 1;
									transport.send( requestHeaders, done );
								} catch (e) {
									// Propagate exception as error if not done
									if ( state < 2 ) {
										done( -1, e );
									// Simply rethrow otherwise
									} else {
										throw e;
									}
								}
							}

							return jqXHR;
						},

						// Serialize an array of form elements or a set of
						// key/values into a query string
						param: function( a, traditional ) {
							var s = [],
								add = function( key, value ) {
									// If value is a function, invoke it and return its value
									value = jQuery.isFunction( value ) ? value() : value;
									s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
								};

							// Set traditional to true for jQuery <= 1.3.2 behavior.
							if ( traditional === undefined ) {
								traditional = jQuery.ajaxSettings.traditional;
							}

							// If an array was passed in, assume that it is an array of form elements.
							if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
								// Serialize the form elements
								jQuery.each( a, function() {
									add( this.name, this.value );
								});

							} else {
								// If traditional, encode the "old" way (the way 1.3.2 or older
								// did it), otherwise encode params recursively.
								for ( var prefix in a ) {
									buildParams( prefix, a[ prefix ], traditional, add );
								}
							}

							// Return the resulting serialization
							return s.join( "&" ).replace( r20, "+" );
						}
					});

					function buildParams( prefix, obj, traditional, add ) {
						if ( jQuery.isArray( obj ) ) {
							// Serialize array item.
							jQuery.each( obj, function( i, v ) {
								if ( traditional || rbracket.test( prefix ) ) {
									// Treat each array item as a scalar.
									add( prefix, v );

								} else {
									// If array item is non-scalar (array or object), encode its
									// numeric index to resolve deserialization ambiguity issues.
									// Note that rack (as of 1.0.0) can't currently deserialize
									// nested arrays properly, and attempting to do so may cause
									// a server error. Possible fixes are to modify rack's
									// deserialization algorithm or to provide an option or flag
									// to force array serialization to be shallow.
									buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
								}
							});

						} else if ( !traditional && jQuery.type( obj ) === "object" ) {
							// Serialize object item.
							for ( var name in obj ) {
								buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
							}

						} else {
							// Serialize scalar item.
							add( prefix, obj );
						}
					}

					// This is still on the jQuery object... for now
					// Want to move this to jQuery.ajax some day
					jQuery.extend({

						// Counter for holding the number of active queries
						active: 0,

						// Last-Modified header cache for next request
						lastModified: {},
						etag: {}

					});

					/* Handles responses to an ajax request:
					 * - sets all responseXXX fields accordingly
					 * - finds the right dataType (mediates between content-type and expected dataType)
					 * - returns the corresponding response
					 */
					function ajaxHandleResponses( s, jqXHR, responses ) {

						var contents = s.contents,
							dataTypes = s.dataTypes,
							responseFields = s.responseFields,
							ct,
							type,
							finalDataType,
							firstDataType;

						// Fill responseXXX fields
						for ( type in responseFields ) {
							if ( type in responses ) {
								jqXHR[ responseFields[type] ] = responses[ type ];
							}
						}

						// Remove auto dataType and get content-type in the process
						while( dataTypes[ 0 ] === "*" ) {
							dataTypes.shift();
							if ( ct === undefined ) {
								ct = s.mimeType || jqXHR.getResponseHeader( "content-type" );
							}
						}

						// Check if we're dealing with a known content-type
						if ( ct ) {
							for ( type in contents ) {
								if ( contents[ type ] && contents[ type ].test( ct ) ) {
									dataTypes.unshift( type );
									break;
								}
							}
						}

						// Check to see if we have a response for the expected dataType
						if ( dataTypes[ 0 ] in responses ) {
							finalDataType = dataTypes[ 0 ];
						} else {
							// Try convertible dataTypes
							for ( type in responses ) {
								if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
									finalDataType = type;
									break;
								}
								if ( !firstDataType ) {
									firstDataType = type;
								}
							}
							// Or just use first one
							finalDataType = finalDataType || firstDataType;
						}

						// If we found a dataType
						// We add the dataType to the list if needed
						// and return the corresponding response
						if ( finalDataType ) {
							if ( finalDataType !== dataTypes[ 0 ] ) {
								dataTypes.unshift( finalDataType );
							}
							return responses[ finalDataType ];
						}
					}

					// Chain conversions given the request and the original response
					function ajaxConvert( s, response ) {

						// Apply the dataFilter if provided
						if ( s.dataFilter ) {
							response = s.dataFilter( response, s.dataType );
						}

						var dataTypes = s.dataTypes,
							converters = {},
							i,
							key,
							length = dataTypes.length,
							tmp,
							// Current and previous dataTypes
							current = dataTypes[ 0 ],
							prev,
							// Conversion expression
							conversion,
							// Conversion function
							conv,
							// Conversion functions (transitive conversion)
							conv1,
							conv2;

						// For each dataType in the chain
						for ( i = 1; i < length; i++ ) {

							// Create converters map
							// with lowercased keys
							if ( i === 1 ) {
								for ( key in s.converters ) {
									if ( typeof key === "string" ) {
										converters[ key.toLowerCase() ] = s.converters[ key ];
									}
								}
							}

							// Get the dataTypes
							prev = current;
							current = dataTypes[ i ];

							// If current is auto dataType, update it to prev
							if ( current === "*" ) {
								current = prev;
							// If no auto and dataTypes are actually different
							} else if ( prev !== "*" && prev !== current ) {

								// Get the converter
								conversion = prev + " " + current;
								conv = converters[ conversion ] || converters[ "* " + current ];

								// If there is no direct converter, search transitively
								if ( !conv ) {
									conv2 = undefined;
									for ( conv1 in converters ) {
										tmp = conv1.split( " " );
										if ( tmp[ 0 ] === prev || tmp[ 0 ] === "*" ) {
											conv2 = converters[ tmp[1] + " " + current ];
											if ( conv2 ) {
												conv1 = converters[ conv1 ];
												if ( conv1 === true ) {
													conv = conv2;
												} else if ( conv2 === true ) {
													conv = conv1;
												}
												break;
											}
										}
									}
								}
								// If we found no converter, dispatch an error
								if ( !( conv || conv2 ) ) {
									jQuery.error( "No conversion from " + conversion.replace(" "," to ") );
								}
								// If found converter is not an equivalence
								if ( conv !== true ) {
									// Convert with 1 or 2 converters accordingly
									response = conv ? conv( response ) : conv2( conv1(response) );
								}
							}
						}
						return response;
					}




					var jsc = jQuery.now(),
						jsre = /(\=)\?(&|$)|\?\?/i;

					// Default jsonp settings
					jQuery.ajaxSetup({
						jsonp: "callback",
						jsonpCallback: function() {
							return jQuery.expando + "_" + ( jsc++ );
						}
					});

					// Detect, normalize options and install callbacks for jsonp requests
					jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

						var inspectData = ( typeof s.data === "string" ) && /^application\/x\-www\-form\-urlencoded/.test( s.contentType );

						if ( s.dataTypes[ 0 ] === "jsonp" ||
							s.jsonp !== false && ( jsre.test( s.url ) ||
									inspectData && jsre.test( s.data ) ) ) {

							var responseContainer,
								jsonpCallback = s.jsonpCallback =
									jQuery.isFunction( s.jsonpCallback ) ? s.jsonpCallback() : s.jsonpCallback,
								previous = window[ jsonpCallback ],
								url = s.url,
								data = s.data,
								replace = "$1" + jsonpCallback + "$2";

							if ( s.jsonp !== false ) {
								url = url.replace( jsre, replace );
								if ( s.url === url ) {
									if ( inspectData ) {
										data = data.replace( jsre, replace );
									}
									if ( s.data === data ) {
										// Add callback manually
										url += (/\?/.test( url ) ? "&" : "?") + s.jsonp + "=" + jsonpCallback;
									}
								}
							}

							s.url = url;
							s.data = data;

							// Install callback
							window[ jsonpCallback ] = function( response ) {
								responseContainer = [ response ];
							};

							// Clean-up function
							jqXHR.always(function() {
								// Set callback back to previous value
								window[ jsonpCallback ] = previous;
								// Call if it was a function and we have a response
								if ( responseContainer && jQuery.isFunction( previous ) ) {
									window[ jsonpCallback ]( responseContainer[ 0 ] );
								}
							});

							// Use data converter to retrieve json after script execution
							s.converters["script json"] = function() {
								if ( !responseContainer ) {
									jQuery.error( jsonpCallback + " was not called" );
								}
								return responseContainer[ 0 ];
							};

							// force json dataType
							s.dataTypes[ 0 ] = "json";

							// Delegate to script
							return "script";
						}
					});




					// Install script dataType
					jQuery.ajaxSetup({
						accepts: {
							script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
						},
						contents: {
							script: /javascript|ecmascript/
						},
						converters: {
							"text script": function( text ) {
								jQuery.globalEval( text );
								return text;
							}
						}
					});

					// Handle cache's special case and global
					jQuery.ajaxPrefilter( "script", function( s ) {
						if ( s.cache === undefined ) {
							s.cache = false;
						}
						if ( s.crossDomain ) {
							s.type = "GET";
							s.global = false;
						}
					});

					// Bind script tag hack transport
					jQuery.ajaxTransport( "script", function(s) {

						// This transport only deals with cross domain requests
						if ( s.crossDomain ) {

							var script,
								head = document.head || document.getElementsByTagName( "head" )[0] || document.documentElement;

							return {

								send: function( _, callback ) {

									script = document.createElement( "script" );

									script.async = "async";

									if ( s.scriptCharset ) {
										script.charset = s.scriptCharset;
									}

									script.src = s.url;

									// Attach handlers for all browsers
									script.onload = script.onreadystatechange = function( _, isAbort ) {

										if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {

											// Handle memory leak in IE
											script.onload = script.onreadystatechange = null;

											// Remove the script
											if ( head && script.parentNode ) {
												head.removeChild( script );
											}

											// Dereference the script
											script = undefined;

											// Callback if not abort
											if ( !isAbort ) {
												callback( 200, "success" );
											}
										}
									};
									// Use insertBefore instead of appendChild  to circumvent an IE6 bug.
									// This arises when a base node is used (#2709 and #4378).
									head.insertBefore( script, head.firstChild );
								},

								abort: function() {
									if ( script ) {
										script.onload( 0, 1 );
									}
								}
							};
						}
					});




					var // #5280: Internet Explorer will keep connections alive if we don't abort on unload
						xhrOnUnloadAbort = window.ActiveXObject ? function() {
							// Abort all pending requests
							for ( var key in xhrCallbacks ) {
								xhrCallbacks[ key ]( 0, 1 );
							}
						} : false,
						xhrId = 0,
						xhrCallbacks;

					// Functions to create xhrs
					function createStandardXHR() {
						try {
							return new window.XMLHttpRequest();
						} catch( e ) {}
					}

					function createActiveXHR() {
						try {
							return new window.ActiveXObject( "Microsoft.XMLHTTP" );
						} catch( e ) {}
					}

					// Create the request object
					// (This is still attached to ajaxSettings for backward compatibility)
					jQuery.ajaxSettings.xhr = window.ActiveXObject ?
						/* Microsoft failed to properly
						 * implement the XMLHttpRequest in IE7 (can't request local files),
						 * so we use the ActiveXObject when it is available
						 * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
						 * we need a fallback.
						 */
						function() {
							return !this.isLocal && createStandardXHR() || createActiveXHR();
						} :
						// For all other browsers, use the standard XMLHttpRequest object
						createStandardXHR;

					// Determine support properties
					(function( xhr ) {
						jQuery.extend( jQuery.support, {
							ajax: !!xhr,
							cors: !!xhr && ( "withCredentials" in xhr )
						});
					})( jQuery.ajaxSettings.xhr() );

					// Create transport if the browser can provide an xhr
					if ( jQuery.support.ajax ) {

						jQuery.ajaxTransport(function( s ) {
							// Cross domain only allowed if supported through XMLHttpRequest
							if ( !s.crossDomain || jQuery.support.cors ) {

								var callback;

								return {
									send: function( headers, complete ) {

										// Get a new xhr
										var xhr = s.xhr(),
											handle,
											i;

										// Open the socket
										// Passing null username, generates a login popup on Opera (#2865)
										if ( s.username ) {
											xhr.open( s.type, s.url, s.async, s.username, s.password );
										} else {
											xhr.open( s.type, s.url, s.async );
										}

										// Apply custom fields if provided
										if ( s.xhrFields ) {
											for ( i in s.xhrFields ) {
												xhr[ i ] = s.xhrFields[ i ];
											}
										}

										// Override mime type if needed
										if ( s.mimeType && xhr.overrideMimeType ) {
											xhr.overrideMimeType( s.mimeType );
										}

										// X-Requested-With header
										// For cross-domain requests, seeing as conditions for a preflight are
										// akin to a jigsaw puzzle, we simply never set it to be sure.
										// (it can always be set on a per-request basis or even using ajaxSetup)
										// For same-domain requests, won't change header if already provided.
										if ( !s.crossDomain && !headers["X-Requested-With"] ) {
											headers[ "X-Requested-With" ] = "XMLHttpRequest";
										}

										// Need an extra try/catch for cross domain requests in Firefox 3
										try {
											for ( i in headers ) {
												xhr.setRequestHeader( i, headers[ i ] );
											}
										} catch( _ ) {}

										// Do send the request
										// This may raise an exception which is actually
										// handled in jQuery.ajax (so no try/catch here)
										xhr.send( ( s.hasContent && s.data ) || null );

										// Listener
										callback = function( _, isAbort ) {

											var status,
												statusText,
												responseHeaders,
												responses,
												xml;

											// Firefox throws exceptions when accessing properties
											// of an xhr when a network error occured
											// http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)
											try {

												// Was never called and is aborted or complete
												if ( callback && ( isAbort || xhr.readyState === 4 ) ) {

													// Only called once
													callback = undefined;

													// Do not keep as active anymore
													if ( handle ) {
														xhr.onreadystatechange = jQuery.noop;
														if ( xhrOnUnloadAbort ) {
															delete xhrCallbacks[ handle ];
														}
													}

													// If it's an abort
													if ( isAbort ) {
														// Abort it manually if needed
														if ( xhr.readyState !== 4 ) {
															xhr.abort();
														}
													} else {
														status = xhr.status;
														responseHeaders = xhr.getAllResponseHeaders();
														responses = {};
														xml = xhr.responseXML;

														// Construct response list
														if ( xml && xml.documentElement /* #4958 */ ) {
															responses.xml = xml;
														}

														// When requesting binary data, IE6-9 will throw an exception
														// on any attempt to access responseText (#11426)
														try {
															responses.text = xhr.responseText;
														} catch( _ ) {
														}

														// Firefox throws an exception when accessing
														// statusText for faulty cross-domain requests
														try {
															statusText = xhr.statusText;
														} catch( e ) {
															// We normalize with Webkit giving an empty statusText
															statusText = "";
														}

														// Filter status for non standard behaviors

														// If the request is local and we have data: assume a success
														// (success with no data won't get notified, that's the best we
														// can do given current implementations)
														if ( !status && s.isLocal && !s.crossDomain ) {
															status = responses.text ? 200 : 404;
														// IE - #1450: sometimes returns 1223 when it should be 204
														} else if ( status === 1223 ) {
															status = 204;
														}
													}
												}
											} catch( firefoxAccessException ) {
												if ( !isAbort ) {
													complete( -1, firefoxAccessException );
												}
											}

											// Call complete if needed
											if ( responses ) {
												complete( status, statusText, responses, responseHeaders );
											}
										};

										// if we're in sync mode or it's in cache
										// and has been retrieved directly (IE6 & IE7)
										// we need to manually fire the callback
										if ( !s.async || xhr.readyState === 4 ) {
											callback();
										} else {
											handle = ++xhrId;
											if ( xhrOnUnloadAbort ) {
												// Create the active xhrs callbacks list if needed
												// and attach the unload handler
												if ( !xhrCallbacks ) {
													xhrCallbacks = {};
													jQuery( window ).unload( xhrOnUnloadAbort );
												}
												// Add to list of active xhrs callbacks
												xhrCallbacks[ handle ] = callback;
											}
											xhr.onreadystatechange = callback;
										}
									},

									abort: function() {
										if ( callback ) {
											callback(0,1);
										}
									}
								};
							}
						});
					}




					var elemdisplay = {},
						iframe, iframeDoc,
						rfxtypes = /^(?:toggle|show|hide)$/,
						rfxnum = /^([+\-]=)?([\d+.\-]+)([a-z%]*)$/i,
						timerId,
						fxAttrs = [
							// height animations
							[ "height", "marginTop", "marginBottom", "paddingTop", "paddingBottom" ],
							// width animations
							[ "width", "marginLeft", "marginRight", "paddingLeft", "paddingRight" ],
							// opacity animations
							[ "opacity" ]
						],
						fxNow;

					jQuery.fn.extend({
						show: function( speed, easing, callback ) {
							var elem, display;

							if ( speed || speed === 0 ) {
								return this.animate( genFx("show", 3), speed, easing, callback );

							} else {
								for ( var i = 0, j = this.length; i < j; i++ ) {
									elem = this[ i ];

									if ( elem.style ) {
										display = elem.style.display;

										// Reset the inline display of this element to learn if it is
										// being hidden by cascaded rules or not
										if ( !jQuery._data(elem, "olddisplay") && display === "none" ) {
											display = elem.style.display = "";
										}

										// Set elements which have been overridden with display: none
										// in a stylesheet to whatever the default browser style is
										// for such an element
										if ( (display === "" && jQuery.css(elem, "display") === "none") ||
											!jQuery.contains( elem.ownerDocument.documentElement, elem ) ) {
											jQuery._data( elem, "olddisplay", defaultDisplay(elem.nodeName) );
										}
									}
								}

								// Set the display of most of the elements in a second loop
								// to avoid the constant reflow
								for ( i = 0; i < j; i++ ) {
									elem = this[ i ];

									if ( elem.style ) {
										display = elem.style.display;

										if ( display === "" || display === "none" ) {
											elem.style.display = jQuery._data( elem, "olddisplay" ) || "";
										}
									}
								}

								return this;
							}
						},

						hide: function( speed, easing, callback ) {
							if ( speed || speed === 0 ) {
								return this.animate( genFx("hide", 3), speed, easing, callback);

							} else {
								var elem, display,
									i = 0,
									j = this.length;

								for ( ; i < j; i++ ) {
									elem = this[i];
									if ( elem.style ) {
										display = jQuery.css( elem, "display" );

										if ( display !== "none" && !jQuery._data( elem, "olddisplay" ) ) {
											jQuery._data( elem, "olddisplay", display );
										}
									}
								}

								// Set the display of the elements in a second loop
								// to avoid the constant reflow
								for ( i = 0; i < j; i++ ) {
									if ( this[i].style ) {
										this[i].style.display = "none";
									}
								}

								return this;
							}
						},

						// Save the old toggle function
						_toggle: jQuery.fn.toggle,

						toggle: function( fn, fn2, callback ) {
							var bool = typeof fn === "boolean";

							if ( jQuery.isFunction(fn) && jQuery.isFunction(fn2) ) {
								this._toggle.apply( this, arguments );

							} else if ( fn == null || bool ) {
								this.each(function() {
									var state = bool ? fn : jQuery(this).is(":hidden");
									jQuery(this)[ state ? "show" : "hide" ]();
								});

							} else {
								this.animate(genFx("toggle", 3), fn, fn2, callback);
							}

							return this;
						},

						fadeTo: function( speed, to, easing, callback ) {
							return this.filter(":hidden").css("opacity", 0).show().end()
										.animate({opacity: to}, speed, easing, callback);
						},

						animate: function( prop, speed, easing, callback ) {
							var optall = jQuery.speed( speed, easing, callback );

							if ( jQuery.isEmptyObject( prop ) ) {
								return this.each( optall.complete, [ false ] );
							}

							// Do not change referenced properties as per-property easing will be lost
							prop = jQuery.extend( {}, prop );

							function doAnimation() {
								// XXX 'this' does not always have a nodeName when running the
								// test suite

								if ( optall.queue === false ) {
									jQuery._mark( this );
								}

								var opt = jQuery.extend( {}, optall ),
									isElement = this.nodeType === 1,
									hidden = isElement && jQuery(this).is(":hidden"),
									name, val, p, e, hooks, replace,
									parts, start, end, unit,
									method;

								// will store per property easing and be used to determine when an animation is complete
								opt.animatedProperties = {};

								// first pass over propertys to expand / normalize
								for ( p in prop ) {
									name = jQuery.camelCase( p );
									if ( p !== name ) {
										prop[ name ] = prop[ p ];
										delete prop[ p ];
									}

									if ( ( hooks = jQuery.cssHooks[ name ] ) && "expand" in hooks ) {
										replace = hooks.expand( prop[ name ] );
										delete prop[ name ];

										// not quite $.extend, this wont overwrite keys already present.
										// also - reusing 'p' from above because we have the correct "name"
										for ( p in replace ) {
											if ( ! ( p in prop ) ) {
												prop[ p ] = replace[ p ];
											}
										}
									}
								}

								for ( name in prop ) {
									val = prop[ name ];
									// easing resolution: per property > opt.specialEasing > opt.easing > 'swing' (default)
									if ( jQuery.isArray( val ) ) {
										opt.animatedProperties[ name ] = val[ 1 ];
										val = prop[ name ] = val[ 0 ];
									} else {
										opt.animatedProperties[ name ] = opt.specialEasing && opt.specialEasing[ name ] || opt.easing || 'swing';
									}

									if ( val === "hide" && hidden || val === "show" && !hidden ) {
										return opt.complete.call( this );
									}

									if ( isElement && ( name === "height" || name === "width" ) ) {
										// Make sure that nothing sneaks out
										// Record all 3 overflow attributes because IE does not
										// change the overflow attribute when overflowX and
										// overflowY are set to the same value
										opt.overflow = [ this.style.overflow, this.style.overflowX, this.style.overflowY ];

										// Set display property to inline-block for height/width
										// animations on inline elements that are having width/height animated
										if ( jQuery.css( this, "display" ) === "inline" &&
												jQuery.css( this, "float" ) === "none" ) {

											// inline-level elements accept inline-block;
											// block-level elements need to be inline with layout
											if ( !jQuery.support.inlineBlockNeedsLayout || defaultDisplay( this.nodeName ) === "inline" ) {
												this.style.display = "inline-block";

											} else {
												this.style.zoom = 1;
											}
										}
									}
								}

								if ( opt.overflow != null ) {
									this.style.overflow = "hidden";
								}

								for ( p in prop ) {
									e = new jQuery.fx( this, opt, p );
									val = prop[ p ];

									if ( rfxtypes.test( val ) ) {

										// Tracks whether to show or hide based on private
										// data attached to the element
										method = jQuery._data( this, "toggle" + p ) || ( val === "toggle" ? hidden ? "show" : "hide" : 0 );
										if ( method ) {
											jQuery._data( this, "toggle" + p, method === "show" ? "hide" : "show" );
											e[ method ]();
										} else {
											e[ val ]();
										}

									} else {
										parts = rfxnum.exec( val );
										start = e.cur();

										if ( parts ) {
											end = parseFloat( parts[2] );
											unit = parts[3] || ( jQuery.cssNumber[ p ] ? "" : "px" );

											// We need to compute starting value
											if ( unit !== "px" ) {
												jQuery.style( this, p, (end || 1) + unit);
												start = ( (end || 1) / e.cur() ) * start;
												jQuery.style( this, p, start + unit);
											}

											// If a +=/-= token was provided, we're doing a relative animation
											if ( parts[1] ) {
												end = ( (parts[ 1 ] === "-=" ? -1 : 1) * end ) + start;
											}

											e.custom( start, end, unit );

										} else {
											e.custom( start, val, "" );
										}
									}
								}

								// For JS strict compliance
								return true;
							}

							return optall.queue === false ?
								this.each( doAnimation ) :
								this.queue( optall.queue, doAnimation );
						},

						stop: function( type, clearQueue, gotoEnd ) {
							if ( typeof type !== "string" ) {
								gotoEnd = clearQueue;
								clearQueue = type;
								type = undefined;
							}
							if ( clearQueue && type !== false ) {
								this.queue( type || "fx", [] );
							}

							return this.each(function() {
								var index,
									hadTimers = false,
									timers = jQuery.timers,
									data = jQuery._data( this );

								// clear marker counters if we know they won't be
								if ( !gotoEnd ) {
									jQuery._unmark( true, this );
								}

								function stopQueue( elem, data, index ) {
									var hooks = data[ index ];
									jQuery.removeData( elem, index, true );
									hooks.stop( gotoEnd );
								}

								if ( type == null ) {
									for ( index in data ) {
										if ( data[ index ] && data[ index ].stop && index.indexOf(".run") === index.length - 4 ) {
											stopQueue( this, data, index );
										}
									}
								} else if ( data[ index = type + ".run" ] && data[ index ].stop ){
									stopQueue( this, data, index );
								}

								for ( index = timers.length; index--; ) {
									if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
										if ( gotoEnd ) {

											// force the next step to be the last
											timers[ index ]( true );
										} else {
											timers[ index ].saveState();
										}
										hadTimers = true;
										timers.splice( index, 1 );
									}
								}

								// start the next in the queue if the last step wasn't forced
								// timers currently will call their complete callbacks, which will dequeue
								// but only if they were gotoEnd
								if ( !( gotoEnd && hadTimers ) ) {
									jQuery.dequeue( this, type );
								}
							});
						}

					});

					// Animations created synchronously will run synchronously
					function createFxNow() {
						setTimeout( clearFxNow, 0 );
						return ( fxNow = jQuery.now() );
					}

					function clearFxNow() {
						fxNow = undefined;
					}

					// Generate parameters to create a standard animation
					function genFx( type, num ) {
						var obj = {};

						jQuery.each( fxAttrs.concat.apply([], fxAttrs.slice( 0, num )), function() {
							obj[ this ] = type;
						});

						return obj;
					}

					// Generate shortcuts for custom animations
					jQuery.each({
						slideDown: genFx( "show", 1 ),
						slideUp: genFx( "hide", 1 ),
						slideToggle: genFx( "toggle", 1 ),
						fadeIn: { opacity: "show" },
						fadeOut: { opacity: "hide" },
						fadeToggle: { opacity: "toggle" }
					}, function( name, props ) {
						jQuery.fn[ name ] = function( speed, easing, callback ) {
							return this.animate( props, speed, easing, callback );
						};
					});

					jQuery.extend({
						speed: function( speed, easing, fn ) {
							var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
								complete: fn || !fn && easing ||
									jQuery.isFunction( speed ) && speed,
								duration: speed,
								easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
							};

							opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
								opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

							// normalize opt.queue - true/undefined/null -> "fx"
							if ( opt.queue == null || opt.queue === true ) {
								opt.queue = "fx";
							}

							// Queueing
							opt.old = opt.complete;

							opt.complete = function( noUnmark ) {
								if ( jQuery.isFunction( opt.old ) ) {
									opt.old.call( this );
								}

								if ( opt.queue ) {
									jQuery.dequeue( this, opt.queue );
								} else if ( noUnmark !== false ) {
									jQuery._unmark( this );
								}
							};

							return opt;
						},

						easing: {
							linear: function( p ) {
								return p;
							},
							swing: function( p ) {
								return ( -Math.cos( p*Math.PI ) / 2 ) + 0.5;
							}
						},

						timers: [],

						fx: function( elem, options, prop ) {
							this.options = options;
							this.elem = elem;
							this.prop = prop;

							options.orig = options.orig || {};
						}

					});

					jQuery.fx.prototype = {
						// Simple function for setting a style value
						update: function() {
							if ( this.options.step ) {
								this.options.step.call( this.elem, this.now, this );
							}

							( jQuery.fx.step[ this.prop ] || jQuery.fx.step._default )( this );
						},

						// Get the current size
						cur: function() {
							if ( this.elem[ this.prop ] != null && (!this.elem.style || this.elem.style[ this.prop ] == null) ) {
								return this.elem[ this.prop ];
							}

							var parsed,
								r = jQuery.css( this.elem, this.prop );
							// Empty strings, null, undefined and "auto" are converted to 0,
							// complex values such as "rotate(1rad)" are returned as is,
							// simple values such as "10px" are parsed to Float.
							return isNaN( parsed = parseFloat( r ) ) ? !r || r === "auto" ? 0 : r : parsed;
						},

						// Start an animation from one number to another
						custom: function( from, to, unit ) {
							var self = this,
								fx = jQuery.fx;

							this.startTime = fxNow || createFxNow();
							this.end = to;
							this.now = this.start = from;
							this.pos = this.state = 0;
							this.unit = unit || this.unit || ( jQuery.cssNumber[ this.prop ] ? "" : "px" );

							function t( gotoEnd ) {
								return self.step( gotoEnd );
							}

							t.queue = this.options.queue;
							t.elem = this.elem;
							t.saveState = function() {
								if ( jQuery._data( self.elem, "fxshow" + self.prop ) === undefined ) {
									if ( self.options.hide ) {
										jQuery._data( self.elem, "fxshow" + self.prop, self.start );
									} else if ( self.options.show ) {
										jQuery._data( self.elem, "fxshow" + self.prop, self.end );
									}
								}
							};

							if ( t() && jQuery.timers.push(t) && !timerId ) {
								timerId = setInterval( fx.tick, fx.interval );
							}
						},

						// Simple 'show' function
						show: function() {
							var dataShow = jQuery._data( this.elem, "fxshow" + this.prop );

							// Remember where we started, so that we can go back to it later
							this.options.orig[ this.prop ] = dataShow || jQuery.style( this.elem, this.prop );
							this.options.show = true;

							// Begin the animation
							// Make sure that we start at a small width/height to avoid any flash of content
							if ( dataShow !== undefined ) {
								// This show is picking up where a previous hide or show left off
								this.custom( this.cur(), dataShow );
							} else {
								this.custom( this.prop === "width" || this.prop === "height" ? 1 : 0, this.cur() );
							}

							// Start by showing the element
							jQuery( this.elem ).show();
						},

						// Simple 'hide' function
						hide: function() {
							// Remember where we started, so that we can go back to it later
							this.options.orig[ this.prop ] = jQuery._data( this.elem, "fxshow" + this.prop ) || jQuery.style( this.elem, this.prop );
							this.options.hide = true;

							// Begin the animation
							this.custom( this.cur(), 0 );
						},

						// Each step of an animation
						step: function( gotoEnd ) {
							var p, n, complete,
								t = fxNow || createFxNow(),
								done = true,
								elem = this.elem,
								options = this.options;

							if ( gotoEnd || t >= options.duration + this.startTime ) {
								this.now = this.end;
								this.pos = this.state = 1;
								this.update();

								options.animatedProperties[ this.prop ] = true;

								for ( p in options.animatedProperties ) {
									if ( options.animatedProperties[ p ] !== true ) {
										done = false;
									}
								}

								if ( done ) {
									// Reset the overflow
									if ( options.overflow != null && !jQuery.support.shrinkWrapBlocks ) {

										jQuery.each( [ "", "X", "Y" ], function( index, value ) {
											elem.style[ "overflow" + value ] = options.overflow[ index ];
										});
									}

									// Hide the element if the "hide" operation was done
									if ( options.hide ) {
										jQuery( elem ).hide();
									}

									// Reset the properties, if the item has been hidden or shown
									if ( options.hide || options.show ) {
										for ( p in options.animatedProperties ) {
											jQuery.style( elem, p, options.orig[ p ] );
											jQuery.removeData( elem, "fxshow" + p, true );
											// Toggle data is no longer needed
											jQuery.removeData( elem, "toggle" + p, true );
										}
									}

									// Execute the complete function
									// in the event that the complete function throws an exception
									// we must ensure it won't be called twice. #5684

									complete = options.complete;
									if ( complete ) {

										options.complete = false;
										complete.call( elem );
									}
								}

								return false;

							} else {
								// classical easing cannot be used with an Infinity duration
								if ( options.duration == Infinity ) {
									this.now = t;
								} else {
									n = t - this.startTime;
									this.state = n / options.duration;

									// Perform the easing function, defaults to swing
									this.pos = jQuery.easing[ options.animatedProperties[this.prop] ]( this.state, n, 0, 1, options.duration );
									this.now = this.start + ( (this.end - this.start) * this.pos );
								}
								// Perform the next step of the animation
								this.update();
							}

							return true;
						}
					};

					jQuery.extend( jQuery.fx, {
						tick: function() {
							var timer,
								timers = jQuery.timers,
								i = 0;

							for ( ; i < timers.length; i++ ) {
								timer = timers[ i ];
								// Checks the timer has not already been removed
								if ( !timer() && timers[ i ] === timer ) {
									timers.splice( i--, 1 );
								}
							}

							if ( !timers.length ) {
								jQuery.fx.stop();
							}
						},

						interval: 13,

						stop: function() {
							clearInterval( timerId );
							timerId = null;
						},

						speeds: {
							slow: 600,
							fast: 200,
							// Default speed
							_default: 400
						},

						step: {
							opacity: function( fx ) {
								jQuery.style( fx.elem, "opacity", fx.now );
							},

							_default: function( fx ) {
								if ( fx.elem.style && fx.elem.style[ fx.prop ] != null ) {
									fx.elem.style[ fx.prop ] = fx.now + fx.unit;
								} else {
									fx.elem[ fx.prop ] = fx.now;
								}
							}
						}
					});

					// Ensure props that can't be negative don't go there on undershoot easing
					jQuery.each( fxAttrs.concat.apply( [], fxAttrs ), function( i, prop ) {
						// exclude marginTop, marginLeft, marginBottom and marginRight from this list
						if ( prop.indexOf( "margin" ) ) {
							jQuery.fx.step[ prop ] = function( fx ) {
								jQuery.style( fx.elem, prop, Math.max(0, fx.now) + fx.unit );
							};
						}
					});

					if ( jQuery.expr && jQuery.expr.filters ) {
						jQuery.expr.filters.animated = function( elem ) {
							return jQuery.grep(jQuery.timers, function( fn ) {
								return elem === fn.elem;
							}).length;
						};
					}

					// Try to restore the default display value of an element
					function defaultDisplay( nodeName ) {

						if ( !elemdisplay[ nodeName ] ) {

							var body = document.body,
								elem = jQuery( "<" + nodeName + ">" ).appendTo( body ),
								display = elem.css( "display" );
							elem.remove();

							// If the simple way fails,
							// get element's real default display by attaching it to a temp iframe
							if ( display === "none" || display === "" ) {
								// No iframe to use yet, so create it
								if ( !iframe ) {
									iframe = document.createElement( "iframe" );
									iframe.frameBorder = iframe.width = iframe.height = 0;
								}

								body.appendChild( iframe );

								// Create a cacheable copy of the iframe document on first call.
								// IE and Opera will allow us to reuse the iframeDoc without re-writing the fake HTML
								// document to it; WebKit & Firefox won't allow reusing the iframe document.
								if ( !iframeDoc || !iframe.createElement ) {
									iframeDoc = ( iframe.contentWindow || iframe.contentDocument ).document;
									iframeDoc.write( ( jQuery.support.boxModel ? "<!doctype html>" : "" ) + "<html><body>" );
									iframeDoc.close();
								}

								elem = iframeDoc.createElement( nodeName );

								iframeDoc.body.appendChild( elem );

								display = jQuery.css( elem, "display" );
								body.removeChild( iframe );
							}

							// Store the correct default display
							elemdisplay[ nodeName ] = display;
						}

						return elemdisplay[ nodeName ];
					}




					var getOffset,
						rtable = /^t(?:able|d|h)$/i,
						rroot = /^(?:body|html)$/i;

					if ( "getBoundingClientRect" in document.documentElement ) {
						getOffset = function( elem, doc, docElem, box ) {
							try {
								box = elem.getBoundingClientRect();
							} catch(e) {}

							// Make sure we're not dealing with a disconnected DOM node
							if ( !box || !jQuery.contains( docElem, elem ) ) {
								return box ? { top: box.top, left: box.left } : { top: 0, left: 0 };
							}

							var body = doc.body,
								win = getWindow( doc ),
								clientTop  = docElem.clientTop  || body.clientTop  || 0,
								clientLeft = docElem.clientLeft || body.clientLeft || 0,
								scrollTop  = win.pageYOffset || jQuery.support.boxModel && docElem.scrollTop  || body.scrollTop,
								scrollLeft = win.pageXOffset || jQuery.support.boxModel && docElem.scrollLeft || body.scrollLeft,
								top  = box.top  + scrollTop  - clientTop,
								left = box.left + scrollLeft - clientLeft;

							return { top: top, left: left };
						};

					} else {
						getOffset = function( elem, doc, docElem ) {
							var computedStyle,
								offsetParent = elem.offsetParent,
								prevOffsetParent = elem,
								body = doc.body,
								defaultView = doc.defaultView,
								prevComputedStyle = defaultView ? defaultView.getComputedStyle( elem, null ) : elem.currentStyle,
								top = elem.offsetTop,
								left = elem.offsetLeft;

							while ( (elem = elem.parentNode) && elem !== body && elem !== docElem ) {
								if ( jQuery.support.fixedPosition && prevComputedStyle.position === "fixed" ) {
									break;
								}

								computedStyle = defaultView ? defaultView.getComputedStyle(elem, null) : elem.currentStyle;
								top  -= elem.scrollTop;
								left -= elem.scrollLeft;

								if ( elem === offsetParent ) {
									top  += elem.offsetTop;
									left += elem.offsetLeft;

									if ( jQuery.support.doesNotAddBorder && !(jQuery.support.doesAddBorderForTableAndCells && rtable.test(elem.nodeName)) ) {
										top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
										left += parseFloat( computedStyle.borderLeftWidth ) || 0;
									}

									prevOffsetParent = offsetParent;
									offsetParent = elem.offsetParent;
								}

								if ( jQuery.support.subtractsBorderForOverflowNotVisible && computedStyle.overflow !== "visible" ) {
									top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
									left += parseFloat( computedStyle.borderLeftWidth ) || 0;
								}

								prevComputedStyle = computedStyle;
							}

							if ( prevComputedStyle.position === "relative" || prevComputedStyle.position === "static" ) {
								top  += body.offsetTop;
								left += body.offsetLeft;
							}

							if ( jQuery.support.fixedPosition && prevComputedStyle.position === "fixed" ) {
								top  += Math.max( docElem.scrollTop, body.scrollTop );
								left += Math.max( docElem.scrollLeft, body.scrollLeft );
							}

							return { top: top, left: left };
						};
					}

					jQuery.fn.offset = function( options ) {
						if ( arguments.length ) {
							return options === undefined ?
								this :
								this.each(function( i ) {
									jQuery.offset.setOffset( this, options, i );
								});
						}

						var elem = this[0],
							doc = elem && elem.ownerDocument;

						if ( !doc ) {
							return null;
						}

						if ( elem === doc.body ) {
							return jQuery.offset.bodyOffset( elem );
						}

						return getOffset( elem, doc, doc.documentElement );
					};

					jQuery.offset = {

						bodyOffset: function( body ) {
							var top = body.offsetTop,
								left = body.offsetLeft;

							if ( jQuery.support.doesNotIncludeMarginInBodyOffset ) {
								top  += parseFloat( jQuery.css(body, "marginTop") ) || 0;
								left += parseFloat( jQuery.css(body, "marginLeft") ) || 0;
							}

							return { top: top, left: left };
						},

						setOffset: function( elem, options, i ) {
							var position = jQuery.css( elem, "position" );

							// set position first, in-case top/left are set even on static elem
							if ( position === "static" ) {
								elem.style.position = "relative";
							}

							var curElem = jQuery( elem ),
								curOffset = curElem.offset(),
								curCSSTop = jQuery.css( elem, "top" ),
								curCSSLeft = jQuery.css( elem, "left" ),
								calculatePosition = ( position === "absolute" || position === "fixed" ) && jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > -1,
								props = {}, curPosition = {}, curTop, curLeft;

							// need to be able to calculate position if either top or left is auto and position is either absolute or fixed
							if ( calculatePosition ) {
								curPosition = curElem.position();
								curTop = curPosition.top;
								curLeft = curPosition.left;
							} else {
								curTop = parseFloat( curCSSTop ) || 0;
								curLeft = parseFloat( curCSSLeft ) || 0;
							}

							if ( jQuery.isFunction( options ) ) {
								options = options.call( elem, i, curOffset );
							}

							if ( options.top != null ) {
								props.top = ( options.top - curOffset.top ) + curTop;
							}
							if ( options.left != null ) {
								props.left = ( options.left - curOffset.left ) + curLeft;
							}

							if ( "using" in options ) {
								options.using.call( elem, props );
							} else {
								curElem.css( props );
							}
						}
					};


					jQuery.fn.extend({

						position: function() {
							if ( !this[0] ) {
								return null;
							}

							var elem = this[0],

							// Get *real* offsetParent
							offsetParent = this.offsetParent(),

							// Get correct offsets
							offset       = this.offset(),
							parentOffset = rroot.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset();

							// Subtract element margins
							// note: when an element has margin: auto the offsetLeft and marginLeft
							// are the same in Safari causing offset.left to incorrectly be 0
							offset.top  -= parseFloat( jQuery.css(elem, "marginTop") ) || 0;
							offset.left -= parseFloat( jQuery.css(elem, "marginLeft") ) || 0;

							// Add offsetParent borders
							parentOffset.top  += parseFloat( jQuery.css(offsetParent[0], "borderTopWidth") ) || 0;
							parentOffset.left += parseFloat( jQuery.css(offsetParent[0], "borderLeftWidth") ) || 0;

							// Subtract the two offsets
							return {
								top:  offset.top  - parentOffset.top,
								left: offset.left - parentOffset.left
							};
						},

						offsetParent: function() {
							return this.map(function() {
								var offsetParent = this.offsetParent || document.body;
								while ( offsetParent && (!rroot.test(offsetParent.nodeName) && jQuery.css(offsetParent, "position") === "static") ) {
									offsetParent = offsetParent.offsetParent;
								}
								return offsetParent;
							});
						}
					});


					// Create scrollLeft and scrollTop methods
					jQuery.each( {scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, function( method, prop ) {
						var top = /Y/.test( prop );

						jQuery.fn[ method ] = function( val ) {
							return jQuery.access( this, function( elem, method, val ) {
								var win = getWindow( elem );

								if ( val === undefined ) {
									return win ? (prop in win) ? win[ prop ] :
										jQuery.support.boxModel && win.document.documentElement[ method ] ||
											win.document.body[ method ] :
										elem[ method ];
								}

								if ( win ) {
									win.scrollTo(
										!top ? val : jQuery( win ).scrollLeft(),
										 top ? val : jQuery( win ).scrollTop()
									);

								} else {
									elem[ method ] = val;
								}
							}, method, val, arguments.length, null );
						};
					});

					function getWindow( elem ) {
						return jQuery.isWindow( elem ) ?
							elem :
							elem.nodeType === 9 ?
								elem.defaultView || elem.parentWindow :
								false;
					}




					// Create width, height, innerHeight, innerWidth, outerHeight and outerWidth methods
					jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
						var clientProp = "client" + name,
							scrollProp = "scroll" + name,
							offsetProp = "offset" + name;

						// innerHeight and innerWidth
						jQuery.fn[ "inner" + name ] = function() {
							var elem = this[0];
							return elem ?
								elem.style ?
								parseFloat( jQuery.css( elem, type, "padding" ) ) :
								this[ type ]() :
								null;
						};

						// outerHeight and outerWidth
						jQuery.fn[ "outer" + name ] = function( margin ) {
							var elem = this[0];
							return elem ?
								elem.style ?
								parseFloat( jQuery.css( elem, type, margin ? "margin" : "border" ) ) :
								this[ type ]() :
								null;
						};

						jQuery.fn[ type ] = function( value ) {
							return jQuery.access( this, function( elem, type, value ) {
								var doc, docElemProp, orig, ret;

								if ( jQuery.isWindow( elem ) ) {
									// 3rd condition allows Nokia support, as it supports the docElem prop but not CSS1Compat
									doc = elem.document;
									docElemProp = doc.documentElement[ clientProp ];
									return jQuery.support.boxModel && docElemProp ||
										doc.body && doc.body[ clientProp ] || docElemProp;
								}

								// Get document width or height
								if ( elem.nodeType === 9 ) {
									// Either scroll[Width/Height] or offset[Width/Height], whichever is greater
									doc = elem.documentElement;

									// when a window > document, IE6 reports a offset[Width/Height] > client[Width/Height]
									// so we can't use max, as it'll choose the incorrect offset[Width/Height]
									// instead we use the correct client[Width/Height]
									// support:IE6
									if ( doc[ clientProp ] >= doc[ scrollProp ] ) {
										return doc[ clientProp ];
									}

									return Math.max(
										elem.body[ scrollProp ], doc[ scrollProp ],
										elem.body[ offsetProp ], doc[ offsetProp ]
									);
								}

								// Get width or height on the element
								if ( value === undefined ) {
									orig = jQuery.css( elem, type );
									ret = parseFloat( orig );
									return jQuery.isNumeric( ret ) ? ret : orig;
								}

								// Set the width or height on the element
								jQuery( elem ).css( type, value );
							}, type, value, arguments.length, null );
						};
					});




					// Expose jQuery to the global object
					window.jQuery = window.$ = jQuery;

					// Expose jQuery as an AMD module, but only for AMD loaders that
					// understand the issues with loading multiple versions of jQuery
					// in a page that all might call define(). The loader will indicate
					// they have special allowances for multiple jQuery versions by
					// specifying define.amd.jQuery = true. Register as a named module,
					// since jQuery can be concatenated with other files that may use define,
					// but not use a proper concatenation script that understands anonymous
					// AMD modules. A named AMD is safest and most robust way to register.
					// Lowercase jquery is used because AMD module names are derived from
					// file names, and jQuery is normally delivered in a lowercase file name.
					// Do this after creating the global so that if an AMD module wants to call
					// noConflict to hide this version of jQuery, it will work.
					if ( "function" === "function" && __webpack_require__(5) && __webpack_require__(5).jQuery ) {
						!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () { return jQuery; }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
					}



					})( window );


					  window.jQuery.noConflict();
					  return window.jQuery;
					}
					module.exports = create('undefined' === typeof window ? undefined : window);
					module.exports.create = create;
					}());


				/***/ },
				/* 5 */
				/***/ function(module, exports) {

					/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__;

					/* WEBPACK VAR INJECTION */}.call(exports, {}))

				/***/ }
				/******/ ]);

			/***/ }
			/******/ ]);

		/***/ }
		/******/ ]);

	/***/ }
	/******/ ]);

/***/ }
/******/ ]);